{"version":3,"file":"EllipsoidGeometry-a49cde27.js","sources":["../../../../Source/Core/EllipsoidGeometry.js"],"sourcesContent":["import arrayFill from './arrayFill.js';\r\nimport BoundingSphere from './BoundingSphere.js';\r\nimport Cartesian2 from './Cartesian2.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport ComponentDatatype from './ComponentDatatype.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport Geometry from './Geometry.js';\r\nimport GeometryAttribute from './GeometryAttribute.js';\r\nimport GeometryAttributes from './GeometryAttributes.js';\r\nimport GeometryOffsetAttribute from './GeometryOffsetAttribute.js';\r\nimport IndexDatatype from './IndexDatatype.js';\r\nimport CesiumMath from './Math.js';\r\nimport PrimitiveType from './PrimitiveType.js';\r\nimport VertexFormat from './VertexFormat.js';\r\n\r\n    var scratchPosition = new Cartesian3();\r\n    var scratchNormal = new Cartesian3();\r\n    var scratchTangent = new Cartesian3();\r\n    var scratchBitangent = new Cartesian3();\r\n    var scratchNormalST = new Cartesian3();\r\n    var defaultRadii = new Cartesian3(1.0, 1.0, 1.0);\r\n\r\n    var cos = Math.cos;\r\n    var sin = Math.sin;\r\n\r\n    /**\r\n     * A description of an ellipsoid centered at the origin.\r\n     *\r\n     * @alias EllipsoidGeometry\r\n     * @constructor\r\n     *\r\n     * @param {Object} [options] Object with the following properties:\r\n     * @param {Cartesian3} [options.radii=Cartesian3(1.0, 1.0, 1.0)] The radii of the ellipsoid in the x, y, and z directions.\r\n     * @param {Cartesian3} [options.innerRadii=options.radii] The inner radii of the ellipsoid in the x, y, and z directions.\r\n     * @param {Number} [options.minimumClock=0.0] The minimum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\r\n     * @param {Number} [options.maximumClock=2*PI] The maximum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.\r\n     * @param {Number} [options.minimumCone=0.0] The minimum angle measured from the positive z-axis and toward the negative z-axis.\r\n     * @param {Number} [options.maximumCone=PI] The maximum angle measured from the positive z-axis and toward the negative z-axis.\r\n     * @param {Number} [options.stackPartitions=64] The number of times to partition the ellipsoid into stacks.\r\n     * @param {Number} [options.slicePartitions=64] The number of times to partition the ellipsoid into radial slices.\r\n     * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\r\n     *\r\n     * @exception {DeveloperError} options.slicePartitions cannot be less than three.\r\n     * @exception {DeveloperError} options.stackPartitions cannot be less than three.\r\n     *\r\n     * @see EllipsoidGeometry#createGeometry\r\n     *\r\n     * @example\r\n     * var ellipsoid = new Cesium.EllipsoidGeometry({\r\n     *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,\r\n     *   radii : new Cesium.Cartesian3(1000000.0, 500000.0, 500000.0)\r\n     * });\r\n     * var geometry = Cesium.EllipsoidGeometry.createGeometry(ellipsoid);\r\n     */\r\n    function EllipsoidGeometry(options) {\r\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n        var radii = defaultValue(options.radii, defaultRadii);\r\n        var innerRadii = defaultValue(options.innerRadii, radii);\r\n        var minimumClock = defaultValue(options.minimumClock, 0.0);\r\n        var maximumClock = defaultValue(options.maximumClock, CesiumMath.TWO_PI);\r\n        var minimumCone = defaultValue(options.minimumCone, 0.0);\r\n        var maximumCone = defaultValue(options.maximumCone, CesiumMath.PI);\r\n        var stackPartitions = Math.round(defaultValue(options.stackPartitions, 64));\r\n        var slicePartitions = Math.round(defaultValue(options.slicePartitions, 64));\r\n        var vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (slicePartitions < 3) {\r\n            throw new DeveloperError('options.slicePartitions cannot be less than three.');\r\n        }\r\n        if (stackPartitions < 3) {\r\n            throw new DeveloperError('options.stackPartitions cannot be less than three.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        this._radii = Cartesian3.clone(radii);\r\n        this._innerRadii = Cartesian3.clone(innerRadii);\r\n        this._minimumClock = minimumClock;\r\n        this._maximumClock = maximumClock;\r\n        this._minimumCone = minimumCone;\r\n        this._maximumCone = maximumCone;\r\n        this._stackPartitions = stackPartitions;\r\n        this._slicePartitions = slicePartitions;\r\n        this._vertexFormat = VertexFormat.clone(vertexFormat);\r\n        this._offsetAttribute = options.offsetAttribute;\r\n        this._workerName = 'createEllipsoidGeometry';\r\n    }\r\n\r\n    /**\r\n     * The number of elements used to pack the object into an array.\r\n     * @type {Number}\r\n     */\r\n    EllipsoidGeometry.packedLength = 2 * (Cartesian3.packedLength) + VertexFormat.packedLength + 7;\r\n\r\n    /**\r\n     * Stores the provided instance into the provided array.\r\n     *\r\n     * @param {EllipsoidGeometry} value The value to pack.\r\n     * @param {Number[]} array The array to pack into.\r\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n     *\r\n     * @returns {Number[]} The array that was packed into\r\n     */\r\n    EllipsoidGeometry.pack = function(value, array, startingIndex) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(value)) {\r\n            throw new DeveloperError('value is required');\r\n        }\r\n        if (!defined(array)) {\r\n            throw new DeveloperError('array is required');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        Cartesian3.pack(value._radii, array, startingIndex);\r\n        startingIndex += Cartesian3.packedLength;\r\n\r\n        Cartesian3.pack(value._innerRadii, array, startingIndex);\r\n        startingIndex += Cartesian3.packedLength;\r\n\r\n        VertexFormat.pack(value._vertexFormat, array, startingIndex);\r\n        startingIndex += VertexFormat.packedLength;\r\n\r\n        array[startingIndex++] = value._minimumClock;\r\n        array[startingIndex++] = value._maximumClock;\r\n        array[startingIndex++] = value._minimumCone;\r\n        array[startingIndex++] = value._maximumCone;\r\n        array[startingIndex++] = value._stackPartitions;\r\n        array[startingIndex++] = value._slicePartitions;\r\n        array[startingIndex] = defaultValue(value._offsetAttribute, -1);\r\n\r\n        return array;\r\n    };\r\n\r\n    var scratchRadii = new Cartesian3();\r\n    var scratchInnerRadii = new Cartesian3();\r\n    var scratchVertexFormat = new VertexFormat();\r\n    var scratchOptions = {\r\n        radii : scratchRadii,\r\n        innerRadii : scratchInnerRadii,\r\n        vertexFormat : scratchVertexFormat,\r\n        minimumClock : undefined,\r\n        maximumClock : undefined,\r\n        minimumCone : undefined,\r\n        maximumCone : undefined,\r\n        stackPartitions : undefined,\r\n        slicePartitions : undefined,\r\n        offsetAttribute : undefined\r\n    };\r\n\r\n    /**\r\n     * Retrieves an instance from a packed array.\r\n     *\r\n     * @param {Number[]} array The packed array.\r\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n     * @param {EllipsoidGeometry} [result] The object into which to store the result.\r\n     * @returns {EllipsoidGeometry} The modified result parameter or a new EllipsoidGeometry instance if one was not provided.\r\n     */\r\n    EllipsoidGeometry.unpack = function(array, startingIndex, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(array)) {\r\n            throw new DeveloperError('array is required');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        var radii = Cartesian3.unpack(array, startingIndex, scratchRadii);\r\n        startingIndex += Cartesian3.packedLength;\r\n\r\n        var innerRadii = Cartesian3.unpack(array, startingIndex, scratchInnerRadii);\r\n        startingIndex += Cartesian3.packedLength;\r\n\r\n        var vertexFormat = VertexFormat.unpack(array, startingIndex, scratchVertexFormat);\r\n        startingIndex += VertexFormat.packedLength;\r\n\r\n        var minimumClock = array[startingIndex++];\r\n        var maximumClock = array[startingIndex++];\r\n        var minimumCone = array[startingIndex++];\r\n        var maximumCone = array[startingIndex++];\r\n        var stackPartitions = array[startingIndex++];\r\n        var slicePartitions = array[startingIndex++];\r\n        var offsetAttribute = array[startingIndex];\r\n\r\n        if (!defined(result)) {\r\n            scratchOptions.minimumClock = minimumClock;\r\n            scratchOptions.maximumClock = maximumClock;\r\n            scratchOptions.minimumCone = minimumCone;\r\n            scratchOptions.maximumCone = maximumCone;\r\n            scratchOptions.stackPartitions = stackPartitions;\r\n            scratchOptions.slicePartitions = slicePartitions;\r\n            scratchOptions.offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\r\n            return new EllipsoidGeometry(scratchOptions);\r\n        }\r\n\r\n        result._radii = Cartesian3.clone(radii, result._radii);\r\n        result._innerRadii = Cartesian3.clone(innerRadii, result._innerRadii);\r\n        result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\r\n        result._minimumClock = minimumClock;\r\n        result._maximumClock = maximumClock;\r\n        result._minimumCone = minimumCone;\r\n        result._maximumCone = maximumCone;\r\n        result._stackPartitions = stackPartitions;\r\n        result._slicePartitions = slicePartitions;\r\n        result._offsetAttribute = offsetAttribute === -1 ? undefined : offsetAttribute;\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Computes the geometric representation of an ellipsoid, including its vertices, indices, and a bounding sphere.\r\n     *\r\n     * @param {EllipsoidGeometry} ellipsoidGeometry A description of the ellipsoid.\r\n     * @returns {Geometry|undefined} The computed vertices and indices.\r\n     */\r\n    EllipsoidGeometry.createGeometry = function(ellipsoidGeometry) {\r\n        var radii = ellipsoidGeometry._radii;\r\n        if ((radii.x <= 0) || (radii.y <= 0) || (radii.z <= 0)) {\r\n            return;\r\n        }\r\n\r\n        var innerRadii = ellipsoidGeometry._innerRadii;\r\n        if ((innerRadii.x <= 0) || (innerRadii.y <= 0) || innerRadii.z <= 0) {\r\n            return;\r\n        }\r\n\r\n        var minimumClock = ellipsoidGeometry._minimumClock;\r\n        var maximumClock = ellipsoidGeometry._maximumClock;\r\n        var minimumCone = ellipsoidGeometry._minimumCone;\r\n        var maximumCone = ellipsoidGeometry._maximumCone;\r\n        var vertexFormat = ellipsoidGeometry._vertexFormat;\r\n\r\n        // Add an extra slice and stack so that the number of partitions is the\r\n        // number of surfaces rather than the number of joints\r\n        var slicePartitions = ellipsoidGeometry._slicePartitions + 1;\r\n        var stackPartitions = ellipsoidGeometry._stackPartitions + 1;\r\n\r\n        slicePartitions = Math.round(slicePartitions * Math.abs(maximumClock - minimumClock) / CesiumMath.TWO_PI);\r\n        stackPartitions = Math.round(stackPartitions * Math.abs(maximumCone - minimumCone) / CesiumMath.PI);\r\n\r\n        if (slicePartitions < 2) {\r\n            slicePartitions = 2;\r\n        }\r\n        if (stackPartitions < 2) {\r\n            stackPartitions = 2;\r\n        }\r\n\r\n        var i;\r\n        var j;\r\n        var index = 0;\r\n\r\n        // Create arrays for theta and phi. Duplicate first and last angle to\r\n        // allow different normals at the intersections.\r\n        var phis = [minimumCone];\r\n        var thetas = [minimumClock];\r\n        for (i = 0; i < stackPartitions; i++) {\r\n            phis.push(minimumCone + i * (maximumCone - minimumCone) / (stackPartitions - 1));\r\n        }\r\n        phis.push(maximumCone);\r\n        for (j = 0; j < slicePartitions; j++) {\r\n            thetas.push(minimumClock + j * (maximumClock - minimumClock) / (slicePartitions - 1));\r\n        }\r\n        thetas.push(maximumClock);\r\n        var numPhis = phis.length;\r\n        var numThetas = thetas.length;\r\n\r\n        // Allow for extra indices if there is an inner surface and if we need\r\n        // to close the sides if the clock range is not a full circle\r\n        var extraIndices = 0;\r\n        var vertexMultiplier = 1.0;\r\n        var hasInnerSurface = ((innerRadii.x !== radii.x) || (innerRadii.y !== radii.y) || innerRadii.z !== radii.z);\r\n        var isTopOpen = false;\r\n        var isBotOpen = false;\r\n        var isClockOpen = false;\r\n        if (hasInnerSurface) {\r\n            vertexMultiplier = 2.0;\r\n            if (minimumCone > 0.0) {\r\n                isTopOpen = true;\r\n                extraIndices += (slicePartitions - 1);\r\n            }\r\n            if (maximumCone < Math.PI) {\r\n                isBotOpen = true;\r\n                extraIndices += (slicePartitions - 1);\r\n            }\r\n            if ((maximumClock - minimumClock) % CesiumMath.TWO_PI) {\r\n                isClockOpen = true;\r\n                extraIndices += ((stackPartitions - 1) * 2) + 1;\r\n            } else {\r\n                extraIndices += 1;\r\n            }\r\n        }\r\n\r\n        var vertexCount = numThetas * numPhis * vertexMultiplier;\r\n        var positions = new Float64Array(vertexCount * 3);\r\n        var isInner = arrayFill(new Array(vertexCount), false);\r\n        var negateNormal = arrayFill(new Array(vertexCount), false);\r\n\r\n        // Multiply by 6 because there are two triangles per sector\r\n        var indexCount = slicePartitions * stackPartitions * vertexMultiplier;\r\n        var numIndices = 6 * (indexCount + extraIndices + 1 - (slicePartitions + stackPartitions) * vertexMultiplier);\r\n        var indices = IndexDatatype.createTypedArray(indexCount, numIndices);\r\n\r\n        var normals = (vertexFormat.normal) ? new Float32Array(vertexCount * 3) : undefined;\r\n        var tangents = (vertexFormat.tangent) ? new Float32Array(vertexCount * 3) : undefined;\r\n        var bitangents = (vertexFormat.bitangent) ? new Float32Array(vertexCount * 3) : undefined;\r\n        var st = (vertexFormat.st) ? new Float32Array(vertexCount * 2) : undefined;\r\n\r\n        // Calculate sin/cos phi\r\n        var sinPhi = new Array(numPhis);\r\n        var cosPhi = new Array(numPhis);\r\n        for (i = 0; i < numPhis; i++) {\r\n            sinPhi[i] = sin(phis[i]);\r\n            cosPhi[i] = cos(phis[i]);\r\n        }\r\n\r\n        // Calculate sin/cos theta\r\n        var sinTheta = new Array(numThetas);\r\n        var cosTheta = new Array(numThetas);\r\n        for (j = 0; j < numThetas; j++) {\r\n            cosTheta[j] = cos(thetas[j]);\r\n            sinTheta[j] = sin(thetas[j]);\r\n        }\r\n\r\n        // Create outer surface\r\n        for (i = 0; i < numPhis; i++) {\r\n            for (j = 0; j < numThetas; j++) {\r\n                positions[index++] = radii.x * sinPhi[i] * cosTheta[j];\r\n                positions[index++] = radii.y * sinPhi[i] * sinTheta[j];\r\n                positions[index++] = radii.z * cosPhi[i];\r\n            }\r\n        }\r\n\r\n        // Create inner surface\r\n        var vertexIndex = vertexCount / 2.0;\r\n        if (hasInnerSurface) {\r\n            for (i = 0; i < numPhis; i++) {\r\n                for (j = 0; j < numThetas; j++) {\r\n                    positions[index++] = innerRadii.x * sinPhi[i] * cosTheta[j];\r\n                    positions[index++] = innerRadii.y * sinPhi[i] * sinTheta[j];\r\n                    positions[index++] = innerRadii.z * cosPhi[i];\r\n\r\n                    // Keep track of which vertices are the inner and which ones\r\n                    // need the normal to be negated\r\n                    isInner[vertexIndex] = true;\r\n                    if (i > 0 && i !== (numPhis - 1) && j !== 0 && j !== (numThetas - 1)) {\r\n                        negateNormal[vertexIndex] = true;\r\n                    }\r\n                    vertexIndex++;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Create indices for outer surface\r\n        index = 0;\r\n        var topOffset;\r\n        var bottomOffset;\r\n        for (i = 1; i < (numPhis - 2); i++) {\r\n            topOffset = i * numThetas;\r\n            bottomOffset = (i + 1) * numThetas;\r\n\r\n            for (j = 1; j < numThetas - 2; j++) {\r\n                indices[index++] = bottomOffset + j;\r\n                indices[index++] = bottomOffset + j + 1;\r\n                indices[index++] = topOffset + j + 1;\r\n\r\n                indices[index++] = bottomOffset + j;\r\n                indices[index++] = topOffset + j + 1;\r\n                indices[index++] = topOffset + j;\r\n            }\r\n        }\r\n\r\n        // Create indices for inner surface\r\n        if (hasInnerSurface) {\r\n            var offset = numPhis * numThetas;\r\n            for (i = 1; i < (numPhis - 2); i++) {\r\n                topOffset = offset + i * numThetas;\r\n                bottomOffset = offset + (i + 1) * numThetas;\r\n\r\n                for (j = 1; j < numThetas - 2; j++) {\r\n                    indices[index++] = bottomOffset + j;\r\n                    indices[index++] = topOffset + j;\r\n                    indices[index++] = topOffset + j + 1;\r\n\r\n                    indices[index++] = bottomOffset + j;\r\n                    indices[index++] = topOffset + j + 1;\r\n                    indices[index++] = bottomOffset + j + 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        var outerOffset;\r\n        var innerOffset;\r\n        if (hasInnerSurface) {\r\n            if (isTopOpen) {\r\n                // Connect the top of the inner surface to the top of the outer surface\r\n                innerOffset = numPhis * numThetas;\r\n                for (i = 1; i < numThetas - 2; i++) {\r\n                    indices[index++] = i;\r\n                    indices[index++] = i + 1;\r\n                    indices[index++] = innerOffset + i + 1;\r\n\r\n                    indices[index++] = i;\r\n                    indices[index++] = innerOffset + i + 1;\r\n                    indices[index++] = innerOffset + i;\r\n                }\r\n            }\r\n\r\n            if (isBotOpen) {\r\n                // Connect the bottom of the inner surface to the bottom of the outer surface\r\n                outerOffset = numPhis * numThetas - numThetas;\r\n                innerOffset = numPhis * numThetas * vertexMultiplier - numThetas;\r\n                for (i = 1; i < numThetas - 2; i++) {\r\n                    indices[index++] = outerOffset + i + 1;\r\n                    indices[index++] = outerOffset + i;\r\n                    indices[index++] = innerOffset + i;\r\n\r\n                    indices[index++] = outerOffset + i + 1;\r\n                    indices[index++] = innerOffset + i;\r\n                    indices[index++] = innerOffset + i + 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Connect the edges if clock is not closed\r\n        if (isClockOpen) {\r\n            for (i = 1; i < numPhis - 2; i++) {\r\n                innerOffset = numThetas * numPhis + (numThetas * i);\r\n                outerOffset = numThetas * i;\r\n                indices[index++] = innerOffset;\r\n                indices[index++] = outerOffset + numThetas;\r\n                indices[index++] = outerOffset;\r\n\r\n                indices[index++] = innerOffset;\r\n                indices[index++] = innerOffset + numThetas;\r\n                indices[index++] = outerOffset + numThetas;\r\n            }\r\n\r\n            for (i = 1; i < numPhis - 2; i++) {\r\n                innerOffset = numThetas * numPhis + (numThetas * (i + 1)) - 1;\r\n                outerOffset = numThetas * (i + 1) - 1;\r\n                indices[index++] = outerOffset + numThetas;\r\n                indices[index++] = innerOffset;\r\n                indices[index++] = outerOffset;\r\n\r\n                indices[index++] = outerOffset + numThetas;\r\n                indices[index++] = innerOffset + numThetas;\r\n                indices[index++] = innerOffset;\r\n            }\r\n        }\r\n\r\n        var attributes = new GeometryAttributes();\r\n\r\n        if (vertexFormat.position) {\r\n            attributes.position = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.DOUBLE,\r\n                componentsPerAttribute : 3,\r\n                values : positions\r\n            });\r\n        }\r\n\r\n        var stIndex = 0;\r\n        var normalIndex = 0;\r\n        var tangentIndex = 0;\r\n        var bitangentIndex = 0;\r\n        var vertexCountHalf = vertexCount / 2.0;\r\n\r\n        var ellipsoid;\r\n        var ellipsoidOuter = Ellipsoid.fromCartesian3(radii);\r\n        var ellipsoidInner = Ellipsoid.fromCartesian3(innerRadii);\r\n\r\n        if (vertexFormat.st || vertexFormat.normal || vertexFormat.tangent || vertexFormat.bitangent) {\r\n            for (i = 0; i < vertexCount; i++) {\r\n                ellipsoid = (isInner[i]) ? ellipsoidInner : ellipsoidOuter;\r\n                var position = Cartesian3.fromArray(positions, i * 3, scratchPosition);\r\n                var normal = ellipsoid.geodeticSurfaceNormal(position, scratchNormal);\r\n                if (negateNormal[i]) {\r\n                    Cartesian3.negate(normal, normal);\r\n                }\r\n\r\n                if (vertexFormat.st) {\r\n                    var normalST = Cartesian2.negate(normal, scratchNormalST);\r\n                    st[stIndex++] = (Math.atan2(normalST.y, normalST.x) / CesiumMath.TWO_PI) + 0.5;\r\n                    st[stIndex++] = (Math.asin(normal.z) / Math.PI) + 0.5;\r\n                }\r\n\r\n                if (vertexFormat.normal) {\r\n                    normals[normalIndex++] = normal.x;\r\n                    normals[normalIndex++] = normal.y;\r\n                    normals[normalIndex++] = normal.z;\r\n                }\r\n\r\n                if (vertexFormat.tangent || vertexFormat.bitangent) {\r\n                    var tangent = scratchTangent;\r\n\r\n                    // Use UNIT_X for the poles\r\n                    var tangetOffset = 0;\r\n                    var unit;\r\n                    if (isInner[i]) {\r\n                        tangetOffset = vertexCountHalf;\r\n                    }\r\n                    if ((!isTopOpen && (i >= tangetOffset && i < (tangetOffset + numThetas * 2)))) {\r\n                        unit = Cartesian3.UNIT_X;\r\n                    } else {\r\n                        unit = Cartesian3.UNIT_Z;\r\n                    }\r\n                    Cartesian3.cross(unit, normal, tangent);\r\n                    Cartesian3.normalize(tangent, tangent);\r\n\r\n                    if (vertexFormat.tangent) {\r\n                        tangents[tangentIndex++] = tangent.x;\r\n                        tangents[tangentIndex++] = tangent.y;\r\n                        tangents[tangentIndex++] = tangent.z;\r\n                    }\r\n\r\n                    if (vertexFormat.bitangent) {\r\n                        var bitangent = Cartesian3.cross(normal, tangent, scratchBitangent);\r\n                        Cartesian3.normalize(bitangent, bitangent);\r\n\r\n                        bitangents[bitangentIndex++] = bitangent.x;\r\n                        bitangents[bitangentIndex++] = bitangent.y;\r\n                        bitangents[bitangentIndex++] = bitangent.z;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (vertexFormat.st) {\r\n                attributes.st = new GeometryAttribute({\r\n                    componentDatatype : ComponentDatatype.FLOAT,\r\n                    componentsPerAttribute : 2,\r\n                    values : st\r\n                });\r\n            }\r\n\r\n            if (vertexFormat.normal) {\r\n                attributes.normal = new GeometryAttribute({\r\n                    componentDatatype : ComponentDatatype.FLOAT,\r\n                    componentsPerAttribute : 3,\r\n                    values : normals\r\n                });\r\n            }\r\n\r\n            if (vertexFormat.tangent) {\r\n                attributes.tangent = new GeometryAttribute({\r\n                    componentDatatype : ComponentDatatype.FLOAT,\r\n                    componentsPerAttribute : 3,\r\n                    values : tangents\r\n                });\r\n            }\r\n\r\n            if (vertexFormat.bitangent) {\r\n                attributes.bitangent = new GeometryAttribute({\r\n                    componentDatatype : ComponentDatatype.FLOAT,\r\n                    componentsPerAttribute : 3,\r\n                    values : bitangents\r\n                });\r\n            }\r\n        }\r\n\r\n        if (defined(ellipsoidGeometry._offsetAttribute)) {\r\n            var length = positions.length;\r\n            var applyOffset = new Uint8Array(length / 3);\r\n            var offsetValue = ellipsoidGeometry._offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\r\n            arrayFill(applyOffset, offsetValue);\r\n            attributes.applyOffset = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.UNSIGNED_BYTE,\r\n                componentsPerAttribute : 1,\r\n                values : applyOffset\r\n            });\r\n        }\r\n\r\n        return new Geometry({\r\n            attributes : attributes,\r\n            indices : indices,\r\n            primitiveType : PrimitiveType.TRIANGLES,\r\n            boundingSphere : BoundingSphere.fromEllipsoid(ellipsoidOuter),\r\n            offsetAttribute : ellipsoidGeometry._offsetAttribute\r\n        });\r\n    };\r\n\r\n    var unitEllipsoidGeometry;\r\n\r\n    /**\r\n     * Returns the geometric representation of a unit ellipsoid, including its vertices, indices, and a bounding sphere.\r\n     * @returns {Geometry} The computed vertices and indices.\r\n     *\r\n     * @private\r\n     */\r\n    EllipsoidGeometry.getUnitEllipsoid = function() {\r\n        if (!defined(unitEllipsoidGeometry)) {\r\n            unitEllipsoidGeometry = EllipsoidGeometry.createGeometry((new EllipsoidGeometry({\r\n                radii : new Cartesian3(1.0, 1.0, 1.0),\r\n                vertexFormat : VertexFormat.POSITION_ONLY\r\n            })));\r\n        }\r\n        return unitEllipsoidGeometry;\r\n    };\r\nexport default EllipsoidGeometry;\r\n"],"names":["Cartesian3","defaultValue","CesiumMath","VertexFormat","DeveloperError","defined","arrayFill","IndexDatatype","GeometryAttributes","GeometryAttribute","ComponentDatatype","Ellipsoid","Cartesian2","GeometryOffsetAttribute","Geometry","PrimitiveType","BoundingSphere"],"mappings":"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"}