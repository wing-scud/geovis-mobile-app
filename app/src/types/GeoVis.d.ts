declare namespace GeoVis {
/// <reference types="node" />

 class Evented {
	protected _listeners: object;
	protected _oneTimeListeners: object;
	protected _EventedParent: Evented;
	protected _EventedParentData: any;
	/**
	 * 监听事件
	 * @param {string} type 监听的事件类型类型
	 * @param {callback} listener 事件回调函数
	 * @return {Evented}
	 * @public
	 */
	on: (type: any, listener: any) => this;
	/**
	 * 关闭监听
	 * @param {string} type 关闭监听的事件类型类型
	 * @param {callback} listener 关闭的事件回调函数
	 * @return {Evented}
	 */
	off: (type: any, listener: any) => this;
	/**
	 * 监听一次
	 * @param {string} type 关闭监听的事件类型类型
	 * @param {callback} listener 关闭的事件回调函数
	 * @return {Evented}
	 */
	once: (type: any, listener: any) => this;
	/**
	 * 触发事件
	 * @param {string} type 关闭监听的事件类型类型
	 * @param {callback} data 关闭的事件回调函数
	 * @return {Evented}
	 */
	fire: (type: any, data: any) => this;
	/**
	 * 关闭监听
	 * @param {string} type 关闭监听的事件类型类型
	 * @return {boolean}
	 */
	listens: (type: any) => any;
	setEventedParent: (parent: any, data: any) => this;
}
 function on(type: any, listener: any): any;
 function off(type: any, listener: any): any;
 function once(type: any, listener: any): any;
 function fire(type: any, data: any): any;
 function setEventedParent(parent: any, data: any): any;
 function listens(type: any): any;
 module Engine {
	//

	class SingleImageryProvider {
		constructor(options: {
			url: Resource | string | HTMLCanvasElement;
			rectangle?: Rectangle;
			credit?: Credit | string;
			ellipsoid?: Ellipsoid;
		});

		/**
		 * Gets the URL of the single, top-level imagery tile.
		 * @memberof SingleTileImageryProvider.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly url: string;

		/**
		 * Gets the proxy used by this provider.
		 * @memberof SingleTileImageryProvider.prototype
		 * @type {Proxy}
		 * @readonly
		 */
		readonly proxy: Proxy;

		/**
		 * Gets the width of each tile, in pixels. This function should
		 * not be called before {@link SingleTileImageryProvider#ready} returns true.
		 * @memberof SingleTileImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly tileWidth: number;

		/**
		 * Gets the height of each tile, in pixels.  This function should
		 * not be called before {@link SingleTileImageryProvider#ready} returns true.
		 * @memberof SingleTileImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly tileHeight: number;

		/**
		 * Gets the maximum level-of-detail that can be requested.  This function should
		 * not be called before {@link SingleTileImageryProvider#ready} returns true.
		 * @memberof SingleTileImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly maximumLevel: number;

		/**
		 * Gets the minimum level-of-detail that can be requested.  This function should
		 * not be called before {@link SingleTileImageryProvider#ready} returns true.
		 * @memberof SingleTileImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly minimumLevel: number;

		/**
		 * Gets the tiling scheme used by this provider.  This function should
		 * not be called before {@link SingleTileImageryProvider#ready} returns true.
		 * @memberof SingleTileImageryProvider.prototype
		 * @type {TilingScheme}
		 * @readonly
		 */
		readonly tilingScheme: TilingScheme;

		/**
		 * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should
		 * not be called before {@link SingleTileImageryProvider#ready} returns true.
		 * @memberof SingleTileImageryProvider.prototype
		 * @type {Rectangle}
		 * @readonly
		 */
		readonly rectangle: Rectangle;

		/**
		 * Gets the tile discard policy.  If not undefined, the discard policy is responsible
		 * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
		 * returns undefined, no tiles are filtered.  This function should
		 * not be called before {@link SingleTileImageryProvider#ready} returns true.
		 * @memberof SingleTileImageryProvider.prototype
		 * @type {TileDiscardPolicy}
		 * @readonly
		 */
		readonly tileDiscardPolicy: TileDiscardPolicy;

		/**
		 * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
		 * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
		 * are passed an instance of {@link TileProviderError}.
		 * @memberof SingleTileImageryProvider.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly errorEvent: Event;

		/**
		 * Gets a value indicating whether or not the provider is ready for use.
		 * @memberof SingleTileImageryProvider.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly ready: boolean;

		/**
		 * Gets a promise that resolves to true when the provider is ready for use.
		 * @memberof SingleTileImageryProvider.prototype
		 * @type {Promise.<Boolean>}
		 * @readonly
		 */
		readonly readyPromise: any;

		/**
		 * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
		 * the source of the imagery.  This function should not be called before {@link SingleTileImageryProvider#ready} returns true.
		 * @memberof SingleTileImageryProvider.prototype
		 * @type {Credit}
		 * @readonly
		 */
		readonly credit: Credit;

		/**
		 * Gets a value indicating whether or not the images provided by this imagery provider
		 * include an alpha channel.  If this property is false, an alpha channel, if present, will
		 * be ignored.  If this property is true, any images without an alpha channel will be treated
		 * as if their alpha is 1.0 everywhere.  When this property is false, memory usage
		 * and texture upload time are reduced.
		 * @memberof SingleTileImageryProvider.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly hasAlphaChannel: boolean;

		/**
		 * Gets the credits to be displayed when a given tile is displayed.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level;
		 * @returns {Credit[]} The credits to be displayed when the tile is displayed.
		 * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.
		 */
		getTileCredits(x: number, y: number, level: number): (Credit)[];

		/**
		 * Requests the image for a given tile.  This function should
		 * not be called before {@link SingleTileImageryProvider#ready} returns true.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level.
		 * @param {Request} [request] The request object. Intended for internal use only.
		 * @returns {Promise.<Image|Canvas>|undefined} A promise for the image that will resolve when the image is available, or
		 *          undefined if there are too many active requests to the server, and the request
		 *          should be retried later.  The resolved image may be either an
		 *          Image or a Canvas DOM object.
		 * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.
		 */
		requestImage(x: number, y: number, level: number, request?: Request): any | any | undefined;

		/**
		 * Picking features is not currently supported by this imagery provider, so this function simply returns
		 * undefined.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level.
		 * @param {Number} longitude The longitude at which to pick features.
		 * @param {Number} latitude  The latitude at which to pick features.
		 * @return {Promise.<ImageryLayerFeatureInfo[]>|undefined} A promise for the picked features that will resolve when the asynchronous
		 *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}
		 *                   instances.  The array may be empty if no features are found at the given location.
		 *                   It may also be undefined if picking is not supported.
		 */
		pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): any | undefined;

	}
	function sampleTerrainMostDetailed(provider: TerrainProvider, positions:Cartographic[]): Promise<Cartographic>[];
}
/**
 * 有序的图层集合.
 *
 * @alias LayerGroup
 * @constructor
 */
 class LayerGroup extends ImageryLayerCollection {
	on: typeof on;
	off: typeof off;
	once: typeof once;
	fire: typeof fire;
	listens: typeof listens;
	setEventedParent: typeof setEventedParent;
	private _layers;
	private _update;
	/**
	 * 获取图层数量
	 * @type {number}
	 * @readonly
	 */
	readonly length: any;
	status(): string;
	/**
	 * 获取图层数组
	 * @returns {Layer[]}
	 */
	readonly layers: any;
	/**
	 * 添加图层.
	 * @param {Layer} layer 需要添加的图层.
	 */
	/**
	 * 移除图层.
	 * @param {Layer} layer 需要移除的图层.
	 */
	/**
	 * 判断Group是否包含图层.
	 * @param {Layer} layer 需要检查的图层.
	 */
	contains(layer: ImageryLayer): boolean;
	/**
	 * 根据索引值获取图层.
	 * @param {Layer} layer 图层索引值.
	 */
	get(index: any): any;
	/**
	 * 下移图层
	 * @param {Layer} layer 需要移动的图层.
	 */
	lower(layer: ImageryLayer): void;
	/**
	 * 下移图层至底部
	 * @param {Layer} layer 需要移动的图层.
	 * lowerToBottom
	 */
	/**
	 * 上移图层
	 * @param {Layer} layer 需要移动的图层.
	 */
	raise(layer: ImageryLayer): void;
}
 class Globe extends EngineGlobe {
	imageryLayers: LayerGroup;
	private _imageryLayerCollection;
	private _terrainProvider;
	private _surface;
	private _surfaceShaderSet;
	constructor(ellipsoid: any);
}
 class Camera extends EngineCamera {
	viewRectangle: Rectangle;
	viewBoundingRectangle: BoundingRectangle;
	on: typeof on;
	off: typeof off;
	once: typeof once;
	fire: typeof fire;
	listens: typeof listens;
	setEventedParent: typeof setEventedParent;
	protected _zoomIn: any;
	protected _zoomOut: any;
	protected _scene: EngineScene;
   static MAX_PITCH: number;
	constructor(scene: any);
	calcDistanceToViewBounds(minlat: number, maxlat: number, minlon: number, maxlon: number): number;
	calculatePositionForGivenTarget(lat: any, lng: any, alt: any, heading: any, tilt: any): any[];
	calcAltitudeForZoom(canvas: any, fov: any, zoom: any, latitude: any): number;
	calcZoomForAltitude(canvas: any, fov: any, altitude: any, latitude: any): number;
	setViewport(viewport: any): void;
	zoomToheight(zoom: any): number;
	heightTozoom(height: any): number;
	updateViewRectangle: () => void;
	scaleZoom(scale: any): number;
	zoom: (dire: string) => void;
}
 class Scene extends EngineScene {
	initializeFrame: () => any;
	render: (time: JulianDate) => any;
	private _camera;
	private _screenSpaceCameraController;
	private _cameraClone;
	private _globe;
	private _view;
	private viewSheds;
	constructor(options: any);
	readonly camera: Camera;
	readonly imageryLayers: LayerGroup;
	imagerySplitPosition: any;
}
 class AbstractMarker extends Evented {
	protected _id: string;
	private _element;
	private _parentElement;
	private _enabled;
	private _visible;
	private _features;
	private _lonlat;
	private _position;
	private _mode;
	serializeble: boolean;
	constructor(pos: Cartesian3 | lonlatTuple, element: HTMLElement, mode: string, serializeble?: boolean);
	mode: String;
	private modechaged;
	attachPopup(arg0: any): any;
	attachTooltip(arg0: any): any;
	readonly id: string;
	/**
	 * 获取或设置element
	 * @memberof AbstractMarker
	 * @type {Nubmber}
	 */
	element: HTMLElement;
	/**
	 * 获取或设置高度
	 * @memberof AbstractMarker
	 * @type {Nubmber}
	 */
	parentElement: HTMLElement;
	/**
	 * 获取或设置高度
	 * @memberof AbstractMarker
	 * @type {Nubmber}
	 */
	visible: boolean;
	/**
	 * 显示或隐藏marker
	 * @memberof AbstractMarker
	 * @type {Boolean}
	 */
	enabled: boolean;
	attach(parentElement: HTMLElement): void;
	detach(): void;
	setXY(x: any, y: any): void;
	addTo(features: FeatureGroup): this;
	removeFrom(features: FeatureGroup): this;
	bindPopup(content: any, maxWOrOpts: any, closeBtn: any): this;
	bindTooltip(content: any, classname: any): this;
	position: Cartesian3;
	lonlat: lonlatTuple;
}
 class MarkerGroup {
	private _markerMap;
	private _earth;
	private _element;
	constructor();
	addMarker(marker: AbstractMarker): AbstractMarker;
	getMarker(key: string): AbstractMarker;
	removeMarker(marker: AbstractMarker): AbstractMarker;
	updateMarkers(): void;
	hasMarker(marker: AbstractMarker): boolean;
	addTo(earth: Earth | Widget): this;
	removeFrom(earth: Earth | Widget): void;
	updateMarker(marker: AbstractMarker): void;
}
export interface FeatureGroupOptions {
	cluster?: Boolean;
}
/** 元素集合类
 * @constructor
 */
 class FeatureGroup extends Evented {
	clustering: any;
	private _pointPrimitives;
	private _pointPrimitivesLight;
	private _primitives;
	private _groundPrimitives;
	private _labels;
	private _map;
	private _earth;
	private _markers;
	private _billboards;
	private _billboardsLight;
	constructor(options?: FeatureGroupOptions);
	readonly primitives: PrimitiveCollection;
	readonly map: Map<string, any>;
	readonly earth: Earth | Widget;
	readonly groundPrimitives: PrimitiveCollection;
	readonly markers: MarkerGroup;
	readonly labels: LabelCollection;
	readonly pointPrimitivesLight: PointPrimitiveCollectionFix;
	readonly pointPrimitives: PointPrimitiveCollection;
	/**
	 * 实体的集合
	 * @type {[]|Feature}
	 */
	readonly values: () => IterableIterator<any>;
	/**
	 * 添加实体
	 * @param {Point|Polyline|Polygon|Circle|Marker|Rectangle} feature 需要添加的实体
	 */
	add(feature: any): void;
	/**
	 * 移除实体
	 * @param {Point|Polyline|Polygon|Circle|Marker|Rectangle} feature 需要移除的实体
	 */
	remove(feature: any): void;
	/**
	 * 根据id获取点
	 * @param {String} id 实体的id
	 */
	get(id: any): any;
	init(): void;
	contains(feature: any): boolean;
	/**
	 * 添加至Earth
	 * @param {Earth} earth
	 */
	addTo(earth: Earth | Widget): this;
	/**
	 * 从Earth移除
	 * @param {Earth} earth
	 */
	removeFrom(earth: Earth | Widget): this;
	removeAll(): void;
}
 enum ProjectionType {
	EPSG4326 = "EPSG:4326",
	EPSG900913 = "EPSG:900913"
}
 enum CameraEventType {
	CHANGE = "change"
}
 enum EarthEventType {
	CHANGE = "change",
	TICK = "tick"
}
export interface WidgetOptions {
	scene?: {
		contextOptions?: any;
		creditContainer?: Element;
		creditViewport?: Element;
		projection?: ProjectionType;
		orderIndependentTranslucency?: boolean;
		scene3DOnly?: boolean;
		terrainExaggeration?: number;
		shadows?: boolean;
		mapMode2D?: any;
		requestRenderMode?: boolean;
		maximumRenderTimeChange?: number;
	};
	shadows?: boolean;
	three?: boolean;
}
 class Widget extends Evented {
	targetFrameRate: number;
	protected _particleGroup: any;
	protected _container: HTMLElement;
	private _canvas;
	private _layers;
	private _features;
	private _clock;
	private _forcedPause;
	private _globe;
	private _scene;
	private _camera;
	private _serialieser;
	private _dataSources;
	private threeRenderer;
	private _lastViewMatrix;
	private renderNeeded;
	private _sceneChanged;
	private handlers;
	/**
	 *
	 * @param {string} container GeoVis绘制场景的HTML节点，或节点的字符串id.
	 * @param {Object} [options={}] 可选参数
	 * @param {string} [options.projection='EPSG:4326'] 投影类型, EPSG:4326或者EPSG:900913.
	 * @param {boolean} [options.scene3DOnly=false] 为true则geometry只会在3D模式下渲染以节省性能.
	 * @param {boolean} [options.shouldAnimate=false] 设置Clock是否运行.
	 * @param {boolean} [options.requestRenderMode=false] 如果为true，则渲染帧仅在需要时才会发生，具体取决于场景中的更改。启用可以提高应用程序的性能，但需要使用Scene#requestRender此模式显式呈现新帧。在API的其他部分中对场景进行更改后，在许多情况下这是必要的.
	 * @param {number} [options.maximumRenderTimeChange=false] 如果requestRenderMode为true，则此值定义在请求呈现之前允许的模拟时间的最大更改.
	 * @param {boolean} [options.cesium=false] 是否启用Cesium中除Widgets以外所有接口
	 * @constructor
	 * @extends Evented
	 */
	constructor(container: string | HTMLElement, options?: WidgetOptions);
	/**
	 * 获取canvas
	 * @memberof Widget.prototype
	 * @type {HTMLDivElement}
	 * @readonly
	 */
	readonly container: HTMLElement;
	/**
	 * 获取canvas
	 * @memberof Widget.prototype
	 * @type {HTMLCanvasElement}
	 * @readonly
	 */
	readonly canvas: HTMLCanvasElement;
	/**
	 * 获取绑定到该Earth的layer集合
	 * @memberof Widget.prototype
	 * @type {LayerGroup}
	 * @readonly
	 */
	readonly layers: LayerGroup;
	/**
	 * 获取绑定到该earth的feature集合
	 * @type {FeatureGroup}
	 * @readonly
	 */
	readonly features: FeatureGroup;
	/**
	 * 获取绑定到该earth的feature集合
	 * @type {FeatureGroup}
	 * @readonly
	 */
	readonly clock: Clock;
	/**
	 * 强制终止场景中的渲染循环
	 * @type {boolean}
	 * @default false
	 * @memberof Widget
	 * @instance
	 */
	forcedPause: boolean;
	readonly particleGroup: any;
	/**
	 * 获取Globe
	 * @type {Globe}
	 * @readonly
	 */
	readonly globe: Globe;
	/**
	 * 获取场景
	 * @type {Globe}
	 * @readonly
	 */
	readonly scene: Scene;
	/**
	 * 获取相机
	 * @type {Camera}
	 * @readonly
	 */
	readonly camera: Camera;
	/**
	 * 缩放相机
	 * @param {string} direction 'in'或者'out'
	 */
	readonly zoom: (dire: string) => void;
	requestUpdate: () => void;
	handleResize: () => void;
	flyTo(position: any, options: any): void;
	destroy: () => void;
	render: () => void;
	save: () => string;
	load: (data: any) => {
		features: any;
		dataSources: any;
	};
}
export interface ViewerOptions extends WidgetOptions {
  shouldAnimate?: boolean,
  dataSources?: DataSourceCollection,
  automaticallyTrackDataSourceClocks?: boolean
}
 class Earth extends Widget {
  // constructor(container: Element | string, options?: Viewer.ConstructorOptions);
  allowDataSourcesToSuspendAnimation: boolean;
  readonly camera: Camera;
  readonly canvas: HTMLCanvasElement;
  readonly clock: Clock;
  clockTrackedDataSource: DataSource;
  readonly dataSourceDisplay: DataSourceDisplay;
  readonly dataSources: DataSourceCollection;
  readonly entities: EntityCollection;
  readonly imageryLayers: LayerGroup;
  // readonly infoBox: InfoBox;
  // readonly navigationHelpButton: NavigationHelpButton;
  // resolutionScale: number;
  readonly scene: Scene;
  readonly screenSpaceEventHandler: ScreenSpaceEventHandler;
  selectedEntity?: Entity;
  readonly selectedEntityChanged: Event;
  readonly shadowMap: ShadowMap;
  shadows: boolean;
  targetFrameRate: number;
  terrainProvider: TerrainProvider;
  terrainShadows: boolean;
  trackedEntity?: Entity;
  readonly trackedEntityChanged: Event;
  useDefaultRenderLoop: boolean;
  // destroy(): void;
  // extend(mixin: ViewerMixin, options: any): void;
  flyTo(target: TargetTypes | Promise<TargetTypes>,
	options?: { duration?: number; offset?: HeadingPitchRange }): Promise<boolean>;
  forceResize(): void;
  // isDestroyed(): boolean;
  // render(): void;
  resize(): void;
  zoomTo(target: TargetTypes | Promise<TargetTypes>,
	offset?: HeadingPitchRange): Promise<boolean>;



  extend(mixin, options): any
  isDestroyed: () => boolean
  // zoomTo(target: Entity | Entity[] | EntityCollection | DataSource | ImageryLayer | Cesium3DTileset | Promise<Entity | Entity[] | EntityCollection | DataSource | ImageryLayer | Cesium3DTileset>, offset?: HeadingPitchRange): Promise<boolean>
  // public flyTo(target: lonlatTuple | Entity | Entity[] | EntityCollection | DataSource | ImageryLayer | Cesium3DTileset | Promise<Entity | Entity[] | EntityCollection | DataSource | ImageryLayer | Cesium3DTileset>, options: {
  //   duration?: number,
  //   maximumHeight?: number,
  //   offset: HeadingPitchRange
  // }): Promise<boolean>
  constructor(container: string | HTMLDivElement, options: ViewerOptions)
}
export type TargetTypes =
  Entity |
  Entity[] |
  EntityCollection |
  DataSource |
  ImageryLayer |
  Cesium3DTileset
 class Material extends EngineMaterial {
	/**
	 * 飞线纹理
	 */
	static PolylineFlyingType: string;
	static PolylineCyberType: string;
	static RadarScanType: string;
	static CyberImpact: string;
	static CyberCone: string;
	static Circular: string;
	static DashAnimate: string;
	static Ripple: string;
	static _materialCache: any;
}
/**
 * 一个2D笛卡尔点。
 * @alias Vector2
 * @constructor
 * @name Vector2
 * @param {Number} [x=0.0] X变量。
 * @param {Number} [y=0.0] Y变量。
 */
 class Vector2 extends Cartesian2 {
	constructor(x: any, y: any);
}
/**
 * 三维笛卡尔向量, Vector3是数字的有序三元组(标记为x，y和z), 可用于表示许多事物，如：
 * 三维空间中的一个点.
 * 三维空间中的方向和长度.
 * 还有其他的东西，一个3D矢量可以用来表示，如动量矢量等.
 */
 class Vector3 extends Cartesian3 {
	constructor(x: any, y: any, z: any);
}
export interface AbstractLayerOptions {
	rectangle?: Rectangle;
	alpha?: number | (() => any);
	brightness?: number | (() => any);
	contrast?: number | (() => any);
	hue?: number | (() => any);
	saturation?: number | (() => any);
	gamma?: number | (() => any);
	splitDirection?: any | (() => any);
	minificationFilter?: any;
	magnificationFilter?: any;
	show?: boolean;
	maximumAnisotropy?: number;
	minimumTerrainLevel?: number;
	maximumTerrainLevel?: number;
}
 class AbstractLayer extends ImageryLayer {
	protected _id: string;
	protected _tileWidth: number;
	protected _tileHeight: number;
	protected _maxLevel: number;
	protected _minLevel: number;
	protected _projection: string;
	protected _alpha: number;
	protected _brightness: number;
	protected _contrast: number;
	protected _hue: number;
	protected _saturation: number;
	protected _name: string;
	protected _layers: LayerGroup;
	protected _layer: ImageryLayer;
	protected _url: string;
	protected _splitDirection: number;
	constructor(provider: ImageryProvider, options?: AbstractLayerOptions);
	readonly id: string;
	/**
	 * 图层url
	 * @memberof AbstractLayer
	 * @type {String}
	 * @name url
	 * @memberof AbstractLayer
	 * @instance
	 * @readonly
	 */
	readonly url: string;
	/**
	 * 图层tileWidth
	 * @memberof AbstractLayer
	 * @type {Number}
	 * @readonly
	 */
	readonly tileWidth: number;
	/**
	 * 图层tileHeight
	 * @memberof AbstractLayer
	 * @type {Number}
	 * @readonly
	 */
	readonly tileHeight: number;
	/**
	 * 图层maxLevel
	 * @memberof AbstractLayer
	 * @type {Number}
	 * @readonly
	 */
	readonly maxLevel: number;
	/**
	 * 图层minLevel
	 * @memberof AbstractLayer
	 * @type {Number}
	 * @readonly
	 */
	readonly minLevel: number;
	/**
	 * 图层projection
	 * @memberof AbstractLayer
	 * @type {Number}
	 * @readonly
	 */
	readonly projection: string;
	/**
	 * 获取visible属性
	 * @memberof AbstractLayer
	 * @type {Bool}
	 * @readonly
	 */
	/**
	* 设置图层是否可见
	* @param {Boolean} visible true or false
	*/
	visible: boolean;
	/**
	 * 获取alpha属性
	 * @memberof AbstractLayer
	 * @type {Number}
	 * @readonly
	 */
	/**
	* 设置字母是否可见
	* @param {number} alpha
	*/
	alpha: number;
	splitDirection: number;
	/**
	 * 图层亮度
	 * @type {Number}
	 */
	brightness: number;
	/**
	 * 图层对比度
	 * @type {Number}
	 */
	contrast: number;
	/**
	 * 图层色彩
	 * @type {Number}
	 */
	hue: number;
	/**
	 * 图层饱和度
	 * @type {Number}
	 */
	saturation: number;
	/**
	 * 图层名称
	 * @type {String}
	 */
	name: string;
	index: any;
	/**
	 * 添加至球上
	 * @param {Earth} earth
	 */
	addTo(layers: LayerGroup): this;
	/**
	 * 从球上删除
	 * @param {Earth} earth
	 */
	removeFrom(layers: LayerGroup, destroy: boolean): this;
}
export interface BingLayerOptions extends AbstractLayerOptions {
	type: string;
	culture?: string;
	name?: string;
	id?: string;
	url: Resource | string;
	key?: string;
	tileProtocol?: string;
	mapStyle?: any;
	ellipsoid?: Ellipsoid;
	tileDiscardPolicy?: TileDiscardPolicy;
}
 class BingLayer extends AbstractLayer {
	constructor(url: string, options: BingLayerOptions);
	/**
	 * 图层id
	 * @type {String}
	 * @readonly
	 */
	readonly id: string;
	/**
	 * 图层url
	 * @type {String}
	 * @readonly
	 */
	readonly url: string;
	/**
	 * 瓦片像素宽
	 * @type {Number}
	 * @readonly
	 */
	readonly tileWidth: number;
	/**
	 * 瓦片像素高
	 * @type {Number}
	 * @readonly
	 */
	readonly tileHeight: number;
	/**
	 * 最大瓦片层级.
	 * @type {Number}
	 * @readonly
	 */
	readonly maxLevel: number;
	/**
	 * 最小瓦片层级.
	 * @type {Number}
	 * @readonly
	 */
	readonly minLevel: number;
	/**
	 * 投影.
	 * @type {String}
	 * @readonly
	 */
	readonly projection: string;
	/**
	 * 图层透明度
	 * @type {Number}
	 */
	alpha: number;
	/**
	 * 图层亮度
	 * @type {Number}
	 */
	brightness: number;
	/**
	 * 图层对比度
	 * @type {Number}
	 */
	contrast: number;
	/**
	 * 图层色彩
	 * @type {Number}
	 */
	hue: number;
	/**
	 * 图层饱和度
	 * @type {Number}
	 */
	saturation: number;
	/**
	 * 图层名称
	 * @type {String}
	 */
	name: string;
	/**
	 * 图层索引
	 * @type {Number}
	 */
	index: number;
	/**
	 * 添加至LayerGroup
	 * @param {LayerGroup} layers
	 */
	addTo(layers: LayerGroup): this;
	/**
	 * 从LayerGroup移除
	 * @param {LayerGroup} layers
	 */
	removeFrom(layers: LayerGroup): this;
}
export interface MultiTypeLayerOptions extends AbstractLayerOptions {
	id?: string;
	name?: string;
}
 class MultiTypeLayer extends AbstractLayer {
	constructor(type: string, options?: MultiTypeLayerOptions);
}
export interface TileLayerOptions extends AbstractLayerOptions {
	tileWidth?: number;
	tileHeight?: number;
	maxLevel?: number;
	minLevel?: number;
	projection?: string;
	id?: string;
	name?: string;
	pickFeaturesUrl?: Resource | string;
	urlSchemeZeroPadding?: any;
	subdomains?: string | string[];
	credit?: Credit | string;
	minimumLevel?: number;
	maximumLevel?: number;
	rectangle?: Rectangle;
	tilingScheme?: TilingScheme;
	ellipsoid?: Ellipsoid;
	hasAlphaChannel?: boolean;
	getFeatureInfoFormats?: GetFeatureInfoFormat[];
	enablePickFeatures?: boolean;
	customTags?: any;
}
/**
 * GeoVis Web提供的基础图层，通过指定的URL模板来获取瓦片.
 * @param {String} options.url  请求瓦片的URL.  包括以下关键字:
 * <ul>
 *     <li><code>{z}</code>: 切片方案中的瓦片层级.  其中0层是四叉树金字塔的根节点.</li>
 *     <li><code>{x}</code>: 切片方案中瓦片的X坐标, 最西边的瓦片的X坐标为0.</li>
 *     <li><code>{y}</code>: 切片方案中瓦片的Y坐标, 最北边的瓦片的Y坐标为0.</li>
 *     <li><code>{s}</code>: 有效子域之一, 用于克服每个主机同步请求数量对浏览器限制.</li>
 *     <li><code>{reverseX}</code>:  切片方案中瓦片的X坐标, 最东边的瓦片的X坐标为0.</li>
 *     <li><code>{reverseY}</code>: 切片方案中瓦片的Y坐标, 最南边的瓦片的Y坐标为0.</li>
 *     <li><code>{reverseZ}</code>: 切片方案中瓦片的层级, 其中0层级为四叉树金字塔中的最大层级.  要使用reverseZ, 必须定义最大层级.</li>
 *     <li><code>{westDegrees}</code>: 瓦片的最西端.</li>
 *     <li><code>{southDegrees}</code>: 瓦片的最南端.</li>
 *     <li><code>{eastDegrees}</code>: 瓦片的最东端.</li>
 *     <li><code>{northDegrees}</code>: 瓦片的最北端.</li>
 *     <li><code>{westProjected}</code>: 投影后的坐标中的瓦片最西端.</li>
 *     <li><code>{southProjected}</code>: 投影后的坐标中的瓦片最南端.</li>
 *     <li><code>{eastProjected}</code>: 投影后的坐标中的瓦片最东端.</li>
 *     <li><code>{northProjected}</code>: 投影后的坐标中的瓦片最北端.</li>
 *     <li><code>{width}</code>: 每个瓦片的宽度（像素表示）.</li>
 *     <li><code>{height}</code>: 每个瓦片的高度（像素表示）.</li>
 * </ul>
 * @param {|Object} [options] Object 主要属性:
 * @param {String} [options.name] 图层名称.
 * @param {Number} [options.tileWidth=256] 瓦片宽度（像素表示）.
 * @param {Number} [options.tileHeight=256] 瓦片高度（像素表示）.
 * @param {String} [options.projection="EPSG:4326"] EPSG:4326或EPSG:900913
 * @param {Object} [options.proxy] 请求所用的代理. 该对象一般包含一个getURL方法用于返回代理的URL.
 * @param {Number} [options.minLevel=0] 图层支持的最小瓦片层级.
 * @param {Number} [options.maxLevel] 图层支持的最大瓦片层级, 如果不定义，则表示无限制.
 * @param {Clock} [options.clock] A Clock instance that is used when determining the value for the time dimension. Required when options.times is specified.
 * @param {TimeIntervalCollection} [options.times] TimeIntervalCollection with its data property being an object containing time dynamic dimension and their values.
 * @extends AbstractLayer
 */
 class TileLayer extends AbstractLayer {
	constructor(url: string, options?: TileLayerOptions);
	/**
	 * 图层亮度
	 * @type {Number}
	 */
	brightness: number;
	/**
	 * 图层对比度
	 * @type {Number}
	 */
	contrast: number;
	/**
	 * 图层色彩
	 * @type {Number}
	 */
	hue: number;
	/**
	 * 图层饱和度
	 * @type {Number}
	 */
	saturation: number;
	/**
	 * 图层名称
	 * @type {String}
	 */
	name: string;
	/**
	 * 图层索引
	 * @type {Number}
	 */
	index: number;
	/**
	 * 添加至LayerGroup
	 * @param {LayerGroup} layers
	 */
	addTo(layers: LayerGroup): this;
	/**
	 * 从LayerGroup移除
	 * @param {LayerGroup} layers
	 */
	removeFrom(layers: LayerGroup): this;
}
export interface RstImageryProviderOptions {
	url: string;
	productId: string;
	proxy?: Proxy;
	tileDiscardPolicy?: TileDiscardPolicy;
	type?: string;
	fileExtension?: string;
	tileWidth?: number;
	tileHeight?: number;
	cameraHeight: number;
	credit?: Credit;
	minimumLevel?: number;
}
 class RstImageryProvider {
	private _maximumLevel;
	private _tilingScheme;
	private _productId;
	private _url;
	private _tileWidth;
	private _tileHeight;
	private _imgHeight;
	private _imgWidth;
	private _maxWidth;
	private _credit;
	private _compressFormat;
	private _cameraHeight;
	private _minimumLevel;
	private _rectangle;
	private _readyPromise;
	private _minlevel;
	private _ready;
	private _proxy;
	private _tileDiscardPolicy;
	private _errorEvent;
	private _type;
	private _fileExtension;
	constructor(options: RstImageryProviderOptions);
	readonly url: string;
	readonly productId: string;
	readonly compressFormat: string;
	readonly imgHeight: number;
	readonly imgWidth: number;
	readonly cameraHeight: number;
	readonly proxy: Proxy;
	readonly tileWidth: number;
	readonly tileHeight: number;
	readonly maximumLevel: number;
	readonly minimumLevel: number;
	readonly tilingScheme: TilingScheme;
	readonly rectangle: Rectangle;
	readonly tileDiscardPolicy: TileDiscardPolicy;
	readonly errorEvent: Event;
	readonly ready: boolean;
	readonly credit: Credit;
	readonly defaultAlpha: any;
	readonly hasAlphaChannel: boolean;
	readonly readyPromise: Promise<boolean>;
	getTileCredits(x: number, y: number, level: number): any;
	requestImage(x: number, y: number, level: number): any;
	pickFeatures(): any;
	flyToCenter(): void;
}
/**
 * 用于加载中科院电子所RST单幅影像的图层
 * @param {Object} options 主要属性:
 * @param {String} options.url 服务的URL.
 * @param {String} options.name 图层名称.
 * @param {String} options.productId 图层对应的产品ID
 */
export interface RstLayerOptions extends AbstractLayerOptions {
	productId?: string;
	cameraHeight?: number;
	name?: string;
	id?: string;
}
 class RstLayer extends AbstractLayer {
	protected _productId: string;
	protected _cameraHeight: number;
	protected _provider: RstImageryProvider;
	protected _id: string;
	protected _url: string;
	protected _tileWidth: number;
	protected _tileHeight: number;
	protected _maxLevel: number;
	protected _minLevel: number;
	protected _projection: string;
	protected _show: boolean;
	protected _alpha: number;
	protected _brightness: number;
	protected _contrast: number;
	protected _hue: number;
	protected _saturation: number;
	protected _name: string;
	protected _layers: LayerGroup;
	protected _layer: ImageryLayer;
	constructor(url: string, options?: RstLayerOptions);
	/**
	 * 图层id
	 * @type {String}
	 * @readonly
	 */
	readonly id: string;
	/**
	 * 图层url
	 * @type {String}
	 * @readonly
	 */
	readonly url: string;
	/**
	 * 瓦片像素宽
	 * @type {Number}
	 * @readonly
	 */
	readonly tileWidth: number;
	/**
	 * 瓦片像素高
	 * @type {Number}
	 * @readonly
	 */
	readonly tileHeight: number;
	/**
	 * 最大瓦片层级.
	 * @type {Number}
	 * @readonly
	 */
	readonly maxLevel: number;
	/**
	 * 最小瓦片层级.
	 * @type {Number}
	 * @readonly
	 */
	readonly minLevel: number;
	/**
	 * 投影.
	 * @type {String}
	 * @readonly
	 */
	readonly projection: string;
	/**
	 * 图层显影
	 * @type {Boolean}
	 */
	visible: boolean;
	/**
	 * 图层透明度
	 * @type {Number}
	 */
	alpha: number;
	/**
	 * 图层亮度
	 * @type {Number}
	 */
	brightness: number;
	/**
	 * 图层对比度
	 * @type {Number}
	 */
	contrast: number;
	/**
	 * 图层色彩
	 * @type {Number}
	 */
	hue: number;
	/**
	 * 图层饱和度
	 * @type {Number}
	 */
	saturation: number;
	/**
	 * 图层名称
	 * @type {String}
	 */
	name: string;
	/**
	 * 图层索引
	 * @type {Number}
	 */
	index: number;
	/**
	 * 添加至LayerGroup
	 * @param {LayerGroup} layers
	 */
	addTo(layers: LayerGroup): this;
	/**
	 * 从LayerGroup移除
	 * @param {LayerGroup} layers
	 */
	removeFrom(layers: LayerGroup): this;
}
/**
 * 通过Web Map Service (WMS)服务提供瓦片图层.
 * @param {Object} options 主要属性:
 * @param {String} options.url WMS服务的URL. URL支持与{@link UrlTemplateImageryProvider}相同的关键字.
 * @param {String} options.layers 包含的图层, 逗号分隔.
 * @param {String} [options.name] 图层名称.
 * @param {Object} [options.parameters=WebMapServiceImageryProvider.DefaultParameters] GetMap URL中传递到WMS服务器的额外的参数.
 * @param {Object} [options.getFeatureInfoParameters=WebMapServiceImageryProvider.GetFeatureInfoDefaultParameters] GetFeatureInfo URL中传递到WMS服务器的额外的参数.
 * @param {Number} [options.tileWidth=256] 瓦片宽度（像素表示）.
 * @param {Number} [options.tileHeight=256] 瓦片高度（像素表示）.
 * @param {String} [options.projection="EPSG:4326"] EPSG:4326或EPSG:900913
 * @param {Object} [options.proxy] 请求所用的代理. 该对象一般包含一个getURL方法用于返回代理的URL.
 * @param {Number} [options.minLevel=0] 图层支持的最小瓦片层级.
 * @param {Number} [options.maxLevel] 图层支持的最大瓦片层级, 如果不定义，则表示无限制.
 */
export interface WMSLayerOptions extends AbstractLayerOptions {
	layers?: string;
	tileWidth?: number;
	tileHeight?: number;
	parameters?: any;
	maxLevel?: number;
	minLevel?: number;
	projection?: string;
	id?: string;
	name?: string;
}
 class WMSLayer extends AbstractLayer {
	constructor(url: string, options?: WMSLayerOptions);
	/**
	 * 图层id
	 * @type {String}
	 * @readonly
	 */
	readonly id: string;
	/**
	 * 图层url
	 * @type {String}
	 * @readonly
	 */
	readonly url: string;
	/**
	 * 瓦片像素宽
	 * @type {Number}
	 * @readonly
	 */
	readonly tileWidth: number;
	/**
	 * 瓦片像素高
	 * @type {Number}
	 * @readonly
	 */
	readonly tileHeight: number;
	/**
	 * 最大瓦片层级.
	 * @type {Number}
	 * @readonly
	 */
	readonly maxLevel: number;
	/**
	 * 最小瓦片层级.
	 * @type {Number}
	 * @readonly
	 */
	readonly minLevel: number;
	/**
	 * 投影.
	 * @type {String}
	 * @readonly
	 */
	readonly projection: string;
	/**
	 * 图层显影
	 * @type {Boolean}
	 */
	visible: boolean;
	/**
	 * 图层透明度
	 * @type {Number}
	 */
	alpha: number;
	/**
	 * 图层亮度
	 * @type {Number}
	 */
	brightness: number;
	/**
	 * 图层对比度
	 * @type {Number}
	 */
	contrast: number;
	/**
	 * 图层色彩
	 * @type {Number}
	 */
	hue: number;
	/**
	 * 图层饱和度
	 * @type {Number}
	 */
	saturation: number;
	/**
	 * 图层名称
	 * @type {String}
	 */
	name: string;
	/**
	 * 图层索引
	 * @type {Number}
	 */
	index: number;
	/**
	 * 添加至LayerGroup
	 * @param {LayerGroup} layers
	 */
	addTo(layers: LayerGroup): this;
	/**
	 * 从LayerGroup移除
	 * @param {LayerGroup} layers
	 */
	removeFrom(layers: LayerGroup): this;
}
/**
 * WMTS图层，通过{@link http://www.opengeospatial.org/standards/wmts|WMTS 1.0.0}服务提供瓦片图层.
 * 该图层支持HTTP KVP-encoded和RESTful的GetTile请求, 但不支持SOAP编码.
 * @param {String} url WMTS GetTile操作的URL(针对KVP-encoded请求) 或tile-URL template (针对RESTful请求). tile-URL template包含以下变量: &#123;style&#125;, &#123;TileMatrixSet&#125;, &#123;TileMatrix&#125;, &#123;TileRow&#125;, &#123;TileCol&#125;.
 * 如果实际值为硬编码或者不是从服务器请求的，前两个变量是可选的. &#123;s&#125; 关键字一般用于指定子域.
 * @param {Object} options 主要属性:
 * @param {String} [options.name='WMTS栅格图层'] 图层名称.
 * @param {String} [options.format='image/jpeg'] 从服务器检索到的图片的MIME类型.
 * @param {String} options.layer WMTS请求的图层名称.
 * @param {String} options.style WMTS请求的样式名称.
 * @param {String} options.tileMatrixSetID WMTS请求所用TileMatrixSet的标识符.
 * @param {Array} [options.tileMatrixLabels] WMTS请求所用TileMatrixSet的标识符列表, 每个TileMatrix层级一个.
 * @param {Number} [options.tileWidth=256] 瓦片宽度（像素表示）.
 * @param {Number} [options.tileHeight=256] 瓦片高度（像素表示）.
 * @param {String} [options.projection="EPSG:4326"] EPSG:4326或EPSG:900913
 * @param {Object} [options.proxy] 请求所用的代理. 该对象一般包含一个getURL方法用于返回代理的URL.
 * @param {Number} [options.minLevel=0] 图层支持的最小瓦片层级.
 * @param {Number} [options.maxLevel] 图层支持的最大瓦片层级, 如果不定义，则表示无限制.
 */
export interface WMTSLayerOptions extends AbstractLayerOptions {
	layer?: string;
	format?: string;
	style?: string;
	tileMatrixSetID?: string;
	tileMatrixLabels?: any[];
	tileWidth?: number;
	tileHeight?: number;
	maxLevel?: number;
	minLevel?: number;
	projection?: string;
	id?: string;
	name?: string;
}
 class WMTSLayer extends AbstractLayer {
	private _show;
	constructor(url: string, options?: WMTSLayerOptions);
	/**
	 * 图层id
	 * @type {String}
	 * @readonly
	 */
	readonly id: string;
	/**
	 * 图层url
	 * @type {String}
	 * @readonly
	 */
	readonly url: string;
	/**
	 * 瓦片像素宽
	 * @type {Number}
	 * @readonly
	 */
	readonly tileWidth: number;
	/**
	 * 瓦片像素高
	 * @type {Number}
	 * @readonly
	 */
	readonly tileHeight: number;
	/**
	 * 最大瓦片层级.
	 * @type {Number}
	 * @readonly
	 */
	readonly maxLevel: number;
	/**
	 * 最小瓦片层级.
	 * @type {Number}
	 * @readonly
	 */
	readonly minLevel: number;
	/**
	 * 投影.
	 * @type {String}
	 * @readonly
	 */
	readonly projection: string;
	/**
	 * 图层显影
	 * @type {Boolean}
	 */
	visible: boolean;
	/**
	 * 图层透明度
	 * @type {Number}
	 */
	alpha: number;
	/**
	 * 图层亮度
	 * @type {Number}
	 */
	brightness: number;
	/**
	 * 图层对比度
	 * @type {Number}
	 */
	contrast: number;
	/**
	 * 图层色彩
	 * @type {Number}
	 */
	hue: number;
	/**
	 * 图层饱和度
	 * @type {Number}
	 */
	saturation: number;
	/**
	 * 图层名称
	 * @type {String}
	 */
	name: string;
	/**
	 * 图层索引
	 * @type {Number}
	 */
	index: number;
	/**
	 * 添加至LayerGroup
	 * @param {LayerGroup} layers
	 */
	addTo(layers: LayerGroup): this;
	/**
	 * 从LayerGroup移除
	 * @param {LayerGroup} layers
	 */
	removeFrom(layers: LayerGroup): this;
}
/**
 * 提供一个单一的、顶层的瓦片.
 * @param {String} url 瓦片的url.
 * @param {Object} options 主要属性:
 * @param {String} [options.name] 图层名称.
 * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] 图片覆盖的矩形（弧度表示）.
 * @param {String} [options.projection="EPSG:4326"] EPSG:4326或EPSG:900913
 */
export interface SingleLayerOptions extends AbstractLayerOptions {
	projection?: string;
	id?: string;
	name?: string;
}
 class SingleLayer extends AbstractLayer {
	constructor(resouce: string | HTMLCanvasElement, options?: SingleLayerOptions);
	/**
	 * 图层id
	 * @type {String}
	 * @readonly
	 */
	readonly id: string;
	/**
	 * 图层url
	 * @type {String}
	 * @readonly
	 */
	readonly url: string;
	/**
	 * 投影.
	 * @type {String}
	 * @readonly
	 */
	readonly projection: string;
	/**
	 * 图层透明度
	 * @type {Number}
	 */
	alpha: number;
	/**
	 * 图层亮度
	 * @type {Number}
	 */
	brightness: number;
	/**
	 * 图层对比度
	 * @type {Number}
	 */
	contrast: number;
	/**
	 * 图层色彩
	 * @type {Number}
	 */
	hue: number;
	/**
	 * 图层饱和度
	 * @type {Number}
	 */
	saturation: number;
	/**
	 * 图层名称
	 * @type {String}
	 */
	name: string;
	/**
	 * 图层索引
	 * @type {Number}
	 */
	index: number;
	/**
	 * 添加至LayerGroup
	 * @param {LayerGroup} layers
	 */
	addTo(layers: LayerGroup): this;
	/**
	 * 从LayerGroup移除
	 * @param {LayerGroup} layers
	 */
	removeFrom(layers: LayerGroup): this;
}
export interface VectorTilesOptions {
	projection?: string;
	maxTiles?: number;
	type?: string;
	style?: any;
}
 class VectorTiles {
	protected urlTemp: string;
	protected tilingScheme: GeographicTilingScheme | WebMercatorTilingScheme;
	protected maxTiles: number;
	protected primitives: any;
	protected tileQueue: any[];
	protected tiles: Map<any, any>;
	protected type: string;
	protected style: string;
	protected _currentLevel: number;
	protected _heights: any;
	protected earth: Earth;
	protected _lastLevel: number;
	constructor(url: string, options?: VectorTilesOptions);
	generateHeights(): void;
	viewChange(): void;
	setVisible(level: number, visible: boolean): void;
	computeTiles(): {
		minTile: Cartesian2;
		maxTile: Cartesian2;
		level: number;
	};
	loadTiles(minX: number, minY: number, maxX: number, maxY: number, level: number): void;
	loadTile(x: number, y: number, xCount: string, yCount: string, level: number): void;
	addTo(earth: Earth): void;
	removeFrom(earth: Earth): void;
}
export interface VectorTile2Options extends AbstractLayerOptions {
	tileWidth?: number;
	tileHeight?: number;
	maxLevel?: number;
	minLevel?: number;
	projection?: string;
	urlSchemeZeroPadding?: any;
	customTags?: any;
	id?: string;
	name?: string;
}
 class VectorTile2 extends AbstractLayer {
	constructor(url: string, options?: VectorTile2Options);
	/**
	 * 添加至LayerGroup
	 * @param {LayerGroup} layers
	 */
	addTo(layers: LayerGroup): this;
	/**
	 * 从LayerGroup移除
	 * @param {LayerGroup} layers
	 */
	removeFrom(layers: LayerGroup): this;
}
 class Queue {
	private dataStore;
	constructor();
	enter(element: any): void;
	delete(): any;
	front(): any;
	back(): any;
	toString(): string;
	empty(): boolean;
	count(): number;
}
/**
 * 提供一个单一的、顶层的瓦片.
 * @param {String} url 瓦片的url.
 * @param {Object} options 主要属性:
 * @param {String} [options.name] 图层名称.
 * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] 图片覆盖的矩形（弧度表示）.
 * @param {String} [options.projection="EPSG:4326"] EPSG:4326或EPSG:900913
 */
export interface GeoTiffLayerOptions {
	noData: number[];
	id?: string;
	name?: string;
	extensions?: string;
	samples?: any;
}
 class GeoTiffLayer extends AbstractLayer {
	static layerQueue: Queue;
	protected _id: string;
	protected _load: boolean;
	protected _tileWidth: number;
	protected _tileHeight: number;
	protected _maxLevel: number;
	protected _minLevel: number;
	protected _alpha: number;
	protected _brightness: number;
	protected _contrast: number;
	protected _hue: number;
	protected _saturation: number;
	protected _name: string;
	protected _layers: LayerGroup;
	protected _layer: ImageryLayer;
	protected _url: string;
	protected _extensions: string;
	protected _show: boolean;
	protected _noData: number[];
	constructor(url: string, options?: GeoTiffLayerOptions);
}
export interface GraticuleProviderOptions {
	tilingScheme?: GeographicTilingScheme;
	textColor?: Color;
	lineColor?: Color;
	tileWidth?: number;
	tileHeight?: number;
	sexagesimal?: boolean;
	numLines?: number;
}
 class GraticuleProvider {
	readonly readyPromise: any;
	getTileCredits: (x: number, y: number, level: number) => Credit[];
	pickFeatures: (x: number, y: number, level: number, longitude: number, latitude: number) => any | undefined;
	protected _tilingScheme: any;
	protected _textColor: Color;
	protected _lineColor: Color;
	protected _tileWidth: number;
	protected _tileHeight: number;
	protected _ready: boolean;
	protected _sexagesimal: boolean;
	protected _numLines: number;
	protected _scene: Scene;
	protected _labels: LabelCollection;
	protected _polylines: PolylineCollection;
	protected _ellipsoid: Ellipsoid;
	protected _canvas: HTMLCanvasElement;
	protected _errorEvent: any;
	protected _credit: Credit;
	protected _currentExtent: any;
	protected _canvasSize: number;
	protected _show: boolean;
	constructor(scene: Scene, description?: GraticuleProviderOptions);
	readonly url: any;
	readonly proxy: any;
	readonly tileWidth: number;
	readonly tileHeight: number;
	readonly maximumLevel: number;
	readonly minimumLevel: number;
	readonly tilingScheme: any;
	readonly rectangle: any;
	readonly tileDiscardPolicy: any;
	readonly errorEvent: any;
	readonly ready: boolean;
	readonly credit: Credit;
	readonly hasAlphaChannel: boolean;
	makeLabel(lng: number, lat: number, text: string, top: boolean): void;
	_drawGrid(extent: any): void;
	requestImage(x: any, y: any, level: any): HTMLCanvasElement;
	setVisible(visible: any): void;
	isVisible(): boolean;
	_decToSex(d: any): string;
	_getExtentView(): Rectangle;
}
export interface GraticuleLayerOptions extends AbstractLayerOptions {
	tileWidth?: number;
	tileHeight?: number;
	projection?: string;
	textColor?: Color;
	lineColor?: Color;
	sexagesimal?: boolean;
	numLines?: number;
	id?: string;
	name?: string;
}
 class GraticuleLayer extends AbstractLayer {
	protected _provider: GraticuleProvider;
	constructor(scene: Scene, options?: GraticuleLayerOptions);
	readonly provider: GraticuleProvider;
	/**
	 * 添加至LayerGroup
	 * @param {LayerGroup} layers
	 */
	addTo(layers: LayerGroup): this;
	/**
	 * 从LayerGroup移除
	 * @param {LayerGroup} layers
	 */
	removeFrom(layers: LayerGroup): this;
}
 class Popup extends Evented {
	private _popup;
	private isOpen;
	private _closeButton;
	private _maxWidth;
	constructor(contententHTML: string, maxWidth: number, closeButton: any);
	readonly element: HTMLDivElement;
	adjust(markerHeight: number): void;
	/**
	 * 获取或设置纬度
	 * @memberof AbstractMarker
	 * @type {Boolean}
	 */
	visible: boolean;
	readonly maxWidth: number;
	readonly closeButton: HTMLDivElement;
	bindButton(button: any): void;
}
/**
 * 创建一个tooltip
 * @param options：{String} content, {String} className
 * @constructor
 */
export interface TooltipOptions {
	contents?: string;
	className?: string;
}
 class Tooltip extends Evented {
	private _content;
	private _direction;
	private _tooltip;
	constructor(options?: TooltipOptions);
	readonly element: HTMLDivElement;
	adjust(markerWidth: any, markerHeight: any): void;
	visible: boolean;
}
/**
 * Html标记类，支持自定义DOM节点
 * @param {[]|Vector3} position 形如[lon, lat, alt]的数组或Vector3表示的坐标
 * @param {Object} [options={}] 可选参数
 * @param {string} [options.icon] 自定义icon路径
 * @param {number} [options.width] icon像素宽
 * @param {number} [options.height] icon像素高
 * @param {number} [options.offsetX] X方向上偏移像素数
 * @param {number} [options.offsetY] Y方向上偏移像素数
 * @param {boolean} [options.adapt] icon是否适应（拉伸）至指定宽高（false则裁切至指定宽高）
 */
export interface MarkerOptions {
	icon?: string;
	adapt?: boolean;
	width?: number;
	height?: number;
	offsetX?: number;
	offsetY?: number;
	id?: string;
	mode?: string;
	serializeble?: boolean;
}
 class Marker extends AbstractMarker {
	private _width;
	private _height;
	private _popup;
	private _tooltip;
	constructor(position: Cartesian3 | lonlatTuple, options?: MarkerOptions);
	readonly popup: Popup;
	onClick(e: any): void;
	attachPopup(popup: Popup): void;
	showPopup(visible: boolean): void;
	attachTooltip(tooltip: Tooltip): void;
	onMouse(event: any): void;
	showTooltip(visible: boolean): void;
}
export interface BasicMarkerOptions {
	dom: HTMLDivElement;
	height?: number;
	width?: number;
	mode?: string;
	serializeble?: boolean;
}
 class BasicMarker extends AbstractMarker {
	_width: number;
	_height: number;
	_popup: Popup;
	_tooltip: Tooltip;
	constructor(pos: Cartesian3 | lonlatTuple, options: BasicMarkerOptions);
	readonly popup: Popup;
	onClick(e: any): void;
	attachPopup(popup: Popup): void;
	showPopup(visible: boolean): void;
	attachTooltip(tooltip: Tooltip): void;
	onMouse(event: any): void;
	showTooltip(visible: boolean): void;
}
 class Menu {
	private _popup;
	private _colorPicker;
	private _bgcolorPicker;
	private _linewidthSelector;
	private _verticalSelector;
	private _horiSelector;
	private _textEle;
	private _fontSizeSelector;
	private _fontFamilySelector;
	private _textSelector;
	private textMarker;
	private isOpen;
	private _entity;
	private _linecolorPicker;
	private _pixelSelector;
	constructor(textMarker: any, textEle: any);
	handleClick: (e: any) => void;
	/**
	 * text
	 * @type {Entity}
	 */
	entity: any;
	pixelOffset: any;
	/**
	 * text
	 * @type {String}
	 */
	horizontalOrigin: any;
	verticalOrigin: any;
	outlineWidth: any;
	text: any;
	/**
	 * weight
	 * @type {Boolean}
	 */
	weight: boolean;
	/**
	 * fillColor
	 * @type {Color}
	 */
	fillColor: any;
	/**
	 * backgroundColor
	 * @type {Color}
	 */
	backgroundColor: any;
	outlineColor: any;
	/**
	 * fontSize
	 * @type {String}
	 */
	fontSize: any;
	/**
	 * fontFamily
	 * @type {String}
	 */
	fontFamily: any;
	getDomByName(name: any): HTMLLIElement;
	getInputByName(name: any): HTMLInputElement;
	inputtext(): void;
	adjust(markerHeight: any): void;
	/**
	 * 获取当前element
	 * @type {Element}
	 */
	readonly element: HTMLDivElement;
	/**
	 * 可见性
	 * @type {Boolean}
	 */
	visible: boolean;
	private update;
}
/**
 * 3D场景中的点
 * @param {Array|Vector3} position 圆心.
 * @param {Object} options 主要属性:
 * @param {Number} options.pixelSize 像素大小.
 * @param {Color} options.color 颜色.
 * @param {outlineColor} options.outlineColor 轮廓颜色.
 * @param {Boolean} options.visible 显隐.
 * @param {DistanceDisplay} options.distanceDisplay 显示控制.
 * @constructor
 */
export interface PointOptions {
	id?: string;
	light?: boolean;
	pixelSize?: number;
	color?: Color;
	outlineColor?: Color;
	outlineWidth?: number;
	visible?: boolean;
	scaleByDistance?: NearFarScalar;
	distanceDisplayCondition?: DistanceDisplayCondition;
	heightReference?: HeightReference;
}
 class Point extends Evented {
	private _ready;
	private _primitive;
	private _id;
	private _light;
	private _lonlat;
	private _popup;
	private element;
	private _height;
	constructor(pos: lonlatTuple | Cartesian3, options?: PointOptions);
	/**
	 * id
	 * @type {String}
	 */
	id: string;
	/**
	 * 笛卡尔坐标
	 * @type {Cartesian3|Vector3}
	 */
	position: Cartesian3;
	/**
	 * 经纬坐标
	 * @type {Array|Lonlat}
	 */
	lonlat: lonlatTuple;
	/**
	 * 点的颜色
	 * @type {Color}
	 */
	color: Color;
	/**
	 * 轮廓颜色
	 * @type {Color}
	 */
	outlineColor: Color;
	clusterShow: any;
	/**
	 * 像素大小
	 * @type {Number}
	 */
	pixelSize: number;
	/**
	 * 显隐
	 * @type {Boolean}
	 */
	visible: boolean;
	/**
	 * 添加至FeatureGroup
	 * @param {FeatureGroup}  features
	 */
	addTo(features: FeatureGroup): false | this;
	/**
	 * 从FeatureGroup移除
	 * @param {FeatureGroup}  features
	 */
	removeFrom(features: FeatureGroup): this;
	readonly popup: Popup;
	bindPopup(content: string, maxWOrOpts: any, closeBtn: boolean): this;
	attachPopup(popup: Popup): void;
	showPopup(visible: boolean): void;
}
/**
 * 由多个坐标确定的线段，支持添加纹理
 *
 * @alias Polyline
 * @constructor
 * @param {Array} positions 形如[[121, 30, 0], [122, 33, 0]]或[Vector3]的坐标数组
 * @param {Object} [options] 可选参数，包括下列选项:
 * @param {String} [options.id] 全局的唯一ID
 * @param {Array.<Color>} [options.colors] Color数组，长度至少为1
 * @param {Boolean} [options.vertexColor=true] Color应用于每个端点（true）或每个线段（false）
 * @param {Boolean} [options.followSurface=true] 是否环绕地球
 * @param {Number} [options.width] 线的宽度
 * @param {Material} [options.material] 线的纹理，显示优先级高于colors
 * @param {DistanceDisplay} options.distanceDisplay 显示控制.
 */
export interface PolylineOptions {
	hMax: any;
	id?: string;
	vertexColor?: boolean;
	colors?: Color[];
	followSurface?: boolean;
	width?: number;
	async?: boolean;
	visible?: boolean;
	material?: Material;
	appearance?: Appearance;
	cartesian?: boolean;
	properties?: object;
	distanceDisplayCondition?: DistanceDisplayCondition;
}
 class Polyline extends Evented {
	private _positions;
	private _colors;
	private _width;
	private _distanceDisplayCondition;
	private _realPositions;
	private _ready;
	private _id;
	private _vertexColor;
	private _followSurface;
	private _async;
	private _visible;
	private _material;
	private _cartesian;
	private _geometry;
	private _newPrimitive;
	private _features;
	private _instance;
	private _lonlats;
	private _properties;
	private _hMax;
	private _appearance;
	constructor(positions: lonlatTuple[] | Cartesian3[], options?: PolylineOptions);
	/**
	 * id
	 * @type {String}
	 */
	id: string;
	/**
	 * 获取或者设置Polyline的位置
	 * @memberof Polyline
	 * @type {Array}
	 */
	lonlats: lonlatTuple[];
	positions: Cartesian3[];
	properties: object;
	/**
	 * 可见性
	 * @type {Boolean}
	 */
	visible: boolean;
	/**
	 * lonlat[121,23,100]
	 * lonlats [[121,23,100], [121,23,100] ]
	 *
	 * position Cartesian3
	 * positions [Cartesian3]
	 */
	/**
	 * 线宽
	 * @type {Number}
	 */
	width: number;
	/**
	 * 获取或者设置Polyline的颜色
	 * @type {Array}
	 */
	colors: Color[];
	material: Material;
	distanceDisplayCondition: DistanceDisplayCondition;
	readonly primitive: Primitive;
	update(): void;
	/**
	 * 添加至FeatureGroup
	 * @param {FeatureGroup}  features
	 */
	addTo(features: FeatureGroup): this;
	/**
	 * 从FeatureGroup移除
	 * @param {FeatureGroup}  features
	 */
	removeFrom(features: FeatureGroup): this;
	/**
	 * 获取正确的颜色数组，如果颜色少于所需则插值添加，如果颜色多余则舍弃；
	 * @param {Array<Color>} colors 颜色的数组
	 * @param {Number} count 渲染所需的数量，一般是顶点的数量或者边长的数量
	 * @return {Array<Color>}
	 */
	getRightColors(colors: Color[], count: number): any[];
}
export interface PolylineBatchOptions {
	id?: string;
}
/**
 * 由多个坐标确定的线段，支持添加纹理
 *
 * @alias Polyline
 * @constructor
 * @param {Array} positions 形如[[121, 30, 0], [122, 33, 0]]的坐标数组
 * @param {Object} [options] 可选参数，包括下列选项:
 * @param {String} [options.id] 全局的唯一ID
 * @param {Array.<Color>} [options.colors] Color数组，长度至少为1
 * @param {Boolean} [options.vertexColor=true] Color应用于每个端点（true）或每个线段（false）
 * @param {Boolean} [options.followSurface=true] 是否环绕地球
 * @param {Number} [options.width] 线的宽度
 * @param {Material} [options.material] 线的纹理，显示优先级高于colors
 * @param {DistanceDisplay} options.distanceDisplay 显示控制.
 */
 class PolylineBatch extends Evented {
	private _id;
	private _features;
	private _primitive;
	private _polylines;
	constructor(polylines: Polyline[], options?: PolylineBatchOptions);
	/**
	 * id
	 * @type {String}
	 */
	id: string;
	update(): void;
	/**
	 * 添加至FeatureGroup
	 * @param {FeatureGroup}  features
	 */
	addTo(features: FeatureGroup): this;
	/**
	 * 从FeatureGroup移除
	 * @param {FeatureGroup}  features
	 */
	removeFrom(features: FeatureGroup): this;
	/**
	 * 获取正确的颜色数组，如果颜色少于所需则插值添加，如果颜色多余则舍弃；
	 * @param {Array<Color>} colors 颜色的数组
	 * @param {Number} count 渲染所需的数量，一般是顶点的数量或者边长的数量
	 * @return {Array<Color>}
	 */
	getRightColors(colors: Color[], count: number): any;
}
 class ColorExt extends Color {
	static fromCssString: typeof Color.fromCssColorString;
}
export interface PolygonBatchOptions {
	id?: string;
	async?: boolean;
	transparent?: boolean;
}
 class PolygonBatch extends Evented {
	private _ready;
	private _id;
	private _async;
	private _transparent;
	private _polygons;
	private _scene;
	private _features;
	private _groundPrimitive;
	private _primitive;
	private _classificationPrimitive;
	private _outlinePrimitive;
	private _earth;
	private _waiting;
	private _positions;
	constructor(polygons: Polygon[], options?: PolygonBatchOptions);
	/**
	 * id
	 * @type {String}
	 */
	id: string;
	readonly primitive: Primitive;
	update(): void;
	handleClick(event: any): void;
	setFillColor(poly: Polygon, color: Color): void;
	setOutlineColor(poly: Polygon, color: Color): void;
	/**
	 * 添加至FeatureGroup
	 * @param {FeatureGroup}  features
	 */
	addTo(features: FeatureGroup): this;
	/**
	 * 从FeatureGroup移除
	 * @param {FeatureGroup}  features
	 */
	removeFrom(features: FeatureGroup): this;
}
export interface PolygonOptions {
	id?: string;
	onTerrain?: boolean;
	visible?: boolean;
	closeTop?: boolean;
	closeBottom?: boolean;
	height?: number;
	extrudedHeight?: number;
	outlineColor?: Color;
	outline?: boolean;
	fill?: boolean;
	material?: Material;
	fillColor?: Color;
	outlineWidth?: number;
	width?: number;
	distanceDisplayCondition?: DistanceDisplayCondition;
	async?: boolean;
	properties?: any;
	name?: string;
	hierarchy?: PolygonHierarchy;
	classificationType?: any;
}
/**
 * 由多个坐标确定的多边形，支持添加纹理
 * @constructor
 * @param {Array<Array>|Array<Vector3>} positions 形如[[121, 30, 0], [122, 33, 0]]或[vec0, vec1, vec2]的坐标数组
 * @param {Object} [options] 可选参数，包括下列选项:
 * @param {Boolean} [options.onTerrain] 是否贴地形渲染.
 * @param {Boolean} [options.visible] 可见性.
 * @param {Boolean} [options.async=true] 异步渲染.
 * @param {Number} [options.height] 离地球的高度.
 * @param {Number} [options.extrudedHeight] 几何体的立体高度.
 * @param {Boolean} [options.outline] 是否显示轮廓
 * @param {Color} [options.outlineColor] 轮廓线颜色
 * @param {Number} [options.outlineWidth=1] 轮廓线宽
 * @param {Boolean} [options.fill] 是否填充
 * @param {Color} [options.fillColor] 填充色
 * @param {DistanceDisplay} options.distanceDisplay 显示控制.
 */
 class Polygon extends Evented {
	static createOutlineInstance: (polygon: any, options: any) => GeometryInstance;
	static createPolygonInstance: (polygon: any, options: any) => GeometryInstance;
	_batchParent: PolygonBatch;
	private _positions;
	private _visible;
	private _onTerrain;
	private _outline;
	private _fill;
	private _hierarchy;
	private _ready;
	private _id;
	private _closeTop;
	private _closeBottom;
	private _height;
	private _extrudedHeight;
	private _outlineColor;
	private _fillColor;
	private _outlineWidth;
	private _width;
	private _distanceDisplayCondition;
	private _async;
	private _properties;
	private _granularity;
	private _stRotation;
	private _perPositionHeight;
	private _material;
	private _name;
	private _primitive;
	private _lonlats;
	private _scene;
	private _outlinePrimitive;
	private _features;
	private _classificationType;
	constructor(positions: lonlatTuple[] | Cartesian3[], options?: PolygonOptions);
	/**
	 * id
	 * @type {String}
	 */
	id: string;
	/**
	 * 异步渲染
	 * @type {Boolean}
	 */
	async: boolean;
	readonly hierarchy: PolygonHierarchy;
	properties: any;
	visible: boolean;
	/**
	 * 贴地形渲染
	 * @type {Boolean}
	 */
	onTerrain: number;
	/**
	 * 离地球的高度.
	 * @type {Boolean}
	 */
	height: number;
	/**
	 * 几何体的立体高度.
	 * @type {Boolean}
	 */
	extrudedHeight: number;
	/**
	 * 是否显示轮廓线
	 * @type {Boolean}
	 */
	outline: boolean;
	/**
	 * 轮廓颜色
	 * @type {Color}
	 */
	outlineColor: Color;
	/**
	 * 是否填充
	 * @type {Boolean}
	 */
	fill: boolean;
	/**
	 * 填充颜色
	 * @type {Color}
	 */
	fillColor: Color;
	material: Material;
	/**
	 * 获取或者设置Polygon的位置
	 * @memberof Polygon
	 * @type {Array}
	 */
	lonlats: lonlatTuple[];
	positions: Cartesian3[];
	classificationType: any;
	/**
	 * 闪烁效果，可直接调用，或制定闪烁的一些参数
	 * @param {Object} [options] 可选参数，包括下列选项:
	 * @param {Number} [options.count=1] 闪烁的次数，默认为1
	 * @param {Number} [options.interval=0.3] 闪烁的间隔事件，默认0.3
	 * @param {Color} [options.toColor] 闪烁的另一个颜色，默认为原始颜色的2/3
	 */
	shine(options: any): void;
	update(): void;
	handleClick(event: any): void;
	/**
	 * 添加至FeatureGroup
	 * @param {FeatureGroup}  features
	 */
	addTo(features: FeatureGroup): this;
	/**
	 * 从FeatureGroup移除
	 * @param {FeatureGroup}  features
	 */
	removeFrom(features: FeatureGroup): this;
}
/**
 * 圆形几何体
 * @param {Array|Vector3} center 圆心.
 * @param {Object} options 主要属性:
 * @param {Number} options.radius 半径（米表示）.
 * @param {Boolean} options.onTerrain 是否贴地形渲染.
 * @param {Boolean} options.visible 可见性.
 * @param {Boolean} [options.async=true] 异步渲染.
 * @param {Number} options.height 离地球的高度.
 * @param {Number} options.extrudedHeight 几何体的立体高度.
 * @param {Number} options.granularity 颗粒度（弧度表示）.
 * @param {Number} [options.stRotation=0.0] 纹理坐标的旋转角度（弧度表示）. 正方向为逆时针方向.
 * @param {Color} options.fillColor 填充颜色.
 * @constructor
 */
export interface CircleOptions {
	radius: number;
	id?: string;
	onTerrain?: boolean;
	visible?: boolean;
	ellipsoid?: Ellipsoid;
	async?: boolean;
	height?: number;
	extrudedHeight?: number;
	granularity?: number;
	vertexFormat?: VertexFormat;
	stRotation?: number;
	shadowVolume?: number;
	fill?: boolean;
	fillColor?: Color;
	material?: Material;
	DistanceDisplayCondition?: DistanceDisplayCondition;
}
 class Circle extends Evented {
	private _ready;
	private _id;
	private _onTerrain;
	private _visible;
	private _async;
	private _radius;
	private _center;
	private _lonlatCenter;
	private _ellipsoid;
	private _height;
	private _extrudedHeight;
	private _granularity;
	private _vertexFormat;
	private _stRotation;
	private _shadowVolume;
	private _fill;
	private _fillColor;
	private _distanceDisplayCondition;
	private _material;
	private _primitive;
	private _outlinePrimitive;
	private _ellipseGeometry;
	private _earth;
	private _waiting;
	private _features;
	constructor(center: lonlatTuple | Cartesian3, options: CircleOptions);
	/**
	 * id
	 * @type {String}
	 */
	id: string;
	/**
	 * 圆心
	 * @type {[]|Vector3}
	 */
	center: Cartesian3;
	lonlatcenter: lonlatTuple;
	visible: boolean;
	/**
	 * 半径
	 * @type {Number}
	 */
	radius: number;
	/**
	 * 贴地形渲染
	 * @type {Boolean}
	 */
	onTerrain: number;
	/**
	 * 异步渲染
	 * @type {Boolean}
	 */
	async: boolean;
	/**
	 * 离地球的高度.
	 * @type {Boolean}
	 */
	height: number;
	/**
	 * 几何体的立体高度.
	 * @type {Boolean}
	 */
	extrudedHeight: number;
	/**
	 * 填充颜色.
	 * @type {Color}
	 */
	fillColor: Color;
	material: Material;
	update(): void;
	/**
	 * 添加至FeatureGroup
	 * @param {FeatureGroup}  features
	 */
	addTo(features: FeatureGroup): this;
	/**
	 * 从FeatureGroup移除
	 * @param {FeatureGroup}  features
	 */
	removeFrom(features: FeatureGroup): this;
}
export interface BillboardOptions {
	show?: true;
	pixelOffset?: Cartesian2;
	eyeOffset?: Cartesian3;
	heightReference?: HeightReference;
	horizontalOrigin?: HorizontalOrigin;
	verticalOrigin?: VerticalOrigin;
	scale?: number;
	image?: string;
	imageSubRegion?: BoundingRectangle;
	color?: Color;
	id?: string;
	rotation?: 0.0;
	alignedAxis?: Cartesian3;
	width?: number;
	height?: number;
	scaleByDistance?: NearFarScalar;
	translucencyByDistance?: NearFarScalar;
	pixelOffsetScaleByDistance?: NearFarScalar;
	sizeInMeters?: false;
	distanceDisplayCondition?: DistanceDisplayCondition;
}
 class Billboard extends BillboardFeature {
	addTo: (features: FeatureGroup) => Billboard;
	removeFrom: (features: FeatureGroup) => Billboard;
	private _position;
	private _lonlat;
	private _id;
	private _marker;
	private _features;
	constructor(pos: lonlatTuple | Cartesian3, options?: BillboardOptions);
	lonlat: lonlatTuple;
	visible: boolean;
	/**
	 * Billboard??????position??Cesium????
	 */
	readonly popup: Popup;
	bindPopup(content: HTMLDivElement, maxWOrOpts: any, closeBtn: HTMLDivElement): void;
	showPopup(visible: any): void;
}
export interface CylinderOptions {
	radius: number;
	id?: string;
	length: number;
	topRadius: number;
	slices: number;
	bottomRadius: number;
	rotation: any;
	vertexFormat: VertexFormat;
	onTerrain?: boolean;
	lookAt?: Cartesian3;
	visible?: boolean;
	ellipsoid?: Ellipsoid;
	async?: boolean;
	fillColor?: Color;
	material?: Material;
	DistanceDisplayCondition?: DistanceDisplayCondition;
}
 class Cylinder extends Evented {
	private _ready;
	private _id;
	private _onTerrain;
	private _visible;
	private _async;
	private _topRadius;
	private _bottomRadius;
	private _length;
	private _center;
	private _slices;
	private _rotation;
	private _headingPitchRoll;
	private _lonlatCenter;
	private _ellipsoid;
	private _vertexFormat;
	private _fillColor;
	private _distanceDisplayCondition;
	private _material;
	private _lookAt;
	private _primitive;
	private _outlinePrimitive;
	private _ellipseGeometry;
	private _earth;
	private _waiting;
	private _features;
	constructor(center: lonlatTuple | Cartesian3, options: CylinderOptions);
	id: string;
	center: Cartesian3;
	lonlatcenter: lonlatTuple;
	topRadius: number;
	bottomRadius: number;
	/**
	 * 贴地形渲染
	 * @type {Boolean}
	 */
	onTerrain: boolean;
	/**
	 * 异步渲染
	 * @type {Boolean}
	 */
	async: boolean;
	rotation: any;
	/**
	 * 填充颜色.
	 * @type {Color}
	 */
	fillColor: Color;
	material: Material;
	update(): void;
	/**
	 * 添加至FeatureGroup
	 * @param {FeatureGroup}  features
	 */
	addTo(features: FeatureGroup): this;
	/**
	 * 从FeatureGroup移除
	 * @param {FeatureGroup}  features
	 */
	removeFrom(features: FeatureGroup): this;
}
/**
 * 由多个坐标确定的线段，支持添加纹理
 *
 * @alias RectangleGeom
 * @constructor
 * @param {Array} positions 形如[[121, 30, 0], [122, 33, 0]]的坐标数组
 * @param {Object} [options] 可选参数，包括下列选项:
 * @param {String} [options.id] 全局的唯一ID
 * @param {Array.<Color>} [options.colors] Color数组，长度至少为1
 * @param {Boolean} [options.vertexColor=true] Color应用于每个端点（true）或每个线段（false）
 * @param {Boolean} [options.followSurface=true] 是否环绕地球
 * @param {Number} [options.width] 线的宽度
 */
export interface RectangleOptions {
	id?: string;
	onTerrain?: boolean;
	visible?: boolean;
	async?: boolean;
	height?: number;
	extrudedHeight?: number;
	granularity?: number;
	stRotation?: number;
	rotation?: number;
	closeBottom?: boolean;
	closeTop?: boolean;
	fill?: boolean;
	fillColor?: Color;
	material?: Material;
}
 class RectangleGeom extends Evented {
	private _ready;
	private _id;
	private _onTerrain;
	private _visible;
	private _async;
	private _bounds;
	private _height;
	private _extrudedHeight;
	private _granularity;
	private _stRotation;
	private _closeBottom;
	private _closeTop;
	private _fill;
	private _fillColor;
	private _material;
	private _scene;
	private _waiting;
	private _rotation;
	private _featureGroup;
	private _distanceDisplayCondition;
	private _primitive;
	private _outlinePrimitive;
	constructor(bounds: any[], options?: RectangleOptions);
	/**
	 *
	 */
	id: string;
	/**
	 * 获取或者设置Point的id
	 * @memberof Point
	 * @type {String}
	 */
	fill: boolean;
	/**
	 * 获取或者设置Polygon的填充颜色
	 * @memberof Polygon
	 * @type {Color}
	 */
	fillColor: Color;
	height: number;
	async: boolean;
	addTo(feartureGroup: FeatureGroup): this;
	removeFrom(features: FeatureGroup): this;
	private update;
}
export interface WallOptions {
	id?: string;
	maximumHeights?: number[];
	minimumHeights?: number[];
	outlineWidth?: number;
	material?: Material;
	granularity?: number;
	async?: boolean;
	outline?: boolean;
	outlineColor?: Color;
	visible?: boolean;
	fill?: boolean;
	fillColor?: Color;
}
 class WallGeom extends Evented {
	private _positions;
	private _lonlats;
	private _id;
	private _maximumHeights;
	private _minimumHeights;
	private _outlineWidth;
	private _material;
	private _granularity;
	private _async;
	private _outline;
	private _visible;
	private _outlineColor;
	private _featureGroup;
	private _scene;
	private _primitive;
	private _distanceDisplayCondition;
	private _fill;
	private _fillColor;
	constructor(positions: lonlatTuple[] | Cartesian3[], options?: WallOptions);
	/**
	 * async
	 * @type {Boolean}
	 */
	async: boolean;
	/**
	 * id
	 * @type {String}
	 */
	id: any;
	/**
	 * fillColor
	 * @type {Color}
	 */
	fillColor: Color;
	/**
	 * maximumHeights
	 * @type {Number}
	 */
	maximumHeights: number[];
	/**
	 * minimumHeights
	 * @type {Number}
	 */
	readonly minimumHeights: number[];
	maximumHminimumHeightseights: any;
	/**
	 * 获取或者设置Wall的位置
	 * @memberof Wall
	 * @type {Array}
	 */
	lonlats: lonlatTuple[];
	positions: Cartesian3[];
	/**
	 * 可见性
	 * @type {Boolean}
	 */
	visible: boolean;
	addTo(feartureGroup: FeatureGroup): this;
	removeFrom(features: FeatureGroup): this;
	private update;
}
/**
 * 根据贝塞尔曲线算法创建具有粒子效果的拟合圆
 * @constructor
 * @param {Array<Number>} start 开始位置， 开始位置和结束位置高度保持一样
 * @param {Array<Number>} end 结束位置， 开始位置和结束位置高度保持一样
 * @param {Emitter} emitter 粒子特征值
 * @param {Color} color 射线颜色
 */
export interface CircleOptions {
	start: lonlatTuple;
	end: lonlatTuple;
	id?: string;
	color?: Color;
	width?: number;
}
 class BezierCurve extends Evented {
	private _positions;
	private _lonlats;
	private _options;
	private _id;
	private _start;
	private _end;
	private _color;
	private _polyline;
	constructor(options: CircleOptions);
	/**
	 * 获取位置信息
	 * @memberof BezierCurve
	 * @type {Array<Cartesian3>}
	 */
	readonly positions: Cartesian3[];
	/**
	 * 获取位置信息
	 * @memberof BezierCurve
	 * @type {Array<lonlatTuple>}
	 */
	readonly lonlats: lonlatTuple[];
	/**
	 * 获取该曲线的ID
	 * @memberOf BezierCurve
	 * @type {String}
	 */
	readonly id: string;
	/**
	 * 获取该曲线的开始位置
	 * @memberOf BezierCurve
	 * @type {Array<Position>}
	 */
	readonly start: lonlatTuple;
	/**
	 * 获取该曲线的结束位置
	 * @memberOf BezierCurve
	 * @type {Array<Position>}
	 */
	readonly end: lonlatTuple;
	/**
	 * 获取曲线实体
	 * @type {Polyline}
	 */
	readonly polyline: EnginePolyline;
	/**
	 * 控制曲线显隐
	 */
	visible: boolean;
	/**
	 * 根据线段起始点计算抛物线
	 * @param {Array<lonlatTuple>} start 开始位置
	 * @param {Array<lonlatTuple>} end 结束位置
	 * @return {Array<Position>}
	 */
	calculateRoute(startCoords: lonlatTuple, endCoords: lonlatTuple): any[];
	/**
	 * 将曲线添加至场景中
	 * @param {Earth} 场景，即所需添加至的地球
	 */
	addTo(earth: Earth): this;
	/**
	 * 从场景中删除曲线
	 * @param {Earth} 场景，即所需添加至的地球
	 */
	removeFrom(earth: Earth): void;
}
/**
 * 文字标牌
 * @alias Label
 * @constructor
 * @name Label
 * @param {Array|Vector3} position 坐标。
 * @param {Object} options 参数
 * @param {String} options.text 文字内容
 * @param {String} options.font 字体及大小，如'24px 微软雅黑'
 * @param {Color} options.fillColor 半径（米表示）.
 */
export interface LabelOptions {
	id?: string;
	show?: boolean;
	text?: string;
	font?: string;
	fillColor?: Color;
	outlineColor?: Color;
	outlineWidth?: number;
	showBackground?: boolean;
	backgroundColor?: Color;
	backgroundPadding?: Cartesian2;
	style?: LabelStyle;
	pixelOffset?: Cartesian2;
	eyeOffset?: Cartesian3;
	horizontalOrigin?: HorizontalOrigin;
	verticalOrigin?: VerticalOrigin;
	scale?: number;
	translucencyByDistance?: any;
	pixelOffsetScaleByDistance?: any;
	disableDepthTestDistance?: number;
	heightReference?: HeightReference;
	scaleByDistance?: NearFarScalar;
	distanceDisplayCondition?: DistanceDisplayCondition;
}
 class Label extends Evented {
	private _ready;
	private _position;
	private _lonlat;
	private _id;
	private _label;
	private _options;
	private _features;
	private _fillColor;
	private _outlineColor;
	private _outlineWidth;
	private _show;
	private _heightReference;
	private _text;
	private _backgroundColor;
	private _font;
	private _backgroundPadding;
	private _style;
	private _pixelOffset;
	private _translucencyByDistance;
	private _pixelOffsetScaleByDistance;
	private _horizontalOrigin;
	private _verticalOrigin;
	private _scale;
	private _distanceDisplayCondition;
	private _showBackground;
	private _eyeOffset;
	private _disableDepthTestDistance;
	private _scaleByDistance;
	constructor(position: lonlatTuple | Cartesian3, options?: LabelOptions);
	/**
	 * id 获取label的uuid
	 * @type {String}
	 */
	id: string;
	/**
	* 控制Label显隐藏
	*/
	show: boolean;
	/**
	* 控制Label显隐藏
	*/
	visible: boolean;
	/**
	 * 获取或设置此广告牌的高度参考。
	 * @memberof Label.prototype
	 * @type {HeightReference}
	 * @default HeightReference.NONE
	 * @name heightReference
	 * @memberof Label
	 * @instance
	 */
	heightReference: HeightReference;
	/**
	 * 文字内容
	 * @memberof Label.prototype
	 * @type {String}
	 * @name text
	 * @memberof Label
	 * @instance
	 */
	text: string;
	/**
	 * 字体
	 * @memberof Label.prototype
	 * @type {String}
	 * @default '30px sans-serif'
	 * @name font
	 * @memberof Label
	 * @instance
	 */
	font: string;
	lonlat: lonlatTuple;
	/**
	 * 获取或设置label的位置
	 * @memberof Label.prototype
	 * @type {Vector3}
	 * @name position
	 * @memberof Label
	 * @instance
	 */
	position: any;
	/**
	 * 文字填充色
	 * @memberof Label.prototype
	 * @type {Color}
	 * @default Color.WHITE
	 * @name fillColor
	 * @memberof Label
	 * @instance
	 */
	fillColor: Color;
	/**
	 * 文字轮廓颜色
	 * @memberof Label.prototype
	 * @type {Color}
	 * @default Color.BLACK
	 * @name outlineColor
	 * @memberof Label
	 * @instance
	 */
	outlineColor: Color;
	/**
	 * 轮廓宽度
	 * @memberof Label.prototype
	 * @type {Number}
	 * @default 1.0
	 * @name outlineWidth
	 * @memberof Label
	 * @instance
	 */
	outlineWidth: number;
	/**
	 * 获取或设置此标签的背景颜色.
	 * @type {Color}
	 * @default new Color(0.165, 0.165, 0.165, 0.8)
	 * @name backgroundColor
	 * @memberof Label
	 * @instance
	 */
	backgroundColor: Color;
	/**
	 * 获取或设置此标签的背景填充（以像素为单位）。该x值控制水平填充，该y值控制垂直填充。
	 * @type {Vector2}
	 * @default new Vector2(7, 5)
	 * @name backgroundPadding
	 * @memberof Label
	 * @instance
	 */
	backgroundPadding: Cartesian2;
	/**
	 * 获取或设置此标签的样式。
	 * @memberof Label.prototype
	 * @type {LabelStyle}
	 * @default LabelStyle.FILL
	 * @name style
	 * @memberof Label
	 * @instance
	 */
	style: LabelStyle;
	/**
	 * 获取或设置屏幕空间中的像素偏移量与该标签的原点。这通常用于将多个标签和广告牌对齐在同一位置，例如图像和文本。屏幕空间原点是画布的左上角; x从左到右y增加，从上到下增加。
	 * @type {Vector2}
	 * @default Vector2.ZERO
	 * @name pixelOffset
	 * @memberof Label
	 * @instance
	 */
	pixelOffset: Cartesian2;
	/**
	 * 根据标签距离相机的距离，获取或设置标签的近透明度和远半透明度属性。
	 * 标签的半透明将在之间进行内插NearFarScalar#nearValue和 NearFarScalar#farValue，
	 * 而相机距离落在指定的上限和下限内NearFarScalar#near和NearFarScalar#far。
	 * 在这些范围之外，标签的半透明度保持固定在最接近的边界。如果未定义，则半透明度禁止将被禁用。
	 * @name translucencyByDistance
	 * @memberof Label
	 * @instance
	 */
	translucencyByDistance: any;
	pixelOffsetScaleByDistance: any;
	scaleByDistance: NearFarScalar;
	/**
	 * 获取或设置此标签的水平原点，该标签确定标签是否绘制在其锚定位置的左侧，中央或右侧。
	 * @memberof Label.prototype
	 * @type {HorizontalOrigin}
	 * @default HorizontalOrigin.LEFT
	 * @name horizontalOrigin
	 * @memberof Label
	 * @instance
	 */
	horizontalOrigin: HorizontalOrigin;
	/**
	 * 获取或设置此标签的垂直原点，该标签确定标签是否在其上方，下方或其位置的中心。
	 * @memberof Label.prototype
	 * @type {VerticalOrigin}
	 * @default VerticalOrigin.BASELINE
	 * @name verticalOrigin
	 * @memberof Label
	 * @instance
	 */
	verticalOrigin: VerticalOrigin;
	/**
	 * 设置label缩放比例
	 * @memberof Label.prototype
	 * @type {Number}
	 * @default 1.0
	 * @name scale
	 * @memberof Label
	 * @instance
	 */
	scale: number;
	/**
	 * 获取或设置条件，指定与相机距离显示该标签的距离。
	 * @type {DistanceDisplayCondition}
	 * @default undefined
	 * @name distanceDisplayCondition
	 * @memberof Label
	 * @instance
	 */
	distanceDisplayCondition: DistanceDisplayCondition;
	showBackground: boolean;
	eyeOffset: Cartesian3;
	clusterShow: any;
	update(): void;
	/**
	 * 添加至FeatureGroup
	 * @param {FeatureGroup}  features
	 */
	addTo(features: FeatureGroup): this;
	/**
	 * 从FeatureGroup移除
	 * @param {FeatureGroup}  features
	 */
	removeFrom(features: FeatureGroup): this;
}
 class Model extends EngineModel {
	 addTo(features: FeatureGroup): this;
}
/**
 * 由多个坐标确定的线段，支持添加纹理
 *
 * @alias KarperskySpline
 * @constructor
 * @param {Object} [options] 可选参数，包括下列选项:
 * @param {String} [options.id] 全局的唯一ID
 * @param {Array} [options.start] 形如[121, 30, 0]的坐标
 * @param {Array} [options.end] 形如[121, 30, 0]的坐标
 * @param {<Color>} [options.color] Color
 * @param {Boolean} [options.followSurface=true] 是否环绕地球
 * @param {Number} [options.maxWidth] 线的最大宽度
 */
export interface KarperskySplineOptions {
	start: lonlatTuple | Cartesian3;
	end: lonlatTuple | Cartesian3;
	id?: string;
	vertexColor?: boolean;
	color?: Color;
	followSurface?: boolean;
	maxWidth?: number;
	async?: boolean;
	visible?: boolean;
	curve?: number;
	fit?: number;
}
 class KarperskySpline extends Evented {
	private _ready;
	private _id;
	private _vertexColor;
	private _color;
	private _followSurface;
	private _maxWidth;
	private _async;
	private _visible;
	private _curve;
	private _fit;
	private scene;
	private _positions;
	private _lonlats;
	private _primitive;
	private _features;
	private _newPrimitive;
	private _index;
	private _startBillboard;
	private addBillboard;
	private _earth;
	private requestID;
	private _currentPrimitive;
	private _scene;
	constructor(options: KarperskySplineOptions);
	/**
	 * 获取或者设置Point的id
	 * @memberof Point
	 * @type {String}
	 */
	id: string;
	/**
	 * 获取line的位置
	 * @memberof Polyline
	 * @type {Array}
	 */
	readonly positions: Cartesian3[];
	readonly lonlats: lonlatTuple[];
	visible: boolean;
	/**
	 * 获取或者设置Polyline的颜色
	 * @memberof Polyline
	 * @type {Array}
	 */
	color: Color;
	update(): void;
	animate(): void;
	animateFrame(): void;
	animateOnce(): void;
	animateFrameOnce(): void;
	calculateRoute(startCoords: any, endCoords: any): any[];
	onPreRender(): void;
	addTo(features: FeatureGroup): this;
	removeFrom(features: FeatureGroup): this;
}
/**
 * Billboard 集合
 * @constructor
 */
export interface EmitterOptions {
	color: Color;
	duration?: number;
	particleCount?: number;
}
 class Emitter extends Evented {
	_collection: any;
	private _path;
	private _options;
	private _duration;
	private _particleCount;
	private _particleList;
	private _realPositions;
	private _interval;
	private _spline;
	private _earth;
	private _tween;
	private _primitives;
	private _billboardMap;
	private _color;
	constructor(path: lonlatTuple[], options?: EmitterOptions);
	emit(): void;
	getPosition(time: number): Cartesian3;
	start(): void;
	stop(): void;
	addTo(particleSys: any): this;
	addEmitter(emitter: any): any;
	add(billboard: any): void;
	removeAll(): void;
}
export interface MoveEntityOptions {
	id?: string;
	pixelSize?: number;
	color?: Color;
	visible?: boolean;
	type?: string;
	modelScale?: number;
	scale?: number;
	image: string;
	model: string;
}
 class MoveEntity extends Evented {
	private _ready;
	private _tmpLonlat;
	private _position;
	private _lonlat;
	private _id;
	private _type;
	private _pointOption;
	private _billboardOption;
	private _modelOption;
	private _pointPrimitive;
	private _billboardPrimitive;
	private _modelPrimitive;
	private _level;
	private _earth;
	private _lastLevel;
	private _modelReady;
	constructor(pos: Cartesian3 | lonlatTuple, options: MoveEntityOptions);
	/**
	 * 获取或设置Point的坐标
	 * @memberof Point
	 * @type {Array}
	 */
	lonlat: lonlatTuple;
	position: Cartesian3;
	tmpPosition: lonlatTuple;
	readonly type: string;
	inViewRec(): boolean;
	update: () => void;
	getLevelByHeight(cartographic: any): "point" | "billboard" | "model";
	addEntityByLevel(level: string): void;
	removeEntityByLevel(level: any): void;
	_addPoint(): void;
	_removePoint(): void;
	_addBillboard(): void;
	_removeBillboard(): void;
	_addModel(): void;
	_removeModel(): void;
	addTo(features: FeatureGroup): false | this;
	removeFrom(features: FeatureGroup): void;
}
export interface RadarOptions {
	id?: string;
	scale: number;
	visible?: boolean;
	outlineColor?: Color;
	outline?: boolean;
	fill?: boolean;
	material?: Material;
	fillColor?: Color;
	speed?: number;
	radius: Cartesian3;
	stackPartitions: number;
	slicePartitions: number;
	subdivisions: number;
	async?: boolean;
	properties?: any;
	distanceDisplayCondition?: DistanceDisplayCondition;
}
/**
 * 由多个坐标确定的多边形，支持添加纹理
 * @constructor
 * @param {Array<Array>|Array<Vector3>} positions 形如[[121, 30, 0], [122, 33, 0]]或[vec0, vec1, vec2]的坐标数组
 * @param {Object} [options] 可选参数，包括下列选项:
 * @param {Boolean} [options.onTerrain] 是否贴地形渲染.
 * @param {Boolean} [options.visible] 可见性.
 * @param {Boolean} [options.async=true] 异步渲染.
 * @param {Number} [options.height] 离地球的高度.
 * @param {Number} [options.extrudedHeight] 几何体的立体高度.
 * @param {Boolean} [options.outline] 是否显示轮廓
 * @param {Color} [options.outlineColor] 轮廓线颜色
 * @param {Number} [options.outlineWidth=1] 轮廓线宽
 * @param {Boolean} [options.fill] 是否填充
 * @param {Color} [options.fillColor] 填充色
 * @param {DistanceDisplay} options.distanceDisplay 显示控制.
 */
 class Polygon extends Evented {
	private _position;
	private _lonlat;
	private _visible;
	private _onTerrain;
	private _outline;
	private _fill;
	private _hierarchy;
	private _ready;
	private _id;
	private _outlineColor;
	private _fillColor;
	private _outlineWidth;
	private _scale;
	private _distanceDisplayCondition;
	private _async;
	private _properties;
	private _material;
	private _name;
	private _primitive;
	private _scene;
	private _earth;
	private _waiting;
	private _featureGroup;
	private _outlinePrimitive;
	private _features;
	private _classificationType;
	private _radius;
	private _stackPartitions;
	private _slicePartitions;
	private _subdivisions;
	private _speed;
	private _instance;
	private _appearance;
	private _outlineAppearance;
	private _outlineInstance;
	constructor(center: lonlatTuple | Cartesian3, options?: RadarOptions);
	/**
	 * id
	 * @type {String}
	 */
	id: string;
	/**
	 * 异步渲染
	 * @type {Boolean}
	 */
	async: boolean;
	properties: any;
	scale: number;
	visible: boolean;
	lonlat: lonlatTuple;
	position: Cartesian3;
	/**
	 * 是否显示轮廓线
	 * @type {Boolean}
	 */
	outline: boolean;
	/**
	 * 是否填充
	 * @type {Boolean}
	 */
	fill: boolean;
	/**
	 * 填充颜色
	 * @type {Color}
	 */
	fillColor: Color;
	radius: Cartesian3;
	outlineColor: Color;
	speed: number;
	update(): void;
	/**
	 * 添加至FeatureGroup
	 * @param {FeatureGroup}  features
	 */
	addTo(features: FeatureGroup): this;
	/**
	 * 从FeatureGroup移除
	 * @param {FeatureGroup}  features
	 */
	removeFrom(features: FeatureGroup): this;
}
 const LineUtil: {
	simplify(positions: any, tolerance: any): any;
	pointToSegmentDistance(p: any, p1: any, p2: any): number;
	closestPointOnSegment(p: any, p1: any, p2: any): any;
	_simplifyDP(points: any, sqTolerance: any): any[];
	_simplifyDPStep(points: any, markers: any, sqTolerance: any, first: any, last: any): void;
	_reducePoints(points: any, sqTolerance: any): any[];
	clipSegment(a: any, b: any, bounds: any, useLastCode: any, round: any): false | any[];
	_getEdgeIntersection(a: any, b: any, code: any, bounds: any, round: any): any;
	_getBitCode(p: any, bounds: any): number;
	_sqDist(p1: any, p2: any): number;
	_sqClosestPointOnSegment(p: any, p1: any, p2: any, sqDist: any): any;
};
 const _default: {
	clipPolygon: (positions: any, bounds: any, round: any) => any;
};
/**
 * @module  color-interpolate
 * Pick color from palette by index
 */
 function interpolate(palette: any): (t: any, mix?: any) => any;
/**
 * Billboard 集合
 * @constructor
 */
export interface ParticleGroupOptions {
	renderMode?: string;
	color?: Color;
}
 class ParticleGroup extends Evented {
	private _collection;
	private _earth;
	constructor(options?: ParticleGroupOptions);
	addTo(earth: Earth): this;
	addEmitter(emitter: Emitter): Emitter;
	/**
	 * 往场景中添加billboard
	 * @param {BillboardMarker} billboard
	 */
	add(billboard: any): void;
	removeAll(): void;
}
 class ViewShed {
	private _viewShedRender;
	private _scene;
	private _targetPosition;
	private _lightCamera;
	private _direction;
	private _debugPrimitive;
	private _linePrimitive;
	private _ellipsoid;
	private _heading;
	private _pitch;
	private _radius;
	private _roll;
	constructor(options: any);
	eyePosition: Cartesian3;
	targetPosition: Cartesian3;
	heading: number;
	pitch: number;
	roll: number;
	isRadar: any;
	destroy(): void;
	private update;
	private _createLineInstance;
	private createLines;
}
export interface TerrainDigOptions {
	scene: any;
	positions: any;
	minHeight: any;
}
 class TerrainDig {
	_wallPrimitive: any;
	_bottomPrimitive: any;
	private _positions;
	private _minHeight;
	private _scene;
	private _center;
	private _centerLonlat;
	private _linePrimitive;
	constructor(options: TerrainDigOptions);
	update(): Promise<void>;
	computePositions(): Promise<any[]>;
	private createBottom;
	private createWall;
}
 class Radar {
	private _viewShedRender;
	private _scene;
	private _targetPosition;
	private _lightCamera;
	private _direction;
	private _debugPrimitive;
	private _linePrimitive;
	private _ellipsoid;
	private _heading;
	private _pitch;
	private _radius;
	private _roll;
	constructor(options: any);
	center: Cartesian3;
	targetPosition: Cartesian3;
	radius: any;
	addTo(feature):void;
	destroy(): void;
	private update;
	private _createLineInstance;
	private createRadome;
}
 class CyberManager {
	primitives: PrimitiveCollection;
	features: FeatureGroup;
	impacts: Primitive[];
	currentImpacts: Primitive[];
	constructor();
	init(): void;
	/**
	 *
	 * @param options
	 */
	emit(options: {
		impact?: boolean;
		cone?: boolean;
		missile?: boolean;
		biubiu?: boolean;
		start: lonlatTuple;
		end: lonlatTuple;
		color: Color;
		type?: string;
		duration: number;
	}): void;
	batchEmit(): void;
	addTo(earth: Earth): void;
	removeFrom(earth: Earth): void;
}
	/**
	 * A collection of key-value pairs that is stored as a hash for easy
	 * lookup but also provides an array for fast iteration.
	 * @alias AssociativeArray
	 * @constructor
	 */
	class AssociativeArray {
		constructor();

		/**
		 * Gets the number of items in the collection.
		 * @memberof AssociativeArray.prototype
		 * @type {Number}
		 */
		length: number;

		/**
		 * Gets an unordered array of all values in the collection.
		 * This is a live array that will automatically reflect the values in the collection,
		 * it should not be modified directly.
		 * @memberof AssociativeArray.prototype
		 * @type {Array}
		 */
		values: any[];

		/**
		 * Determines if the provided key is in the array.
		 * @param {String|Number} key The key to check.
		 * @returns {Boolean} <code>true</code> if the key is in the array, <code>false</code> otherwise.
		 */
		contains(key: string | number): boolean;

		/**
		 * Associates the provided key with the provided value.  If the key already
		 * exists, it is overwritten with the new value.
		 * @param {String|Number} key A unique identifier.
		 * @param {*} value The value to associate with the provided key.
		 */
		set(key: string | number, value: any): void;

		/**
		 * Retrieves the value associated with the provided key.
		 * @param {String|Number} key The key whose value is to be retrieved.
		 * @returns {*} The associated value, or undefined if the key does not exist in the collection.
		 */
		get(key: string | number): any;

		/**
		 * Removes a key-value pair from the collection.
		 * @param {String|Number} key The key to be removed.
		 * @returns {Boolean} True if it was removed, false if the key was not in the collection.
		 */
		remove(key: string | number): boolean;

		/**
		 * Clears the collection.
		 */
		removeAll(): void;

	}

	/**
	 * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.
	 * @alias AxisAlignedBoundingBox
	 * @constructor
	 * @param {Cartesian3} [minimum=Cartesian3.ZERO] The minimum point along the x, y, and z axes.
	 * @param {Cartesian3} [maximum=Cartesian3.ZERO] The maximum point along the x, y, and z axes.
	 * @param {Cartesian3} [center] The center of the box; automatically computed if not supplied.
	 * @see BoundingSphere
	 * @see BoundingRectangle
	 */
	class AxisAlignedBoundingBox {
		constructor(minimum?: Cartesian3, maximum?: Cartesian3, center?: Cartesian3);

		/**
		 * The minimum point defining the bounding box.
		 * @type {Cartesian3}
		 * @default {@link Cartesian3.ZERO}
		 */
		minimum: Cartesian3;

		/**
		 * The maximum point defining the bounding box.
		 * @type {Cartesian3}
		 * @default {@link Cartesian3.ZERO}
		 */
		maximum: Cartesian3;

		/**
		 * The center point of the bounding box.
		 * @type {Cartesian3}
		 */
		center: Cartesian3;

		/**
		 * Computes an instance of an AxisAlignedBoundingBox. The box is determined by
		 * finding the points spaced the farthest apart on the x, y, and z axes.
		 * @param {Cartesian3[]} positions List of points that the bounding box will enclose.  Each point must have a <code>x</code>, <code>y</code>, and <code>z</code> properties.
		 * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.
		 * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.
		 * @example
		 * // Compute an axis aligned bounding box enclosing two points.
		 * var box = Cesium.AxisAlignedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);
		 */
		static fromPoints(positions: (Cartesian3)[], result?: AxisAlignedBoundingBox): AxisAlignedBoundingBox;

		/**
		 * Duplicates a AxisAlignedBoundingBox instance.
		 * @param {AxisAlignedBoundingBox} box The bounding box to duplicate.
		 * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.
		 * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if none was provided. (Returns undefined if box is undefined)
		 */
		static clone(box: AxisAlignedBoundingBox, result?: AxisAlignedBoundingBox): AxisAlignedBoundingBox;

		/**
		 * Compares the provided AxisAlignedBoundingBox componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {AxisAlignedBoundingBox} [left] The first AxisAlignedBoundingBox.
		 * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		static equals(left?: AxisAlignedBoundingBox, right?: AxisAlignedBoundingBox): boolean;

		/**
		 * Determines which side of a plane a box is located.
		 * @param {AxisAlignedBoundingBox} box The bounding box to test.
		 * @param {Plane} plane The plane to test against.
		 * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane
		 *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is
		 *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box
		 *                      intersects the plane.
		 */
		static intersectPlane(box: AxisAlignedBoundingBox, plane: Plane): any;

		/**
		 * Duplicates this AxisAlignedBoundingBox instance.
		 * @param {AxisAlignedBoundingBox} [result] The object onto which to store the result.
		 * @returns {AxisAlignedBoundingBox} The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.
		 */
		clone(result?: AxisAlignedBoundingBox): AxisAlignedBoundingBox;

		/**
		 * Determines which side of a plane this box is located.
		 * @param {Plane} plane The plane to test against.
		 * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane
		 *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is
		 *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box
		 *                      intersects the plane.
		 */
		intersectPlane(plane: Plane): any;

		/**
		 * Compares this AxisAlignedBoundingBox against the provided AxisAlignedBoundingBox componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {AxisAlignedBoundingBox} [right] The right hand side AxisAlignedBoundingBox.
		 * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
		 */
		equals(right?: AxisAlignedBoundingBox): boolean;

	}

	/**
	 * Computes the barycentric coordinates for a point with respect to a triangle.
	 * @exports barycentricCoordinates
	 * @param {Cartesian2|Cartesian3} point The point to test.
	 * @param {Cartesian2|Cartesian3} p0 The first point of the triangle, corresponding to the barycentric x-axis.
	 * @param {Cartesian2|Cartesian3} p1 The second point of the triangle, corresponding to the barycentric y-axis.
	 * @param {Cartesian2|Cartesian3} p2 The third point of the triangle, corresponding to the barycentric z-axis.
	 * @param {Cartesian3} [result] The object onto which to store the result.
	 * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
	 * @example
	 * // Returns Cartesian3.UNIT_X
	 * var p = new Cesium.Cartesian3(-1.0, 0.0, 0.0);
	 * var b = Cesium.barycentricCoordinates(p,
	 *   new Cesium.Cartesian3(-1.0, 0.0, 0.0),
	 *   new Cesium.Cartesian3( 1.0, 0.0, 0.0),
	 *   new Cesium.Cartesian3( 0.0, 1.0, 1.0));
	 */
	namespace barycentricCoordinates {
	}

	/**
	 * Finds an item in a sorted array.
	 * @exports binarySearch
	 * @param {Array} array The sorted array to search.
	 * @param {*} itemToFind The item to find in the array.
	 * @param {binarySearch~Function} comparator The function to use to compare the item to
	 *        elements in the array.
	 * @returns {Number} The index of <code>itemToFind</code> in the array, if it exists.  If <code>itemToFind</code>
	 *        does not exist, the return value is a negative number which is the bitwise complement (~)
	 *        of the index before which the itemToFind should be inserted in order to maintain the
	 *        sorted order of the array.
	 * @example
	 * // Create a comparator function to search through an array of numbers.
	 * function comparator(a, b) {
	 *     return a - b;
	 * };
	 * var numbers = [0, 2, 4, 6, 8];
	 * var index = Cesium.binarySearch(numbers, 6, comparator); // 3
	 */
	namespace binarySearch {
	}

	/**
	 * Object for setting and retrieving the default Bing Maps API key.
	 * A Bing API key is only required if you are using {@link BingMapsImageryProvider}
	 * or {@link BingMapsGeocoderService}. You can create your own key at
	 * {@link https://www.bingmapsportal.com/}.
	 * @exports BingMapsApi
	 */
	namespace BingMapsApi {
		/**
		 * The default Bing Maps API key to use if one is not provided to the
		 * constructor of an object that uses the Bing Maps API.
		 * @type {String}
		 */
		const defaultKey: string;

	}

	/**
	 * Provides geocoding through Bing Maps.
	 * @alias BingMapsGeocoderService
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {String} [options.key] A key to use with the Bing Maps geocoding service
	 */
	class BingMapsGeocoderService {
		constructor(options: {
			key?: string;
		});

		/**
		 * @function
		 * @param {String} query The query to be sent to the geocoder service
		 * @returns {Promise<GeocoderService~Result[]>}
		 */
		geocode(query: string): any;

	}

	/**
	 * A bounding rectangle given by a corner, width and height.
	 * @alias BoundingRectangle
	 * @constructor
	 * @param {Number} [x=0.0] The x coordinate of the rectangle.
	 * @param {Number} [y=0.0] The y coordinate of the rectangle.
	 * @param {Number} [width=0.0] The width of the rectangle.
	 * @param {Number} [height=0.0] The height of the rectangle.
	 * @see BoundingSphere
	 * @see Packable
	 */
	class BoundingRectangle {
		constructor(x?: number, y?: number, width?: number, height?: number);

		/**
		 * The x coordinate of the rectangle.
		 * @type {Number}
		 * @default 0.0
		 */
		x: number;

		/**
		 * The y coordinate of the rectangle.
		 * @type {Number}
		 * @default 0.0
		 */
		y: number;

		/**
		 * The width of the rectangle.
		 * @type {Number}
		 * @default 0.0
		 */
		width: number;

		/**
		 * The height of the rectangle.
		 * @type {Number}
		 * @default 0.0
		 */
		height: number;

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {BoundingRectangle} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: BoundingRectangle, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {BoundingRectangle} [result] The object into which to store the result.
		 * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: BoundingRectangle): BoundingRectangle;

		/**
		 * Computes a bounding rectangle enclosing the list of 2D points.
		 * The rectangle is oriented with the corner at the bottom left.
		 * @param {Cartesian2[]} positions List of points that the bounding rectangle will enclose.  Each point must have <code>x</code> and <code>y</code> properties.
		 * @param {BoundingRectangle} [result] The object onto which to store the result.
		 * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.
		 */
		static fromPoints(positions: (Cartesian2)[], result?: BoundingRectangle): BoundingRectangle;

		/**
		 * Computes a bounding rectangle from a rectangle.
		 * @param {Rectangle} rectangle The valid rectangle used to create a bounding rectangle.
		 * @param {Object} [projection=GeographicProjection] The projection used to project the rectangle into 2D.
		 * @param {BoundingRectangle} [result] The object onto which to store the result.
		 * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.
		 */
		static fromRectangle(rectangle: Rectangle, projection?: any, result?: BoundingRectangle): BoundingRectangle;

		/**
		 * Duplicates a BoundingRectangle instance.
		 * @param {BoundingRectangle} rectangle The bounding rectangle to duplicate.
		 * @param {BoundingRectangle} [result] The object onto which to store the result.
		 * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided. (Returns undefined if rectangle is undefined)
		 */
		static clone(rectangle: BoundingRectangle, result?: BoundingRectangle): BoundingRectangle;

		/**
		 * Computes a bounding rectangle that is the union of the left and right bounding rectangles.
		 * @param {BoundingRectangle} left A rectangle to enclose in bounding rectangle.
		 * @param {BoundingRectangle} right A rectangle to enclose in a bounding rectangle.
		 * @param {BoundingRectangle} [result] The object onto which to store the result.
		 * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.
		 */
		static union(left: BoundingRectangle, right: BoundingRectangle, result?: BoundingRectangle): BoundingRectangle;

		/**
		 * Computes a bounding rectangle by enlarging the provided rectangle until it contains the provided point.
		 * @param {BoundingRectangle} rectangle A rectangle to expand.
		 * @param {Cartesian2} point A point to enclose in a bounding rectangle.
		 * @param {BoundingRectangle} [result] The object onto which to store the result.
		 * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.
		 */
		static expand(rectangle: BoundingRectangle, point: Cartesian2, result?: BoundingRectangle): BoundingRectangle;

		/**
		 * Determines if two rectangles intersect.
		 * @param {BoundingRectangle} left A rectangle to check for intersection.
		 * @param {BoundingRectangle} right The other rectangle to check for intersection.
		 * @returns {Intersect} <code>Intersect.INTESECTING</code> if the rectangles intersect, <code>Intersect.OUTSIDE</code> otherwise.
		 */
		static intersect(left: BoundingRectangle, right: BoundingRectangle): any;

		/**
		 * Compares the provided BoundingRectangles componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {BoundingRectangle} [left] The first BoundingRectangle.
		 * @param {BoundingRectangle} [right] The second BoundingRectangle.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		static equals(left?: BoundingRectangle, right?: BoundingRectangle): boolean;

		/**
		 * Duplicates this BoundingRectangle instance.
		 * @param {BoundingRectangle} [result] The object onto which to store the result.
		 * @returns {BoundingRectangle} The modified result parameter or a new BoundingRectangle instance if one was not provided.
		 */
		clone(result?: BoundingRectangle): BoundingRectangle;

		/**
		 * Determines if this rectangle intersects with another.
		 * @param {BoundingRectangle} right A rectangle to check for intersection.
		 * @returns {Intersect} <code>Intersect.INTESECTING</code> if the rectangles intersect, <code>Intersect.OUTSIDE</code> otherwise.
		 */
		intersect(right: BoundingRectangle): any;

		/**
		 * Compares this BoundingRectangle against the provided BoundingRectangle componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {BoundingRectangle} [right] The right hand side BoundingRectangle.
		 * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
		 */
		equals(right?: BoundingRectangle): boolean;

	}

	/**
	 * A bounding sphere with a center and a radius.
	 * @alias BoundingSphere
	 * @constructor
	 * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the bounding sphere.
	 * @param {Number} [radius=0.0] The radius of the bounding sphere.
	 * @see AxisAlignedBoundingBox
	 * @see BoundingRectangle
	 * @see Packable
	 */
	class BoundingSphere {
		constructor(center?: Cartesian3, radius?: number);

		/**
		 * The center point of the sphere.
		 * @type {Cartesian3}
		 * @default {@link Cartesian3.ZERO}
		 */
		center: Cartesian3;

		/**
		 * The radius of the sphere.
		 * @type {Number}
		 * @default 0.0
		 */
		radius: number;

		/**
		 * Computes a tight-fitting bounding sphere enclosing a list of 3D Cartesian points.
		 * The bounding sphere is computed by running two algorithms, a naive algorithm and
		 * Ritter's algorithm. The smaller of the two spheres is used to ensure a tight fit.
		 * @param {Cartesian3[]} [positions] An array of points that the bounding sphere will enclose.  Each point must have <code>x</code>, <code>y</code>, and <code>z</code> properties.
		 * @param {BoundingSphere} [result] The object onto which to store the result.
		 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.
		 * @see {@link http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding/|Bounding Sphere computation article}
		 */
		static fromPoints(positions?: (Cartesian3)[], result?: BoundingSphere): BoundingSphere;

		/**
		 * Computes a bounding sphere from a rectangle projected in 2D.
		 * @param {Rectangle} [rectangle] The rectangle around which to create a bounding sphere.
		 * @param {Object} [projection=GeographicProjection] The projection used to project the rectangle into 2D.
		 * @param {BoundingSphere} [result] The object onto which to store the result.
		 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
		 */
		static fromRectangle2D(rectangle?: Rectangle, projection?: any, result?: BoundingSphere): BoundingSphere;

		/**
		 * Computes a bounding sphere from a rectangle projected in 2D.  The bounding sphere accounts for the
		 * object's minimum and maximum heights over the rectangle.
		 * @param {Rectangle} [rectangle] The rectangle around which to create a bounding sphere.
		 * @param {Object} [projection=GeographicProjection] The projection used to project the rectangle into 2D.
		 * @param {Number} [minimumHeight=0.0] The minimum height over the rectangle.
		 * @param {Number} [maximumHeight=0.0] The maximum height over the rectangle.
		 * @param {BoundingSphere} [result] The object onto which to store the result.
		 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
		 */
		static fromRectangleWithHeights2D(rectangle?: Rectangle, projection?: any, minimumHeight?: number, maximumHeight?: number, result?: BoundingSphere): BoundingSphere;

		/**
		 * Computes a bounding sphere from a rectangle in 3D. The bounding sphere is created using a subsample of points
		 * on the ellipsoid and contained in the rectangle. It may not be accurate for all rectangles on all types of ellipsoids.
		 * @param {Rectangle} [rectangle] The valid rectangle used to create a bounding sphere.
		 * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid used to determine positions of the rectangle.
		 * @param {Number} [surfaceHeight=0.0] The height above the surface of the ellipsoid.
		 * @param {BoundingSphere} [result] The object onto which to store the result.
		 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
		 */
		static fromRectangle3D(rectangle?: Rectangle, ellipsoid?: Ellipsoid, surfaceHeight?: number, result?: BoundingSphere): BoundingSphere;

		/**
		 * Computes a tight-fitting bounding sphere enclosing a list of 3D points, where the points are
		 * stored in a flat array in X, Y, Z, order.  The bounding sphere is computed by running two
		 * algorithms, a naive algorithm and Ritter's algorithm. The smaller of the two spheres is used to
		 * ensure a tight fit.
		 * @param {Number[]} [positions] An array of points that the bounding sphere will enclose.  Each point
		 *        is formed from three elements in the array in the order X, Y, Z.
		 * @param {Cartesian3} [center=Cartesian3.ZERO] The position to which the positions are relative, which need not be the
		 *        origin of the coordinate system.  This is useful when the positions are to be used for
		 *        relative-to-center (RTC) rendering.
		 * @param {Number} [stride=3] The number of array elements per vertex.  It must be at least 3, but it may
		 *        be higher.  Regardless of the value of this parameter, the X coordinate of the first position
		 *        is at array index 0, the Y coordinate is at array index 1, and the Z coordinate is at array index
		 *        2.  When stride is 3, the X coordinate of the next position then begins at array index 3.  If
		 *        the stride is 5, however, two array elements are skipped and the next position begins at array
		 *        index 5.
		 * @param {BoundingSphere} [result] The object onto which to store the result.
		 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.
		 * @example
		 * // Compute the bounding sphere from 3 positions, each specified relative to a center.
		 * // In addition to the X, Y, and Z coordinates, the points array contains two additional
		 * // elements per point which are ignored for the purpose of computing the bounding sphere.
		 * var center = new Cesium.Cartesian3(1.0, 2.0, 3.0);
		 * var points = [1.0, 2.0, 3.0, 0.1, 0.2,
		 *               4.0, 5.0, 6.0, 0.1, 0.2,
		 *               7.0, 8.0, 9.0, 0.1, 0.2];
		 * var sphere = Cesium.BoundingSphere.fromVertices(points, center, 5);
		 * @see {@link http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding/|Bounding Sphere computation article}
		 */
		static fromVertices(positions?: number[], center?: Cartesian3, stride?: number, result?: BoundingSphere): BoundingSphere;

		/**
		 * Computes a tight-fitting bounding sphere enclosing a list of {@link EncodedCartesian3}s, where the points are
		 * stored in parallel flat arrays in X, Y, Z, order.  The bounding sphere is computed by running two
		 * algorithms, a naive algorithm and Ritter's algorithm. The smaller of the two spheres is used to
		 * ensure a tight fit.
		 * @param {Number[]} [positionsHigh] An array of high bits of the encoded cartesians that the bounding sphere will enclose.  Each point
		 *        is formed from three elements in the array in the order X, Y, Z.
		 * @param {Number[]} [positionsLow] An array of low bits of the encoded cartesians that the bounding sphere will enclose.  Each point
		 *        is formed from three elements in the array in the order X, Y, Z.
		 * @param {BoundingSphere} [result] The object onto which to store the result.
		 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.
		 * @see {@link http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding/|Bounding Sphere computation article}
		 */
		static fromEncodedCartesianVertices(positionsHigh?: number[], positionsLow?: number[], result?: BoundingSphere): BoundingSphere;

		/**
		 * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere
		 * tighly and fully encompases the box.
		 * @param {Cartesian3} [corner] The minimum height over the rectangle.
		 * @param {Cartesian3} [oppositeCorner] The maximum height over the rectangle.
		 * @param {BoundingSphere} [result] The object onto which to store the result.
		 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
		 * @example
		 * // Create a bounding sphere around the unit cube
		 * var sphere = Cesium.BoundingSphere.fromCornerPoints(new Cesium.Cartesian3(-0.5, -0.5, -0.5), new Cesium.Cartesian3(0.5, 0.5, 0.5));
		 */
		static fromCornerPoints(corner?: Cartesian3, oppositeCorner?: Cartesian3, result?: BoundingSphere): BoundingSphere;

		/**
		 * Creates a bounding sphere encompassing an ellipsoid.
		 * @param {Ellipsoid} ellipsoid The ellipsoid around which to create a bounding sphere.
		 * @param {BoundingSphere} [result] The object onto which to store the result.
		 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
		 * @example
		 * var boundingSphere = Cesium.BoundingSphere.fromEllipsoid(ellipsoid);
		 */
		static fromEllipsoid(ellipsoid: Ellipsoid, result?: BoundingSphere): BoundingSphere;

		/**
		 * Computes a tight-fitting bounding sphere enclosing the provided array of bounding spheres.
		 * @param {BoundingSphere[]} [boundingSpheres] The array of bounding spheres.
		 * @param {BoundingSphere} [result] The object onto which to store the result.
		 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
		 */
		static fromBoundingSpheres(boundingSpheres?: (BoundingSphere)[], result?: BoundingSphere): BoundingSphere;

		/**
		 * Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box.
		 * @param {OrientedBoundingBox} orientedBoundingBox The oriented bounding box.
		 * @param {BoundingSphere} [result] The object onto which to store the result.
		 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
		 */
		static fromOrientedBoundingBox(orientedBoundingBox: OrientedBoundingBox, result?: BoundingSphere): BoundingSphere;

		/**
		 * Duplicates a BoundingSphere instance.
		 * @param {BoundingSphere} sphere The bounding sphere to duplicate.
		 * @param {BoundingSphere} [result] The object onto which to store the result.
		 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided. (Returns undefined if sphere is undefined)
		 */
		static clone(sphere: BoundingSphere, result?: BoundingSphere): BoundingSphere;

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {BoundingSphere} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: BoundingSphere, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {BoundingSphere} [result] The object into which to store the result.
		 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: BoundingSphere): BoundingSphere;

		/**
		 * Computes a bounding sphere that contains both the left and right bounding spheres.
		 * @param {BoundingSphere} left A sphere to enclose in a bounding sphere.
		 * @param {BoundingSphere} right A sphere to enclose in a bounding sphere.
		 * @param {BoundingSphere} [result] The object onto which to store the result.
		 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
		 */
		static union(left: BoundingSphere, right: BoundingSphere, result?: BoundingSphere): BoundingSphere;

		/**
		 * Computes a bounding sphere by enlarging the provided sphere to contain the provided point.
		 * @param {BoundingSphere} sphere A sphere to expand.
		 * @param {Cartesian3} point A point to enclose in a bounding sphere.
		 * @param {BoundingSphere} [result] The object onto which to store the result.
		 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
		 */
		static expand(sphere: BoundingSphere, point: Cartesian3, result?: BoundingSphere): BoundingSphere;

		/**
		 * Determines which side of a plane a sphere is located.
		 * @param {BoundingSphere} sphere The bounding sphere to test.
		 * @param {Plane} plane The plane to test against.
		 * @returns {Intersect} {@link Intersect.INSIDE} if the entire sphere is on the side of the plane
		 *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire sphere is
		 *                      on the opposite side, and {@link Intersect.INTERSECTING} if the sphere
		 *                      intersects the plane.
		 */
		static intersectPlane(sphere: BoundingSphere, plane: Plane): any;

		/**
		 * Applies a 4x4 affine transformation matrix to a bounding sphere.
		 * @param {BoundingSphere} sphere The bounding sphere to apply the transformation to.
		 * @param {Matrix4} transform The transformation matrix to apply to the bounding sphere.
		 * @param {BoundingSphere} [result] The object onto which to store the result.
		 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
		 */
		static transform(sphere: BoundingSphere, transform: Matrix4, result?: BoundingSphere): BoundingSphere;

		/**
		 * Computes the estimated distance squared from the closest point on a bounding sphere to a point.
		 * @param {BoundingSphere} sphere The sphere.
		 * @param {Cartesian3} cartesian The point
		 * @returns {Number} The estimated distance squared from the bounding sphere to the point.
		 * @example
		 * // Sort bounding spheres from back to front
		 * spheres.sort(function(a, b) {
		 *     return Cesium.BoundingSphere.distanceSquaredTo(b, camera.positionWC) - Cesium.BoundingSphere.distanceSquaredTo(a, camera.positionWC);
		 * });
		 */
		static distanceSquaredTo(sphere: BoundingSphere, cartesian: Cartesian3): number;

		/**
		 * Applies a 4x4 affine transformation matrix to a bounding sphere where there is no scale
		 * The transformation matrix is not verified to have a uniform scale of 1.
		 * This method is faster than computing the general bounding sphere transform using {@link BoundingSphere.transform}.
		 * @param {BoundingSphere} sphere The bounding sphere to apply the transformation to.
		 * @param {Matrix4} transform The transformation matrix to apply to the bounding sphere.
		 * @param {BoundingSphere} [result] The object onto which to store the result.
		 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
		 * @example
		 * var modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(positionOnEllipsoid);
		 * var boundingSphere = new Cesium.BoundingSphere();
		 * var newBoundingSphere = Cesium.BoundingSphere.transformWithoutScale(boundingSphere, modelMatrix);
		 */
		static transformWithoutScale(sphere: BoundingSphere, transform: Matrix4, result?: BoundingSphere): BoundingSphere;

		/**
		 * The distances calculated by the vector from the center of the bounding sphere to position projected onto direction
		 * plus/minus the radius of the bounding sphere.
		 * <br>
		 * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the
		 * closest and farthest planes from position that intersect the bounding sphere.
		 * @param {BoundingSphere} sphere The bounding sphere to calculate the distance to.
		 * @param {Cartesian3} position The position to calculate the distance from.
		 * @param {Cartesian3} direction The direction from position.
		 * @param {Interval} [result] A Interval to store the nearest and farthest distances.
		 * @returns {Interval} The nearest and farthest distances on the bounding sphere from position in direction.
		 */
		static computePlaneDistances(sphere: BoundingSphere, position: Cartesian3, direction: Cartesian3, result?: Interval): Interval;

		/**
		 * Creates a bounding sphere in 2D from a bounding sphere in 3D world coordinates.
		 * @param {BoundingSphere} sphere The bounding sphere to transform to 2D.
		 * @param {Object} [projection=GeographicProjection] The projection to 2D.
		 * @param {BoundingSphere} [result] The object onto which to store the result.
		 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
		 */
		static projectTo2D(sphere: BoundingSphere, projection?: any, result?: BoundingSphere): BoundingSphere;

		/**
		 * Determines whether or not a sphere is hidden from view by the occluder.
		 * @param {BoundingSphere} sphere The bounding sphere surrounding the occludee object.
		 * @param {Occluder} occluder The occluder.
		 * @returns {Boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.
		 */
		static isOccluded(sphere: BoundingSphere, occluder: Occluder): boolean;

		/**
		 * Compares the provided BoundingSphere componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {BoundingSphere} [left] The first BoundingSphere.
		 * @param {BoundingSphere} [right] The second BoundingSphere.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		static equals(left?: BoundingSphere, right?: BoundingSphere): boolean;

		/**
		 * Determines which side of a plane the sphere is located.
		 * @param {Plane} plane The plane to test against.
		 * @returns {Intersect} {@link Intersect.INSIDE} if the entire sphere is on the side of the plane
		 *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire sphere is
		 *                      on the opposite side, and {@link Intersect.INTERSECTING} if the sphere
		 *                      intersects the plane.
		 */
		intersectPlane(plane: Plane): any;

		/**
		 * Computes the estimated distance squared from the closest point on a bounding sphere to a point.
		 * @param {Cartesian3} cartesian The point
		 * @returns {Number} The estimated distance squared from the bounding sphere to the point.
		 * @example
		 * // Sort bounding spheres from back to front
		 * spheres.sort(function(a, b) {
		 *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);
		 * });
		 */
		distanceSquaredTo(cartesian: Cartesian3): number;

		/**
		 * The distances calculated by the vector from the center of the bounding sphere to position projected onto direction
		 * plus/minus the radius of the bounding sphere.
		 * <br>
		 * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the
		 * closest and farthest planes from position that intersect the bounding sphere.
		 * @param {Cartesian3} position The position to calculate the distance from.
		 * @param {Cartesian3} direction The direction from position.
		 * @param {Interval} [result] A Interval to store the nearest and farthest distances.
		 * @returns {Interval} The nearest and farthest distances on the bounding sphere from position in direction.
		 */
		computePlaneDistances(position: Cartesian3, direction: Cartesian3, result?: Interval): Interval;

		/**
		 * Determines whether or not a sphere is hidden from view by the occluder.
		 * @param {Occluder} occluder The occluder.
		 * @returns {Boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.
		 */
		isOccluded(occluder: Occluder): boolean;

		/**
		 * Compares this BoundingSphere against the provided BoundingSphere componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {BoundingSphere} [right] The right hand side BoundingSphere.
		 * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
		 */
		equals(right?: BoundingSphere): boolean;

		/**
		 * Duplicates this BoundingSphere instance.
		 * @param {BoundingSphere} [result] The object onto which to store the result.
		 * @returns {BoundingSphere} The modified result parameter or a new BoundingSphere instance if none was provided.
		 */
		clone(result?: BoundingSphere): BoundingSphere;

		/**
		 * Computes the radius of the BoundingSphere.
		 * @returns {Number} The radius of the BoundingSphere.
		 */
		volume(): number;

	}

	/**
	 * Describes a cube centered at the origin.
	 * @alias BoxGeometry
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Cartesian3} options.minimum The minimum x, y, and z coordinates of the box.
	 * @param {Cartesian3} options.maximum The maximum x, y, and z coordinates of the box.
	 * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
	 * @see BoxGeometry.fromDimensions
	 * @see BoxGeometry.createGeometry
	 * @see Packable
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Box.html|Cesium Sandcastle Box Demo}
	 * @example
	 * var box = new Cesium.BoxGeometry({
	 *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,
	 *   maximum : new Cesium.Cartesian3(250000.0, 250000.0, 250000.0),
	 *   minimum : new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0)
	 * });
	 * var geometry = Cesium.BoxGeometry.createGeometry(box);
	 */
	class BoxGeometry {
		constructor(options: {
			minimum: Cartesian3;
			maximum: Cartesian3;
			vertexFormat?: VertexFormat;
		});

		/**
		 * Creates a cube centered at the origin given its dimensions.
		 * @param {Object} options Object with the following properties:
		 * @param {Cartesian3} options.dimensions The width, depth, and height of the box stored in the x, y, and z coordinates of the <code>Cartesian3</code>, respectively.
		 * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
		 * @returns {BoxGeometry}
		 * @exception {DeveloperError} All dimensions components must be greater than or equal to zero.
		 * @example
		 * var box = Cesium.BoxGeometry.fromDimensions({
		 *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,
		 *   dimensions : new Cesium.Cartesian3(500000.0, 500000.0, 500000.0)
		 * });
		 * var geometry = Cesium.BoxGeometry.createGeometry(box);
		 * @see BoxGeometry.createGeometry
		 */
		static fromDimensions(options: {
			dimensions: Cartesian3;
			vertexFormat?: VertexFormat;
		}): BoxGeometry;

		/**
		 * Creates a cube from the dimensions of an AxisAlignedBoundingBox.
		 * @param {AxisAlignedBoundingBox} boundingBox A description of the AxisAlignedBoundingBox.
		 * @returns {BoxGeometry}
		 * @example
		 * var aabb = Cesium.AxisAlignedBoundingBox.fromPoints(Cesium.Cartesian3.fromDegreesArray([
		 *      -72.0, 40.0,
		 *      -70.0, 35.0,
		 *      -75.0, 30.0,
		 *      -70.0, 30.0,
		 *      -68.0, 40.0
		 * ]));
		 * var box = Cesium.BoxGeometry.fromAxisAlignedBoundingBox(aabb);
		 * @see BoxGeometry.createGeometry
		 */
		static fromAxisAlignedBoundingBox(boundingBox: AxisAlignedBoundingBox): BoxGeometry;

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {BoxGeometry} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: BoxGeometry, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {BoxGeometry} [result] The object into which to store the result.
		 * @returns {BoxGeometry} The modified result parameter or a new BoxGeometry instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: BoxGeometry): BoxGeometry;

		/**
		 * Computes the geometric representation of a box, including its vertices, indices, and a bounding sphere.
		 * @param {BoxGeometry} boxGeometry A description of the box.
		 * @returns {Geometry|undefined} The computed vertices and indices.
		 */
		static createGeometry(boxGeometry: BoxGeometry): Geometry | undefined;

	}

	/**
	 * A description of the outline of a cube centered at the origin.
	 * @alias BoxOutlineGeometry
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Cartesian3} options.minimum The minimum x, y, and z coordinates of the box.
	 * @param {Cartesian3} options.maximum The maximum x, y, and z coordinates of the box.
	 * @see BoxOutlineGeometry.fromDimensions
	 * @see BoxOutlineGeometry.createGeometry
	 * @see Packable
	 * @example
	 * var box = new Cesium.BoxOutlineGeometry({
	 *   maximum : new Cesium.Cartesian3(250000.0, 250000.0, 250000.0),
	 *   minimum : new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0)
	 * });
	 * var geometry = Cesium.BoxOutlineGeometry.createGeometry(box);
	 */
	class BoxOutlineGeometry {
		constructor(options: {
			minimum: Cartesian3;
			maximum: Cartesian3;
		});

		/**
		 * Creates an outline of a cube centered at the origin given its dimensions.
		 * @param {Object} options Object with the following properties:
		 * @param {Cartesian3} options.dimensions The width, depth, and height of the box stored in the x, y, and z coordinates of the <code>Cartesian3</code>, respectively.
		 * @returns {BoxOutlineGeometry}
		 * @exception {DeveloperError} All dimensions components must be greater than or equal to zero.
		 * @example
		 * var box = Cesium.BoxOutlineGeometry.fromDimensions({
		 *   dimensions : new Cesium.Cartesian3(500000.0, 500000.0, 500000.0)
		 * });
		 * var geometry = Cesium.BoxOutlineGeometry.createGeometry(box);
		 * @see BoxOutlineGeometry.createGeometry
		 */
		static fromDimensions(options: {
			dimensions: Cartesian3;
		}): BoxOutlineGeometry;

		/**
		 * Creates an outline of a cube from the dimensions of an AxisAlignedBoundingBox.
		 * @param {AxisAlignedBoundingBox} boundingBox A description of the AxisAlignedBoundingBox.
		 * @returns {BoxOutlineGeometry}
		 * @example
		 * var aabb = Cesium.AxisAlignedBoundingBox.fromPoints(Cesium.Cartesian3.fromDegreesArray([
		 *      -72.0, 40.0,
		 *      -70.0, 35.0,
		 *      -75.0, 30.0,
		 *      -70.0, 30.0,
		 *      -68.0, 40.0
		 * ]));
		 * var box = Cesium.BoxOutlineGeometry.fromAxisAlignedBoundingBox(aabb);
		 *  @see BoxOutlineGeometry.createGeometry
		 */
		static fromAxisAlignedBoundingBox(boundingBox: AxisAlignedBoundingBox): BoxOutlineGeometry;

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {BoxOutlineGeometry} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: BoxOutlineGeometry, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {BoxOutlineGeometry} [result] The object into which to store the result.
		 * @returns {BoxOutlineGeometry} The modified result parameter or a new BoxOutlineGeometry instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: BoxOutlineGeometry): BoxOutlineGeometry;

		/**
		 * Computes the geometric representation of an outline of a box, including its vertices, indices, and a bounding sphere.
		 * @param {BoxOutlineGeometry} boxGeometry A description of the box outline.
		 * @returns {Geometry|undefined} The computed vertices and indices.
		 */
		static createGeometry(boxGeometry: BoxOutlineGeometry): Geometry | undefined;

	}

	/**
	 * A browser-independent function to cancel an animation frame requested using {@link requestAnimationFrame}.
	 * @exports cancelAnimationFrame
	 * @param {Number} requestID The value returned by {@link requestAnimationFrame}.
	 * @see {@link http://www.w3.org/TR/animation-timing/#the-WindowAnimationTiming-interface|The WindowAnimationTiming interface}
	 */
	namespace cancelAnimationFrame {
	}

	/**
	 * A 2D Cartesian point.
	 * @alias Cartesian2
	 * @constructor
	 * @param {Number} [x=0.0] The X component.
	 * @param {Number} [y=0.0] The Y component.
	 * @see Cartesian3
	 * @see Cartesian4
	 * @see Packable
	 */
	class Cartesian2 {
		constructor(x?: number, y?: number);

		/**
		 * The X component.
		 * @type {Number}
		 * @default 0.0
		 */
		x: number;

		/**
		 * The Y component.
		 * @type {Number}
		 * @default 0.0
		 */
		y: number;

		/**
		 * Creates a Cartesian2 instance from x and y coordinates.
		 * @param {Number} x The x coordinate.
		 * @param {Number} y The y coordinate.
		 * @param {Cartesian2} [result] The object onto which to store the result.
		 * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
		 */
		static fromElements(x: number, y: number, result?: Cartesian2): Cartesian2;

		/**
		 * Duplicates a Cartesian2 instance.
		 * @param {Cartesian2} cartesian The Cartesian to duplicate.
		 * @param {Cartesian2} [result] The object onto which to store the result.
		 * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided. (Returns undefined if cartesian is undefined)
		 */
		static clone(cartesian: Cartesian2, result?: Cartesian2): Cartesian2;

		/**
		 * Creates a Cartesian2 instance from an existing Cartesian3.  This simply takes the
		 * x and y properties of the Cartesian3 and drops z.
		 * @function
		 * @param {Cartesian3} cartesian The Cartesian3 instance to create a Cartesian2 instance from.
		 * @param {Cartesian2} [result] The object onto which to store the result.
		 * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
		 */
		static fromCartesian3(cartesian: Cartesian3, result?: Cartesian2): Cartesian2;

		/**
		 * Creates a Cartesian2 instance from an existing Cartesian4.  This simply takes the
		 * x and y properties of the Cartesian4 and drops z and w.
		 * @function
		 * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian2 instance from.
		 * @param {Cartesian2} [result] The object onto which to store the result.
		 * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
		 */
		static fromCartesian4(cartesian: Cartesian4, result?: Cartesian2): Cartesian2;

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {Cartesian2} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: Cartesian2, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {Cartesian2} [result] The object into which to store the result.
		 * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: Cartesian2): Cartesian2;

		/**
		 * Flattens an array of Cartesian2s into and array of components.
		 * @param {Cartesian2[]} array The array of cartesians to pack.
		 * @param {Number[]} result The array onto which to store the result.
		 * @returns {Number[]} The packed array.
		 */
		static packArray(array: (Cartesian2)[], result: number[]): number[];

		/**
		 * Unpacks an array of cartesian components into and array of Cartesian2s.
		 * @param {Number[]} array The array of components to unpack.
		 * @param {Cartesian2[]} result The array onto which to store the result.
		 * @returns {Cartesian2[]} The unpacked array.
		 */
		static unpackArray(array: number[], result: (Cartesian2)[]): (Cartesian2)[];

		/**
		 * Creates a Cartesian2 from two consecutive elements in an array.
		 * @function
		 * @param {Number[]} array The array whose two consecutive elements correspond to the x and y components, respectively.
		 * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.
		 * @param {Cartesian2} [result] The object onto which to store the result.
		 * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
		 * @example
		 * // Create a Cartesian2 with (1.0, 2.0)
		 * var v = [1.0, 2.0];
		 * var p = Cesium.Cartesian2.fromArray(v);
		 * // Create a Cartesian2 with (1.0, 2.0) using an offset into an array
		 * var v2 = [0.0, 0.0, 1.0, 2.0];
		 * var p2 = Cesium.Cartesian2.fromArray(v2, 2);
		 */
		static fromArray(array: number[], startingIndex?: number, result?: Cartesian2): Cartesian2;

		/**
		 * Computes the value of the maximum component for the supplied Cartesian.
		 * @param {Cartesian2} cartesian The cartesian to use.
		 * @returns {Number} The value of the maximum component.
		 */
		static maximumComponent(cartesian: Cartesian2): number;

		/**
		 * Computes the value of the minimum component for the supplied Cartesian.
		 * @param {Cartesian2} cartesian The cartesian to use.
		 * @returns {Number} The value of the minimum component.
		 */
		static minimumComponent(cartesian: Cartesian2): number;

		/**
		 * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.
		 * @param {Cartesian2} first A cartesian to compare.
		 * @param {Cartesian2} second A cartesian to compare.
		 * @param {Cartesian2} result The object into which to store the result.
		 * @returns {Cartesian2} A cartesian with the minimum components.
		 */
		static minimumByComponent(first: Cartesian2, second: Cartesian2, result: Cartesian2): Cartesian2;

		/**
		 * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.
		 * @param {Cartesian2} first A cartesian to compare.
		 * @param {Cartesian2} second A cartesian to compare.
		 * @param {Cartesian2} result The object into which to store the result.
		 * @returns {Cartesian2} A cartesian with the maximum components.
		 */
		static maximumByComponent(first: Cartesian2, second: Cartesian2, result: Cartesian2): Cartesian2;

		/**
		 * Computes the provided Cartesian's squared magnitude.
		 * @param {Cartesian2} cartesian The Cartesian instance whose squared magnitude is to be computed.
		 * @returns {Number} The squared magnitude.
		 */
		static magnitudeSquared(cartesian: Cartesian2): number;

		/**
		 * Computes the Cartesian's magnitude (length).
		 * @param {Cartesian2} cartesian The Cartesian instance whose magnitude is to be computed.
		 * @returns {Number} The magnitude.
		 */
		static magnitude(cartesian: Cartesian2): number;

		/**
		 * Computes the distance between two points.
		 * @param {Cartesian2} left The first point to compute the distance from.
		 * @param {Cartesian2} right The second point to compute the distance to.
		 * @returns {Number} The distance between two points.
		 * @example
		 * // Returns 1.0
		 * var d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(2.0, 0.0));
		 */
		static distance(left: Cartesian2, right: Cartesian2): number;

		/**
		 * Computes the squared distance between two points.  Comparing squared distances
		 * using this function is more efficient than comparing distances using {@link Cartesian2#distance}.
		 * @param {Cartesian2} left The first point to compute the distance from.
		 * @param {Cartesian2} right The second point to compute the distance to.
		 * @returns {Number} The distance between two points.
		 * @example
		 * // Returns 4.0, not 2.0
		 * var d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(3.0, 0.0));
		 */
		static distanceSquared(left: Cartesian2, right: Cartesian2): number;

		/**
		 * Computes the normalized form of the supplied Cartesian.
		 * @param {Cartesian2} cartesian The Cartesian to be normalized.
		 * @param {Cartesian2} result The object onto which to store the result.
		 * @returns {Cartesian2} The modified result parameter.
		 */
		static normalize(cartesian: Cartesian2, result: Cartesian2): Cartesian2;

		/**
		 * Computes the dot (scalar) product of two Cartesians.
		 * @param {Cartesian2} left The first Cartesian.
		 * @param {Cartesian2} right The second Cartesian.
		 * @returns {Number} The dot product.
		 */
		static dot(left: Cartesian2, right: Cartesian2): number;

		/**
		 * Computes the componentwise product of two Cartesians.
		 * @param {Cartesian2} left The first Cartesian.
		 * @param {Cartesian2} right The second Cartesian.
		 * @param {Cartesian2} result The object onto which to store the result.
		 * @returns {Cartesian2} The modified result parameter.
		 */
		static multiplyComponents(left: Cartesian2, right: Cartesian2, result: Cartesian2): Cartesian2;

		/**
		 * Computes the componentwise quotient of two Cartesians.
		 * @param {Cartesian2} left The first Cartesian.
		 * @param {Cartesian2} right The second Cartesian.
		 * @param {Cartesian2} result The object onto which to store the result.
		 * @returns {Cartesian2} The modified result parameter.
		 */
		static divideComponents(left: Cartesian2, right: Cartesian2, result: Cartesian2): Cartesian2;

		/**
		 * Computes the componentwise sum of two Cartesians.
		 * @param {Cartesian2} left The first Cartesian.
		 * @param {Cartesian2} right The second Cartesian.
		 * @param {Cartesian2} result The object onto which to store the result.
		 * @returns {Cartesian2} The modified result parameter.
		 */
		static add(left: Cartesian2, right: Cartesian2, result: Cartesian2): Cartesian2;

		/**
		 * Computes the componentwise difference of two Cartesians.
		 * @param {Cartesian2} left The first Cartesian.
		 * @param {Cartesian2} right The second Cartesian.
		 * @param {Cartesian2} result The object onto which to store the result.
		 * @returns {Cartesian2} The modified result parameter.
		 */
		static subtract(left: Cartesian2, right: Cartesian2, result: Cartesian2): Cartesian2;

		/**
		 * Multiplies the provided Cartesian componentwise by the provided scalar.
		 * @param {Cartesian2} cartesian The Cartesian to be scaled.
		 * @param {Number} scalar The scalar to multiply with.
		 * @param {Cartesian2} result The object onto which to store the result.
		 * @returns {Cartesian2} The modified result parameter.
		 */
		static multiplyByScalar(cartesian: Cartesian2, scalar: number, result: Cartesian2): Cartesian2;

		/**
		 * Divides the provided Cartesian componentwise by the provided scalar.
		 * @param {Cartesian2} cartesian The Cartesian to be divided.
		 * @param {Number} scalar The scalar to divide by.
		 * @param {Cartesian2} result The object onto which to store the result.
		 * @returns {Cartesian2} The modified result parameter.
		 */
		static divideByScalar(cartesian: Cartesian2, scalar: number, result: Cartesian2): Cartesian2;

		/**
		 * Negates the provided Cartesian.
		 * @param {Cartesian2} cartesian The Cartesian to be negated.
		 * @param {Cartesian2} result The object onto which to store the result.
		 * @returns {Cartesian2} The modified result parameter.
		 */
		static negate(cartesian: Cartesian2, result: Cartesian2): Cartesian2;

		/**
		 * Computes the absolute value of the provided Cartesian.
		 * @param {Cartesian2} cartesian The Cartesian whose absolute value is to be computed.
		 * @param {Cartesian2} result The object onto which to store the result.
		 * @returns {Cartesian2} The modified result parameter.
		 */
		static abs(cartesian: Cartesian2, result: Cartesian2): Cartesian2;

		/**
		 * Computes the linear interpolation or extrapolation at t using the provided cartesians.
		 * @param {Cartesian2} start The value corresponding to t at 0.0.
		 * @param {Cartesian2} end The value corresponding to t at 1.0.
		 * @param {Number} t The point along t at which to interpolate.
		 * @param {Cartesian2} result The object onto which to store the result.
		 * @returns {Cartesian2} The modified result parameter.
		 */
		static lerp(start: Cartesian2, end: Cartesian2, t: number, result: Cartesian2): Cartesian2;

		/**
		 * Returns the angle, in radians, between the provided Cartesians.
		 * @param {Cartesian2} left The first Cartesian.
		 * @param {Cartesian2} right The second Cartesian.
		 * @returns {Number} The angle between the Cartesians.
		 */
		static angleBetween(left: Cartesian2, right: Cartesian2): number;

		/**
		 * Returns the axis that is most orthogonal to the provided Cartesian.
		 * @param {Cartesian2} cartesian The Cartesian on which to find the most orthogonal axis.
		 * @param {Cartesian2} result The object onto which to store the result.
		 * @returns {Cartesian2} The most orthogonal axis.
		 */
		static mostOrthogonalAxis(cartesian: Cartesian2, result: Cartesian2): Cartesian2;

		/**
		 * Compares the provided Cartesians componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Cartesian2} [left] The first Cartesian.
		 * @param {Cartesian2} [right] The second Cartesian.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		static equals(left?: Cartesian2, right?: Cartesian2): boolean;

		/**
		 * Compares the provided Cartesians componentwise and returns
		 * <code>true</code> if they pass an absolute or relative tolerance test,
		 * <code>false</code> otherwise.
		 * @param {Cartesian2} [left] The first Cartesian.
		 * @param {Cartesian2} [right] The second Cartesian.
		 * @param {Number} [relativeEpsilon] The relative epsilon tolerance to use for equality testing.
		 * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
		 * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
		 */
		static equalsEpsilon(left?: Cartesian2, right?: Cartesian2, relativeEpsilon?: number, absoluteEpsilon?: number): boolean;

		/**
		 * An immutable Cartesian2 instance initialized to (0.0, 0.0).
		 * @type {Cartesian2}
		 * @constant
		 */
		static ZERO: Cartesian2;

		/**
		 * An immutable Cartesian2 instance initialized to (1.0, 0.0).
		 * @type {Cartesian2}
		 * @constant
		 */
		static UNIT_X: Cartesian2;

		/**
		 * An immutable Cartesian2 instance initialized to (0.0, 1.0).
		 * @type {Cartesian2}
		 * @constant
		 */
		static UNIT_Y: Cartesian2;

		/**
		 * Duplicates this Cartesian2 instance.
		 * @param {Cartesian2} [result] The object onto which to store the result.
		 * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.
		 */
		clone(result?: Cartesian2): Cartesian2;

		/**
		 * Compares this Cartesian against the provided Cartesian componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Cartesian2} [right] The right hand side Cartesian.
		 * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
		 */
		equals(right?: Cartesian2): boolean;

		/**
		 * Compares this Cartesian against the provided Cartesian componentwise and returns
		 * <code>true</code> if they pass an absolute or relative tolerance test,
		 * <code>false</code> otherwise.
		 * @param {Cartesian2} [right] The right hand side Cartesian.
		 * @param {Number} [relativeEpsilon] The relative epsilon tolerance to use for equality testing.
		 * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
		 * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
		 */
		equalsEpsilon(right?: Cartesian2, relativeEpsilon?: number, absoluteEpsilon?: number): boolean;

		/**
		 * Creates a string representing this Cartesian in the format '(x, y)'.
		 * @returns {String} A string representing the provided Cartesian in the format '(x, y)'.
		 */
		toString(): string;

	}

	/**
	 * A 3D Cartesian point.
	 * @alias Cartesian3
	 * @constructor
	 * @param {Number} [x=0.0] The X component.
	 * @param {Number} [y=0.0] The Y component.
	 * @param {Number} [z=0.0] The Z component.
	 * @see Cartesian2
	 * @see Cartesian4
	 * @see Packable
	 */
	class Cartesian3 {
		constructor(x?: number, y?: number, z?: number);

		/**
		 * The X component.
		 * @type {Number}
		 * @default 0.0
		 */
		x: number;

		/**
		 * The Y component.
		 * @type {Number}
		 * @default 0.0
		 */
		y: number;

		/**
		 * The Z component.
		 * @type {Number}
		 * @default 0.0
		 */
		z: number;

		/**
		 * Converts the provided Spherical into Cartesian3 coordinates.
		 * @param {Spherical} spherical The Spherical to be converted to Cartesian3.
		 * @param {Cartesian3} [result] The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
		 */
		static fromSpherical(spherical: Spherical, result?: Cartesian3): Cartesian3;

		/**
		 * Creates a Cartesian3 instance from x, y and z coordinates.
		 * @param {Number} x The x coordinate.
		 * @param {Number} y The y coordinate.
		 * @param {Number} z The z coordinate.
		 * @param {Cartesian3} [result] The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
		 */
		static fromElements(x: number, y: number, z: number, result?: Cartesian3): Cartesian3;

		/**
		 * Duplicates a Cartesian3 instance.
		 * @param {Cartesian3} cartesian The Cartesian to duplicate.
		 * @param {Cartesian3} [result] The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided. (Returns undefined if cartesian is undefined)
		 */
		static clone(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;

		/**
		 * Creates a Cartesian3 instance from an existing Cartesian4.  This simply takes the
		 * x, y, and z properties of the Cartesian4 and drops w.
		 * @function
		 * @param {Cartesian4} cartesian The Cartesian4 instance to create a Cartesian3 instance from.
		 * @param {Cartesian3} [result] The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
		 */
		static fromCartesian4(cartesian: Cartesian4, result?: Cartesian3): Cartesian3;

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {Cartesian3} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: Cartesian3, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {Cartesian3} [result] The object into which to store the result.
		 * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: Cartesian3): Cartesian3;

		/**
		 * Flattens an array of Cartesian3s into an array of components.
		 * @param {Cartesian3[]} array The array of cartesians to pack.
		 * @param {Number[]} result The array onto which to store the result.
		 * @returns {Number[]} The packed array.
		 */
		static packArray(array: (Cartesian3)[], result: number[]): number[];

		/**
		 * Unpacks an array of cartesian components into an array of Cartesian3s.
		 * @param {Number[]} array The array of components to unpack.
		 * @param {Cartesian3[]} result The array onto which to store the result.
		 * @returns {Cartesian3[]} The unpacked array.
		 */
		static unpackArray(array: number[], result: (Cartesian3)[]): (Cartesian3)[];

		/**
		 * Creates a Cartesian3 from three consecutive elements in an array.
		 * @function
		 * @param {Number[]} array The array whose three consecutive elements correspond to the x, y, and z components, respectively.
		 * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.
		 * @param {Cartesian3} [result] The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
		 * @example
		 * // Create a Cartesian3 with (1.0, 2.0, 3.0)
		 * var v = [1.0, 2.0, 3.0];
		 * var p = Cesium.Cartesian3.fromArray(v);
		 * // Create a Cartesian3 with (1.0, 2.0, 3.0) using an offset into an array
		 * var v2 = [0.0, 0.0, 1.0, 2.0, 3.0];
		 * var p2 = Cesium.Cartesian3.fromArray(v2, 2);
		 */
		static fromArray(array: number[], startingIndex?: number, result?: Cartesian3): Cartesian3;

		/**
		 * Computes the value of the maximum component for the supplied Cartesian.
		 * @param {Cartesian3} cartesian The cartesian to use.
		 * @returns {Number} The value of the maximum component.
		 */
		static maximumComponent(cartesian: Cartesian3): number;

		/**
		 * Computes the value of the minimum component for the supplied Cartesian.
		 * @param {Cartesian3} cartesian The cartesian to use.
		 * @returns {Number} The value of the minimum component.
		 */
		static minimumComponent(cartesian: Cartesian3): number;

		/**
		 * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.
		 * @param {Cartesian3} first A cartesian to compare.
		 * @param {Cartesian3} second A cartesian to compare.
		 * @param {Cartesian3} result The object into which to store the result.
		 * @returns {Cartesian3} A cartesian with the minimum components.
		 */
		static minimumByComponent(first: Cartesian3, second: Cartesian3, result: Cartesian3): Cartesian3;

		/**
		 * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.
		 * @param {Cartesian3} first A cartesian to compare.
		 * @param {Cartesian3} second A cartesian to compare.
		 * @param {Cartesian3} result The object into which to store the result.
		 * @returns {Cartesian3} A cartesian with the maximum components.
		 */
		static maximumByComponent(first: Cartesian3, second: Cartesian3, result: Cartesian3): Cartesian3;

		/**
		 * Computes the provided Cartesian's squared magnitude.
		 * @param {Cartesian3} cartesian The Cartesian instance whose squared magnitude is to be computed.
		 * @returns {Number} The squared magnitude.
		 */
		static magnitudeSquared(cartesian: Cartesian3): number;

		/**
		 * Computes the Cartesian's magnitude (length).
		 * @param {Cartesian3} cartesian The Cartesian instance whose magnitude is to be computed.
		 * @returns {Number} The magnitude.
		 */
		static magnitude(cartesian: Cartesian3): number;

		/**
		 * Computes the distance between two points.
		 * @param {Cartesian3} left The first point to compute the distance from.
		 * @param {Cartesian3} right The second point to compute the distance to.
		 * @returns {Number} The distance between two points.
		 * @example
		 * // Returns 1.0
		 * var d = Cesium.Cartesian3.distance(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(2.0, 0.0, 0.0));
		 */
		static distance(left: Cartesian3, right: Cartesian3): number;

		/**
		 * Computes the squared distance between two points.  Comparing squared distances
		 * using this function is more efficient than comparing distances using {@link Cartesian3#distance}.
		 * @param {Cartesian3} left The first point to compute the distance from.
		 * @param {Cartesian3} right The second point to compute the distance to.
		 * @returns {Number} The distance between two points.
		 * @example
		 * // Returns 4.0, not 2.0
		 * var d = Cesium.Cartesian3.distanceSquared(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(3.0, 0.0, 0.0));
		 */
		static distanceSquared(left: Cartesian3, right: Cartesian3): number;

		/**
		 * Computes the normalized form of the supplied Cartesian.
		 * @param {Cartesian3} cartesian The Cartesian to be normalized.
		 * @param {Cartesian3} result The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter.
		 */
		static normalize(cartesian: Cartesian3, result: Cartesian3): Cartesian3;

		/**
		 * Computes the dot (scalar) product of two Cartesians.
		 * @param {Cartesian3} left The first Cartesian.
		 * @param {Cartesian3} right The second Cartesian.
		 * @returns {Number} The dot product.
		 */
		static dot(left: Cartesian3, right: Cartesian3): number;

		/**
		 * Computes the componentwise product of two Cartesians.
		 * @param {Cartesian3} left The first Cartesian.
		 * @param {Cartesian3} right The second Cartesian.
		 * @param {Cartesian3} result The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter.
		 */
		static multiplyComponents(left: Cartesian3, right: Cartesian3, result: Cartesian3): Cartesian3;

		/**
		 * Computes the componentwise quotient of two Cartesians.
		 * @param {Cartesian3} left The first Cartesian.
		 * @param {Cartesian3} right The second Cartesian.
		 * @param {Cartesian3} result The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter.
		 */
		static divideComponents(left: Cartesian3, right: Cartesian3, result: Cartesian3): Cartesian3;

		/**
		 * Computes the componentwise sum of two Cartesians.
		 * @param {Cartesian3} left The first Cartesian.
		 * @param {Cartesian3} right The second Cartesian.
		 * @param {Cartesian3} result The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter.
		 */
		static add(left: Cartesian3, right: Cartesian3, result: Cartesian3): Cartesian3;

		/**
		 * Computes the componentwise difference of two Cartesians.
		 * @param {Cartesian3} left The first Cartesian.
		 * @param {Cartesian3} right The second Cartesian.
		 * @param {Cartesian3} result The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter.
		 */
		static subtract(left: Cartesian3, right: Cartesian3, result: Cartesian3): Cartesian3;

		/**
		 * Multiplies the provided Cartesian componentwise by the provided scalar.
		 * @param {Cartesian3} cartesian The Cartesian to be scaled.
		 * @param {Number} scalar The scalar to multiply with.
		 * @param {Cartesian3} result The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter.
		 */
		static multiplyByScalar(cartesian: Cartesian3, scalar: number, result: Cartesian3): Cartesian3;

		/**
		 * Divides the provided Cartesian componentwise by the provided scalar.
		 * @param {Cartesian3} cartesian The Cartesian to be divided.
		 * @param {Number} scalar The scalar to divide by.
		 * @param {Cartesian3} result The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter.
		 */
		static divideByScalar(cartesian: Cartesian3, scalar: number, result: Cartesian3): Cartesian3;

		/**
		 * Negates the provided Cartesian.
		 * @param {Cartesian3} cartesian The Cartesian to be negated.
		 * @param {Cartesian3} result The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter.
		 */
		static negate(cartesian: Cartesian3, result: Cartesian3): Cartesian3;

		/**
		 * Computes the absolute value of the provided Cartesian.
		 * @param {Cartesian3} cartesian The Cartesian whose absolute value is to be computed.
		 * @param {Cartesian3} result The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter.
		 */
		static abs(cartesian: Cartesian3, result: Cartesian3): Cartesian3;

		/**
		 * Computes the linear interpolation or extrapolation at t using the provided cartesians.
		 * @param {Cartesian3} start The value corresponding to t at 0.0.
		 * @param {Cartesian3} end The value corresponding to t at 1.0.
		 * @param {Number} t The point along t at which to interpolate.
		 * @param {Cartesian3} result The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter.
		 */
		static lerp(start: Cartesian3, end: Cartesian3, t: number, result: Cartesian3): Cartesian3;

		/**
		 * Returns the angle, in radians, between the provided Cartesians.
		 * @param {Cartesian3} left The first Cartesian.
		 * @param {Cartesian3} right The second Cartesian.
		 * @returns {Number} The angle between the Cartesians.
		 */
		static angleBetween(left: Cartesian3, right: Cartesian3): number;

		/**
		 * Returns the axis that is most orthogonal to the provided Cartesian.
		 * @param {Cartesian3} cartesian The Cartesian on which to find the most orthogonal axis.
		 * @param {Cartesian3} result The object onto which to store the result.
		 * @returns {Cartesian3} The most orthogonal axis.
		 */
		static mostOrthogonalAxis(cartesian: Cartesian3, result: Cartesian3): Cartesian3;

		/**
		 * Projects vector a onto vector b
		 * @param {Cartesian3} a The vector that needs projecting
		 * @param {Cartesian3} b The vector to project onto
		 * @param {Cartesian3} result The result cartesian
		 * @returns {Cartesian3} The modified result parameter
		 */
		static projectVector(a: Cartesian3, b: Cartesian3, result: Cartesian3): Cartesian3;

		/**
		 * Compares the provided Cartesians componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Cartesian3} [left] The first Cartesian.
		 * @param {Cartesian3} [right] The second Cartesian.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		static equals(left?: Cartesian3, right?: Cartesian3): boolean;

		/**
		 * Compares the provided Cartesians componentwise and returns
		 * <code>true</code> if they pass an absolute or relative tolerance test,
		 * <code>false</code> otherwise.
		 * @param {Cartesian3} [left] The first Cartesian.
		 * @param {Cartesian3} [right] The second Cartesian.
		 * @param {Number} [relativeEpsilon] The relative epsilon tolerance to use for equality testing.
		 * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
		 * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
		 */
		static equalsEpsilon(left?: Cartesian3, right?: Cartesian3, relativeEpsilon?: number, absoluteEpsilon?: number): boolean;

		/**
		 * Computes the cross (outer) product of two Cartesians.
		 * @param {Cartesian3} left The first Cartesian.
		 * @param {Cartesian3} right The second Cartesian.
		 * @param {Cartesian3} result The object onto which to store the result.
		 * @returns {Cartesian3} The cross product.
		 */
		static cross(left: Cartesian3, right: Cartesian3, result: Cartesian3): Cartesian3;

		/**
		 * Computes the midpoint between the right and left Cartesian.
		 * @param {Cartesian3} left The first Cartesian.
		 * @param {Cartesian3} right The second Cartesian.
		 * @param {Cartesian3} result The object onto which to store the result.
		 * @returns {Cartesian3} The midpoint.
		 */
		static midpoint(left: Cartesian3, right: Cartesian3, result: Cartesian3): Cartesian3;

		/**
		 * Returns a Cartesian3 position from longitude and latitude values given in degrees.
		 * @param {Number} longitude The longitude, in degrees
		 * @param {Number} latitude The latitude, in degrees
		 * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.
		 * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.
		 * @param {Cartesian3} [result] The object onto which to store the result.
		 * @returns {Cartesian3} The position
		 * @example
		 * var position = Cesium.Cartesian3.fromDegrees(-115.0, 37.0);
		 */
		static fromDegrees(longitude: number, latitude: number, height?: number, ellipsoid?: Ellipsoid, result?: Cartesian3): Cartesian3;

		/**
		 * Returns a Cartesian3 position from longitude and latitude values given in radians.
		 * @param {Number} longitude The longitude, in radians
		 * @param {Number} latitude The latitude, in radians
		 * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.
		 * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.
		 * @param {Cartesian3} [result] The object onto which to store the result.
		 * @returns {Cartesian3} The position
		 * @example
		 * var position = Cesium.Cartesian3.fromRadians(-2.007, 0.645);
		 */
		static fromRadians(longitude: number, latitude: number, height?: number, ellipsoid?: Ellipsoid, result?: Cartesian3): Cartesian3;

		/**
		 * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in degrees.
		 * @param {Number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].
		 * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the coordinates lie.
		 * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.
		 * @returns {Cartesian3[]} The array of positions.
		 * @example
		 * var positions = Cesium.Cartesian3.fromDegreesArray([-115.0, 37.0, -107.0, 33.0]);
		 */
		static fromDegreesArray(coordinates: number[], ellipsoid?: Ellipsoid, result?: (Cartesian3)[]): (Cartesian3)[];

		/**
		 * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in radians.
		 * @param {Number[]} coordinates A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].
		 * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the coordinates lie.
		 * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.
		 * @returns {Cartesian3[]} The array of positions.
		 * @example
		 * var positions = Cesium.Cartesian3.fromRadiansArray([-2.007, 0.645, -1.867, .575]);
		 */
		static fromRadiansArray(coordinates: number[], ellipsoid?: Ellipsoid, result?: (Cartesian3)[]): (Cartesian3)[];

		/**
		 * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in degrees.
		 * @param {Number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].
		 * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.
		 * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.
		 * @returns {Cartesian3[]} The array of positions.
		 * @example
		 * var positions = Cesium.Cartesian3.fromDegreesArrayHeights([-115.0, 37.0, 100000.0, -107.0, 33.0, 150000.0]);
		 */
		static fromDegreesArrayHeights(coordinates: number[], ellipsoid?: Ellipsoid, result?: (Cartesian3)[]): (Cartesian3)[];

		/**
		 * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in radians.
		 * @param {Number[]} coordinates A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].
		 * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.
		 * @param {Cartesian3[]} [result] An array of Cartesian3 objects to store the result.
		 * @returns {Cartesian3[]} The array of positions.
		 * @example
		 * var positions = Cesium.Cartesian3.fromRadiansArrayHeights([-2.007, 0.645, 100000.0, -1.867, .575, 150000.0]);
		 */
		static fromRadiansArrayHeights(coordinates: number[], ellipsoid?: Ellipsoid, result?: (Cartesian3)[]): (Cartesian3)[];

		/**
		 * An immutable Cartesian3 instance initialized to (0.0, 0.0, 0.0).
		 * @type {Cartesian3}
		 * @constant
		 */
		static ZERO: Cartesian3;

		/**
		 * An immutable Cartesian3 instance initialized to (1.0, 0.0, 0.0).
		 * @type {Cartesian3}
		 * @constant
		 */
		static UNIT_X: Cartesian3;

		/**
		 * An immutable Cartesian3 instance initialized to (0.0, 1.0, 0.0).
		 * @type {Cartesian3}
		 * @constant
		 */
		static UNIT_Y: Cartesian3;

		/**
		 * An immutable Cartesian3 instance initialized to (0.0, 0.0, 1.0).
		 * @type {Cartesian3}
		 * @constant
		 */
		static UNIT_Z: Cartesian3;

		/**
		 * Duplicates this Cartesian3 instance.
		 * @param {Cartesian3} [result] The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
		 */
		clone(result?: Cartesian3): Cartesian3;

		/**
		 * Compares this Cartesian against the provided Cartesian componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Cartesian3} [right] The right hand side Cartesian.
		 * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
		 */
		equals(right?: Cartesian3): boolean;

		/**
		 * Compares this Cartesian against the provided Cartesian componentwise and returns
		 * <code>true</code> if they pass an absolute or relative tolerance test,
		 * <code>false</code> otherwise.
		 * @param {Cartesian3} [right] The right hand side Cartesian.
		 * @param {Number} [relativeEpsilon] The relative epsilon tolerance to use for equality testing.
		 * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
		 * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
		 */
		equalsEpsilon(right?: Cartesian3, relativeEpsilon?: number, absoluteEpsilon?: number): boolean;

		/**
		 * Creates a string representing this Cartesian in the format '(x, y, z)'.
		 * @returns {String} A string representing this Cartesian in the format '(x, y, z)'.
		 */
		toString(): string;

	}

	/**
	 * A 4D Cartesian point.
	 * @alias Cartesian4
	 * @constructor
	 * @param {Number} [x=0.0] The X component.
	 * @param {Number} [y=0.0] The Y component.
	 * @param {Number} [z=0.0] The Z component.
	 * @param {Number} [w=0.0] The W component.
	 * @see Cartesian2
	 * @see Cartesian3
	 * @see Packable
	 */
	class Cartesian4 {
		constructor(x?: number, y?: number, z?: number, w?: number);

		/**
		 * The X component.
		 * @type {Number}
		 * @default 0.0
		 */
		x: number;

		/**
		 * The Y component.
		 * @type {Number}
		 * @default 0.0
		 */
		y: number;

		/**
		 * The Z component.
		 * @type {Number}
		 * @default 0.0
		 */
		z: number;

		/**
		 * The W component.
		 * @type {Number}
		 * @default 0.0
		 */
		w: number;

		/**
		 * Creates a Cartesian4 instance from x, y, z and w coordinates.
		 * @param {Number} x The x coordinate.
		 * @param {Number} y The y coordinate.
		 * @param {Number} z The z coordinate.
		 * @param {Number} w The w coordinate.
		 * @param {Cartesian4} [result] The object onto which to store the result.
		 * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
		 */
		static fromElements(x: number, y: number, z: number, w: number, result?: Cartesian4): Cartesian4;

		/**
		 * Creates a Cartesian4 instance from a {@link Color}. <code>red</code>, <code>green</code>, <code>blue</code>,
		 * and <code>alpha</code> map to <code>x</code>, <code>y</code>, <code>z</code>, and <code>w</code>, respectively.
		 * @param {Color} color The source color.
		 * @param {Cartesian4} [result] The object onto which to store the result.
		 * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
		 */
		static fromColor(color: Color, result?: Cartesian4): Cartesian4;

		/**
		 * Duplicates a Cartesian4 instance.
		 * @param {Cartesian4} cartesian The Cartesian to duplicate.
		 * @param {Cartesian4} [result] The object onto which to store the result.
		 * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided. (Returns undefined if cartesian is undefined)
		 */
		static clone(cartesian: Cartesian4, result?: Cartesian4): Cartesian4;

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {Cartesian4} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: Cartesian4, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {Cartesian4} [result] The object into which to store the result.
		 * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: Cartesian4): Cartesian4;

		/**
		 * Flattens an array of Cartesian4s into and array of components.
		 * @param {Cartesian4[]} array The array of cartesians to pack.
		 * @param {Number[]} result The array onto which to store the result.
		 * @returns {Number[]} The packed array.
		 */
		static packArray(array: (Cartesian4)[], result: number[]): number[];

		/**
		 * Unpacks an array of cartesian components into and array of Cartesian4s.
		 * @param {Number[]} array The array of components to unpack.
		 * @param {Cartesian4[]} result The array onto which to store the result.
		 * @returns {Cartesian4[]} The unpacked array.
		 */
		static unpackArray(array: number[], result: (Cartesian4)[]): (Cartesian4)[];

		/**
		 * Creates a Cartesian4 from four consecutive elements in an array.
		 * @function
		 * @param {Number[]} array The array whose four consecutive elements correspond to the x, y, z, and w components, respectively.
		 * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to the x component.
		 * @param {Cartesian4} [result] The object onto which to store the result.
		 * @returns {Cartesian4}  The modified result parameter or a new Cartesian4 instance if one was not provided.
		 * @example
		 * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0)
		 * var v = [1.0, 2.0, 3.0, 4.0];
		 * var p = Cesium.Cartesian4.fromArray(v);
		 * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0) using an offset into an array
		 * var v2 = [0.0, 0.0, 1.0, 2.0, 3.0, 4.0];
		 * var p2 = Cesium.Cartesian4.fromArray(v2, 2);
		 */
		static fromArray(array: number[], startingIndex?: number, result?: Cartesian4): Cartesian4;

		/**
		 * Computes the value of the maximum component for the supplied Cartesian.
		 * @param {Cartesian4} cartesian The cartesian to use.
		 * @returns {Number} The value of the maximum component.
		 */
		static maximumComponent(cartesian: Cartesian4): number;

		/**
		 * Computes the value of the minimum component for the supplied Cartesian.
		 * @param {Cartesian4} cartesian The cartesian to use.
		 * @returns {Number} The value of the minimum component.
		 */
		static minimumComponent(cartesian: Cartesian4): number;

		/**
		 * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.
		 * @param {Cartesian4} first A cartesian to compare.
		 * @param {Cartesian4} second A cartesian to compare.
		 * @param {Cartesian4} result The object into which to store the result.
		 * @returns {Cartesian4} A cartesian with the minimum components.
		 */
		static minimumByComponent(first: Cartesian4, second: Cartesian4, result: Cartesian4): Cartesian4;

		/**
		 * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.
		 * @param {Cartesian4} first A cartesian to compare.
		 * @param {Cartesian4} second A cartesian to compare.
		 * @param {Cartesian4} result The object into which to store the result.
		 * @returns {Cartesian4} A cartesian with the maximum components.
		 */
		static maximumByComponent(first: Cartesian4, second: Cartesian4, result: Cartesian4): Cartesian4;

		/**
		 * Computes the provided Cartesian's squared magnitude.
		 * @param {Cartesian4} cartesian The Cartesian instance whose squared magnitude is to be computed.
		 * @returns {Number} The squared magnitude.
		 */
		static magnitudeSquared(cartesian: Cartesian4): number;

		/**
		 * Computes the Cartesian's magnitude (length).
		 * @param {Cartesian4} cartesian The Cartesian instance whose magnitude is to be computed.
		 * @returns {Number} The magnitude.
		 */
		static magnitude(cartesian: Cartesian4): number;

		/**
		 * Computes the 4-space distance between two points.
		 * @param {Cartesian4} left The first point to compute the distance from.
		 * @param {Cartesian4} right The second point to compute the distance to.
		 * @returns {Number} The distance between two points.
		 * @example
		 * // Returns 1.0
		 * var d = Cesium.Cartesian4.distance(
		 *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),
		 *   new Cesium.Cartesian4(2.0, 0.0, 0.0, 0.0));
		 */
		static distance(left: Cartesian4, right: Cartesian4): number;

		/**
		 * Computes the squared distance between two points.  Comparing squared distances
		 * using this function is more efficient than comparing distances using {@link Cartesian4#distance}.
		 * @param {Cartesian4} left The first point to compute the distance from.
		 * @param {Cartesian4} right The second point to compute the distance to.
		 * @returns {Number} The distance between two points.
		 * @example
		 * // Returns 4.0, not 2.0
		 * var d = Cesium.Cartesian4.distance(
		 *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),
		 *   new Cesium.Cartesian4(3.0, 0.0, 0.0, 0.0));
		 */
		static distanceSquared(left: Cartesian4, right: Cartesian4): number;

		/**
		 * Computes the normalized form of the supplied Cartesian.
		 * @param {Cartesian4} cartesian The Cartesian to be normalized.
		 * @param {Cartesian4} result The object onto which to store the result.
		 * @returns {Cartesian4} The modified result parameter.
		 */
		static normalize(cartesian: Cartesian4, result: Cartesian4): Cartesian4;

		/**
		 * Computes the dot (scalar) product of two Cartesians.
		 * @param {Cartesian4} left The first Cartesian.
		 * @param {Cartesian4} right The second Cartesian.
		 * @returns {Number} The dot product.
		 */
		static dot(left: Cartesian4, right: Cartesian4): number;

		/**
		 * Computes the componentwise product of two Cartesians.
		 * @param {Cartesian4} left The first Cartesian.
		 * @param {Cartesian4} right The second Cartesian.
		 * @param {Cartesian4} result The object onto which to store the result.
		 * @returns {Cartesian4} The modified result parameter.
		 */
		static multiplyComponents(left: Cartesian4, right: Cartesian4, result: Cartesian4): Cartesian4;

		/**
		 * Computes the componentwise quotient of two Cartesians.
		 * @param {Cartesian4} left The first Cartesian.
		 * @param {Cartesian4} right The second Cartesian.
		 * @param {Cartesian4} result The object onto which to store the result.
		 * @returns {Cartesian4} The modified result parameter.
		 */
		static divideComponents(left: Cartesian4, right: Cartesian4, result: Cartesian4): Cartesian4;

		/**
		 * Computes the componentwise sum of two Cartesians.
		 * @param {Cartesian4} left The first Cartesian.
		 * @param {Cartesian4} right The second Cartesian.
		 * @param {Cartesian4} result The object onto which to store the result.
		 * @returns {Cartesian4} The modified result parameter.
		 */
		static add(left: Cartesian4, right: Cartesian4, result: Cartesian4): Cartesian4;

		/**
		 * Computes the componentwise difference of two Cartesians.
		 * @param {Cartesian4} left The first Cartesian.
		 * @param {Cartesian4} right The second Cartesian.
		 * @param {Cartesian4} result The object onto which to store the result.
		 * @returns {Cartesian4} The modified result parameter.
		 */
		static subtract(left: Cartesian4, right: Cartesian4, result: Cartesian4): Cartesian4;

		/**
		 * Multiplies the provided Cartesian componentwise by the provided scalar.
		 * @param {Cartesian4} cartesian The Cartesian to be scaled.
		 * @param {Number} scalar The scalar to multiply with.
		 * @param {Cartesian4} result The object onto which to store the result.
		 * @returns {Cartesian4} The modified result parameter.
		 */
		static multiplyByScalar(cartesian: Cartesian4, scalar: number, result: Cartesian4): Cartesian4;

		/**
		 * Divides the provided Cartesian componentwise by the provided scalar.
		 * @param {Cartesian4} cartesian The Cartesian to be divided.
		 * @param {Number} scalar The scalar to divide by.
		 * @param {Cartesian4} result The object onto which to store the result.
		 * @returns {Cartesian4} The modified result parameter.
		 */
		static divideByScalar(cartesian: Cartesian4, scalar: number, result: Cartesian4): Cartesian4;

		/**
		 * Negates the provided Cartesian.
		 * @param {Cartesian4} cartesian The Cartesian to be negated.
		 * @param {Cartesian4} result The object onto which to store the result.
		 * @returns {Cartesian4} The modified result parameter.
		 */
		static negate(cartesian: Cartesian4, result: Cartesian4): Cartesian4;

		/**
		 * Computes the absolute value of the provided Cartesian.
		 * @param {Cartesian4} cartesian The Cartesian whose absolute value is to be computed.
		 * @param {Cartesian4} result The object onto which to store the result.
		 * @returns {Cartesian4} The modified result parameter.
		 */
		static abs(cartesian: Cartesian4, result: Cartesian4): Cartesian4;

		/**
		 * Computes the linear interpolation or extrapolation at t using the provided cartesians.
		 * @param {Cartesian4} start The value corresponding to t at 0.0.
		 * @param {Cartesian4}end The value corresponding to t at 1.0.
		 * @param {Number} t The point along t at which to interpolate.
		 * @param {Cartesian4} result The object onto which to store the result.
		 * @returns {Cartesian4} The modified result parameter.
		 */
		static lerp(start: Cartesian4, end: Cartesian4, t: number, result: Cartesian4): Cartesian4;

		/**
		 * Returns the axis that is most orthogonal to the provided Cartesian.
		 * @param {Cartesian4} cartesian The Cartesian on which to find the most orthogonal axis.
		 * @param {Cartesian4} result The object onto which to store the result.
		 * @returns {Cartesian4} The most orthogonal axis.
		 */
		static mostOrthogonalAxis(cartesian: Cartesian4, result: Cartesian4): Cartesian4;

		/**
		 * Compares the provided Cartesians componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Cartesian4} [left] The first Cartesian.
		 * @param {Cartesian4} [right] The second Cartesian.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		static equals(left?: Cartesian4, right?: Cartesian4): boolean;

		/**
		 * Compares the provided Cartesians componentwise and returns
		 * <code>true</code> if they pass an absolute or relative tolerance test,
		 * <code>false</code> otherwise.
		 * @param {Cartesian4} [left] The first Cartesian.
		 * @param {Cartesian4} [right] The second Cartesian.
		 * @param {Number} [relativeEpsilon] The relative epsilon tolerance to use for equality testing.
		 * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
		 * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
		 */
		static equalsEpsilon(left?: Cartesian4, right?: Cartesian4, relativeEpsilon?: number, absoluteEpsilon?: number): boolean;

		/**
		 * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 0.0).
		 * @type {Cartesian4}
		 * @constant
		 */
		static ZERO: Cartesian4;

		/**
		 * An immutable Cartesian4 instance initialized to (1.0, 0.0, 0.0, 0.0).
		 * @type {Cartesian4}
		 * @constant
		 */
		static UNIT_X: Cartesian4;

		/**
		 * An immutable Cartesian4 instance initialized to (0.0, 1.0, 0.0, 0.0).
		 * @type {Cartesian4}
		 * @constant
		 */
		static UNIT_Y: Cartesian4;

		/**
		 * An immutable Cartesian4 instance initialized to (0.0, 0.0, 1.0, 0.0).
		 * @type {Cartesian4}
		 * @constant
		 */
		static UNIT_Z: Cartesian4;

		/**
		 * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 1.0).
		 * @type {Cartesian4}
		 * @constant
		 */
		static UNIT_W: Cartesian4;

		/**
		 * Duplicates this Cartesian4 instance.
		 * @param {Cartesian4} [result] The object onto which to store the result.
		 * @returns {Cartesian4} The modified result parameter or a new Cartesian4 instance if one was not provided.
		 */
		clone(result?: Cartesian4): Cartesian4;

		/**
		 * Compares this Cartesian against the provided Cartesian componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Cartesian4} [right] The right hand side Cartesian.
		 * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
		 */
		equals(right?: Cartesian4): boolean;

		/**
		 * Compares this Cartesian against the provided Cartesian componentwise and returns
		 * <code>true</code> if they pass an absolute or relative tolerance test,
		 * <code>false</code> otherwise.
		 * @param {Cartesian4} [right] The right hand side Cartesian.
		 * @param {Number} [relativeEpsilon] The relative epsilon tolerance to use for equality testing.
		 * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
		 * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
		 */
		equalsEpsilon(right?: Cartesian4, relativeEpsilon?: number, absoluteEpsilon?: number): boolean;

		/**
		 * Creates a string representing this Cartesian in the format '(x, y)'.
		 * @returns {String} A string representing the provided Cartesian in the format '(x, y)'.
		 */
		toString(): string;

		/**
		 * Packs an arbitrary floating point value to 4 values representable using uint8.
		 * @param {Number} value A floating point number
		 * @param {Cartesian4} [result] The Cartesian4 that will contain the packed float.
		 * @returns {Cartesian4} A Cartesian4 representing the float packed to values in x, y, z, and w.
		 */
		static packFloat(value: number, result?: Cartesian4): Cartesian4;

	}

	/**
	 * A position defined by longitude, latitude, and height.
	 * @alias Cartographic
	 * @constructor
	 * @param {Number} [longitude=0.0] The longitude, in radians.
	 * @param {Number} [latitude=0.0] The latitude, in radians.
	 * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.
	 * @see Ellipsoid
	 */
	class Cartographic {
		constructor(longitude?: number, latitude?: number, height?: number);

		/**
		 * The longitude, in radians.
		 * @type {Number}
		 * @default 0.0
		 */
		longitude: number;

		/**
		 * The latitude, in radians.
		 * @type {Number}
		 * @default 0.0
		 */
		latitude: number;

		/**
		 * The height, in meters, above the ellipsoid.
		 * @type {Number}
		 * @default 0.0
		 */
		height: number;

		/**
		 * Creates a new Cartographic instance from longitude and latitude
		 * specified in radians.
		 * @param {Number} longitude The longitude, in radians.
		 * @param {Number} latitude The latitude, in radians.
		 * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.
		 * @param {Cartographic} [result] The object onto which to store the result.
		 * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.
		 */
		static fromRadians(longitude: number, latitude: number, height?: number, result?: Cartographic): Cartographic;

		/**
		 * Creates a new Cartographic instance from longitude and latitude
		 * specified in degrees.  The values in the resulting object will
		 * be in radians.
		 * @param {Number} longitude The longitude, in degrees.
		 * @param {Number} latitude The latitude, in degrees.
		 * @param {Number} [height=0.0] The height, in meters, above the ellipsoid.
		 * @param {Cartographic} [result] The object onto which to store the result.
		 * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.
		 */
		static fromDegrees(longitude: number, latitude: number, height?: number, result?: Cartographic): Cartographic;

		/**
		 * Creates a new Cartographic instance from a Cartesian position. The values in the
		 * resulting object will be in radians.
		 * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.
		 * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.
		 * @param {Cartographic} [result] The object onto which to store the result.
		 * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.
		 */
		static fromCartesian(cartesian: Cartesian3, ellipsoid?: Ellipsoid, result?: Cartographic): Cartographic;

		/**
		 * Creates a new Cartesian3 instance from a Cartographic input. The values in the inputted
		 * object should be in radians.
		 * @param {Cartographic} cartographic Input to be converted into a Cartesian3 output.
		 * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the position lies.
		 * @param {Cartesian3} [result] The object onto which to store the result.
		 * @returns {Cartesian3} The position
		 */
		static toCartesian(cartographic: Cartographic, ellipsoid?: Ellipsoid, result?: Cartesian3): Cartesian3;

		/**
		 * Duplicates a Cartographic instance.
		 * @param {Cartographic} cartographic The cartographic to duplicate.
		 * @param {Cartographic} [result] The object onto which to store the result.
		 * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided. (Returns undefined if cartographic is undefined)
		 */
		static clone(cartographic: Cartographic, result?: Cartographic): Cartographic;

		/**
		 * Compares the provided cartographics componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Cartographic} [left] The first cartographic.
		 * @param {Cartographic} [right] The second cartographic.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		static equals(left?: Cartographic, right?: Cartographic): boolean;

		/**
		 * Compares the provided cartographics componentwise and returns
		 * <code>true</code> if they are within the provided epsilon,
		 * <code>false</code> otherwise.
		 * @param {Cartographic} [left] The first cartographic.
		 * @param {Cartographic} [right] The second cartographic.
		 * @param {Number} [epsilon] The epsilon to use for equality testing.
		 * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
		 */
		static equalsEpsilon(left?: Cartographic, right?: Cartographic, epsilon?: number): boolean;

		/**
		 * An immutable Cartographic instance initialized to (0.0, 0.0, 0.0).
		 * @type {Cartographic}
		 * @constant
		 */
		static ZERO: Cartographic;

		/**
		 * Duplicates this instance.
		 * @param {Cartographic} [result] The object onto which to store the result.
		 * @returns {Cartographic} The modified result parameter or a new Cartographic instance if one was not provided.
		 */
		clone(result?: Cartographic): Cartographic;

		/**
		 * Compares the provided against this cartographic componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Cartographic} [right] The second cartographic.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		equals(right?: Cartographic): boolean;

		/**
		 * Compares the provided against this cartographic componentwise and returns
		 * <code>true</code> if they are within the provided epsilon,
		 * <code>false</code> otherwise.
		 * @param {Cartographic} [right] The second cartographic.
		 * @param {Number} [epsilon] The epsilon to use for equality testing.
		 * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
		 */
		equalsEpsilon(right?: Cartographic, epsilon?: number): boolean;

		/**
		 * Creates a string representing this cartographic in the format '(longitude, latitude, height)'.
		 * @returns {String} A string representing the provided cartographic in the format '(longitude, latitude, height)'.
		 */
		toString(): string;

	}

	/**
	 * Geocodes queries containing longitude and latitude coordinates and an optional height.
	 * Query format: `longitude latitude (height)` with longitude/latitude in degrees and height in meters.
	 * @alias CartographicGeocoderService
	 * @constructor
	 */
	class CartographicGeocoderService {
		constructor();

		/**
		 * @function
		 * @param {String} query The query to be sent to the geocoder service
		 * @returns {Promise<GeocoderService~Result[]>}
		 */
		geocode(query: string): any;

	}

	/**
	 * A Catmull-Rom spline is a cubic spline where the tangent at control points,
	 * except the first and last, are computed using the previous and next control points.
	 * Catmull-Rom splines are in the class C<sup>1</sup>.
	 * @alias CatmullRomSpline
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.
	 *                The values are in no way connected to the clock time. They are the parameterization for the curve.
	 * @param {Cartesian3[]} options.points The array of {@link Cartesian3} control points.
	 * @param {Cartesian3} [options.firstTangent] The tangent of the curve at the first control point.
	 *                     If the tangent is not given, it will be estimated.
	 * @param {Cartesian3} [options.lastTangent] The tangent of the curve at the last control point.
	 *                     If the tangent is not given, it will be estimated.
	 * @exception {DeveloperError} points.length must be greater than or equal to 2.
	 * @exception {DeveloperError} times.length must be equal to points.length.
	 * @example
	 * // spline above the earth from Philadelphia to Los Angeles
	 * var spline = new Cesium.CatmullRomSpline({
	 *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],
	 *     points : [
	 *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),
	 *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),
	 *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),
	 *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),
	 *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)
	 *     ]
	 * });
	 * var p0 = spline.evaluate(times[i]);         // equal to positions[i]
	 * var p1 = spline.evaluate(times[i] + delta); // interpolated value when delta < times[i + 1] - times[i]
	 * @see HermiteSpline
	 * @see LinearSpline
	 * @see QuaternionSpline
	 * @see WeightSpline
	 */
	class CatmullRomSpline {
		constructor(options: {
			times: number[];
			points: (Cartesian3)[];
			firstTangent?: Cartesian3;
			lastTangent?: Cartesian3;
		});

		/**
		 * An array of times for the control points.
		 * @memberof CatmullRomSpline.prototype
		 * @type {Number[]}
		 * @readonly
		 */
		readonly times: number[];

		/**
		 * An array of {@link Cartesian3} control points.
		 * @memberof CatmullRomSpline.prototype
		 * @type {Cartesian3[]}
		 * @readonly
		 */
		readonly points: (Cartesian3)[];

		/**
		 * The tangent at the first control point.
		 * @memberof CatmullRomSpline.prototype
		 * @type {Cartesian3}
		 * @readonly
		 */
		readonly firstTangent: Cartesian3;

		/**
		 * The tangent at the last control point.
		 * @memberof CatmullRomSpline.prototype
		 * @type {Cartesian3}
		 * @readonly
		 */
		readonly lastTangent: Cartesian3;

		/**
		 * Finds an index <code>i</code> in <code>times</code> such that the parameter
		 * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.
		 * @function
		 * @param {Number} time The time.
		 * @returns {Number} The index for the element at the start of the interval.
		 * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>
		 *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element
		 *                             in the array <code>times</code>.
		 */
		findTimeInterval(time: number): number;

		/**
		 * Wraps the given time to the period covered by the spline.
		 * @function
		 * @param {Number} time The time.
		 * @return {Number} The time, wrapped around to the updated animation.
		 */
		wrapTime(time: number): number;

		/**
		 * Clamps the given time to the period covered by the spline.
		 * @function
		 * @param {Number} time The time.
		 * @return {Number} The time, clamped to the animation period.
		 */
		clampTime(time: number): number;

		/**
		 * Evaluates the curve at a given time.
		 * @param {Number} time The time at which to evaluate the curve.
		 * @param {Cartesian3} [result] The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter or a new instance of the point on the curve at the given time.
		 * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>
		 *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element
		 *                             in the array <code>times</code>.
		 */
		evaluate(time: number, result?: Cartesian3): Cartesian3;

	}

	/**
	 * A {@link TerrainProvider} that accesses terrain data in a Cesium terrain format.
	 * The supported formats are described on the {@link https://cesiumjs.org/data-and-assets/terrain/formats/|Terrain Formats page}.
	 * @alias CesiumTerrainProvider
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Resource|String|Promise<Resource>|Promise<String>} options.url The URL of the Cesium terrain server.
	 * @param {Boolean} [options.requestVertexNormals=false] Flag that indicates if the client should request additional lighting information from the server, in the form of per vertex normals if available.
	 * @param {Boolean} [options.requestWaterMask=false] Flag that indicates if the client should request per tile water masks from the server,  if available.
	 * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If not specified, the WGS84 ellipsoid is used.
	 * @param {Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.
	 * @example
	 * // Create Arctic DEM terrain with normals.
	 * var viewer = new Cesium.Viewer('cesiumContainer', {
	 *     terrainProvider : new Cesium.CesiumTerrainProvider({
	 *         url : Cesium.IonResource.fromAssetId(3956),
	 *         requestVertexNormals : true
	 *     })
	 * });
	 * @see createWorldTerrain
	 * @see TerrainProvider
	 */
	class CesiumTerrainProvider {
		constructor(options: {
			url: Resource | string | any | any;
			requestVertexNormals?: boolean;
			requestWaterMask?: boolean;
			ellipsoid?: Ellipsoid;
			credit?: Credit | string;
		});

		/**
		 * Requests the geometry for a given tile.  This function should not be called before
		 * {@link CesiumTerrainProvider#ready} returns true.  The result must include terrain data and
		 * may optionally include a water mask and an indication of which child tiles are available.
		 * @param {Number} x The X coordinate of the tile for which to request geometry.
		 * @param {Number} y The Y coordinate of the tile for which to request geometry.
		 * @param {Number} level The level of the tile for which to request geometry.
		 * @param {Request} [request] The request object. Intended for internal use only.
		 * @returns {Promise.<TerrainData>|undefined} A promise for the requested geometry.  If this method
		 *          returns undefined instead of a promise, it is an indication that too many requests are already
		 *          pending and the request will be retried later.
		 * @exception {DeveloperError} This function must not be called before {@link CesiumTerrainProvider#ready}
		 *            returns true.
		 */
		requestTileGeometry(x: number, y: number, level: number, request?: Request): any | undefined;

		/**
		 * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing
		 * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
		 * are passed an instance of {@link TileProviderError}.
		 * @memberof CesiumTerrainProvider.prototype
		 * @type {Event}
		 */
		errorEvent: Event;

		/**
		 * Gets the credit to display when this terrain provider is active.  Typically this is used to credit
		 * the source of the terrain.  This function should not be called before {@link CesiumTerrainProvider#ready} returns true.
		 * @memberof CesiumTerrainProvider.prototype
		 * @type {Credit}
		 */
		credit: Credit;

		/**
		 * Gets the tiling scheme used by this provider.  This function should
		 * not be called before {@link CesiumTerrainProvider#ready} returns true.
		 * @memberof CesiumTerrainProvider.prototype
		 * @type {GeographicTilingScheme}
		 */
		tilingScheme: GeographicTilingScheme;

		/**
		 * Gets a value indicating whether or not the provider is ready for use.
		 * @memberof CesiumTerrainProvider.prototype
		 * @type {Boolean}
		 */
		ready: boolean;

		/**
		 * Gets a promise that resolves to true when the provider is ready for use.
		 * @memberof CesiumTerrainProvider.prototype
		 * @type {Promise.<Boolean>}
		 * @readonly
		 */
		readonly readyPromise: any;

		/**
		 * Gets a value indicating whether or not the provider includes a water mask.  The water mask
		 * indicates which areas of the globe are water rather than land, so they can be rendered
		 * as a reflective surface with animated waves.  This function should not be
		 * called before {@link CesiumTerrainProvider#ready} returns true.
		 * @memberof CesiumTerrainProvider.prototype
		 * @type {Boolean}
		 * @exception {DeveloperError} This property must not be called before {@link CesiumTerrainProvider#ready}
		 */
		hasWaterMask: boolean;

		/**
		 * Gets a value indicating whether or not the requested tiles include vertex normals.
		 * This function should not be called before {@link CesiumTerrainProvider#ready} returns true.
		 * @memberof CesiumTerrainProvider.prototype
		 * @type {Boolean}
		 * @exception {DeveloperError} This property must not be called before {@link CesiumTerrainProvider#ready}
		 */
		hasVertexNormals: boolean;

		/**
		 * Boolean flag that indicates if the client should request vertex normals from the server.
		 * Vertex normals data is appended to the standard tile mesh data only if the client requests the vertex normals and
		 * if the server provides vertex normals.
		 * @memberof CesiumTerrainProvider.prototype
		 * @type {Boolean}
		 */
		requestVertexNormals: boolean;

		/**
		 * Boolean flag that indicates if the client should request a watermask from the server.
		 * Watermask data is appended to the standard tile mesh data only if the client requests the watermask and
		 * if the server provides a watermask.
		 * @memberof CesiumTerrainProvider.prototype
		 * @type {Boolean}
		 */
		requestWaterMask: boolean;

		/**
		 * Gets an object that can be used to determine availability of terrain from this provider, such as
		 * at points and in rectangles.  This function should not be called before
		 * {@link CesiumTerrainProvider#ready} returns true.  This property may be undefined if availability
		 * information is not available.
		 * @memberof CesiumTerrainProvider.prototype
		 * @type {TileAvailability}
		 */
		availability: TileAvailability;

		/**
		 * Gets the maximum geometric error allowed in a tile at a given level.
		 * @param {Number} level The tile level for which to get the maximum geometric error.
		 * @returns {Number} The maximum geometric error.
		 */
		getLevelMaximumGeometricError(level: number): number;

		/**
		 * Determines whether data for a tile is available to be loaded.
		 * @param {Number} x The X coordinate of the tile for which to request geometry.
		 * @param {Number} y The Y coordinate of the tile for which to request geometry.
		 * @param {Number} level The level of the tile for which to request geometry.
		 * @returns {Boolean} Undefined if not supported, otherwise true or false.
		 */
		getTileDataAvailable(x: number, y: number, level: number): boolean;

	}

	/**
	 * A description of a circle on the ellipsoid. Circle geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
	 * @alias CircleGeometry
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Cartesian3} options.center The circle's center point in the fixed frame.
	 * @param {Number} options.radius The radius in meters.
	 * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the circle will be on.
	 * @param {Number} [options.height=0.0] The distance in meters between the circle and the ellipsoid surface.
	 * @param {Number} [options.granularity=0.02] The angular distance between points on the circle in radians.
	 * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
	 * @param {Number} [options.extrudedHeight=0.0] The distance in meters between the circle's extruded face and the ellipsoid surface.
	 * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.
	 * @exception {DeveloperError} radius must be greater than zero.
	 * @exception {DeveloperError} granularity must be greater than zero.
	 * @see CircleGeometry.createGeometry
	 * @see Packable
	 * @example
	 * // Create a circle.
	 * var circle = new Cesium.CircleGeometry({
	 *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),
	 *   radius : 100000.0
	 * });
	 * var geometry = Cesium.CircleGeometry.createGeometry(circle);
	 */
	class CircleGeometry {
		constructor(options: {
			center: Cartesian3;
			radius: number;
			ellipsoid?: Ellipsoid;
			height?: number;
			granularity?: number;
			vertexFormat?: VertexFormat;
			extrudedHeight?: number;
			stRotation?: number;
		});

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {CircleGeometry} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: CircleGeometry, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {CircleGeometry} [result] The object into which to store the result.
		 * @returns {CircleGeometry} The modified result parameter or a new CircleGeometry instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: CircleGeometry): CircleGeometry;

		/**
		 * Computes the geometric representation of a circle on an ellipsoid, including its vertices, indices, and a bounding sphere.
		 * @param {CircleGeometry} circleGeometry A description of the circle.
		 * @returns {Geometry|undefined} The computed vertices and indices.
		 */
		static createGeometry(circleGeometry: CircleGeometry): Geometry | undefined;

	}

	/**
	 * A description of the outline of a circle on the ellipsoid.
	 * @alias CircleOutlineGeometry
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Cartesian3} options.center The circle's center point in the fixed frame.
	 * @param {Number} options.radius The radius in meters.
	 * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the circle will be on.
	 * @param {Number} [options.height=0.0] The distance in meters between the circle and the ellipsoid surface.
	 * @param {Number} [options.granularity=0.02] The angular distance between points on the circle in radians.
	 * @param {Number} [options.extrudedHeight=0.0] The distance in meters between the circle's extruded face and the ellipsoid surface.
	 * @param {Number} [options.numberOfVerticalLines=16] Number of lines to draw between the top and bottom of an extruded circle.
	 * @exception {DeveloperError} radius must be greater than zero.
	 * @exception {DeveloperError} granularity must be greater than zero.
	 * @see CircleOutlineGeometry.createGeometry
	 * @see Packable
	 * @example
	 * // Create a circle.
	 * var circle = new Cesium.CircleOutlineGeometry({
	 *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),
	 *   radius : 100000.0
	 * });
	 * var geometry = Cesium.CircleOutlineGeometry.createGeometry(circle);
	 */
	class CircleOutlineGeometry {
		constructor(options: {
			center: Cartesian3;
			radius: number;
			ellipsoid?: Ellipsoid;
			height?: number;
			granularity?: number;
			extrudedHeight?: number;
			numberOfVerticalLines?: number;
		});

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {CircleOutlineGeometry} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: CircleOutlineGeometry, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {CircleOutlineGeometry} [result] The object into which to store the result.
		 * @returns {CircleOutlineGeometry} The modified result parameter or a new CircleOutlineGeometry instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: CircleOutlineGeometry): CircleOutlineGeometry;

		/**
		 * Computes the geometric representation of an outline of a circle on an ellipsoid, including its vertices, indices, and a bounding sphere.
		 * @param {CircleOutlineGeometry} circleGeometry A description of the circle.
		 * @returns {Geometry|undefined} The computed vertices and indices.
		 */
		static createGeometry(circleGeometry: CircleOutlineGeometry): Geometry | undefined;

	}

	/**
	 * A simple clock for keeping track of simulated time.
	 * @alias Clock
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {JulianDate} [options.startTime] The start time of the clock.
	 * @param {JulianDate} [options.stopTime] The stop time of the clock.
	 * @param {JulianDate} [options.currentTime] The current time.
	 * @param {Number} [options.multiplier=1.0] Determines how much time advances when {@link Clock#tick} is called, negative values allow for advancing backwards.
	 * @param {ClockStep} [options.clockStep=ClockStep.SYSTEM_CLOCK_MULTIPLIER] Determines if calls to {@link Clock#tick} are frame dependent or system clock dependent.
	 * @param {ClockRange} [options.clockRange=ClockRange.UNBOUNDED] Determines how the clock should behave when {@link Clock#startTime} or {@link Clock#stopTime} is reached.
	 * @param {Boolean} [options.canAnimate=true] Indicates whether {@link Clock#tick} can advance time.  This could be false if data is being buffered, for example.  The clock will only tick when both {@link Clock#canAnimate} and {@link Clock#shouldAnimate} are true.
	 * @param {Boolean} [options.shouldAnimate=false] Indicates whether {@link Clock#tick} should attempt to advance time.  The clock will only tick when both {@link Clock#canAnimate} and {@link Clock#shouldAnimate} are true.
	 * @exception {DeveloperError} startTime must come before stopTime.
	 * @example
	 * // Create a clock that loops on Christmas day 2013 and runs in real-time.
	 * var clock = new Cesium.Clock({
	 *    startTime : Cesium.JulianDate.fromIso8601("2013-12-25"),
	 *    currentTime : Cesium.JulianDate.fromIso8601("2013-12-25"),
	 *    stopTime : Cesium.JulianDate.fromIso8601("2013-12-26"),
	 *    clockRange : Cesium.ClockRange.LOOP_STOP,
	 *    clockStep : Cesium.ClockStep.SYSTEM_CLOCK_MULTIPLIER
	 * });
	 * @see ClockStep
	 * @see ClockRange
	 * @see JulianDate
	 */
	class Clock {
		constructor(options?: {
			startTime?: JulianDate;
			stopTime?: JulianDate;
			currentTime?: JulianDate;
			multiplier?: number;
			clockStep?: any;
			clockRange?: any;
			canAnimate?: boolean;
			shouldAnimate?: boolean;
		});

		/**
		 * The start time of the clock.
		 * @type {JulianDate}
		 */
		startTime: JulianDate;

		/**
		 * The stop time of the clock.
		 * @type {JulianDate}
		 */
		stopTime: JulianDate;

		/**
		 * Determines how the clock should behave when
		 * {@link Clock#startTime} or {@link Clock#stopTime}
		 * is reached.
		 * @type {ClockRange}
		 * @default {@link ClockRange.UNBOUNDED}
		 */
		clockRange: any;

		/**
		 * Indicates whether {@link Clock#tick} can advance time.  This could be false if data is being buffered,
		 * for example.  The clock will only advance time when both
		 * {@link Clock#canAnimate} and {@link Clock#shouldAnimate} are true.
		 * @type {Boolean}
		 * @default true
		 */
		canAnimate: boolean;

		/**
		 * An {@link Event} that is fired whenever {@link Clock#tick} is called.
		 * @type {Event}
		 */
		onTick: Event;

		/**
		 * The current time.
		 * Changing this property will change
		 * {@link Clock#clockStep} from {@link ClockStep.SYSTEM_CLOCK} to
		 * {@link ClockStep.SYSTEM_CLOCK_MULTIPLIER}.
		 * @memberof Clock.prototype
		 * @type {JulianDate}
		 */
		currentTime: JulianDate;

		/**
		 * Gets or sets how much time advances when {@link Clock#tick} is called. Negative values allow for advancing backwards.
		 * If {@link Clock#clockStep} is set to {@link ClockStep.TICK_DEPENDENT}, this is the number of seconds to advance.
		 * If {@link Clock#clockStep} is set to {@link ClockStep.SYSTEM_CLOCK_MULTIPLIER}, this value is multiplied by the
		 * elapsed system time since the last call to {@link Clock#tick}.
		 * Changing this property will change
		 * {@link Clock#clockStep} from {@link ClockStep.SYSTEM_CLOCK} to
		 * {@link ClockStep.SYSTEM_CLOCK_MULTIPLIER}.
		 * @memberof Clock.prototype
		 * @type {Number}
		 * @default 1.0
		 */
		multiplier: number;

		/**
		 * Determines if calls to {@link Clock#tick} are frame dependent or system clock dependent.
		 * Changing this property to {@link ClockStep.SYSTEM_CLOCK} will set
		 * {@link Clock#multiplier} to 1.0, {@link Clock#shouldAnimate} to true, and
		 * {@link Clock#currentTime} to the current system clock time.
		 * @memberof Clock.prototype
		 * @type ClockStep
		 * @default {@link ClockStep.SYSTEM_CLOCK_MULTIPLIER}
		 */
		clockStep: any;

		/**
		 * Indicates whether {@link Clock#tick} should attempt to advance time.
		 * The clock will only advance time when both
		 * {@link Clock#canAnimate} and {@link Clock#shouldAnimate} are true.
		 * Changing this property will change
		 * {@link Clock#clockStep} from {@link ClockStep.SYSTEM_CLOCK} to
		 * {@link ClockStep.SYSTEM_CLOCK_MULTIPLIER}.
		 * @memberof Clock.prototype
		 * @type {Boolean}
		 * @default false
		 */
		shouldAnimate: boolean;

		/**
		 * Advances the clock from the current time based on the current configuration options.
		 * tick should be called every frame, regardless of whether animation is taking place
		 * or not.  To control animation, use the {@link Clock#shouldAnimate} property.
		 * @returns {JulianDate} The new value of the {@link Clock#currentTime} property.
		 */
		tick(): JulianDate;

	}

	/**
	 * Constants used by {@link Clock#tick} to determine behavior
	 * when {@link Clock#startTime} or {@link Clock#stopTime} is reached.
	 * @exports ClockRange
	 * @see Clock
	 * @see ClockStep
	 */
	namespace ClockRange {
		/**
		 * {@link Clock#tick} will always advances the clock in its current direction.
		 * @type {Number}
		 * @constant
		 */
		const UNBOUNDED: number;

		/**
		 * When {@link Clock#startTime} or {@link Clock#stopTime} is reached,
		 * {@link Clock#tick} will not advance {@link Clock#currentTime} any further.
		 * @type {Number}
		 * @constant
		 */
		const CLAMPED: number;

		/**
		 * When {@link Clock#stopTime} is reached, {@link Clock#tick} will advance
		 * {@link Clock#currentTime} to the opposite end of the interval.  When
		 * time is moving backwards, {@link Clock#tick} will not advance past
		 * {@link Clock#startTime}
		 * @type {Number}
		 * @constant
		 */
		const LOOP_STOP: number;

	}

	/**
	 * Constants to determine how much time advances with each call
	 * to {@link Clock#tick}.
	 * @exports ClockStep
	 * @see Clock
	 * @see ClockRange
	 */
	namespace ClockStep {
		/**
		 * {@link Clock#tick} advances the current time by a fixed step,
		 * which is the number of seconds specified by {@link Clock#multiplier}.
		 * @type {Number}
		 * @constant
		 */
		const TICK_DEPENDENT: number;

		/**
		 * {@link Clock#tick} advances the current time by the amount of system
		 * time elapsed since the previous call multiplied by {@link Clock#multiplier}.
		 * @type {Number}
		 * @constant
		 */
		const SYSTEM_CLOCK_MULTIPLIER: number;

		/**
		 * {@link Clock#tick} sets the clock to the current system time;
		 * ignoring all other settings.
		 * @type {Number}
		 * @constant
		 */
		const SYSTEM_CLOCK: number;

	}

	/**
	 * Clones an object, returning a new object containing the same properties.
	 * @exports clone
	 * @param {Object} object The object to clone.
	 * @param {Boolean} [deep=false] If true, all properties will be deep cloned recursively.
	 * @returns {Object} The cloned object.
	 */
	namespace clone {
	}

	/**
	 * A color, specified using red, green, blue, and alpha values,
	 * which range from <code>0</code> (no intensity) to <code>1.0</code> (full intensity).
	 * @param {Number} [red=1.0] The red component.
	 * @param {Number} [green=1.0] The green component.
	 * @param {Number} [blue=1.0] The blue component.
	 * @param {Number} [alpha=1.0] The alpha component.
	 * @constructor
	 * @alias Color
	 * @see Packable
	 */
	class Color {
		constructor(red?: number, green?: number, blue?: number, alpha?: number);

		/**
		 * The red component.
		 * @type {Number}
		 * @default 1.0
		 */
		red: number;

		/**
		 * The green component.
		 * @type {Number}
		 * @default 1.0
		 */
		green: number;

		/**
		 * The blue component.
		 * @type {Number}
		 * @default 1.0
		 */
		blue: number;

		/**
		 * The alpha component.
		 * @type {Number}
		 * @default 1.0
		 */
		alpha: number;

		/**
		 * Creates a Color instance from a {@link Cartesian4}. <code>x</code>, <code>y</code>, <code>z</code>,
		 * and <code>w</code> map to <code>red</code>, <code>green</code>, <code>blue</code>, and <code>alpha</code>, respectively.
		 * @param {Cartesian4} cartesian The source cartesian.
		 * @param {Color} [result] The object onto which to store the result.
		 * @returns {Color} The modified result parameter or a new Color instance if one was not provided.
		 */
		static fromCartesian4(cartesian: Cartesian4, result?: Color): Color;

		/**
		 * Creates a new Color specified using red, green, blue, and alpha values
		 * that are in the range of 0 to 255, converting them internally to a range of 0.0 to 1.0.
		 * @param {Number} [red=255] The red component.
		 * @param {Number} [green=255] The green component.
		 * @param {Number} [blue=255] The blue component.
		 * @param {Number} [alpha=255] The alpha component.
		 * @param {Color} [result] The object onto which to store the result.
		 * @returns {Color} The modified result parameter or a new Color instance if one was not provided.
		 */
		static fromBytes(red?: number, green?: number, blue?: number, alpha?: number, result?: Color): Color;

		/**
		 * Creates a new Color that has the same red, green, and blue components
		 * of the specified color, but with the specified alpha value.
		 * @param {Color} color The base color
		 * @param {Number} alpha The new alpha component.
		 * @param {Color} [result] The object onto which to store the result.
		 * @returns {Color} The modified result parameter or a new Color instance if one was not provided.
		 * @example var translucentRed = Cesium.Color.fromAlpha(Cesium.Color.RED, 0.9);
		 */
		static fromAlpha(color: Color, alpha: number, result?: Color): Color;

		/**
		 * Creates a new Color from a single numeric unsigned 32-bit RGBA value, using the endianness
		 * of the system.
		 * @param {Number} rgba A single numeric unsigned 32-bit RGBA value.
		 * @param {Color} [result] The object to store the result in, if undefined a new instance will be created.
		 * @returns {Color} The color object.
		 * @example
		 * var color = Cesium.Color.fromRgba(0x67ADDFFF);
		 * @see Color#toRgba
		 */
		static fromRgba(rgba: number, result?: Color): Color;

		/**
		 * Creates a Color instance from hue, saturation, and lightness.
		 * @param {Number} [hue=0] The hue angle 0...1
		 * @param {Number} [saturation=0] The saturation value 0...1
		 * @param {Number} [lightness=0] The lightness value 0...1
		 * @param {Number} [alpha=1.0] The alpha component 0...1
		 * @param {Color} [result] The object to store the result in, if undefined a new instance will be created.
		 * @returns {Color} The color object.
		 * @see {@link http://www.w3.org/TR/css3-color/#hsl-color|CSS color values}
		 */
		static fromHsl(hue?: number, saturation?: number, lightness?: number, alpha?: number, result?: Color): Color;

		/**
		 * Creates a random color using the provided options. For reproducible random colors, you should
		 * call {@link CesiumMath#setRandomNumberSeed} once at the beginning of your application.
		 * @param {Object} [options] Object with the following properties:
		 * @param {Number} [options.red] If specified, the red component to use instead of a randomized value.
		 * @param {Number} [options.minimumRed=0.0] The maximum red value to generate if none was specified.
		 * @param {Number} [options.maximumRed=1.0] The minimum red value to generate if none was specified.
		 * @param {Number} [options.green] If specified, the green component to use instead of a randomized value.
		 * @param {Number} [options.minimumGreen=0.0] The maximum green value to generate if none was specified.
		 * @param {Number} [options.maximumGreen=1.0] The minimum green value to generate if none was specified.
		 * @param {Number} [options.blue] If specified, the blue component to use instead of a randomized value.
		 * @param {Number} [options.minimumBlue=0.0] The maximum blue value to generate if none was specified.
		 * @param {Number} [options.maximumBlue=1.0] The minimum blue value to generate if none was specified.
		 * @param {Number} [options.alpha] If specified, the alpha component to use instead of a randomized value.
		 * @param {Number} [options.minimumAlpha=0.0] The maximum alpha value to generate if none was specified.
		 * @param {Number} [options.maximumAlpha=1.0] The minimum alpha value to generate if none was specified.
		 * @param {Color} [result] The object to store the result in, if undefined a new instance will be created.
		 * @returns {Color} The modified result parameter or a new instance if result was undefined.
		 * @exception {DeveloperError} minimumRed must be less than or equal to maximumRed.
		 * @exception {DeveloperError} minimumGreen must be less than or equal to maximumGreen.
		 * @exception {DeveloperError} minimumBlue must be less than or equal to maximumBlue.
		 * @exception {DeveloperError} minimumAlpha must be less than or equal to maximumAlpha.
		 * @example
		 * //Create a completely random color
		 * var color = Cesium.Color.fromRandom();
		 * //Create a random shade of yellow.
		 * var color = Cesium.Color.fromRandom({
		 *     red : 1.0,
		 *     green : 1.0,
		 *     alpha : 1.0
		 * });
		 * //Create a random bright color.
		 * var color = Cesium.Color.fromRandom({
		 *     minimumRed : 0.75,
		 *     minimumGreen : 0.75,
		 *     minimumBlue : 0.75,
		 *     alpha : 1.0
		 * });
		 */
		static fromRandom(options?: {
			red?: number;
			minimumRed?: number;
			maximumRed?: number;
			green?: number;
			minimumGreen?: number;
			maximumGreen?: number;
			blue?: number;
			minimumBlue?: number;
			maximumBlue?: number;
			alpha?: number;
			minimumAlpha?: number;
			maximumAlpha?: number;
		}, result?: Color): Color;

		/**
		 * Creates a Color instance from a CSS color value.
		 * @param {String} color The CSS color value in #rgb, #rrggbb, rgb(), rgba(), hsl(), or hsla() format.
		 * @param {Color} [result] The object to store the result in, if undefined a new instance will be created.
		 * @returns {Color} The color object, or undefined if the string was not a valid CSS color.
		 * @example
		 * var cesiumBlue = Cesium.Color.fromCssColorString('#67ADDF');
		 * var green = Cesium.Color.fromCssColorString('green');
		 * @see {@link http://www.w3.org/TR/css3-color|CSS color values}
		 */
		static fromCssColorString(color: string, result?: Color): Color;

		static fromCssString(color: string, result?: Color): Color;

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {Color} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: Color, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {Color} [result] The object into which to store the result.
		 * @returns {Color} The modified result parameter or a new Color instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: Color): Color;

		/**
		 * Converts a 'byte' color component in the range of 0 to 255 into
		 * a 'float' color component in the range of 0 to 1.0.
		 * @param {Number} number The number to be converted.
		 * @returns {Number} The converted number.
		 */
		static byteToFloat(number: number): number;

		/**
		 * Converts a 'float' color component in the range of 0 to 1.0 into
		 * a 'byte' color component in the range of 0 to 255.
		 * @param {Number} number The number to be converted.
		 * @returns {Number} The converted number.
		 */
		static floatToByte(number: number): number;

		/**
		 * Duplicates a Color.
		 * @param {Color} color The Color to duplicate.
		 * @param {Color} [result] The object to store the result in, if undefined a new instance will be created.
		 * @returns {Color} The modified result parameter or a new instance if result was undefined. (Returns undefined if color is undefined)
		 */
		static clone(color: Color, result?: Color): Color;

		/**
		 * Returns true if the first Color equals the second color.
		 * @param {Color} left The first Color to compare for equality.
		 * @param {Color} right The second Color to compare for equality.
		 * @returns {Boolean} <code>true</code> if the Colors are equal; otherwise, <code>false</code>.
		 */
		static equals(left: Color, right: Color): boolean;

		/**
		 * Returns a duplicate of a Color instance.
		 * @param {Color} [result] The object to store the result in, if undefined a new instance will be created.
		 * @returns {Color} The modified result parameter or a new instance if result was undefined.
		 */
		clone(result?: Color): Color;

		/**
		 * Returns true if this Color equals other.
		 * @param {Color} other The Color to compare for equality.
		 * @returns {Boolean} <code>true</code> if the Colors are equal; otherwise, <code>false</code>.
		 */
		equals(other: Color): boolean;

		/**
		 * Returns <code>true</code> if this Color equals other componentwise within the specified epsilon.
		 * @param {Color} other The Color to compare for equality.
		 * @param {Number} [epsilon=0.0] The epsilon to use for equality testing.
		 * @returns {Boolean} <code>true</code> if the Colors are equal within the specified epsilon; otherwise, <code>false</code>.
		 */
		equalsEpsilon(other: Color, epsilon?: number): boolean;

		/**
		 * Creates a string representing this Color in the format '(red, green, blue, alpha)'.
		 * @returns {String} A string representing this Color in the format '(red, green, blue, alpha)'.
		 */
		toString(): string;

		/**
		 * Creates a string containing the CSS color value for this color.
		 * @returns {String} The CSS equivalent of this color.
		 * @see {@link http://www.w3.org/TR/css3-color/#rgba-color|CSS RGB or RGBA color values}
		 */
		toCssColorString(): string;

		/**
		 * Converts this color to an array of red, green, blue, and alpha values
		 * that are in the range of 0 to 255.
		 * @param {Number[]} [result] The array to store the result in, if undefined a new instance will be created.
		 * @returns {Number[]} The modified result parameter or a new instance if result was undefined.
		 */
		toBytes(result?: number[]): number[];

		/**
		 * Converts this color to a single numeric unsigned 32-bit RGBA value, using the endianness
		 * of the system.
		 * @returns {Number} A single numeric unsigned 32-bit RGBA value.
		 * @example
		 * var rgba = Cesium.Color.BLUE.toRgba();
		 * @see Color.fromRgba
		 */
		toRgba(): number;

		/**
		 * Brightens this color by the provided magnitude.
		 * @param {Number} magnitude A positive number indicating the amount to brighten.
		 * @param {Color} result The object onto which to store the result.
		 * @returns {Color} The modified result parameter.
		 * @example
		 * var brightBlue = Cesium.Color.BLUE.brighten(0.5, new Cesium.Color());
		 */
		brighten(magnitude: number, result: Color): Color;

		/**
		 * Darkens this color by the provided magnitude.
		 * @param {Number} magnitude A positive number indicating the amount to darken.
		 * @param {Color} result The object onto which to store the result.
		 * @returns {Color} The modified result parameter.
		 * @example
		 * var darkBlue = Cesium.Color.BLUE.darken(0.5, new Cesium.Color());
		 */
		darken(magnitude: number, result: Color): Color;

		/**
		 * Creates a new Color that has the same red, green, and blue components
		 * as this Color, but with the specified alpha value.
		 * @param {Number} alpha The new alpha component.
		 * @param {Color} [result] The object onto which to store the result.
		 * @returns {Color} The modified result parameter or a new Color instance if one was not provided.
		 * @example var translucentRed = Cesium.Color.RED.withAlpha(0.9);
		 */
		withAlpha(alpha: number, result?: Color): Color;

		/**
		 * Computes the componentwise sum of two Colors.
		 * @param {Color} left The first Color.
		 * @param {Color} right The second Color.
		 * @param {Color} result The object onto which to store the result.
		 * @returns {Color} The modified result parameter.
		 */
		static add(left: Color, right: Color, result: Color): Color;

		/**
		 * Computes the componentwise difference of two Colors.
		 * @param {Color} left The first Color.
		 * @param {Color} right The second Color.
		 * @param {Color} result The object onto which to store the result.
		 * @returns {Color} The modified result parameter.
		 */
		static subtract(left: Color, right: Color, result: Color): Color;

		/**
		 * Computes the componentwise product of two Colors.
		 * @param {Color} left The first Color.
		 * @param {Color} right The second Color.
		 * @param {Color} result The object onto which to store the result.
		 * @returns {Color} The modified result parameter.
		 */
		static multiply(left: Color, right: Color, result: Color): Color;

		/**
		 * Computes the componentwise quotient of two Colors.
		 * @param {Color} left The first Color.
		 * @param {Color} right The second Color.
		 * @param {Color} result The object onto which to store the result.
		 * @returns {Color} The modified result parameter.
		 */
		static divide(left: Color, right: Color, result: Color): Color;

		/**
		 * Computes the componentwise modulus of two Colors.
		 * @param {Color} left The first Color.
		 * @param {Color} right The second Color.
		 * @param {Color} result The object onto which to store the result.
		 * @returns {Color} The modified result parameter.
		 */
		static mod(left: Color, right: Color, result: Color): Color;

		/**
		 * Multiplies the provided Color componentwise by the provided scalar.
		 * @param {Color} color The Color to be scaled.
		 * @param {Number} scalar The scalar to multiply with.
		 * @param {Color} result The object onto which to store the result.
		 * @returns {Color} The modified result parameter.
		 */
		static multiplyByScalar(color: Color, scalar: number, result: Color): Color;

		/**
		 * Divides the provided Color componentwise by the provided scalar.
		 * @param {Color} color The Color to be divided.
		 * @param {Number} scalar The scalar to divide with.
		 * @param {Color} result The object onto which to store the result.
		 * @returns {Color} The modified result parameter.
		 */
		static divideByScalar(color: Color, scalar: number, result: Color): Color;

		/**
		 * An immutable Color instance initialized to CSS color #F0F8FF
		 * <span class="colorSwath" style="background: #F0F8FF;"></span>
		 * @constant
		 * @type {Color}
		 */
		static ALICEBLUE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FAEBD7
		 * <span class="colorSwath" style="background: #FAEBD7;"></span>
		 * @constant
		 * @type {Color}
		 */
		static ANTIQUEWHITE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #00FFFF
		 * <span class="colorSwath" style="background: #00FFFF;"></span>
		 * @constant
		 * @type {Color}
		 */
		static AQUA: Color;

		/**
		 * An immutable Color instance initialized to CSS color #7FFFD4
		 * <span class="colorSwath" style="background: #7FFFD4;"></span>
		 * @constant
		 * @type {Color}
		 */
		static AQUAMARINE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #F0FFFF
		 * <span class="colorSwath" style="background: #F0FFFF;"></span>
		 * @constant
		 * @type {Color}
		 */
		static AZURE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #F5F5DC
		 * <span class="colorSwath" style="background: #F5F5DC;"></span>
		 * @constant
		 * @type {Color}
		 */
		static BEIGE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FFE4C4
		 * <span class="colorSwath" style="background: #FFE4C4;"></span>
		 * @constant
		 * @type {Color}
		 */
		static BISQUE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #000000
		 * <span class="colorSwath" style="background: #000000;"></span>
		 * @constant
		 * @type {Color}
		 */
		static BLACK: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FFEBCD
		 * <span class="colorSwath" style="background: #FFEBCD;"></span>
		 * @constant
		 * @type {Color}
		 */
		static BLANCHEDALMOND: Color;

		/**
		 * An immutable Color instance initialized to CSS color #0000FF
		 * <span class="colorSwath" style="background: #0000FF;"></span>
		 * @constant
		 * @type {Color}
		 */
		static BLUE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #8A2BE2
		 * <span class="colorSwath" style="background: #8A2BE2;"></span>
		 * @constant
		 * @type {Color}
		 */
		static BLUEVIOLET: Color;

		/**
		 * An immutable Color instance initialized to CSS color #A52A2A
		 * <span class="colorSwath" style="background: #A52A2A;"></span>
		 * @constant
		 * @type {Color}
		 */
		static BROWN: Color;

		/**
		 * An immutable Color instance initialized to CSS color #DEB887
		 * <span class="colorSwath" style="background: #DEB887;"></span>
		 * @constant
		 * @type {Color}
		 */
		static BURLYWOOD: Color;

		/**
		 * An immutable Color instance initialized to CSS color #5F9EA0
		 * <span class="colorSwath" style="background: #5F9EA0;"></span>
		 * @constant
		 * @type {Color}
		 */
		static CADETBLUE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #7FFF00
		 * <span class="colorSwath" style="background: #7FFF00;"></span>
		 * @constant
		 * @type {Color}
		 */
		static CHARTREUSE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #D2691E
		 * <span class="colorSwath" style="background: #D2691E;"></span>
		 * @constant
		 * @type {Color}
		 */
		static CHOCOLATE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FF7F50
		 * <span class="colorSwath" style="background: #FF7F50;"></span>
		 * @constant
		 * @type {Color}
		 */
		static CORAL: Color;

		/**
		 * An immutable Color instance initialized to CSS color #6495ED
		 * <span class="colorSwath" style="background: #6495ED;"></span>
		 * @constant
		 * @type {Color}
		 */
		static CORNFLOWERBLUE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FFF8DC
		 * <span class="colorSwath" style="background: #FFF8DC;"></span>
		 * @constant
		 * @type {Color}
		 */
		static CORNSILK: Color;

		/**
		 * An immutable Color instance initialized to CSS color #DC143C
		 * <span class="colorSwath" style="background: #DC143C;"></span>
		 * @constant
		 * @type {Color}
		 */
		static CRIMSON: Color;

		/**
		 * An immutable Color instance initialized to CSS color #00FFFF
		 * <span class="colorSwath" style="background: #00FFFF;"></span>
		 * @constant
		 * @type {Color}
		 */
		static CYAN: Color;

		/**
		 * An immutable Color instance initialized to CSS color #00008B
		 * <span class="colorSwath" style="background: #00008B;"></span>
		 * @constant
		 * @type {Color}
		 */
		static DARKBLUE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #008B8B
		 * <span class="colorSwath" style="background: #008B8B;"></span>
		 * @constant
		 * @type {Color}
		 */
		static DARKCYAN: Color;

		/**
		 * An immutable Color instance initialized to CSS color #B8860B
		 * <span class="colorSwath" style="background: #B8860B;"></span>
		 * @constant
		 * @type {Color}
		 */
		static DARKGOLDENROD: Color;

		/**
		 * An immutable Color instance initialized to CSS color #A9A9A9
		 * <span class="colorSwath" style="background: #A9A9A9;"></span>
		 * @constant
		 * @type {Color}
		 */
		static DARKGRAY: Color;

		/**
		 * An immutable Color instance initialized to CSS color #006400
		 * <span class="colorSwath" style="background: #006400;"></span>
		 * @constant
		 * @type {Color}
		 */
		static DARKGREEN: Color;

		/**
		 * An immutable Color instance initialized to CSS color #A9A9A9
		 * <span class="colorSwath" style="background: #A9A9A9;"></span>
		 * @constant
		 * @type {Color}
		 */
		static DARKGREY: Color;

		/**
		 * An immutable Color instance initialized to CSS color #BDB76B
		 * <span class="colorSwath" style="background: #BDB76B;"></span>
		 * @constant
		 * @type {Color}
		 */
		static DARKKHAKI: Color;

		/**
		 * An immutable Color instance initialized to CSS color #8B008B
		 * <span class="colorSwath" style="background: #8B008B;"></span>
		 * @constant
		 * @type {Color}
		 */
		static DARKMAGENTA: Color;

		/**
		 * An immutable Color instance initialized to CSS color #556B2F
		 * <span class="colorSwath" style="background: #556B2F;"></span>
		 * @constant
		 * @type {Color}
		 */
		static DARKOLIVEGREEN: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FF8C00
		 * <span class="colorSwath" style="background: #FF8C00;"></span>
		 * @constant
		 * @type {Color}
		 */
		static DARKORANGE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #9932CC
		 * <span class="colorSwath" style="background: #9932CC;"></span>
		 * @constant
		 * @type {Color}
		 */
		static DARKORCHID: Color;

		/**
		 * An immutable Color instance initialized to CSS color #8B0000
		 * <span class="colorSwath" style="background: #8B0000;"></span>
		 * @constant
		 * @type {Color}
		 */
		static DARKRED: Color;

		/**
		 * An immutable Color instance initialized to CSS color #E9967A
		 * <span class="colorSwath" style="background: #E9967A;"></span>
		 * @constant
		 * @type {Color}
		 */
		static DARKSALMON: Color;

		/**
		 * An immutable Color instance initialized to CSS color #8FBC8F
		 * <span class="colorSwath" style="background: #8FBC8F;"></span>
		 * @constant
		 * @type {Color}
		 */
		static DARKSEAGREEN: Color;

		/**
		 * An immutable Color instance initialized to CSS color #483D8B
		 * <span class="colorSwath" style="background: #483D8B;"></span>
		 * @constant
		 * @type {Color}
		 */
		static DARKSLATEBLUE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #2F4F4F
		 * <span class="colorSwath" style="background: #2F4F4F;"></span>
		 * @constant
		 * @type {Color}
		 */
		static DARKSLATEGRAY: Color;

		/**
		 * An immutable Color instance initialized to CSS color #2F4F4F
		 * <span class="colorSwath" style="background: #2F4F4F;"></span>
		 * @constant
		 * @type {Color}
		 */
		static DARKSLATEGREY: Color;

		/**
		 * An immutable Color instance initialized to CSS color #00CED1
		 * <span class="colorSwath" style="background: #00CED1;"></span>
		 * @constant
		 * @type {Color}
		 */
		static DARKTURQUOISE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #9400D3
		 * <span class="colorSwath" style="background: #9400D3;"></span>
		 * @constant
		 * @type {Color}
		 */
		static DARKVIOLET: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FF1493
		 * <span class="colorSwath" style="background: #FF1493;"></span>
		 * @constant
		 * @type {Color}
		 */
		static DEEPPINK: Color;

		/**
		 * An immutable Color instance initialized to CSS color #00BFFF
		 * <span class="colorSwath" style="background: #00BFFF;"></span>
		 * @constant
		 * @type {Color}
		 */
		static DEEPSKYBLUE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #696969
		 * <span class="colorSwath" style="background: #696969;"></span>
		 * @constant
		 * @type {Color}
		 */
		static DIMGRAY: Color;

		/**
		 * An immutable Color instance initialized to CSS color #696969
		 * <span class="colorSwath" style="background: #696969;"></span>
		 * @constant
		 * @type {Color}
		 */
		static DIMGREY: Color;

		/**
		 * An immutable Color instance initialized to CSS color #1E90FF
		 * <span class="colorSwath" style="background: #1E90FF;"></span>
		 * @constant
		 * @type {Color}
		 */
		static DODGERBLUE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #B22222
		 * <span class="colorSwath" style="background: #B22222;"></span>
		 * @constant
		 * @type {Color}
		 */
		static FIREBRICK: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FFFAF0
		 * <span class="colorSwath" style="background: #FFFAF0;"></span>
		 * @constant
		 * @type {Color}
		 */
		static FLORALWHITE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #228B22
		 * <span class="colorSwath" style="background: #228B22;"></span>
		 * @constant
		 * @type {Color}
		 */
		static FORESTGREEN: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FF00FF
		 * <span class="colorSwath" style="background: #FF00FF;"></span>
		 * @constant
		 * @type {Color}
		 */
		static FUCHSIA: Color;

		/**
		 * An immutable Color instance initialized to CSS color #DCDCDC
		 * <span class="colorSwath" style="background: #DCDCDC;"></span>
		 * @constant
		 * @type {Color}
		 */
		static GAINSBORO: Color;

		/**
		 * An immutable Color instance initialized to CSS color #F8F8FF
		 * <span class="colorSwath" style="background: #F8F8FF;"></span>
		 * @constant
		 * @type {Color}
		 */
		static GHOSTWHITE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FFD700
		 * <span class="colorSwath" style="background: #FFD700;"></span>
		 * @constant
		 * @type {Color}
		 */
		static GOLD: Color;

		/**
		 * An immutable Color instance initialized to CSS color #DAA520
		 * <span class="colorSwath" style="background: #DAA520;"></span>
		 * @constant
		 * @type {Color}
		 */
		static GOLDENROD: Color;

		/**
		 * An immutable Color instance initialized to CSS color #808080
		 * <span class="colorSwath" style="background: #808080;"></span>
		 * @constant
		 * @type {Color}
		 */
		static GRAY: Color;

		/**
		 * An immutable Color instance initialized to CSS color #008000
		 * <span class="colorSwath" style="background: #008000;"></span>
		 * @constant
		 * @type {Color}
		 */
		static GREEN: Color;

		/**
		 * An immutable Color instance initialized to CSS color #ADFF2F
		 * <span class="colorSwath" style="background: #ADFF2F;"></span>
		 * @constant
		 * @type {Color}
		 */
		static GREENYELLOW: Color;

		/**
		 * An immutable Color instance initialized to CSS color #808080
		 * <span class="colorSwath" style="background: #808080;"></span>
		 * @constant
		 * @type {Color}
		 */
		static GREY: Color;

		/**
		 * An immutable Color instance initialized to CSS color #F0FFF0
		 * <span class="colorSwath" style="background: #F0FFF0;"></span>
		 * @constant
		 * @type {Color}
		 */
		static HONEYDEW: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FF69B4
		 * <span class="colorSwath" style="background: #FF69B4;"></span>
		 * @constant
		 * @type {Color}
		 */
		static HOTPINK: Color;

		/**
		 * An immutable Color instance initialized to CSS color #CD5C5C
		 * <span class="colorSwath" style="background: #CD5C5C;"></span>
		 * @constant
		 * @type {Color}
		 */
		static INDIANRED: Color;

		/**
		 * An immutable Color instance initialized to CSS color #4B0082
		 * <span class="colorSwath" style="background: #4B0082;"></span>
		 * @constant
		 * @type {Color}
		 */
		static INDIGO: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FFFFF0
		 * <span class="colorSwath" style="background: #FFFFF0;"></span>
		 * @constant
		 * @type {Color}
		 */
		static IVORY: Color;

		/**
		 * An immutable Color instance initialized to CSS color #F0E68C
		 * <span class="colorSwath" style="background: #F0E68C;"></span>
		 * @constant
		 * @type {Color}
		 */
		static KHAKI: Color;

		/**
		 * An immutable Color instance initialized to CSS color #E6E6FA
		 * <span class="colorSwath" style="background: #E6E6FA;"></span>
		 * @constant
		 * @type {Color}
		 */
		static LAVENDER: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FFF0F5
		 * <span class="colorSwath" style="background: #FFF0F5;"></span>
		 * @constant
		 * @type {Color}
		 */
		static LAVENDAR_BLUSH: Color;

		/**
		 * An immutable Color instance initialized to CSS color #7CFC00
		 * <span class="colorSwath" style="background: #7CFC00;"></span>
		 * @constant
		 * @type {Color}
		 */
		static LAWNGREEN: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FFFACD
		 * <span class="colorSwath" style="background: #FFFACD;"></span>
		 * @constant
		 * @type {Color}
		 */
		static LEMONCHIFFON: Color;

		/**
		 * An immutable Color instance initialized to CSS color #ADD8E6
		 * <span class="colorSwath" style="background: #ADD8E6;"></span>
		 * @constant
		 * @type {Color}
		 */
		static LIGHTBLUE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #F08080
		 * <span class="colorSwath" style="background: #F08080;"></span>
		 * @constant
		 * @type {Color}
		 */
		static LIGHTCORAL: Color;

		/**
		 * An immutable Color instance initialized to CSS color #E0FFFF
		 * <span class="colorSwath" style="background: #E0FFFF;"></span>
		 * @constant
		 * @type {Color}
		 */
		static LIGHTCYAN: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FAFAD2
		 * <span class="colorSwath" style="background: #FAFAD2;"></span>
		 * @constant
		 * @type {Color}
		 */
		static LIGHTGOLDENRODYELLOW: Color;

		/**
		 * An immutable Color instance initialized to CSS color #D3D3D3
		 * <span class="colorSwath" style="background: #D3D3D3;"></span>
		 * @constant
		 * @type {Color}
		 */
		static LIGHTGRAY: Color;

		/**
		 * An immutable Color instance initialized to CSS color #90EE90
		 * <span class="colorSwath" style="background: #90EE90;"></span>
		 * @constant
		 * @type {Color}
		 */
		static LIGHTGREEN: Color;

		/**
		 * An immutable Color instance initialized to CSS color #D3D3D3
		 * <span class="colorSwath" style="background: #D3D3D3;"></span>
		 * @constant
		 * @type {Color}
		 */
		static LIGHTGREY: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FFB6C1
		 * <span class="colorSwath" style="background: #FFB6C1;"></span>
		 * @constant
		 * @type {Color}
		 */
		static LIGHTPINK: Color;

		/**
		 * An immutable Color instance initialized to CSS color #20B2AA
		 * <span class="colorSwath" style="background: #20B2AA;"></span>
		 * @constant
		 * @type {Color}
		 */
		static LIGHTSEAGREEN: Color;

		/**
		 * An immutable Color instance initialized to CSS color #87CEFA
		 * <span class="colorSwath" style="background: #87CEFA;"></span>
		 * @constant
		 * @type {Color}
		 */
		static LIGHTSKYBLUE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #778899
		 * <span class="colorSwath" style="background: #778899;"></span>
		 * @constant
		 * @type {Color}
		 */
		static LIGHTSLATEGRAY: Color;

		/**
		 * An immutable Color instance initialized to CSS color #778899
		 * <span class="colorSwath" style="background: #778899;"></span>
		 * @constant
		 * @type {Color}
		 */
		static LIGHTSLATEGREY: Color;

		/**
		 * An immutable Color instance initialized to CSS color #B0C4DE
		 * <span class="colorSwath" style="background: #B0C4DE;"></span>
		 * @constant
		 * @type {Color}
		 */
		static LIGHTSTEELBLUE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FFFFE0
		 * <span class="colorSwath" style="background: #FFFFE0;"></span>
		 * @constant
		 * @type {Color}
		 */
		static LIGHTYELLOW: Color;

		/**
		 * An immutable Color instance initialized to CSS color #00FF00
		 * <span class="colorSwath" style="background: #00FF00;"></span>
		 * @constant
		 * @type {Color}
		 */
		static LIME: Color;

		/**
		 * An immutable Color instance initialized to CSS color #32CD32
		 * <span class="colorSwath" style="background: #32CD32;"></span>
		 * @constant
		 * @type {Color}
		 */
		static LIMEGREEN: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FAF0E6
		 * <span class="colorSwath" style="background: #FAF0E6;"></span>
		 * @constant
		 * @type {Color}
		 */
		static LINEN: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FF00FF
		 * <span class="colorSwath" style="background: #FF00FF;"></span>
		 * @constant
		 * @type {Color}
		 */
		static MAGENTA: Color;

		/**
		 * An immutable Color instance initialized to CSS color #800000
		 * <span class="colorSwath" style="background: #800000;"></span>
		 * @constant
		 * @type {Color}
		 */
		static MAROON: Color;

		/**
		 * An immutable Color instance initialized to CSS color #66CDAA
		 * <span class="colorSwath" style="background: #66CDAA;"></span>
		 * @constant
		 * @type {Color}
		 */
		static MEDIUMAQUAMARINE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #0000CD
		 * <span class="colorSwath" style="background: #0000CD;"></span>
		 * @constant
		 * @type {Color}
		 */
		static MEDIUMBLUE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #BA55D3
		 * <span class="colorSwath" style="background: #BA55D3;"></span>
		 * @constant
		 * @type {Color}
		 */
		static MEDIUMORCHID: Color;

		/**
		 * An immutable Color instance initialized to CSS color #9370DB
		 * <span class="colorSwath" style="background: #9370DB;"></span>
		 * @constant
		 * @type {Color}
		 */
		static MEDIUMPURPLE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #3CB371
		 * <span class="colorSwath" style="background: #3CB371;"></span>
		 * @constant
		 * @type {Color}
		 */
		static MEDIUMSEAGREEN: Color;

		/**
		 * An immutable Color instance initialized to CSS color #7B68EE
		 * <span class="colorSwath" style="background: #7B68EE;"></span>
		 * @constant
		 * @type {Color}
		 */
		static MEDIUMSLATEBLUE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #00FA9A
		 * <span class="colorSwath" style="background: #00FA9A;"></span>
		 * @constant
		 * @type {Color}
		 */
		static MEDIUMSPRINGGREEN: Color;

		/**
		 * An immutable Color instance initialized to CSS color #48D1CC
		 * <span class="colorSwath" style="background: #48D1CC;"></span>
		 * @constant
		 * @type {Color}
		 */
		static MEDIUMTURQUOISE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #C71585
		 * <span class="colorSwath" style="background: #C71585;"></span>
		 * @constant
		 * @type {Color}
		 */
		static MEDIUMVIOLETRED: Color;

		/**
		 * An immutable Color instance initialized to CSS color #191970
		 * <span class="colorSwath" style="background: #191970;"></span>
		 * @constant
		 * @type {Color}
		 */
		static MIDNIGHTBLUE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #F5FFFA
		 * <span class="colorSwath" style="background: #F5FFFA;"></span>
		 * @constant
		 * @type {Color}
		 */
		static MINTCREAM: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FFE4E1
		 * <span class="colorSwath" style="background: #FFE4E1;"></span>
		 * @constant
		 * @type {Color}
		 */
		static MISTYROSE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FFE4B5
		 * <span class="colorSwath" style="background: #FFE4B5;"></span>
		 * @constant
		 * @type {Color}
		 */
		static MOCCASIN: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FFDEAD
		 * <span class="colorSwath" style="background: #FFDEAD;"></span>
		 * @constant
		 * @type {Color}
		 */
		static NAVAJOWHITE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #000080
		 * <span class="colorSwath" style="background: #000080;"></span>
		 * @constant
		 * @type {Color}
		 */
		static NAVY: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FDF5E6
		 * <span class="colorSwath" style="background: #FDF5E6;"></span>
		 * @constant
		 * @type {Color}
		 */
		static OLDLACE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #808000
		 * <span class="colorSwath" style="background: #808000;"></span>
		 * @constant
		 * @type {Color}
		 */
		static OLIVE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #6B8E23
		 * <span class="colorSwath" style="background: #6B8E23;"></span>
		 * @constant
		 * @type {Color}
		 */
		static OLIVEDRAB: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FFA500
		 * <span class="colorSwath" style="background: #FFA500;"></span>
		 * @constant
		 * @type {Color}
		 */
		static ORANGE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FF4500
		 * <span class="colorSwath" style="background: #FF4500;"></span>
		 * @constant
		 * @type {Color}
		 */
		static ORANGERED: Color;

		/**
		 * An immutable Color instance initialized to CSS color #DA70D6
		 * <span class="colorSwath" style="background: #DA70D6;"></span>
		 * @constant
		 * @type {Color}
		 */
		static ORCHID: Color;

		/**
		 * An immutable Color instance initialized to CSS color #EEE8AA
		 * <span class="colorSwath" style="background: #EEE8AA;"></span>
		 * @constant
		 * @type {Color}
		 */
		static PALEGOLDENROD: Color;

		/**
		 * An immutable Color instance initialized to CSS color #98FB98
		 * <span class="colorSwath" style="background: #98FB98;"></span>
		 * @constant
		 * @type {Color}
		 */
		static PALEGREEN: Color;

		/**
		 * An immutable Color instance initialized to CSS color #AFEEEE
		 * <span class="colorSwath" style="background: #AFEEEE;"></span>
		 * @constant
		 * @type {Color}
		 */
		static PALETURQUOISE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #DB7093
		 * <span class="colorSwath" style="background: #DB7093;"></span>
		 * @constant
		 * @type {Color}
		 */
		static PALEVIOLETRED: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FFEFD5
		 * <span class="colorSwath" style="background: #FFEFD5;"></span>
		 * @constant
		 * @type {Color}
		 */
		static PAPAYAWHIP: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FFDAB9
		 * <span class="colorSwath" style="background: #FFDAB9;"></span>
		 * @constant
		 * @type {Color}
		 */
		static PEACHPUFF: Color;

		/**
		 * An immutable Color instance initialized to CSS color #CD853F
		 * <span class="colorSwath" style="background: #CD853F;"></span>
		 * @constant
		 * @type {Color}
		 */
		static PERU: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FFC0CB
		 * <span class="colorSwath" style="background: #FFC0CB;"></span>
		 * @constant
		 * @type {Color}
		 */
		static PINK: Color;

		/**
		 * An immutable Color instance initialized to CSS color #DDA0DD
		 * <span class="colorSwath" style="background: #DDA0DD;"></span>
		 * @constant
		 * @type {Color}
		 */
		static PLUM: Color;

		/**
		 * An immutable Color instance initialized to CSS color #B0E0E6
		 * <span class="colorSwath" style="background: #B0E0E6;"></span>
		 * @constant
		 * @type {Color}
		 */
		static POWDERBLUE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #800080
		 * <span class="colorSwath" style="background: #800080;"></span>
		 * @constant
		 * @type {Color}
		 */
		static PURPLE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FF0000
		 * <span class="colorSwath" style="background: #FF0000;"></span>
		 * @constant
		 * @type {Color}
		 */
		static RED: Color;

		/**
		 * An immutable Color instance initialized to CSS color #BC8F8F
		 * <span class="colorSwath" style="background: #BC8F8F;"></span>
		 * @constant
		 * @type {Color}
		 */
		static ROSYBROWN: Color;

		/**
		 * An immutable Color instance initialized to CSS color #4169E1
		 * <span class="colorSwath" style="background: #4169E1;"></span>
		 * @constant
		 * @type {Color}
		 */
		static ROYALBLUE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #8B4513
		 * <span class="colorSwath" style="background: #8B4513;"></span>
		 * @constant
		 * @type {Color}
		 */
		static SADDLEBROWN: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FA8072
		 * <span class="colorSwath" style="background: #FA8072;"></span>
		 * @constant
		 * @type {Color}
		 */
		static SALMON: Color;

		/**
		 * An immutable Color instance initialized to CSS color #F4A460
		 * <span class="colorSwath" style="background: #F4A460;"></span>
		 * @constant
		 * @type {Color}
		 */
		static SANDYBROWN: Color;

		/**
		 * An immutable Color instance initialized to CSS color #2E8B57
		 * <span class="colorSwath" style="background: #2E8B57;"></span>
		 * @constant
		 * @type {Color}
		 */
		static SEAGREEN: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FFF5EE
		 * <span class="colorSwath" style="background: #FFF5EE;"></span>
		 * @constant
		 * @type {Color}
		 */
		static SEASHELL: Color;

		/**
		 * An immutable Color instance initialized to CSS color #A0522D
		 * <span class="colorSwath" style="background: #A0522D;"></span>
		 * @constant
		 * @type {Color}
		 */
		static SIENNA: Color;

		/**
		 * An immutable Color instance initialized to CSS color #C0C0C0
		 * <span class="colorSwath" style="background: #C0C0C0;"></span>
		 * @constant
		 * @type {Color}
		 */
		static SILVER: Color;

		/**
		 * An immutable Color instance initialized to CSS color #87CEEB
		 * <span class="colorSwath" style="background: #87CEEB;"></span>
		 * @constant
		 * @type {Color}
		 */
		static SKYBLUE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #6A5ACD
		 * <span class="colorSwath" style="background: #6A5ACD;"></span>
		 * @constant
		 * @type {Color}
		 */
		static SLATEBLUE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #708090
		 * <span class="colorSwath" style="background: #708090;"></span>
		 * @constant
		 * @type {Color}
		 */
		static SLATEGRAY: Color;

		/**
		 * An immutable Color instance initialized to CSS color #708090
		 * <span class="colorSwath" style="background: #708090;"></span>
		 * @constant
		 * @type {Color}
		 */
		static SLATEGREY: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FFFAFA
		 * <span class="colorSwath" style="background: #FFFAFA;"></span>
		 * @constant
		 * @type {Color}
		 */
		static SNOW: Color;

		/**
		 * An immutable Color instance initialized to CSS color #00FF7F
		 * <span class="colorSwath" style="background: #00FF7F;"></span>
		 * @constant
		 * @type {Color}
		 */
		static SPRINGGREEN: Color;

		/**
		 * An immutable Color instance initialized to CSS color #4682B4
		 * <span class="colorSwath" style="background: #4682B4;"></span>
		 * @constant
		 * @type {Color}
		 */
		static STEELBLUE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #D2B48C
		 * <span class="colorSwath" style="background: #D2B48C;"></span>
		 * @constant
		 * @type {Color}
		 */
		static TAN: Color;

		/**
		 * An immutable Color instance initialized to CSS color #008080
		 * <span class="colorSwath" style="background: #008080;"></span>
		 * @constant
		 * @type {Color}
		 */
		static TEAL: Color;

		/**
		 * An immutable Color instance initialized to CSS color #D8BFD8
		 * <span class="colorSwath" style="background: #D8BFD8;"></span>
		 * @constant
		 * @type {Color}
		 */
		static THISTLE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FF6347
		 * <span class="colorSwath" style="background: #FF6347;"></span>
		 * @constant
		 * @type {Color}
		 */
		static TOMATO: Color;

		/**
		 * An immutable Color instance initialized to CSS color #40E0D0
		 * <span class="colorSwath" style="background: #40E0D0;"></span>
		 * @constant
		 * @type {Color}
		 */
		static TURQUOISE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #EE82EE
		 * <span class="colorSwath" style="background: #EE82EE;"></span>
		 * @constant
		 * @type {Color}
		 */
		static VIOLET: Color;

		/**
		 * An immutable Color instance initialized to CSS color #F5DEB3
		 * <span class="colorSwath" style="background: #F5DEB3;"></span>
		 * @constant
		 * @type {Color}
		 */
		static WHEAT: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FFFFFF
		 * <span class="colorSwath" style="background: #FFFFFF;"></span>
		 * @constant
		 * @type {Color}
		 */
		static WHITE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #F5F5F5
		 * <span class="colorSwath" style="background: #F5F5F5;"></span>
		 * @constant
		 * @type {Color}
		 */
		static WHITESMOKE: Color;

		/**
		 * An immutable Color instance initialized to CSS color #FFFF00
		 * <span class="colorSwath" style="background: #FFFF00;"></span>
		 * @constant
		 * @type {Color}
		 */
		static YELLOW: Color;

		/**
		 * An immutable Color instance initialized to CSS color #9ACD32
		 * <span class="colorSwath" style="background: #9ACD32;"></span>
		 * @constant
		 * @type {Color}
		 */
		static YELLOWGREEN: Color;

		/**
		 * An immutable Color instance initialized to CSS transparent.
		 * <span class="colorSwath" style="background: transparent;"></span>
		 * @constant
		 * @type {Color}
		 */
		static TRANSPARENT: Color;

	}

	/**
	 * Value and type information for per-instance geometry color.
	 * @alias ColorGeometryInstanceAttribute
	 * @constructor
	 * @param {Number} [red=1.0] The red component.
	 * @param {Number} [green=1.0] The green component.
	 * @param {Number} [blue=1.0] The blue component.
	 * @param {Number} [alpha=1.0] The alpha component.
	 * @example
	 * var instance = new Cesium.GeometryInstance({
	 *   geometry : Cesium.BoxGeometry.fromDimensions({
	 *     dimensions : new Cesium.Cartesian3(1000000.0, 1000000.0, 500000.0)
	 *   }),
	 *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(
	 *     Cesium.Cartesian3.fromDegrees(0.0, 0.0)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),
	 *   id : 'box',
	 *   attributes : {
	 *     color : new Cesium.ColorGeometryInstanceAttribute(red, green, blue, alpha)
	 *   }
	 * });
	 * @see GeometryInstance
	 * @see GeometryInstanceAttribute
	 */
	class ColorGeometryInstanceAttribute {
		constructor(red?: number, green?: number, blue?: number, alpha?: number);

		/**
		 * The values for the attributes stored in a typed array.
		 * @type Uint8Array
		 * @default [255, 255, 255, 255]
		 */
		value: Uint8Array;

		/**
		 * The datatype of each component in the attribute, e.g., individual elements in
		 * {@link ColorGeometryInstanceAttribute#value}.
		 * @memberof ColorGeometryInstanceAttribute.prototype
		 * @type {ComponentDatatype}
		 * @readonly
		 * @default {@link ComponentDatatype.UNSIGNED_BYTE}
		 */
		readonly componentDatatype: any;

		/**
		 * The number of components in the attributes, i.e., {@link ColorGeometryInstanceAttribute#value}.
		 * @memberof ColorGeometryInstanceAttribute.prototype
		 * @type {Number}
		 * @readonly
		 * @default 4
		 */
		readonly componentsPerAttribute: number;

		/**
		 * When <code>true</code> and <code>componentDatatype</code> is an integer format,
		 * indicate that the components should be mapped to the range [0, 1] (unsigned)
		 * or [-1, 1] (signed) when they are accessed as floating-point for rendering.
		 * @memberof ColorGeometryInstanceAttribute.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		readonly normalize: boolean;

		/**
		 * Creates a new {@link ColorGeometryInstanceAttribute} instance given the provided {@link Color}.
		 * @param {Color} color The color.
		 * @returns {ColorGeometryInstanceAttribute} The new {@link ColorGeometryInstanceAttribute} instance.
		 * @example
		 * var instance = new Cesium.GeometryInstance({
		 *   geometry : geometry,
		 *   attributes : {
		 *     color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.CORNFLOWERBLUE),
		 *   }
		 * });
		 */
		static fromColor(color: Color): ColorGeometryInstanceAttribute;

		/**
		 * Converts a color to a typed array that can be used to assign a color attribute.
		 * @param {Color} color The color.
		 * @param {Uint8Array} [result] The array to store the result in, if undefined a new instance will be created.
		 * @returns {Uint8Array} The modified result parameter or a new instance if result was undefined.
		 * @example
		 * var attributes = primitive.getGeometryInstanceAttributes('an id');
		 * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA, attributes.color);
		 */
		static toValue(color: Color, result?: Uint8Array): Uint8Array;

		/**
		 * Compares the provided ColorGeometryInstanceAttributes and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {ColorGeometryInstanceAttribute} [left] The first ColorGeometryInstanceAttribute.
		 * @param {ColorGeometryInstanceAttribute} [right] The second ColorGeometryInstanceAttribute.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		static equals(left?: ColorGeometryInstanceAttribute, right?: ColorGeometryInstanceAttribute): boolean;

	}

	/**
	 * Merges two objects, copying their properties onto a new combined object. When two objects have the same
	 * property, the value of the property on the first object is used.  If either object is undefined,
	 * it will be treated as an empty object.
	 * @example
	 * var object1 = {
	 *     propOne : 1,
	 *     propTwo : {
	 *         value1 : 10
	 *     }
	 * }
	 * var object2 = {
	 *     propTwo : 2
	 * }
	 * var final = Cesium.combine(object1, object2);
	 * // final === {
	 * //     propOne : 1,
	 * //     propTwo : {
	 * //         value1 : 10
	 * //     }
	 * // }
	 * @param {Object} [object1] The first object to merge.
	 * @param {Object} [object2] The second object to merge.
	 * @param {Boolean} [deep=false] Perform a recursive merge.
	 * @returns {Object} The combined object containing all properties from both objects.
	 * @exports combine
	 */
	namespace combine {
	}

	/**
	 * WebGL component datatypes.  Components are intrinsics,
	 * which form attributes, which form vertices.
	 * @exports ComponentDatatype
	 */
	namespace ComponentDatatype {
		/**
		 * 8-bit signed byte corresponding to <code>gl.BYTE</code> and the type
		 * of an element in <code>Int8Array</code>.
		 * @type {Number}
		 * @constant
		 */
		const BYTE: number;

		/**
		 * 8-bit unsigned byte corresponding to <code>UNSIGNED_BYTE</code> and the type
		 * of an element in <code>Uint8Array</code>.
		 * @type {Number}
		 * @constant
		 */
		const UNSIGNED_BYTE: number;

		/**
		 * 16-bit signed short corresponding to <code>SHORT</code> and the type
		 * of an element in <code>Int16Array</code>.
		 * @type {Number}
		 * @constant
		 */
		const SHORT: number;

		/**
		 * 16-bit unsigned short corresponding to <code>UNSIGNED_SHORT</code> and the type
		 * of an element in <code>Uint16Array</code>.
		 * @type {Number}
		 * @constant
		 */
		const UNSIGNED_SHORT: number;

		/**
		 * 32-bit floating-point corresponding to <code>FLOAT</code> and the type
		 * of an element in <code>Float32Array</code>.
		 * @type {Number}
		 * @constant
		 */
		const FLOAT: number;

		/**
		 * Returns the size, in bytes, of the corresponding datatype.
		 * @param {ComponentDatatype} componentDatatype The component datatype to get the size of.
		 * @returns {Number} The size in bytes.
		 * @exception {DeveloperError} componentDatatype is not a valid value.
		 * @example
		 * // Returns Int8Array.BYTES_PER_ELEMENT
		 * var size = Cesium.ComponentDatatype.getSizeInBytes(Cesium.ComponentDatatype.BYTE);
		 */
		function getSizeInBytes(componentDatatype: any): number;

		/**
		 * Gets the {@link ComponentDatatype} for the provided TypedArray instance.
		 * @param {TypedArray} array The typed array.
		 * @returns {ComponentDatatype} The ComponentDatatype for the provided array, or undefined if the array is not a TypedArray.
		 */
		function fromTypedArray(array: any): any;

		/**
		 * Validates that the provided component datatype is a valid {@link ComponentDatatype}
		 * @param {ComponentDatatype} componentDatatype The component datatype to validate.
		 * @returns {Boolean} <code>true</code> if the provided component datatype is a valid value; otherwise, <code>false</code>.
		 * @example
		 * if (!Cesium.ComponentDatatype.validate(componentDatatype)) {
		 *   throw new Cesium.DeveloperError('componentDatatype must be a valid value.');
		 * }
		 */
		function validate(componentDatatype: any): boolean;

		/**
		 * Creates a typed array corresponding to component data type.
		 * @param {ComponentDatatype} componentDatatype The component data type.
		 * @param {Number|Array} valuesOrLength The length of the array to create or an array.
		 * @returns {Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} A typed array.
		 * @exception {DeveloperError} componentDatatype is not a valid value.
		 * @example
		 * // creates a Float32Array with length of 100
		 * var typedArray = Cesium.ComponentDatatype.createTypedArray(Cesium.ComponentDatatype.FLOAT, 100);
		 */
		function createTypedArray(componentDatatype: any, valuesOrLength: number | any[]): Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array;

		/**
		 * Creates a typed view of an array of bytes.
		 * @param {ComponentDatatype} componentDatatype The type of the view to create.
		 * @param {ArrayBuffer} buffer The buffer storage to use for the view.
		 * @param {Number} [byteOffset] The offset, in bytes, to the first element in the view.
		 * @param {Number} [length] The number of elements in the view.
		 * @returns {Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} A typed array view of the buffer.
		 * @exception {DeveloperError} componentDatatype is not a valid value.
		 */
		function createArrayBufferView(componentDatatype: any, buffer: ArrayBuffer, byteOffset?: number, length?: number): Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array;

		/**
		 * Get the ComponentDatatype from its name.
		 * @param {String} name The name of the ComponentDatatype.
		 * @returns {ComponentDatatype} The ComponentDatatype.
		 * @exception {DeveloperError} name is not a valid value.
		 */
		function fromName(name: string): any;

	}

	/**
	 * Describes a compressed texture and contains a compressed texture buffer.
	 * @alias CompressedTextureBuffer
	 * @constructor
	 * @param {PixelFormat} internalFormat The pixel format of the compressed texture.
	 * @param {Number} width The width of the texture.
	 * @param {Number} height The height of the texture.
	 * @param {Uint8Array} buffer The compressed texture buffer.
	 */
	class CompressedTextureBuffer {
		constructor(internalFormat: any, width: number, height: number, buffer: Uint8Array);

		/**
		 * The format of the compressed texture.
		 * @type PixelFormat
		 * @readonly
		 * @memberof CompressedTextureBuffer.prototype
		 */
		readonly internalFormat: any;

		/**
		 * The width of the texture.
		 * @type Number
		 * @readonly
		 * @memberof CompressedTextureBuffer.prototype
		 */
		readonly width: number;

		/**
		 * The height of the texture.
		 * @type Number
		 * @readonly
		 * @memberof CompressedTextureBuffer.prototype
		 */
		readonly height: number;

		/**
		 * The compressed texture buffer.
		 * @type Uint8Array
		 * @readonly
		 * @memberof CompressedTextureBuffer.prototype
		 */
		readonly bufferView: Uint8Array;

		/**
		 * Creates a shallow clone of a compressed texture buffer.
		 * @param {CompressedTextureBuffer} object The compressed texture buffer to be cloned.
		 * @return {CompressedTextureBuffer} A shallow clone of the compressed texture buffer.
		 */
		static clone(object: CompressedTextureBuffer): CompressedTextureBuffer;

		/**
		 * Creates a shallow clone of this compressed texture buffer.
		 * @return {CompressedTextureBuffer} A shallow clone of the compressed texture buffer.
		 */
		clone(): CompressedTextureBuffer;

	}

	/**
	 * A description of a polygon composed of arbitrary coplanar positions.
	 * @alias CoplanarPolygonGeometry
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.
	 * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.
	 * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
	 * @example
	 * var polygon = new Cesium.CoplanarPolygonGeometry({
	 *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([
	 *      -90.0, 30.0, 0.0,
	 *      -90.0, 30.0, 1000.0,
	 *      -80.0, 30.0, 1000.0,
	 *      -80.0, 30.0, 0.0
	 *   ])
	 * });
	 * var geometry = Cesium.CoplanarPolygonGeometry.createGeometry(polygon);
	 * @see CoplanarPolygonGeometry.createGeometry
	 */
	class CoplanarPolygonGeometry {
		constructor(options: {
			polygonHierarchy: PolygonHierarchy;
			stRotation?: number;
			vertexFormat?: VertexFormat;
			ellipsoid?: any;
			offsetAttribute?: any;
		});

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		packedLength: number;

		/**
		 * A description of a coplanar polygon from an array of positions.
		 * @param {Object} options Object with the following properties:
		 * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.
		 * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
		 * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.
		 * @returns {CoplanarPolygonGeometry}
		 * @example
		 * // create a polygon from points
		 * var polygon = Cesium.CoplanarPolygonGeometry.fromPositions({
		 *   positions : Cesium.Cartesian3.fromDegreesArray([
		 *     -72.0, 40.0,
		 *     -70.0, 35.0,
		 *     -75.0, 30.0,
		 *     -70.0, 30.0,
		 *     -68.0, 40.0
		 *   ])
		 * });
		 * var geometry = Cesium.PolygonGeometry.createGeometry(polygon);
		 * @see PolygonGeometry#createGeometry
		 */
		static fromPositions(options: {
			positions: (Cartesian3)[];
			vertexFormat?: VertexFormat;
			stRotation?: number;
		}): CoplanarPolygonGeometry;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {CoplanarPolygonGeometry} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: CoplanarPolygonGeometry, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {CoplanarPolygonGeometry} [result] The object into which to store the result.
		 * @returns {CoplanarPolygonGeometry} The modified result parameter or a new CoplanarPolygonGeometry instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: CoplanarPolygonGeometry): CoplanarPolygonGeometry;

		/**
		 * Computes the geometric representation of an arbitrary coplanar polygon, including its vertices, indices, and a bounding sphere.
		 * @param {CoplanarPolygonGeometry} polygonGeometry A description of the polygon.
		 * @returns {Geometry|undefined} The computed vertices and indices.
		 */
		static createGeometry(polygonGeometry: CoplanarPolygonGeometry): Geometry | undefined;

	}

	/**
	 * A description of the outline of a polygon composed of arbitrary coplanar positions.
	 * @alias CoplanarPolygonOutlineGeometry
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.
	 * @see CoplanarPolygonOutlineGeometry.createGeometry
	 * @example
	 * var polygonOutline = new Cesium.CoplanarPolygonOutlineGeometry({
	 *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([
	 *      -90.0, 30.0, 0.0,
	 *      -90.0, 30.0, 1000.0,
	 *      -80.0, 30.0, 1000.0,
	 *      -80.0, 30.0, 0.0
	 *   ])
	 * });
	 * var geometry = Cesium.CoplanarPolygonOutlineGeometry.createGeometry(polygonOutline);
	 */
	class CoplanarPolygonOutlineGeometry {
		constructor(options: {
			polygonHierarchy: PolygonHierarchy;
		});

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		packedLength: number;

		/**
		 * A description of a coplanar polygon outline from an array of positions.
		 * @param {Object} options Object with the following properties:
		 * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.
		 * @returns {CoplanarPolygonOutlineGeometry}
		 */
		static fromPositions(options: {
			positions: (Cartesian3)[];
		}): CoplanarPolygonOutlineGeometry;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {CoplanarPolygonOutlineGeometry} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: CoplanarPolygonOutlineGeometry, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {CoplanarPolygonOutlineGeometry} [result] The object into which to store the result.
		 * @returns {CoplanarPolygonOutlineGeometry} The modified result parameter or a new CoplanarPolygonOutlineGeometry instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: CoplanarPolygonOutlineGeometry): CoplanarPolygonOutlineGeometry;

		/**
		 * Computes the geometric representation of an arbitrary coplanar polygon, including its vertices, indices, and a bounding sphere.
		 * @param {CoplanarPolygonOutlineGeometry} polygonGeometry A description of the polygon.
		 * @returns {Geometry|undefined} The computed vertices and indices.
		 */
		static createGeometry(polygonGeometry: CoplanarPolygonOutlineGeometry): Geometry | undefined;

	}

	/**
	 * Style options for corners.
	 * @demo The {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Corridor.html&label=Geometries|Corridor Demo}
	 * demonstrates the three corner types, as used by {@link CorridorGraphics}.
	 * @exports CornerType
	 */
	namespace CornerType {
		/**
		 * <img src="Images/CornerTypeRounded.png" style="vertical-align: middle;" width="186" height="189" />
		 * Corner has a smooth edge.
		 * @type {Number}
		 * @constant
		 */
		const ROUNDED: number;

		/**
		 * <img src="Images/CornerTypeMitered.png" style="vertical-align: middle;" width="186" height="189" />
		 * Corner point is the intersection of adjacent edges.
		 * @type {Number}
		 * @constant
		 */
		const MITERED: number;

		/**
		 * <img src="Images/CornerTypeBeveled.png" style="vertical-align: middle;" width="186" height="189" />
		 * Corner is clipped.
		 * @type {Number}
		 * @constant
		 */
		const BEVELED: number;

	}

	/**
	 * A description of a corridor. Corridor geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
	 * @alias CorridorGeometry
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor.
	 * @param {Number} options.width The distance between the edges of the corridor in meters.
	 * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.
	 * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
	 * @param {Number} [options.height=0] The distance in meters between the ellipsoid surface and the positions.
	 * @param {Number} [options.extrudedHeight] The distance in meters between the ellipsoid surface and the extruded face.
	 * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
	 * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.
	 * @see CorridorGeometry.createGeometry
	 * @see Packable
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Corridor.html|Cesium Sandcastle Corridor Demo}
	 * @example
	 * var corridor = new Cesium.CorridorGeometry({
	 *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,
	 *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),
	 *   width : 100000
	 * });
	 */
	class CorridorGeometry {
		constructor(options: {
			positions: (Cartesian3)[];
			width: number;
			ellipsoid?: Ellipsoid;
			granularity?: number;
			height?: number;
			extrudedHeight?: number;
			vertexFormat?: VertexFormat;
			cornerType?: any;
		});

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {CorridorGeometry} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: CorridorGeometry, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {CorridorGeometry} [result] The object into which to store the result.
		 * @returns {CorridorGeometry} The modified result parameter or a new CorridorGeometry instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: CorridorGeometry): CorridorGeometry;

		/**
		 * Computes the bounding rectangle given the provided options
		 * @param {Object} options Object with the following properties:
		 * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor.
		 * @param {Number} options.width The distance between the edges of the corridor in meters.
		 * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.
		 * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.
		 * @param {Rectangle} [result] An object in which to store the result.
		 * @returns {Rectangle} The result rectangle.
		 */
		static computeRectangle(options: {
			positions: (Cartesian3)[];
			width: number;
			ellipsoid?: Ellipsoid;
			cornerType?: any;
		}, result?: Rectangle): Rectangle;

		/**
		 * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.
		 * @param {CorridorGeometry} corridorGeometry A description of the corridor.
		 * @returns {Geometry|undefined} The computed vertices and indices.
		 */
		static createGeometry(corridorGeometry: CorridorGeometry): Geometry | undefined;

	}

	/**
	 * A description of a corridor outline.
	 * @alias CorridorOutlineGeometry
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Cartesian3[]} options.positions An array of positions that define the center of the corridor outline.
	 * @param {Number} options.width The distance between the edges of the corridor outline.
	 * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.
	 * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
	 * @param {Number} [options.height=0] The distance in meters between the positions and the ellipsoid surface.
	 * @param {Number} [options.extrudedHeight] The distance in meters between the extruded face and the ellipsoid surface.
	 * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.
	 * @see CorridorOutlineGeometry.createGeometry
	 * @example
	 * var corridor = new Cesium.CorridorOutlineGeometry({
	 *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),
	 *   width : 100000
	 * });
	 */
	class CorridorOutlineGeometry {
		constructor(options: {
			positions: (Cartesian3)[];
			width: number;
			ellipsoid?: Ellipsoid;
			granularity?: number;
			height?: number;
			extrudedHeight?: number;
			cornerType?: any;
		});

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {CorridorOutlineGeometry} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: CorridorOutlineGeometry, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {CorridorOutlineGeometry} [result] The object into which to store the result.
		 * @returns {CorridorOutlineGeometry} The modified result parameter or a new CorridorOutlineGeometry instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: CorridorOutlineGeometry): CorridorOutlineGeometry;

		/**
		 * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.
		 * @param {CorridorOutlineGeometry} corridorOutlineGeometry A description of the corridor.
		 * @returns {Geometry|undefined} The computed vertices and indices.
		 */
		static createGeometry(corridorOutlineGeometry: CorridorOutlineGeometry): Geometry | undefined;

	}

	/**
	 * Creates a {@link CesiumTerrainProvider} instance for the {@link https://cesium.com/content/cesiumworldterrain|Cesium World Terrain}.
	 * @exports createWorldTerrain
	 * @param {Object} [options] Object with the following properties:
	 * @param {Boolean} [options.requestVertexNormals=false] Flag that indicates if the client should request additional lighting information from the server if available.
	 * @param {Boolean} [options.requestWaterMask=false] Flag that indicates if the client should request per tile water masks from the server if available.
	 * @returns {CesiumTerrainProvider}
	 * @see Ion
	 * @example
	 * // Create Cesium World Terrain with default settings
	 * var viewer = new Cesium.Viewer('cesiumContainer', {
	 *     terrainProvider : Cesium.createWorldTerrain();
	 * });
	 * @example
	 * // Create Cesium World Terrain with water and normals.
	 * var viewer = new Cesium.Viewer('cesiumContainer', {
	 *     terrainProvider : Cesium.createWorldTerrain({
	 *         requestWaterMask : true,
	 *         requestVertexNormals : true
	 *     });
	 * });
	 */
	namespace createWorldTerrain {
	}

	/**
	 * A credit contains data pertaining to how to display attributions/credits for certain content on the screen.
	 * @param {String} html An string representing an html code snippet
	 * @param {Boolean} [showOnScreen=false] If true, the credit will be visible in the main credit container.  Otherwise, it will appear in a popover
	 * @alias Credit
	 * @constructor
	 * @exception {DeveloperError} html is required.
	 * @example
	 * //Create a credit with a tooltip, image and link
	 * var credit = new Cesium.Credit('<a href="https://cesiumjs.org/" target="_blank"><img src="/images/cesium_logo.png" title="Cesium"/></a>');
	 */
	class Credit {
		constructor(html: string, showOnScreen?: boolean);

		/**
		 * The credit content
		 * @memberof Credit.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly html: string;

		/**
		 * Whether the credit should be displayed on screen or in a lightbox
		 * @memberof Credit.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly showOnScreen: boolean;

		/**
		 * Gets the credit element
		 * @memberof Credit.prototype
		 * @type {HTMLElement}
		 * @readonly
		 */
		readonly element: HTMLElement;

		/**
		 * Returns true if the credits are equal
		 * @param {Credit} left The first credit
		 * @param {Credit} right The second credit
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		static equals(left: Credit, right: Credit): boolean;

		/**
		 * Returns true if the credits are equal
		 * @param {Credit} credit The credit to compare to.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		equals(credit: Credit): boolean;

		/**
		 * Duplicates a Credit instance.
		 * @param {Credit} [credit] The Credit to duplicate.
		 * @returns {Credit} A new Credit instance that is a duplicate of the one provided. (Returns undefined if the credit is undefined)
		 */
		static clone(credit?: Credit): Credit;

	}

	/**
	 * Defines functions for 3rd order polynomial functions of one variable with only real coefficients.
	 * @exports CubicRealPolynomial
	 */
	namespace CubicRealPolynomial {
		/**
		 * Provides the discriminant of the cubic equation from the supplied coefficients.
		 * @param {Number} a The coefficient of the 3rd order monomial.
		 * @param {Number} b The coefficient of the 2nd order monomial.
		 * @param {Number} c The coefficient of the 1st order monomial.
		 * @param {Number} d The coefficient of the 0th order monomial.
		 * @returns {Number} The value of the discriminant.
		 */
		function computeDiscriminant(a: number, b: number, c: number, d: number): number;

		/**
		 * Provides the real valued roots of the cubic polynomial with the provided coefficients.
		 * @param {Number} a The coefficient of the 3rd order monomial.
		 * @param {Number} b The coefficient of the 2nd order monomial.
		 * @param {Number} c The coefficient of the 1st order monomial.
		 * @param {Number} d The coefficient of the 0th order monomial.
		 * @returns {Number[]} The real valued roots.
		 */
		function computeRealRoots(a: number, b: number, c: number, d: number): number[];

	}

	/**
	 * The culling volume defined by planes.
	 * @alias CullingVolume
	 * @constructor
	 * @param {Cartesian4[]} [planes] An array of clipping planes.
	 */
	class CullingVolume {
		constructor(planes?: (Cartesian4)[]);

		/**
		 * Each plane is represented by a Cartesian4 object, where the x, y, and z components
		 * define the unit vector normal to the plane, and the w component is the distance of the
		 * plane from the origin.
		 * @type {Cartesian4[]}
		 * @default []
		 */
		planes: (Cartesian4)[];

		/**
		 * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.
		 * The planes are aligned to the x, y, and z axes in world coordinates.
		 * @param {BoundingSphere} boundingSphere The bounding sphere used to create the culling volume.
		 * @param {CullingVolume} [result] The object onto which to store the result.
		 * @returns {CullingVolume} The culling volume created from the bounding sphere.
		 */
		static fromBoundingSphere(boundingSphere: BoundingSphere, result?: CullingVolume): CullingVolume;

		/**
		 * Determines whether a bounding volume intersects the culling volume.
		 * @param {Object} boundingVolume The bounding volume whose intersection with the culling volume is to be tested.
		 * @returns {Intersect}  Intersect.OUTSIDE, Intersect.INTERSECTING, or Intersect.INSIDE.
		 */
		computeVisibility(boundingVolume: any): any;

	}

	/**
	 * A description of a cylinder.
	 * @alias CylinderGeometry
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Number} options.length The length of the cylinder.
	 * @param {Number} options.topRadius The radius of the top of the cylinder.
	 * @param {Number} options.bottomRadius The radius of the bottom of the cylinder.
	 * @param {Number} [options.slices=128] The number of edges around the perimeter of the cylinder.
	 * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
	 * @exception {DeveloperError} options.slices must be greater than or equal to 3.
	 * @see CylinderGeometry.createGeometry
	 * @example
	 * // create cylinder geometry
	 * var cylinder = new Cesium.CylinderGeometry({
	 *     length: 200000,
	 *     topRadius: 80000,
	 *     bottomRadius: 200000,
	 * });
	 * var geometry = Cesium.CylinderGeometry.createGeometry(cylinder);
	 */
	class CylinderGeometry {
		constructor(options: {
			length: number;
			topRadius: number;
			bottomRadius: number;
			slices?: number;
			vertexFormat?: VertexFormat;
		});

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {CylinderGeometry} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: CylinderGeometry, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {CylinderGeometry} [result] The object into which to store the result.
		 * @returns {CylinderGeometry} The modified result parameter or a new CylinderGeometry instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: CylinderGeometry): CylinderGeometry;

		/**
		 * Computes the geometric representation of a cylinder, including its vertices, indices, and a bounding sphere.
		 * @param {CylinderGeometry} cylinderGeometry A description of the cylinder.
		 * @returns {Geometry|undefined} The computed vertices and indices.
		 */
		static createGeometry(cylinderGeometry: CylinderGeometry): Geometry | undefined;

	}

	/**
	 * A description of the outline of a cylinder.
	 * @alias CylinderOutlineGeometry
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Number} options.length The length of the cylinder.
	 * @param {Number} options.topRadius The radius of the top of the cylinder.
	 * @param {Number} options.bottomRadius The radius of the bottom of the cylinder.
	 * @param {Number} [options.slices=128] The number of edges around the perimeter of the cylinder.
	 * @param {Number} [options.numberOfVerticalLines=16] Number of lines to draw between the top and bottom surfaces of the cylinder.
	 * @exception {DeveloperError} options.length must be greater than 0.
	 * @exception {DeveloperError} options.topRadius must be greater than 0.
	 * @exception {DeveloperError} options.bottomRadius must be greater than 0.
	 * @exception {DeveloperError} bottomRadius and topRadius cannot both equal 0.
	 * @exception {DeveloperError} options.slices must be greater than or equal to 3.
	 * @see CylinderOutlineGeometry.createGeometry
	 * @example
	 * // create cylinder geometry
	 * var cylinder = new Cesium.CylinderOutlineGeometry({
	 *     length: 200000,
	 *     topRadius: 80000,
	 *     bottomRadius: 200000,
	 * });
	 * var geometry = Cesium.CylinderOutlineGeometry.createGeometry(cylinder);
	 */
	class CylinderOutlineGeometry {
		constructor(options: {
			length: number;
			topRadius: number;
			bottomRadius: number;
			slices?: number;
			numberOfVerticalLines?: number;
		});

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {CylinderOutlineGeometry} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: CylinderOutlineGeometry, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {CylinderOutlineGeometry} [result] The object into which to store the result.
		 * @returns {CylinderOutlineGeometry} The modified result parameter or a new CylinderOutlineGeometry instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: CylinderOutlineGeometry): CylinderOutlineGeometry;

		/**
		 * Computes the geometric representation of an outline of a cylinder, including its vertices, indices, and a bounding sphere.
		 * @param {CylinderOutlineGeometry} cylinderGeometry A description of the cylinder outline.
		 * @returns {Geometry|undefined} The computed vertices and indices.
		 */
		static createGeometry(cylinderGeometry: CylinderOutlineGeometry): Geometry | undefined;

	}

	/**
	 * A simple proxy that appends the desired resource as the sole query parameter
	 * to the given proxy URL.
	 * @alias DefaultProxy
	 * @constructor
	 * @param {String} proxy The proxy URL that will be used to requests all resources.
	 */
	class DefaultProxy {
		constructor(proxy: string);

		/**
		 * Get the final URL to use to request a given resource.
		 * @param {String} resource The resource to request.
		 * @returns {String} proxied resource
		 */
		getURL(resource: string): string;

	}

	/**
	 * Destroys an object.  Each of the object's functions, including functions in its prototype,
	 * is replaced with a function that throws a {@link DeveloperError}, except for the object's
	 * <code>isDestroyed</code> function, which is set to a function that returns <code>true</code>.
	 * The object's properties are removed with <code>delete</code>.
	 * <br /><br />
	 * This function is used by objects that hold native resources, e.g., WebGL resources, which
	 * need to be explicitly released.  Client code calls an object's <code>destroy</code> function,
	 * which then releases the native resource and calls <code>destroyObject</code> to put itself
	 * in a destroyed state.
	 * @exports destroyObject
	 * @param {Object} object The object to destroy.
	 * @param {String} [message] The message to include in the exception that is thrown if
	 *                           a destroyed object's function is called.
	 * @example
	 * // How a texture would destroy itself.
	 * this.destroy = function () {
	 *     _gl.deleteTexture(_texture);
	 *     return Cesium.destroyObject(this);
	 * };
	 * @see DeveloperError
	 */
	namespace destroyObject {
	}

	/**
	 * Constructs an exception object that is thrown due to a developer error, e.g., invalid argument,
	 * argument out of range, etc.  This exception should only be thrown during development;
	 * it usually indicates a bug in the calling code.  This exception should never be
	 * caught; instead the calling code should strive not to generate it.
	 * <br /><br />
	 * On the other hand, a {@link RuntimeError} indicates an exception that may
	 * be thrown at runtime, e.g., out of memory, that the calling code should be prepared
	 * to catch.
	 * @alias DeveloperError
	 * @constructor
	 * @extends Error
	 * @param {String} [message] The error message for this exception.
	 * @see RuntimeError
	 */
	class DeveloperError extends Error {
		constructor(message?: string);

		/**
		 * 'DeveloperError' indicating that this exception was thrown due to a developer error.
		 * @type {String}
		 * @readonly
		 */
		readonly name: string;

		/**
		 * The explanation for why this exception was thrown.
		 * @type {String}
		 * @readonly
		 */
		readonly message: string;

		/**
		 * The stack trace of this exception, if available.
		 * @type {String}
		 * @readonly
		 */
		readonly stack: string;

	}

	/**
	 * Determines visibility based on the distance to the camera.
	 * @alias DistanceDisplayCondition
	 * @constructor
	 * @param {Number} [near=0.0] The smallest distance in the interval where the object is visible.
	 * @param {Number} [far=Number.MAX_VALUE] The largest distance in the interval where the object is visible.
	 * @example
	 * // Make a billboard that is only visible when the distance to the camera is between 10 and 20 meters.
	 * billboard.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(10.0, 20.0);
	 */
	class DistanceDisplayCondition {
		constructor(near?: number, far?: number);

		/**
		 * The smallest distance in the interval where the object is visible.
		 * @memberof DistanceDisplayCondition.prototype
		 * @type {Number}
		 * @default 0.0
		 */
		near: number;

		/**
		 * The largest distance in the interval where the object is visible.
		 * @memberof DistanceDisplayCondition.prototype
		 * @type {Number}
		 * @default Number.MAX_VALUE
		 */
		far: number;

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {DistanceDisplayCondition} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: DistanceDisplayCondition, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {DistanceDisplayCondition} [result] The object into which to store the result.
		 * @returns {DistanceDisplayCondition} The modified result parameter or a new DistanceDisplayCondition instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: DistanceDisplayCondition): DistanceDisplayCondition;

		/**
		 * Determines if two distance display conditions are equal.
		 * @param {DistanceDisplayCondition} left A distance display condition.
		 * @param {DistanceDisplayCondition} right Another distance display condition.
		 * @return {Boolean} Whether the two distance display conditions are equal.
		 */
		static equals(left: DistanceDisplayCondition, right: DistanceDisplayCondition): boolean;

		/**
		 * Duplicates a distance display condition instance.
		 * @param {DistanceDisplayCondition} [value] The distance display condition to duplicate.
		 * @param {DistanceDisplayCondition} [result] The result onto which to store the result.
		 * @return {DistanceDisplayCondition} The duplicated instance.
		 */
		static clone(value?: DistanceDisplayCondition, result?: DistanceDisplayCondition): DistanceDisplayCondition;

		/**
		 * Duplicates this instance.
		 * @param {DistanceDisplayCondition} [result] The result onto which to store the result.
		 * @return {DistanceDisplayCondition} The duplicated instance.
		 */
		clone(result?: DistanceDisplayCondition): DistanceDisplayCondition;

		/**
		 * Determines if this distance display condition is equal to another.
		 * @param {DistanceDisplayCondition} other Another distance display condition.
		 * @return {Boolean} Whether this distance display condition is equal to the other.
		 */
		equals(other: DistanceDisplayCondition): boolean;

	}

	/**
	 * Value and type information for per-instance geometry attribute that determines if the geometry instance has a distance display condition.
	 * @alias DistanceDisplayConditionGeometryInstanceAttribute
	 * @constructor
	 * @param {Number} [near=0.0] The near distance.
	 * @param {Number} [far=Number.MAX_VALUE] The far distance.
	 * @exception {DeveloperError} far must be greater than near.
	 * @example
	 * var instance = new Cesium.GeometryInstance({
	 *   geometry : new Cesium.BoxGeometry({
	 *     vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL,
	 *     minimum : new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0),
	 *     maximum : new Cesium.Cartesian3(250000.0, 250000.0, 250000.0)
	 *   }),
	 *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(
	 *     Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),
	 *   id : 'box',
	 *   attributes : {
	 *     distanceDisplayCondition : new Cesium.DistanceDisplayConditionGeometryInstanceAttribute(100.0, 10000.0)
	 *   }
	 * });
	 * @see GeometryInstance
	 * @see GeometryInstanceAttribute
	 */
	class DistanceDisplayConditionGeometryInstanceAttribute {
		constructor(near?: number, far?: number);

		/**
		 * The values for the attributes stored in a typed array.
		 * @type Float32Array
		 * @default [0.0, 0.0, Number.MAX_VALUE]
		 */
		value: Float32Array;

		/**
		 * The datatype of each component in the attribute, e.g., individual elements in
		 * {@link DistanceDisplayConditionGeometryInstanceAttribute#value}.
		 * @memberof DistanceDisplayConditionGeometryInstanceAttribute.prototype
		 * @type {ComponentDatatype}
		 * @readonly
		 * @default {@link ComponentDatatype.FLOAT}
		 */
		readonly componentDatatype: any;

		/**
		 * The number of components in the attributes, i.e., {@link DistanceDisplayConditionGeometryInstanceAttribute#value}.
		 * @memberof DistanceDisplayConditionGeometryInstanceAttribute.prototype
		 * @type {Number}
		 * @readonly
		 * @default 3
		 */
		readonly componentsPerAttribute: number;

		/**
		 * When <code>true</code> and <code>componentDatatype</code> is an integer format,
		 * indicate that the components should be mapped to the range [0, 1] (unsigned)
		 * or [-1, 1] (signed) when they are accessed as floating-point for rendering.
		 * @memberof DistanceDisplayConditionGeometryInstanceAttribute.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default false
		 */
		readonly normalize: boolean;

		/**
		 * Creates a new {@link DistanceDisplayConditionGeometryInstanceAttribute} instance given the provided an enabled flag and {@link DistanceDisplayCondition}.
		 * @param {DistanceDisplayCondition} distanceDisplayCondition The distance display condition.
		 * @returns {DistanceDisplayConditionGeometryInstanceAttribute} The new {@link DistanceDisplayConditionGeometryInstanceAttribute} instance.
		 * @exception {DeveloperError} distanceDisplayCondition.far must be greater than distanceDisplayCondition.near
		 * @example
		 * var distanceDisplayCondition = new Cesium.DistanceDisplayCondition(100.0, 10000.0);
		 * var instance = new Cesium.GeometryInstance({
		 *   geometry : geometry,
		 *   attributes : {
		 *     distanceDisplayCondition : Cesium.DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition)
		 *   }
		 * });
		 */
		static fromDistanceDisplayCondition(distanceDisplayCondition: DistanceDisplayCondition): DistanceDisplayConditionGeometryInstanceAttribute;

		/**
		 * Converts a distance display condition to a typed array that can be used to assign a distance display condition attribute.
		 * @param {DistanceDisplayCondition} distanceDisplayCondition The distance display condition value.
		 * @param {Float32Array} [result] The array to store the result in, if undefined a new instance will be created.
		 * @returns {Float32Array} The modified result parameter or a new instance if result was undefined.
		 * @example
		 * var attributes = primitive.getGeometryInstanceAttributes('an id');
		 * attributes.distanceDisplayCondition = Cesium.DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);
		 */
		static toValue(distanceDisplayCondition: DistanceDisplayCondition, result?: Float32Array): Float32Array;

	}

	/**
	 * Easing functions for use with {@link TweenCollection}.  These function are from
	 * {@link https://github.com/sole/tween.js/|Tween.js} and Robert Penner.  See the
	 * {@link http://sole.github.io/tween.js/examples/03_graphs.html|Tween.js graphs for each function}.
	 * @exports EasingFunction
	 */
	namespace EasingFunction {
		/**
		 * Linear easing.
		 * @type {Function}
		 * @constant
		 */
		const LINEAR_NONE: Function;

		/**
		 * Quadratic in.
		 * @type {Function}
		 * @constant
		 */
		const QUADRACTIC_IN: Function;

		/**
		 * Quadratic out.
		 * @type {Function}
		 * @constant
		 */
		const QUADRACTIC_OUT: Function;

		/**
		 * Quadratic in then out.
		 * @type {Function}
		 * @constant
		 */
		const QUADRACTIC_IN_OUT: Function;

		/**
		 * Cubic in.
		 * @type {Function}
		 * @constant
		 */
		const CUBIC_IN: Function;

		/**
		 * Cubic out.
		 * @type {Function}
		 * @constant
		 */
		const CUBIC_OUT: Function;

		/**
		 * Cubic in then out.
		 * @type {Function}
		 * @constant
		 */
		const CUBIC_IN_OUT: Function;

		/**
		 * Quartic in.
		 * @type {Function}
		 * @constant
		 */
		const QUARTIC_IN: Function;

		/**
		 * Quartic out.
		 * @type {Function}
		 * @constant
		 */
		const QUARTIC_OUT: Function;

		/**
		 * Quartic in then out.
		 * @type {Function}
		 * @constant
		 */
		const QUARTIC_IN_OUT: Function;

		/**
		 * Quintic in.
		 * @type {Function}
		 * @constant
		 */
		const QUINTIC_IN: Function;

		/**
		 * Quintic out.
		 * @type {Function}
		 * @constant
		 */
		const QUINTIC_OUT: Function;

		/**
		 * Quintic in then out.
		 * @type {Function}
		 * @constant
		 */
		const QUINTIC_IN_OUT: Function;

		/**
		 * Sinusoidal in.
		 * @type {Function}
		 * @constant
		 */
		const SINUSOIDAL_IN: Function;

		/**
		 * Sinusoidal out.
		 * @type {Function}
		 * @constant
		 */
		const SINUSOIDAL_OUT: Function;

		/**
		 * Sinusoidal in then out.
		 * @type {Function}
		 * @constant
		 */
		const SINUSOIDAL_IN_OUT: Function;

		/**
		 * Exponential in.
		 * @type {Function}
		 * @constant
		 */
		const EXPONENTIAL_IN: Function;

		/**
		 * Exponential out.
		 * @type {Function}
		 * @constant
		 */
		const EXPONENTIAL_OUT: Function;

		/**
		 * Exponential in then out.
		 * @type {Function}
		 * @constant
		 */
		const EXPONENTIAL_IN_OUT: Function;

		/**
		 * Circular in.
		 * @type {Function}
		 * @constant
		 */
		const CIRCULAR_IN: Function;

		/**
		 * Circular out.
		 * @type {Function}
		 * @constant
		 */
		const CIRCULAR_OUT: Function;

		/**
		 * Circular in then out.
		 * @type {Function}
		 * @constant
		 */
		const CIRCULAR_IN_OUT: Function;

		/**
		 * Elastic in.
		 * @type {Function}
		 * @constant
		 */
		const ELASTIC_IN: Function;

		/**
		 * Elastic out.
		 * @type {Function}
		 * @constant
		 */
		const ELASTIC_OUT: Function;

		/**
		 * Elastic in then out.
		 * @type {Function}
		 * @constant
		 */
		const ELASTIC_IN_OUT: Function;

		/**
		 * Back in.
		 * @type {Function}
		 * @constant
		 */
		const BACK_IN: Function;

		/**
		 * Back out.
		 * @type {Function}
		 * @constant
		 */
		const BACK_OUT: Function;

		/**
		 * Back in then out.
		 * @type {Function}
		 * @constant
		 */
		const BACK_IN_OUT: Function;

		/**
		 * Bounce in.
		 * @type {Function}
		 * @constant
		 */
		const BOUNCE_IN: Function;

		/**
		 * Bounce out.
		 * @type {Function}
		 * @constant
		 */
		const BOUNCE_OUT: Function;

		/**
		 * Bounce in then out.
		 * @type {Function}
		 * @constant
		 */
		const BOUNCE_IN_OUT: Function;

	}

	/**
	 * A description of an ellipse on an ellipsoid. Ellipse geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
	 * @alias EllipseGeometry
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.
	 * @param {Number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.
	 * @param {Number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.
	 * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the ellipse will be on.
	 * @param {Number} [options.height=0.0] The distance in meters between the ellipse and the ellipsoid surface.
	 * @param {Number} [options.extrudedHeight] The distance in meters between the ellipse's extruded face and the ellipsoid surface.
	 * @param {Number} [options.rotation=0.0] The angle of rotation counter-clockwise from north.
	 * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates counter-clockwise from north.
	 * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The angular distance between points on the ellipse in radians.
	 * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
	 * @exception {DeveloperError} semiMajorAxis and semiMinorAxis must be greater than zero.
	 * @exception {DeveloperError} semiMajorAxis must be greater than or equal to the semiMinorAxis.
	 * @exception {DeveloperError} granularity must be greater than zero.
	 * @example
	 * // Create an ellipse.
	 * var ellipse = new Cesium.EllipseGeometry({
	 *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),
	 *   semiMajorAxis : 500000.0,
	 *   semiMinorAxis : 300000.0,
	 *   rotation : Cesium.Math.toRadians(60.0)
	 * });
	 * var geometry = Cesium.EllipseGeometry.createGeometry(ellipse);
	 * @see EllipseGeometry.createGeometry
	 */
	class EllipseGeometry {
		constructor(options: {
			center: Cartesian3;
			semiMajorAxis: number;
			semiMinorAxis: number;
			ellipsoid?: Ellipsoid;
			height?: number;
			extrudedHeight?: number;
			rotation?: number;
			stRotation?: number;
			granularity?: number;
			vertexFormat?: VertexFormat;
		});

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {EllipseGeometry} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: EllipseGeometry, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {EllipseGeometry} [result] The object into which to store the result.
		 * @returns {EllipseGeometry} The modified result parameter or a new EllipseGeometry instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: EllipseGeometry): EllipseGeometry;

		/**
		 * Computes the bounding rectangle based on the provided options
		 * @param {Object} options Object with the following properties:
		 * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.
		 * @param {Number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.
		 * @param {Number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.
		 * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the ellipse will be on.
		 * @param {Number} [options.rotation=0.0] The angle of rotation counter-clockwise from north.
		 * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The angular distance between points on the ellipse in radians.
		 * @param {Rectangle} [result] An object in which to store the result
		 * @returns {Rectangle} The result rectangle
		 */
		static computeRectangle(options: {
			center: Cartesian3;
			semiMajorAxis: number;
			semiMinorAxis: number;
			ellipsoid?: Ellipsoid;
			rotation?: number;
			granularity?: number;
		}, result?: Rectangle): Rectangle;

		/**
		 * Computes the geometric representation of a ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.
		 * @param {EllipseGeometry} ellipseGeometry A description of the ellipse.
		 * @returns {Geometry|undefined} The computed vertices and indices.
		 */
		static createGeometry(ellipseGeometry: EllipseGeometry): Geometry | undefined;

	}

	/**
	 * A description of the outline of an ellipse on an ellipsoid.
	 * @alias EllipseOutlineGeometry
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Cartesian3} options.center The ellipse's center point in the fixed frame.
	 * @param {Number} options.semiMajorAxis The length of the ellipse's semi-major axis in meters.
	 * @param {Number} options.semiMinorAxis The length of the ellipse's semi-minor axis in meters.
	 * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid the ellipse will be on.
	 * @param {Number} [options.height=0.0] The distance in meters between the ellipse and the ellipsoid surface.
	 * @param {Number} [options.extrudedHeight] The distance in meters between the ellipse's extruded face and the ellipsoid surface.
	 * @param {Number} [options.rotation=0.0] The angle from north (counter-clockwise) in radians.
	 * @param {Number} [options.granularity=0.02] The angular distance between points on the ellipse in radians.
	 * @param {Number} [options.numberOfVerticalLines=16] Number of lines to draw between the top and bottom surface of an extruded ellipse.
	 * @exception {DeveloperError} semiMajorAxis and semiMinorAxis must be greater than zero.
	 * @exception {DeveloperError} semiMajorAxis must be greater than or equal to the semiMinorAxis.
	 * @exception {DeveloperError} granularity must be greater than zero.
	 * @see EllipseOutlineGeometry.createGeometry
	 * @example
	 * var ellipse = new Cesium.EllipseOutlineGeometry({
	 *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),
	 *   semiMajorAxis : 500000.0,
	 *   semiMinorAxis : 300000.0,
	 *   rotation : Cesium.Math.toRadians(60.0)
	 * });
	 * var geometry = Cesium.EllipseOutlineGeometry.createGeometry(ellipse);
	 */
	class EllipseOutlineGeometry {
		constructor(options: {
			center: Cartesian3;
			semiMajorAxis: number;
			semiMinorAxis: number;
			ellipsoid?: Ellipsoid;
			height?: number;
			extrudedHeight?: number;
			rotation?: number;
			granularity?: number;
			numberOfVerticalLines?: number;
		});

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {EllipseOutlineGeometry} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: EllipseOutlineGeometry, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {EllipseOutlineGeometry} [result] The object into which to store the result.
		 * @returns {EllipseOutlineGeometry} The modified result parameter or a new EllipseOutlineGeometry instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: EllipseOutlineGeometry): EllipseOutlineGeometry;

		/**
		 * Computes the geometric representation of an outline of an ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.
		 * @param {EllipseOutlineGeometry} ellipseGeometry A description of the ellipse.
		 * @returns {Geometry|undefined} The computed vertices and indices.
		 */
		static createGeometry(ellipseGeometry: EllipseOutlineGeometry): Geometry | undefined;

	}

	/**
	 * A quadratic surface defined in Cartesian coordinates by the equation
	 * <code>(x / a)^2 + (y / b)^2 + (z / c)^2 = 1</code>.  Primarily used
	 * by Cesium to represent the shape of planetary bodies.
	 * Rather than constructing this object directly, one of the provided
	 * constants is normally used.
	 * @alias Ellipsoid
	 * @constructor
	 * @param {Number} [x=0] The radius in the x direction.
	 * @param {Number} [y=0] The radius in the y direction.
	 * @param {Number} [z=0] The radius in the z direction.
	 * @exception {DeveloperError} All radii components must be greater than or equal to zero.
	 * @see Ellipsoid.fromCartesian3
	 * @see Ellipsoid.WGS84
	 * @see Ellipsoid.UNIT_SPHERE
	 */
	class Ellipsoid {
		constructor(x?: number, y?: number, z?: number);

		/**
		 * Gets the radii of the ellipsoid.
		 * @memberof Ellipsoid.prototype
		 * @type {Cartesian3}
		 * @readonly
		 */
		readonly radii: Cartesian3;

		/**
		 * Gets the squared radii of the ellipsoid.
		 * @memberof Ellipsoid.prototype
		 * @type {Cartesian3}
		 * @readonly
		 */
		readonly radiiSquared: Cartesian3;

		/**
		 * Gets the radii of the ellipsoid raise to the fourth power.
		 * @memberof Ellipsoid.prototype
		 * @type {Cartesian3}
		 * @readonly
		 */
		readonly radiiToTheFourth: Cartesian3;

		/**
		 * Gets one over the radii of the ellipsoid.
		 * @memberof Ellipsoid.prototype
		 * @type {Cartesian3}
		 * @readonly
		 */
		readonly oneOverRadii: Cartesian3;

		/**
		 * Gets one over the squared radii of the ellipsoid.
		 * @memberof Ellipsoid.prototype
		 * @type {Cartesian3}
		 * @readonly
		 */
		readonly oneOverRadiiSquared: Cartesian3;

		/**
		 * Gets the minimum radius of the ellipsoid.
		 * @memberof Ellipsoid.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly minimumRadius: number;

		/**
		 * Gets the maximum radius of the ellipsoid.
		 * @memberof Ellipsoid.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly maximumRadius: number;

		/**
		 * Duplicates an Ellipsoid instance.
		 * @param {Ellipsoid} ellipsoid The ellipsoid to duplicate.
		 * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new
		 *                    instance should be created.
		 * @returns {Ellipsoid} The cloned Ellipsoid. (Returns undefined if ellipsoid is undefined)
		 */
		static clone(ellipsoid: Ellipsoid, result?: Ellipsoid): Ellipsoid;

		/**
		 * Computes an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions.
		 * @param {Cartesian3} [cartesian=Cartesian3.ZERO] The ellipsoid's radius in the x, y, and z directions.
		 * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new
		 *                    instance should be created.
		 * @returns {Ellipsoid} A new Ellipsoid instance.
		 * @exception {DeveloperError} All radii components must be greater than or equal to zero.
		 * @see Ellipsoid.WGS84
		 * @see Ellipsoid.UNIT_SPHERE
		 */
		static fromCartesian3(cartesian?: Cartesian3, result?: Ellipsoid): Ellipsoid;

		/**
		 * An Ellipsoid instance initialized to the WGS84 standard.
		 * @type {Ellipsoid}
		 * @constant
		 */
		static WGS84: Ellipsoid;

		/**
		 * An Ellipsoid instance initialized to radii of (1.0, 1.0, 1.0).
		 * @type {Ellipsoid}
		 * @constant
		 */
		static UNIT_SPHERE: Ellipsoid;

		/**
		 * An Ellipsoid instance initialized to a sphere with the lunar radius.
		 * @type {Ellipsoid}
		 * @constant
		 */
		static MOON: Ellipsoid;

		/**
		 * Duplicates an Ellipsoid instance.
		 * @param {Ellipsoid} [result] The object onto which to store the result, or undefined if a new
		 *                    instance should be created.
		 * @returns {Ellipsoid} The cloned Ellipsoid.
		 */
		clone(result?: Ellipsoid): Ellipsoid;

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {Ellipsoid} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: Ellipsoid, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {Ellipsoid} [result] The object into which to store the result.
		 * @returns {Ellipsoid} The modified result parameter or a new Ellipsoid instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: Ellipsoid): Ellipsoid;

		/**
		 * Computes the unit vector directed from the center of this ellipsoid toward the provided Cartesian position.
		 * @function
		 * @param {Cartesian3} cartesian The Cartesian for which to to determine the geocentric normal.
		 * @param {Cartesian3} [result] The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
		 */
		geocentricSurfaceNormal(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;

		/**
		 * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.
		 * @param {Cartographic} cartographic The cartographic position for which to to determine the geodetic normal.
		 * @param {Cartesian3} [result] The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
		 */
		geodeticSurfaceNormalCartographic(cartographic: Cartographic, result?: Cartesian3): Cartesian3;

		/**
		 * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.
		 * @param {Cartesian3} cartesian The Cartesian position for which to to determine the surface normal.
		 * @param {Cartesian3} [result] The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
		 */
		geodeticSurfaceNormal(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;

		/**
		 * Converts the provided cartographic to Cartesian representation.
		 * @param {Cartographic} cartographic The cartographic position.
		 * @param {Cartesian3} [result] The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
		 * @example
		 * //Create a Cartographic and determine it's Cartesian representation on a WGS84 ellipsoid.
		 * var position = new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 5000);
		 * var cartesianPosition = Cesium.Ellipsoid.WGS84.cartographicToCartesian(position);
		 */
		cartographicToCartesian(cartographic: Cartographic, result?: Cartesian3): Cartesian3;

		/**
		 * Converts the provided array of cartographics to an array of Cartesians.
		 * @param {Cartographic[]} cartographics An array of cartographic positions.
		 * @param {Cartesian3[]} [result] The object onto which to store the result.
		 * @returns {Cartesian3[]} The modified result parameter or a new Array instance if none was provided.
		 * @example
		 * //Convert an array of Cartographics and determine their Cartesian representation on a WGS84 ellipsoid.
		 * var positions = [new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 0),
		 *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.321), Cesium.Math.toRadians(78.123), 100),
		 *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.645), Cesium.Math.toRadians(78.456), 250)];
		 * var cartesianPositions = Cesium.Ellipsoid.WGS84.cartographicArrayToCartesianArray(positions);
		 */
		cartographicArrayToCartesianArray(cartographics: (Cartographic)[], result?: (Cartesian3)[]): (Cartesian3)[];

		/**
		 * Converts the provided cartesian to cartographic representation.
		 * The cartesian is undefined at the center of the ellipsoid.
		 * @param {Cartesian3} cartesian The Cartesian position to convert to cartographic representation.
		 * @param {Cartographic} [result] The object onto which to store the result.
		 * @returns {Cartographic} The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.
		 * @example
		 * //Create a Cartesian and determine it's Cartographic representation on a WGS84 ellipsoid.
		 * var position = new Cesium.Cartesian3(17832.12, 83234.52, 952313.73);
		 * var cartographicPosition = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);
		 */
		cartesianToCartographic(cartesian: Cartesian3, result?: Cartographic): Cartographic;

		/**
		 * Converts the provided array of cartesians to an array of cartographics.
		 * @param {Cartesian3[]} cartesians An array of Cartesian positions.
		 * @param {Cartographic[]} [result] The object onto which to store the result.
		 * @returns {Cartographic[]} The modified result parameter or a new Array instance if none was provided.
		 * @example
		 * //Create an array of Cartesians and determine their Cartographic representation on a WGS84 ellipsoid.
		 * var positions = [new Cesium.Cartesian3(17832.12, 83234.52, 952313.73),
		 *                  new Cesium.Cartesian3(17832.13, 83234.53, 952313.73),
		 *                  new Cesium.Cartesian3(17832.14, 83234.54, 952313.73)]
		 * var cartographicPositions = Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(positions);
		 */
		cartesianArrayToCartographicArray(cartesians: (Cartesian3)[], result?: (Cartographic)[]): (Cartographic)[];

		/**
		 * Scales the provided Cartesian position along the geodetic surface normal
		 * so that it is on the surface of this ellipsoid.  If the position is
		 * at the center of the ellipsoid, this function returns undefined.
		 * @param {Cartesian3} cartesian The Cartesian position to scale.
		 * @param {Cartesian3} [result] The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.
		 */
		scaleToGeodeticSurface(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;

		/**
		 * Scales the provided Cartesian position along the geocentric surface normal
		 * so that it is on the surface of this ellipsoid.
		 * @param {Cartesian3} cartesian The Cartesian position to scale.
		 * @param {Cartesian3} [result] The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
		 */
		scaleToGeocentricSurface(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;

		/**
		 * Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying
		 * its components by the result of {@link Ellipsoid#oneOverRadii}.
		 * @param {Cartesian3} position The position to transform.
		 * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and
		 *        return a new instance.
		 * @returns {Cartesian3} The position expressed in the scaled space.  The returned instance is the
		 *          one passed as the result parameter if it is not undefined, or a new instance of it is.
		 */
		transformPositionToScaledSpace(position: Cartesian3, result?: Cartesian3): Cartesian3;

		/**
		 * Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying
		 * its components by the result of {@link Ellipsoid#radii}.
		 * @param {Cartesian3} position The position to transform.
		 * @param {Cartesian3} [result] The position to which to copy the result, or undefined to create and
		 *        return a new instance.
		 * @returns {Cartesian3} The position expressed in the unscaled space.  The returned instance is the
		 *          one passed as the result parameter if it is not undefined, or a new instance of it is.
		 */
		transformPositionFromScaledSpace(position: Cartesian3, result?: Cartesian3): Cartesian3;

		/**
		 * Compares this Ellipsoid against the provided Ellipsoid componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Ellipsoid} [right] The other Ellipsoid.
		 * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
		 */
		equals(right?: Ellipsoid): boolean;

		/**
		 * Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'.
		 * @returns {String} A string representing this ellipsoid in the format '(radii.x, radii.y, radii.z)'.
		 */
		toString(): string;

		/**
		 * Computes a point which is the intersection of the surface normal with the z-axis.
		 * @param {Cartesian3} position the position. must be on the surface of the ellipsoid.
		 * @param {Number} [buffer = 0.0] A buffer to subtract from the ellipsoid size when checking if the point is inside the ellipsoid.
		 *                                In earth case, with common earth datums, there is no need for this buffer since the intersection point is always (relatively) very close to the center.
		 *                                In WGS84 datum, intersection point is at max z = +-42841.31151331382 (0.673% of z-axis).
		 *                                Intersection point could be outside the ellipsoid if the ratio of MajorAxis / AxisOfRotation is bigger than the square root of 2
		 * @param {Cartesian3} [result] The cartesian to which to copy the result, or undefined to create and
		 *        return a new instance.
		 * @returns {Cartesian3 | undefined} the intersection point if it's inside the ellipsoid, undefined otherwise
		 * @exception {DeveloperError} position is required.
		 * @exception {DeveloperError} Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y).
		 * @exception {DeveloperError} Ellipsoid.radii.z must be greater than 0.
		 */
		getSurfaceNormalIntersectionWithZAxis(position: Cartesian3, buffer?: number, result?: Cartesian3): Cartesian3 | undefined;

	}

	/**
	 * Initializes a geodesic on the ellipsoid connecting the two provided planetodetic points.
	 * @alias EllipsoidGeodesic
	 * @constructor
	 * @param {Cartographic} [start] The initial planetodetic point on the path.
	 * @param {Cartographic} [end] The final planetodetic point on the path.
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the geodesic lies.
	 */
	class EllipsoidGeodesic {
		constructor(start?: Cartographic, end?: Cartographic, ellipsoid?: Ellipsoid);

		/**
		 * Gets the ellipsoid.
		 * @memberof EllipsoidGeodesic.prototype
		 * @type {Ellipsoid}
		 * @readonly
		 */
		readonly ellipsoid: Ellipsoid;

		/**
		 * Gets the surface distance between the start and end point
		 * @memberof EllipsoidGeodesic.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly surfaceDistance: number;

		/**
		 * Gets the initial planetodetic point on the path.
		 * @memberof EllipsoidGeodesic.prototype
		 * @type {Cartographic}
		 * @readonly
		 */
		readonly start: Cartographic;

		/**
		 * Gets the final planetodetic point on the path.
		 * @memberof EllipsoidGeodesic.prototype
		 * @type {Cartographic}
		 * @readonly
		 */
		readonly end: Cartographic;

		/**
		 * Gets the heading at the initial point.
		 * @memberof EllipsoidGeodesic.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly startHeading: number;

		/**
		 * Gets the heading at the final point.
		 * @memberof EllipsoidGeodesic.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly endHeading: number;

		/**
		 * Sets the start and end points of the geodesic
		 * @param {Cartographic} start The initial planetodetic point on the path.
		 * @param {Cartographic} end The final planetodetic point on the path.
		 */
		setEndPoints(start: Cartographic, end: Cartographic): void;

		/**
		 * Provides the location of a point at the indicated portion along the geodesic.
		 * @param {Number} fraction The portion of the distance between the initial and final points.
		 * @param {Cartographic} result The object in which to store the result.
		 * @returns {Cartographic} The location of the point along the geodesic.
		 */
		interpolateUsingFraction(fraction: number, result: Cartographic): Cartographic;

		/**
		 * Provides the location of a point at the indicated distance along the geodesic.
		 * @param {Number} distance The distance from the inital point to the point of interest along the geodesic
		 * @param {Cartographic} result The object in which to store the result.
		 * @returns {Cartographic} The location of the point along the geodesic.
		 * @exception {DeveloperError} start and end must be set before calling function interpolateUsingSurfaceDistance
		 */
		interpolateUsingSurfaceDistance(distance: number, result: Cartographic): Cartographic;

	}

	/**
	 * A description of an ellipsoid centered at the origin.
	 * @alias EllipsoidGeometry
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Cartesian3} [options.radii=Cartesian3(1.0, 1.0, 1.0)] The radii of the ellipsoid in the x, y, and z directions.
	 * @param {Number} [options.stackPartitions=64] The number of times to partition the ellipsoid into stacks.
	 * @param {Number} [options.slicePartitions=64] The number of times to partition the ellipsoid into radial slices.
	 * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
	 * @exception {DeveloperError} options.slicePartitions cannot be less than three.
	 * @exception {DeveloperError} options.stackPartitions cannot be less than three.
	 * @see EllipsoidGeometry#createGeometry
	 * @example
	 * var ellipsoid = new Cesium.EllipsoidGeometry({
	 *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,
	 *   radii : new Cesium.Cartesian3(1000000.0, 500000.0, 500000.0)
	 * });
	 * var geometry = Cesium.EllipsoidGeometry.createGeometry(ellipsoid);
	 */
	class EllipsoidGeometry {
		constructor(options?: {
			radii?: Cartesian3;
			stackPartitions?: number;
			slicePartitions?: number;
			vertexFormat?: VertexFormat;
		});

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {EllipsoidGeometry} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: EllipsoidGeometry, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {EllipsoidGeometry} [result] The object into which to store the result.
		 * @returns {EllipsoidGeometry} The modified result parameter or a new EllipsoidGeometry instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: EllipsoidGeometry): EllipsoidGeometry;

		/**
		 * Computes the geometric representation of an ellipsoid, including its vertices, indices, and a bounding sphere.
		 * @param {EllipsoidGeometry} ellipsoidGeometry A description of the ellipsoid.
		 * @returns {Geometry|undefined} The computed vertices and indices.
		 */
		static createGeometry(ellipsoidGeometry: EllipsoidGeometry): Geometry | undefined;

	}

	/**
	 * A description of the outline of an ellipsoid centered at the origin.
	 * @alias EllipsoidOutlineGeometry
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Cartesian3} [options.radii=Cartesian3(1.0, 1.0, 1.0)] The radii of the ellipsoid in the x, y, and z directions.
	 * @param {Number} [options.stackPartitions=10] The count of stacks for the ellipsoid (1 greater than the number of parallel lines).
	 * @param {Number} [options.slicePartitions=8] The count of slices for the ellipsoid (Equal to the number of radial lines).
	 * @param {Number} [options.subdivisions=128] The number of points per line, determining the granularity of the curvature.
	 * @exception {DeveloperError} options.stackPartitions must be greater than or equal to one.
	 * @exception {DeveloperError} options.slicePartitions must be greater than or equal to zero.
	 * @exception {DeveloperError} options.subdivisions must be greater than or equal to zero.
	 * @example
	 * var ellipsoid = new Cesium.EllipsoidOutlineGeometry({
	 *   radii : new Cesium.Cartesian3(1000000.0, 500000.0, 500000.0),
	 *   stackPartitions: 6,
	 *   slicePartitions: 5
	 * });
	 * var geometry = Cesium.EllipsoidOutlineGeometry.createGeometry(ellipsoid);
	 */
	class EllipsoidOutlineGeometry {
		constructor(options?: {
			radii?: Cartesian3;
			stackPartitions?: number;
			slicePartitions?: number;
			subdivisions?: number;
		});

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {EllipsoidOutlineGeometry} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: EllipsoidOutlineGeometry, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {EllipsoidOutlineGeometry} [result] The object into which to store the result.
		 * @returns {EllipsoidOutlineGeometry} The modified result parameter or a new EllipsoidOutlineGeometry instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: EllipsoidOutlineGeometry): EllipsoidOutlineGeometry;

		/**
		 * Computes the geometric representation of an outline of an ellipsoid, including its vertices, indices, and a bounding sphere.
		 * @param {EllipsoidOutlineGeometry} ellipsoidGeometry A description of the ellipsoid outline.
		 * @returns {Geometry|undefined} The computed vertices and indices.
		 */
		static createGeometry(ellipsoidGeometry: EllipsoidOutlineGeometry): Geometry | undefined;

	}

	/**
	 * A plane tangent to the provided ellipsoid at the provided origin.
	 * If origin is not on the surface of the ellipsoid, it's surface projection will be used.
	 * If origin is at the center of the ellipsoid, an exception will be thrown.
	 * @alias EllipsoidTangentPlane
	 * @constructor
	 * @param {Cartesian3} origin The point on the surface of the ellipsoid where the tangent plane touches.
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use.
	 * @exception {DeveloperError} origin must not be at the center of the ellipsoid.
	 */
	class EllipsoidTangentPlane {
		constructor(origin: Cartesian3, ellipsoid?: Ellipsoid);

		/**
		 * Gets the ellipsoid.
		 * @memberof EllipsoidTangentPlane.prototype
		 * @type {Ellipsoid}
		 */
		ellipsoid: Ellipsoid;

		/**
		 * Gets the origin.
		 * @memberof EllipsoidTangentPlane.prototype
		 * @type {Cartesian3}
		 */
		origin: Cartesian3;

		/**
		 * Gets the plane which is tangent to the ellipsoid.
		 * @memberof EllipsoidTangentPlane.prototype
		 * @readonly
		 * @type {Plane}
		 */
		readonly plane: Plane;

		/**
		 * Gets the local X-axis (east) of the tangent plane.
		 * @memberof EllipsoidTangentPlane.prototype
		 * @readonly
		 * @type {Cartesian3}
		 */
		readonly xAxis: Cartesian3;

		/**
		 * Gets the local Y-axis (north) of the tangent plane.
		 * @memberof EllipsoidTangentPlane.prototype
		 * @readonly
		 * @type {Cartesian3}
		 */
		readonly yAxis: Cartesian3;

		/**
		 * Creates a new instance from the provided ellipsoid and the center
		 * point of the provided Cartesians.
		 * @param {Cartesian3} cartesians The list of positions surrounding the center point.
		 * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use.
		 */
		static fromPoints(cartesians: Cartesian3, ellipsoid?: Ellipsoid): void;

		/**
		 * Computes the projection of the provided 3D position onto the 2D plane, radially outward from the {@link EllipsoidTangentPlane.ellipsoid} coordinate system origin.
		 * @param {Cartesian3} cartesian The point to project.
		 * @param {Cartesian2} [result] The object onto which to store the result.
		 * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided. Undefined if there is no intersection point
		 */
		projectPointOntoPlane(cartesian: Cartesian3, result?: Cartesian2): Cartesian2;

		/**
		 * Computes the projection of the provided 3D positions onto the 2D plane (where possible), radially outward from the global origin.
		 * The resulting array may be shorter than the input array - if a single projection is impossible it will not be included.
		 * @see EllipsoidTangentPlane.projectPointOntoPlane
		 * @param {Cartesian3[]} cartesians The array of points to project.
		 * @param {Cartesian2[]} [result] The array of Cartesian2 instances onto which to store results.
		 * @returns {Cartesian2[]} The modified result parameter or a new array of Cartesian2 instances if none was provided.
		 */
		projectPointsOntoPlane(cartesians: (Cartesian3)[], result?: (Cartesian2)[]): (Cartesian2)[];

		/**
		 * Computes the projection of the provided 3D position onto the 2D plane, along the plane normal.
		 * @param {Cartesian3} cartesian The point to project.
		 * @param {Cartesian2} [result] The object onto which to store the result.
		 * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
		 */
		projectPointToNearestOnPlane(cartesian: Cartesian3, result?: Cartesian2): Cartesian2;

		/**
		 * Computes the projection of the provided 3D positions onto the 2D plane, along the plane normal.
		 * @see EllipsoidTangentPlane.projectPointToNearestOnPlane
		 * @param {Cartesian3[]} cartesians The array of points to project.
		 * @param {Cartesian2[]} [result] The array of Cartesian2 instances onto which to store results.
		 * @returns {Cartesian2[]} The modified result parameter or a new array of Cartesian2 instances if none was provided. This will have the same length as <code>cartesians</code>.
		 */
		projectPointsToNearestOnPlane(cartesians: (Cartesian3)[], result?: (Cartesian2)[]): (Cartesian2)[];

		/**
		 * Computes the projection of the provided 2D position onto the 3D ellipsoid.
		 * @param {Cartesian2} cartesian The points to project.
		 * @param {Cartesian3} [result] The Cartesian3 instance to store result.
		 * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if none was provided.
		 */
		projectPointOntoEllipsoid(cartesian: Cartesian2, result?: Cartesian3): Cartesian3;

		/**
		 * Computes the projection of the provided 2D positions onto the 3D ellipsoid.
		 * @param {Cartesian2[]} cartesians The array of points to project.
		 * @param {Cartesian3[]} [result] The array of Cartesian3 instances onto which to store results.
		 * @returns {Cartesian3[]} The modified result parameter or a new array of Cartesian3 instances if none was provided.
		 */
		projectPointsOntoEllipsoid(cartesians: (Cartesian2)[], result?: (Cartesian3)[]): (Cartesian3)[];

	}

	/**
	 * A very simple {@link TerrainProvider} that produces geometry by tessellating an ellipsoidal
	 * surface.
	 * @alias EllipsoidTerrainProvider
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {TilingScheme} [options.tilingScheme] The tiling scheme specifying how the ellipsoidal
	 * surface is broken into tiles.  If this parameter is not provided, a {@link GeographicTilingScheme}
	 * is used.
	 * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If the tilingScheme is specified,
	 * this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither
	 * parameter is specified, the WGS84 ellipsoid is used.
	 * @see TerrainProvider
	 */
	class EllipsoidTerrainProvider {
		constructor(options?: {
			tilingScheme?: TilingScheme;
			ellipsoid?: Ellipsoid;
		});

		/**
		 * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing
		 * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
		 * are passed an instance of {@link TileProviderError}.
		 * @memberof EllipsoidTerrainProvider.prototype
		 * @type {Event}
		 */
		errorEvent: Event;

		/**
		 * Gets the credit to display when this terrain provider is active.  Typically this is used to credit
		 * the source of the terrain.  This function should not be called before {@link EllipsoidTerrainProvider#ready} returns true.
		 * @memberof EllipsoidTerrainProvider.prototype
		 * @type {Credit}
		 */
		credit: Credit;

		/**
		 * Gets the tiling scheme used by this provider.  This function should
		 * not be called before {@link EllipsoidTerrainProvider#ready} returns true.
		 * @memberof EllipsoidTerrainProvider.prototype
		 * @type {GeographicTilingScheme}
		 */
		tilingScheme: GeographicTilingScheme;

		/**
		 * Gets a value indicating whether or not the provider is ready for use.
		 * @memberof EllipsoidTerrainProvider.prototype
		 * @type {Boolean}
		 */
		ready: boolean;

		/**
		 * Gets a promise that resolves to true when the provider is ready for use.
		 * @memberof EllipsoidTerrainProvider.prototype
		 * @type {Promise.<Boolean>}
		 * @readonly
		 */
		readonly readyPromise: any;

		/**
		 * Gets a value indicating whether or not the provider includes a water mask.  The water mask
		 * indicates which areas of the globe are water rather than land, so they can be rendered
		 * as a reflective surface with animated waves.  This function should not be
		 * called before {@link EllipsoidTerrainProvider#ready} returns true.
		 * @memberof EllipsoidTerrainProvider.prototype
		 * @type {Boolean}
		 */
		hasWaterMask: boolean;

		/**
		 * Gets a value indicating whether or not the requested tiles include vertex normals.
		 * This function should not be called before {@link EllipsoidTerrainProvider#ready} returns true.
		 * @memberof EllipsoidTerrainProvider.prototype
		 * @type {Boolean}
		 */
		hasVertexNormals: boolean;

		/**
		 * Requests the geometry for a given tile.  This function should not be called before
		 * {@link TerrainProvider#ready} returns true.  The result includes terrain
		 * data and indicates that all child tiles are available.
		 * @param {Number} x The X coordinate of the tile for which to request geometry.
		 * @param {Number} y The Y coordinate of the tile for which to request geometry.
		 * @param {Number} level The level of the tile for which to request geometry.
		 * @param {Request} [request] The request object. Intended for internal use only.
		 * @returns {Promise.<TerrainData>|undefined} A promise for the requested geometry.  If this method
		 *          returns undefined instead of a promise, it is an indication that too many requests are already
		 *          pending and the request will be retried later.
		 */
		requestTileGeometry(x: number, y: number, level: number, request?: Request): any | undefined;

		/**
		 * Gets the maximum geometric error allowed in a tile at a given level.
		 * @param {Number} level The tile level for which to get the maximum geometric error.
		 * @returns {Number} The maximum geometric error.
		 */
		getLevelMaximumGeometricError(level: number): number;

		/**
		 * Determines whether data for a tile is available to be loaded.
		 * @param {Number} x The X coordinate of the tile for which to request geometry.
		 * @param {Number} y The Y coordinate of the tile for which to request geometry.
		 * @param {Number} level The level of the tile for which to request geometry.
		 * @returns {Boolean} Undefined if not supported, otherwise true or false.
		 */
		getTileDataAvailable(x: number, y: number, level: number): boolean;

	}

	/**
	 * A generic utility class for managing subscribers for a particular event.
	 * This class is usually instantiated inside of a container class and
	 * exposed as a property for others to subscribe to.
	 * @alias Event
	 * @constructor
	 * @example
	 * MyObject.prototype.myListener = function(arg1, arg2) {
	 *     this.myArg1Copy = arg1;
	 *     this.myArg2Copy = arg2;
	 * }
	 * var myObjectInstance = new MyObject();
	 * var evt = new Cesium.Event();
	 * evt.addEventListener(MyObject.prototype.myListener, myObjectInstance);
	 * evt.raiseEvent('1', '2');
	 * evt.removeEventListener(MyObject.prototype.myListener);
	 */
	class Event {
		constructor();

		/**
		 * The number of listeners currently subscribed to the event.
		 * @memberof Event.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly numberOfListeners: number;

		/**
		 * Registers a callback function to be executed whenever the event is raised.
		 * An optional scope can be provided to serve as the <code>this</code> pointer
		 * in which the function will execute.
		 * @param {Function} listener The function to be executed when the event is raised.
		 * @param {Object} [scope] An optional object scope to serve as the <code>this</code>
		 *        pointer in which the listener function will execute.
		 * @returns {Function} A function that will remove this event listener when invoked.
		 * @see Event#raiseEvent
		 * @see Event#removeEventListener
		 */
		addEventListener(listener: Function, scope?: any): Function;

		/**
		 * Unregisters a previously registered callback.
		 * @param {Function} listener The function to be unregistered.
		 * @param {Object} [scope] The scope that was originally passed to addEventListener.
		 * @returns {Boolean} <code>true</code> if the listener was removed; <code>false</code> if the listener and scope are not registered with the event.
		 * @see Event#addEventListener
		 * @see Event#raiseEvent
		 */
		removeEventListener(listener: Function, scope?: any): boolean;

		/**
		 * Raises the event by calling each registered listener with all supplied arguments.
		 * @param {*} arguments This method takes any number of parameters and passes them through to the listener functions.
		 * @see Event#addEventListener
		 * @see Event#removeEventListener
		 */
		raiseEvent(arguments: any): void;

	}

	/**
	 * A convenience object that simplifies the common pattern of attaching event listeners
	 * to several events, then removing all those listeners at once later, for example, in
	 * a destroy method.
	 * @alias EventHelper
	 * @constructor
	 * @example
	 * var helper = new Cesium.EventHelper();
	 * helper.add(someObject.event, listener1, this);
	 * helper.add(otherObject.event, listener2, this);
	 * // later...
	 * helper.removeAll();
	 * @see Event
	 */
	class EventHelper {
		constructor();

		/**
		 * Adds a listener to an event, and records the registration to be cleaned up later.
		 * @param {Event} event The event to attach to.
		 * @param {Function} listener The function to be executed when the event is raised.
		 * @param {Object} [scope] An optional object scope to serve as the <code>this</code>
		 *        pointer in which the listener function will execute.
		 * @returns {Function} A function that will remove this event listener when invoked.
		 * @see Event#addEventListener
		 */
		add(event: Event, listener: Function, scope?: any): Function;

		/**
		 * Unregisters all previously added listeners.
		 * @see Event#removeEventListener
		 */
		removeAll(): void;

	}

	/**
	 * Constants to determine how an interpolated value is extrapolated
	 * when querying outside the bounds of available data.
	 * @exports ExtrapolationType
	 * @see SampledProperty
	 */
	namespace ExtrapolationType {
		/**
		 * No extrapolation occurs.
		 * @type {Number}
		 * @constant
		 */
		const NONE: number;

		/**
		 * The first or last value is used when outside the range of sample data.
		 * @type {Number}
		 * @constant
		 */
		const HOLD: number;

		/**
		 * The value is extrapolated.
		 * @type {Number}
		 * @constant
		 */
		const EXTRAPOLATE: number;

	}

	/**
	 * A set of functions to detect whether the current browser supports
	 * various features.
	 * @exports FeatureDetection
	 */
	namespace FeatureDetection {
		/**
		 * Detects whether the current browser supports the full screen standard.
		 * @returns {Boolean} true if the browser supports the full screen standard, false if not.
		 * @see Fullscreen
		 * @see {@link http://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html|W3C Fullscreen Living Specification}
		 */
		function supportsFullscreen(): boolean;

		/**
		 * Detects whether the current browser supports typed arrays.
		 * @returns {Boolean} true if the browser supports typed arrays, false if not.
		 * @see {@link http://www.khronos.org/registry/typedarray/specs/latest/|Typed Array Specification}
		 */
		function supportsTypedArrays(): boolean;

		/**
		 * Detects whether the current browser supports Web Workers.
		 * @returns {Boolean} true if the browsers supports Web Workers, false if not.
		 * @see {@link http://www.w3.org/TR/workers/}
		 */
		function supportsWebWorkers(): boolean;

		/**
		 * Detects whether the current browser supports Web Assembly.
		 * @returns {Boolean} true if the browsers supports Web Assembly, false if not.
		 * @see {@link https://developer.mozilla.org/en-US/docs/WebAssembly}
		 */
		function supportsWebAssembly(): boolean;

	}

	/**
	 * Formats an error object into a String.  If available, uses name, message, and stack
	 * properties, otherwise, falls back on toString().
	 * @exports formatError
	 * @param {*} object The item to find in the array.
	 * @returns {String} A string containing the formatted error.
	 */
	namespace formatError {
	}

	/**
	 * Describes a frustum at the given the origin and orientation.
	 * @alias FrustumGeometry
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {PerspectiveFrustum|OrthographicFrustum} options.frustum The frustum.
	 * @param {Cartesian3} options.origin The origin of the frustum.
	 * @param {Quaternion} options.orientation The orientation of the frustum.
	 * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
	 */
	class FrustumGeometry {
		constructor(options: {
			frustum: PerspectiveFrustum | OrthographicFrustum;
			origin: Cartesian3;
			orientation: Quaternion;
			vertexFormat?: VertexFormat;
		});

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {FrustumGeometry} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: FrustumGeometry, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {FrustumGeometry} [result] The object into which to store the result.
		 */
		static unpack(array: number[], startingIndex?: number, result?: FrustumGeometry): void;

		/**
		 * Computes the geometric representation of a frustum, including its vertices, indices, and a bounding sphere.
		 * @param {FrustumGeometry} frustumGeometry A description of the frustum.
		 * @returns {Geometry|undefined} The computed vertices and indices.
		 */
		static createGeometry(frustumGeometry: FrustumGeometry): Geometry | undefined;

	}

	/**
	 * A description of the outline of a frustum with the given the origin and orientation.
	 * @alias FrustumOutlineGeometry
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {PerspectiveFrustum|OrthographicFrustum} options.frustum The frustum.
	 * @param {Cartesian3} options.origin The origin of the frustum.
	 * @param {Quaternion} options.orientation The orientation of the frustum.
	 */
	class FrustumOutlineGeometry {
		constructor(options: {
			frustum: PerspectiveFrustum | OrthographicFrustum;
			origin: Cartesian3;
			orientation: Quaternion;
		});

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {FrustumOutlineGeometry} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: FrustumOutlineGeometry, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {FrustumOutlineGeometry} [result] The object into which to store the result.
		 */
		static unpack(array: number[], startingIndex?: number, result?: FrustumOutlineGeometry): void;

		/**
		 * Computes the geometric representation of a frustum outline, including its vertices, indices, and a bounding sphere.
		 * @param {FrustumOutlineGeometry} frustumGeometry A description of the frustum.
		 * @returns {Geometry|undefined} The computed vertices and indices.
		 */
		static createGeometry(frustumGeometry: FrustumOutlineGeometry): Geometry | undefined;

	}

	/**
	 * Browser-independent functions for working with the standard fullscreen API.
	 * @exports Fullscreen
	 * @see {@link http://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html|W3C Fullscreen Living Specification}
	 */
	namespace Fullscreen {
		/**
		 * Detects whether the browser supports the standard fullscreen API.
		 * @returns {Boolean} <code>true</code> if the browser supports the standard fullscreen API,
		 * <code>false</code> otherwise.
		 */
		function supportsFullscreen(): boolean;

		/**
		 * Asynchronously requests the browser to enter fullscreen mode on the given element.
		 * If fullscreen mode is not supported by the browser, does nothing.
		 * @param {Object} element The HTML element which will be placed into fullscreen mode.
		 * @param {any} [vrDevice] The VR device.
		 * @example
		 * // Put the entire page into fullscreen.
		 * Cesium.Fullscreen.requestFullscreen(document.body)
		 * // Place only the Cesium canvas into fullscreen.
		 * Cesium.Fullscreen.requestFullscreen(scene.canvas)
		 */
		function requestFullscreen(element: any, vrDevice?: any): void;

		/**
		 * Asynchronously exits fullscreen mode.  If the browser is not currently
		 * in fullscreen, or if fullscreen mode is not supported by the browser, does nothing.
		 */
		function exitFullscreen(): void;

	}

	/**
	 * Provides geocoding through an external service. This type describes an interface and
	 * is not intended to be used.
	 * @alias GeocoderService
	 * @constructor
	 * @see BingMapsGeocoderService
	 * @see PeliasGeocoderService
	 * @see OpenCageGeocoderService
	 */
	class GeocoderService {
		constructor();

		/**
		 * @function
		 * @param {String} query The query to be sent to the geocoder service
		 * @param {GeocodeType} [type=GeocodeType.SEARCH] The type of geocode to perform.
		 * @returns {Promise<GeocoderService~Result[]>}
		 */
		geocode(query: string, type?: any): any;

	}

	/**
	 * The type of geocoding to be performed by a {@link GeocoderService}.
	 * @exports GeocodeType
	 * @see Geocoder
	 */
	namespace GeocodeType {
		/**
		 * Perform a search where the input is considered complete.
		 * @type {Number}
		 * @constant
		 */
		const SEARCH: number;

		/**
		 * Perform an auto-complete using partial input, typically
		 * reserved for providing possible results as a user is typing.
		 * @type {Number}
		 * @constant
		 */
		const AUTOCOMPLETE: number;

	}

	/**
	 * A simple map projection where longitude and latitude are linearly mapped to X and Y by multiplying
	 * them by the {@link Ellipsoid#maximumRadius}.  This projection
	 * is commonly known as geographic, equirectangular, equidistant cylindrical, or plate carrée.  It
	 * is also known as EPSG:4326.
	 * @alias GeographicProjection
	 * @constructor
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid.
	 * @see WebMercatorProjection
	 */
	class GeographicProjection {
		constructor(ellipsoid?: Ellipsoid);

		/**
		 * Gets the {@link Ellipsoid}.
		 * @memberof GeographicProjection.prototype
		 * @type {Ellipsoid}
		 * @readonly
		 */
		readonly ellipsoid: Ellipsoid;

		/**
		 * Projects a set of {@link Cartographic} coordinates, in radians, to map coordinates, in meters.
		 * X and Y are the longitude and latitude, respectively, multiplied by the maximum radius of the
		 * ellipsoid.  Z is the unmodified height.
		 * @param {Cartographic} cartographic The coordinates to project.
		 * @param {Cartesian3} [result] An instance into which to copy the result.  If this parameter is
		 *        undefined, a new instance is created and returned.
		 * @returns {Cartesian3} The projected coordinates.  If the result parameter is not undefined, the
		 *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is
		 *          created and returned.
		 */
		project(cartographic: Cartographic, result?: Cartesian3): Cartesian3;

		/**
		 * Unprojects a set of projected {@link Cartesian3} coordinates, in meters, to {@link Cartographic}
		 * coordinates, in radians.  Longitude and Latitude are the X and Y coordinates, respectively,
		 * divided by the maximum radius of the ellipsoid.  Height is the unmodified Z coordinate.
		 * @param {Cartesian3} cartesian The Cartesian position to unproject with height (z) in meters.
		 * @param {Cartographic} [result] An instance into which to copy the result.  If this parameter is
		 *        undefined, a new instance is created and returned.
		 * @returns {Cartographic} The unprojected coordinates.  If the result parameter is not undefined, the
		 *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is
		 *          created and returned.
		 */
		unproject(cartesian: Cartesian3, result?: Cartographic): Cartographic;

	}

	/**
	 * A tiling scheme for geometry referenced to a simple {@link GeographicProjection} where
	 * longitude and latitude are directly mapped to X and Y.  This projection is commonly
	 * known as geographic, equirectangular, equidistant cylindrical, or plate carrée.
	 * @alias GeographicTilingScheme
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid whose surface is being tiled. Defaults to
	 * the WGS84 ellipsoid.
	 * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the tiling scheme.
	 * @param {Number} [options.numberOfLevelZeroTilesX=2] The number of tiles in the X direction at level zero of
	 * the tile tree.
	 * @param {Number} [options.numberOfLevelZeroTilesY=1] The number of tiles in the Y direction at level zero of
	 * the tile tree.
	 */
	class GeographicTilingScheme {
		constructor(options?: {
			ellipsoid?: Ellipsoid;
			rectangle?: Rectangle;
			numberOfLevelZeroTilesX?: number;
			numberOfLevelZeroTilesY?: number;
		});

		/**
		 * Gets the ellipsoid that is tiled by this tiling scheme.
		 * @memberof GeographicTilingScheme.prototype
		 * @type {Ellipsoid}
		 */
		ellipsoid: Ellipsoid;

		/**
		 * Gets the rectangle, in radians, covered by this tiling scheme.
		 * @memberof GeographicTilingScheme.prototype
		 * @type {Rectangle}
		 */
		rectangle: Rectangle;

		/**
		 * Gets the map projection used by this tiling scheme.
		 * @memberof GeographicTilingScheme.prototype
		 * @type {MapProjection}
		 */
		projection: MapProjection;

		/**
		 * Gets the total number of tiles in the X direction at a specified level-of-detail.
		 * @param {Number} level The level-of-detail.
		 * @returns {Number} The number of tiles in the X direction at the given level.
		 */
		getNumberOfXTilesAtLevel(level: number): number;

		/**
		 * Gets the total number of tiles in the Y direction at a specified level-of-detail.
		 * @param {Number} level The level-of-detail.
		 * @returns {Number} The number of tiles in the Y direction at the given level.
		 */
		getNumberOfYTilesAtLevel(level: number): number;

		/**
		 * Transforms a rectangle specified in geodetic radians to the native coordinate system
		 * of this tiling scheme.
		 * @param {Rectangle} rectangle The rectangle to transform.
		 * @param {Rectangle} [result] The instance to which to copy the result, or undefined if a new instance
		 *        should be created.
		 * @returns {Rectangle} The specified 'result', or a new object containing the native rectangle if 'result'
		 *          is undefined.
		 */
		rectangleToNativeRectangle(rectangle: Rectangle, result?: Rectangle): Rectangle;

		/**
		 * Converts tile x, y coordinates and level to a rectangle expressed in the native coordinates
		 * of the tiling scheme.
		 * @param {Number} x The integer x coordinate of the tile.
		 * @param {Number} y The integer y coordinate of the tile.
		 * @param {Number} level The tile level-of-detail.  Zero is the least detailed.
		 * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance
		 *        should be created.
		 * @returns {Rectangle} The specified 'result', or a new object containing the rectangle
		 *          if 'result' is undefined.
		 */
		tileXYToNativeRectangle(x: number, y: number, level: number, result?: any): Rectangle;

		/**
		 * Converts tile x, y coordinates and level to a cartographic rectangle in radians.
		 * @param {Number} x The integer x coordinate of the tile.
		 * @param {Number} y The integer y coordinate of the tile.
		 * @param {Number} level The tile level-of-detail.  Zero is the least detailed.
		 * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance
		 *        should be created.
		 * @returns {Rectangle} The specified 'result', or a new object containing the rectangle
		 *          if 'result' is undefined.
		 */
		tileXYToRectangle(x: number, y: number, level: number, result?: any): Rectangle;

		/**
		 * Calculates the tile x, y coordinates of the tile containing
		 * a given cartographic position.
		 * @param {Cartographic} position The position.
		 * @param {Number} level The tile level-of-detail.  Zero is the least detailed.
		 * @param {Cartesian2} [result] The instance to which to copy the result, or undefined if a new instance
		 *        should be created.
		 * @returns {Cartesian2} The specified 'result', or a new object containing the tile x, y coordinates
		 *          if 'result' is undefined.
		 */
		positionToTileXY(position: Cartographic, level: number, result?: Cartesian2): Cartesian2;

	}

	/**
	 * A geometry representation with attributes forming vertices and optional index data
	 * defining primitives.  Geometries and an {@link Appearance}, which describes the shading,
	 * can be assigned to a {@link Primitive} for visualization.  A <code>Primitive</code> can
	 * be created from many heterogeneous - in many cases - geometries for performance.
	 * <p>
	 * Geometries can be transformed and optimized using functions in {@link GeometryPipeline}.
	 * </p>
	 * @alias Geometry
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {GeometryAttributes} options.attributes Attributes, which make up the geometry's vertices.
	 * @param {PrimitiveType} [options.primitiveType=PrimitiveType.TRIANGLES] The type of primitives in the geometry.
	 * @param {Uint16Array|Uint32Array} [options.indices] Optional index data that determines the primitives in the geometry.
	 * @param {BoundingSphere} [options.boundingSphere] An optional bounding sphere that fully enclosed the geometry.
	 * @see PolygonGeometry
	 * @see RectangleGeometry
	 * @see EllipseGeometry
	 * @see CircleGeometry
	 * @see WallGeometry
	 * @see SimplePolylineGeometry
	 * @see BoxGeometry
	 * @see EllipsoidGeometry
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Geometry%20and%20Appearances.html|Geometry and Appearances Demo}
	 * @example
	 * // Create geometry with a position attribute and indexed lines.
	 * var positions = new Float64Array([
	 *   0.0, 0.0, 0.0,
	 *   7500000.0, 0.0, 0.0,
	 *   0.0, 7500000.0, 0.0
	 * ]);
	 * var geometry = new Cesium.Geometry({
	 *   attributes : {
	 *     position : new Cesium.GeometryAttribute({
	 *       componentDatatype : Cesium.ComponentDatatype.DOUBLE,
	 *       componentsPerAttribute : 3,
	 *       values : positions
	 *     })
	 *   },
	 *   indices : new Uint16Array([0, 1, 1, 2, 2, 0]),
	 *   primitiveType : Cesium.PrimitiveType.LINES,
	 *   boundingSphere : Cesium.BoundingSphere.fromVertices(positions)
	 * });
	 */
	class Geometry {
		constructor(options: {
			attributes: GeometryAttributes;
			primitiveType?: any;
			indices?: Uint16Array | Uint32Array;
			boundingSphere?: BoundingSphere;
		});

		/**
		 * Attributes, which make up the geometry's vertices.  Each property in this object corresponds to a
		 * {@link GeometryAttribute} containing the attribute's data.
		 * <p>
		 * Attributes are always stored non-interleaved in a Geometry.
		 * </p>
		 * <p>
		 * There are reserved attribute names with well-known semantics.  The following attributes
		 * are created by a Geometry (depending on the provided {@link VertexFormat}.
		 * <ul>
		 *    <li><code>position</code> - 3D vertex position.  64-bit floating-point (for precision).  3 components per attribute.  See {@link VertexFormat#position}.</li>
		 *    <li><code>normal</code> - Normal (normalized), commonly used for lighting.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#normal}.</li>
		 *    <li><code>st</code> - 2D texture coordinate.  32-bit floating-point.  2 components per attribute.  See {@link VertexFormat#st}.</li>
		 *    <li><code>bitangent</code> - Bitangent (normalized), used for tangent-space effects like bump mapping.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#bitangent}.</li>
		 *    <li><code>tangent</code> - Tangent (normalized), used for tangent-space effects like bump mapping.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#tangent}.</li>
		 * </ul>
		 * </p>
		 * <p>
		 * The following attribute names are generally not created by a Geometry, but are added
		 * to a Geometry by a {@link Primitive} or {@link GeometryPipeline} functions to prepare
		 * the geometry for rendering.
		 * <ul>
		 *    <li><code>position3DHigh</code> - High 32 bits for encoded 64-bit position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>
		 *    <li><code>position3DLow</code> - Low 32 bits for encoded 64-bit position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>
		 *    <li><code>position3DHigh</code> - High 32 bits for encoded 64-bit 2D (Columbus view) position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>
		 *    <li><code>position2DLow</code> - Low 32 bits for encoded 64-bit 2D (Columbus view) position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>
		 *    <li><code>color</code> - RGBA color (normalized) usually from {@link GeometryInstance#color}.  32-bit floating-point.  4 components per attribute.</li>
		 *    <li><code>pickColor</code> - RGBA color used for picking.  32-bit floating-point.  4 components per attribute.</li>
		 * </ul>
		 * </p>
		 * @type GeometryAttributes
		 * @default undefined
		 * @example
		 * geometry.attributes.position = new Cesium.GeometryAttribute({
		 *   componentDatatype : Cesium.ComponentDatatype.FLOAT,
		 *   componentsPerAttribute : 3,
		 *   values : new Float32Array(0)
		 * });
		 * @see GeometryAttribute
		 * @see VertexFormat
		 */
		attributes: GeometryAttributes;

		/**
		 * Optional index data that - along with {@link Geometry#primitiveType} -
		 * determines the primitives in the geometry.
		 * @type Array
		 * @default undefined
		 */
		indices: any[];

		/**
		 * The type of primitives in the geometry.  This is most often {@link PrimitiveType.TRIANGLES},
		 * but can varying based on the specific geometry.
		 * @type PrimitiveType
		 * @default undefined
		 */
		primitiveType: any;

		/**
		 * An optional bounding sphere that fully encloses the geometry.  This is
		 * commonly used for culling.
		 * @type BoundingSphere
		 * @default undefined
		 */
		boundingSphere: BoundingSphere;

		/**
		 * Computes the number of vertices in a geometry.  The runtime is linear with
		 * respect to the number of attributes in a vertex, not the number of vertices.
		 * @param {Geometry} geometry The geometry.
		 * @returns {Number} The number of vertices in the geometry.
		 * @example
		 * var numVertices = Cesium.Geometry.computeNumberOfVertices(geometry);
		 */
		static computeNumberOfVertices(geometry: Geometry): number;

	}

	/**
	 * Values and type information for geometry attributes.  A {@link Geometry}
	 * generally contains one or more attributes.  All attributes together form
	 * the geometry's vertices.
	 * @alias GeometryAttribute
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {ComponentDatatype} [options.componentDatatype] The datatype of each component in the attribute, e.g., individual elements in values.
	 * @param {Number} [options.componentsPerAttribute] A number between 1 and 4 that defines the number of components in an attributes.
	 * @param {Boolean} [options.normalize=false] When <code>true</code> and <code>componentDatatype</code> is an integer format, indicate that the components should be mapped to the range [0, 1] (unsigned) or [-1, 1] (signed) when they are accessed as floating-point for rendering.
	 * @param {TypedArray} [options.values] The values for the attributes stored in a typed array.
	 * @exception {DeveloperError} options.componentsPerAttribute must be between 1 and 4.
	 * @example
	 * var geometry = new Cesium.Geometry({
	 *   attributes : {
	 *     position : new Cesium.GeometryAttribute({
	 *       componentDatatype : Cesium.ComponentDatatype.FLOAT,
	 *       componentsPerAttribute : 3,
	 *       values : new Float32Array([
	 *         0.0, 0.0, 0.0,
	 *         7500000.0, 0.0, 0.0,
	 *         0.0, 7500000.0, 0.0
	 *       ])
	 *     })
	 *   },
	 *   primitiveType : Cesium.PrimitiveType.LINE_LOOP
	 * });
	 * @see Geometry
	 */
	class GeometryAttribute {
		constructor(options?: {
			componentDatatype?: any;
			componentsPerAttribute?: number;
			normalize?: boolean;
			values?: any;
		});

		/**
		 * The datatype of each component in the attribute, e.g., individual elements in
		 * {@link GeometryAttribute#values}.
		 * @type ComponentDatatype
		 * @default undefined
		 */
		componentDatatype: any;

		/**
		 * A number between 1 and 4 that defines the number of components in an attributes.
		 * For example, a position attribute with x, y, and z components would have 3 as
		 * shown in the code example.
		 * @type Number
		 * @default undefined
		 * @example
		 * attribute.componentDatatype = Cesium.ComponentDatatype.FLOAT;
		 * attribute.componentsPerAttribute = 3;
		 * attribute.values = new Float32Array([
		 *   0.0, 0.0, 0.0,
		 *   7500000.0, 0.0, 0.0,
		 *   0.0, 7500000.0, 0.0
		 * ]);
		 */
		componentsPerAttribute: number;

		/**
		 * When <code>true</code> and <code>componentDatatype</code> is an integer format,
		 * indicate that the components should be mapped to the range [0, 1] (unsigned)
		 * or [-1, 1] (signed) when they are accessed as floating-point for rendering.
		 * <p>
		 * This is commonly used when storing colors using {@link ComponentDatatype.UNSIGNED_BYTE}.
		 * </p>
		 * @type Boolean
		 * @default false
		 * @example
		 * attribute.componentDatatype = Cesium.ComponentDatatype.UNSIGNED_BYTE;
		 * attribute.componentsPerAttribute = 4;
		 * attribute.normalize = true;
		 * attribute.values = new Uint8Array([
		 *   Cesium.Color.floatToByte(color.red),
		 *   Cesium.Color.floatToByte(color.green),
		 *   Cesium.Color.floatToByte(color.blue),
		 *   Cesium.Color.floatToByte(color.alpha)
		 * ]);
		 */
		normalize: boolean;

		/**
		 * The values for the attributes stored in a typed array.  In the code example,
		 * every three elements in <code>values</code> defines one attributes since
		 * <code>componentsPerAttribute</code> is 3.
		 * @type TypedArray
		 * @default undefined
		 * @example
		 * attribute.componentDatatype = Cesium.ComponentDatatype.FLOAT;
		 * attribute.componentsPerAttribute = 3;
		 * attribute.values = new Float32Array([
		 *   0.0, 0.0, 0.0,
		 *   7500000.0, 0.0, 0.0,
		 *   0.0, 7500000.0, 0.0
		 * ]);
		 */
		values: any;

	}

	/**
	 * Attributes, which make up a geometry's vertices.  Each property in this object corresponds to a
	 * {@link GeometryAttribute} containing the attribute's data.
	 * <p>
	 * Attributes are always stored non-interleaved in a Geometry.
	 * </p>
	 * @alias GeometryAttributes
	 * @constructor
	 */
	class GeometryAttributes {
		constructor();

		/**
		 * The 3D position attribute.
		 * <p>
		 * 64-bit floating-point (for precision).  3 components per attribute.
		 * </p>
		 * @type GeometryAttribute
		 * @default undefined
		 */
		position: GeometryAttribute;

		/**
		 * The normal attribute (normalized), which is commonly used for lighting.
		 * <p>
		 * 32-bit floating-point.  3 components per attribute.
		 * </p>
		 * @type GeometryAttribute
		 * @default undefined
		 */
		normal: GeometryAttribute;

		/**
		 * The 2D texture coordinate attribute.
		 * <p>
		 * 32-bit floating-point.  2 components per attribute
		 * </p>
		 * @type GeometryAttribute
		 * @default undefined
		 */
		st: GeometryAttribute;

		/**
		 * The bitangent attribute (normalized), which is used for tangent-space effects like bump mapping.
		 * <p>
		 * 32-bit floating-point.  3 components per attribute.
		 * </p>
		 * @type GeometryAttribute
		 * @default undefined
		 */
		bitangent: GeometryAttribute;

		/**
		 * The tangent attribute (normalized), which is used for tangent-space effects like bump mapping.
		 * <p>
		 * 32-bit floating-point.  3 components per attribute.
		 * </p>
		 * @type GeometryAttribute
		 * @default undefined
		 */
		tangent: GeometryAttribute;

		/**
		 * The color attribute.
		 * <p>
		 * 8-bit unsigned integer. 4 components per attribute.
		 * </p>
		 * @type GeometryAttribute
		 * @default undefined
		 */
		color: GeometryAttribute;

	}

	/**
	 * Geometry instancing allows one {@link Geometry} object to be positions in several
	 * different locations and colored uniquely.  For example, one {@link BoxGeometry} can
	 * be instanced several times, each with a different <code>modelMatrix</code> to change
	 * its position, rotation, and scale.
	 * @alias GeometryInstance
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Geometry} options.geometry The geometry to instance.
	 * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The model matrix that transforms to transform the geometry from model to world coordinates.
	 * @param {Object} [options.id] A user-defined object to return when the instance is picked with {@link Scene#pick} or get/set per-instance attributes with {@link Primitive#getGeometryInstanceAttributes}.
	 * @param {Object} [options.attributes] Per-instance attributes like a show or color attribute shown in the example below.
	 * @example
	 * // Create geometry for a box, and two instances that refer to it.
	 * // One instance positions the box on the bottom and colored aqua.
	 * // The other instance positions the box on the top and color white.
	 * var geometry = Cesium.BoxGeometry.fromDimensions({
	 *   vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL,
	 *   dimensions : new Cesium.Cartesian3(1000000.0, 1000000.0, 500000.0)
	 * });
	 * var instanceBottom = new Cesium.GeometryInstance({
	 *   geometry : geometry,
	 *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(
	 *     Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),
	 *   attributes : {
	 *     color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)
	 *   },
	 *   id : 'bottom'
	 * });
	 * var instanceTop = new Cesium.GeometryInstance({
	 *   geometry : geometry,
	 *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(
	 *     Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 3000000.0), new Cesium.Matrix4()),
	 *   attributes : {
	 *     color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)
	 *   },
	 *   id : 'top'
	 * });
	 * @see Geometry
	 */
	class GeometryInstance {
		constructor(options: {
			geometry: GeometryTypes;
			modelMatrix?: Matrix4;
			id?: any;
			attributes?: any;
		});

		/**
		 * The geometry being instanced.
		 * @type Geometry
		 * @default undefined
		 */
		geometry: Geometry;

		/**
		 * The 4x4 transformation matrix that transforms the geometry from model to world coordinates.
		 * When this is the identity matrix, the geometry is drawn in world coordinates, i.e., Earth's WGS84 coordinates.
		 * Local reference frames can be used by providing a different transformation matrix, like that returned
		 * by {@link Transforms.eastNorthUpToFixedFrame}.
		 * @type Matrix4
		 * @default Matrix4.IDENTITY
		 */
		modelMatrix: Matrix4;

		/**
		 * User-defined object returned when the instance is picked or used to get/set per-instance attributes.
		 * @type Object
		 * @default undefined
		 * @see Scene#pick
		 * @see Primitive#getGeometryInstanceAttributes
		 */
		id: any;

		/**
		 * Per-instance attributes like {@link ColorGeometryInstanceAttribute} or {@link ShowGeometryInstanceAttribute}.
		 * {@link Geometry} attributes varying per vertex; these attributes are constant for the entire instance.
		 * @type Object
		 * @default undefined
		 */
		attributes: any;

	}

	/**
	 * Values and type information for per-instance geometry attributes.
	 * @alias GeometryInstanceAttribute
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {ComponentDatatype} options.componentDatatype The datatype of each component in the attribute, e.g., individual elements in values.
	 * @param {Number} options.componentsPerAttribute A number between 1 and 4 that defines the number of components in an attributes.
	 * @param {Boolean} [options.normalize=false] When <code>true</code> and <code>componentDatatype</code> is an integer format, indicate that the components should be mapped to the range [0, 1] (unsigned) or [-1, 1] (signed) when they are accessed as floating-point for rendering.
	 * @param {Number[]} options.value The value for the attribute.
	 * @exception {DeveloperError} options.componentsPerAttribute must be between 1 and 4.
	 * @example
	 * var instance = new Cesium.GeometryInstance({
	 *   geometry : Cesium.BoxGeometry.fromDimensions({
	 *     dimensions : new Cesium.Cartesian3(1000000.0, 1000000.0, 500000.0)
	 *   }),
	 *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(
	 *     Cesium.Cartesian3.fromDegrees(0.0, 0.0)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),
	 *   id : 'box',
	 *   attributes : {
	 *     color : new Cesium.GeometryInstanceAttribute({
	 *       componentDatatype : Cesium.ComponentDatatype.UNSIGNED_BYTE,
	 *       componentsPerAttribute : 4,
	 *       normalize : true,
	 *       value : [255, 255, 0, 255]
	 *     })
	 *   }
	 * });
	 * @see ColorGeometryInstanceAttribute
	 * @see ShowGeometryInstanceAttribute
	 * @see DistanceDisplayConditionGeometryInstanceAttribute
	 */
	class GeometryInstanceAttribute {
		constructor(options: {
			componentDatatype: any;
			componentsPerAttribute: number;
			normalize?: boolean;
			value: number[];
		});

		/**
		 * The datatype of each component in the attribute, e.g., individual elements in
		 * {@link GeometryInstanceAttribute#value}.
		 * @type ComponentDatatype
		 * @default undefined
		 */
		componentDatatype: any;

		/**
		 * A number between 1 and 4 that defines the number of components in an attributes.
		 * For example, a position attribute with x, y, and z components would have 3 as
		 * shown in the code example.
		 * @type Number
		 * @default undefined
		 * @example
		 * show : new Cesium.GeometryInstanceAttribute({
		 *   componentDatatype : Cesium.ComponentDatatype.UNSIGNED_BYTE,
		 *   componentsPerAttribute : 1,
		 *   normalize : true,
		 *   value : [1.0]
		 * })
		 */
		componentsPerAttribute: number;

		/**
		 * When <code>true</code> and <code>componentDatatype</code> is an integer format,
		 * indicate that the components should be mapped to the range [0, 1] (unsigned)
		 * or [-1, 1] (signed) when they are accessed as floating-point for rendering.
		 * <p>
		 * This is commonly used when storing colors using {@link ComponentDatatype.UNSIGNED_BYTE}.
		 * </p>
		 * @type Boolean
		 * @default false
		 * @example
		 * attribute.componentDatatype = Cesium.ComponentDatatype.UNSIGNED_BYTE;
		 * attribute.componentsPerAttribute = 4;
		 * attribute.normalize = true;
		 * attribute.value = [
		 *   Cesium.Color.floatToByte(color.red),
		 *   Cesium.Color.floatToByte(color.green),
		 *   Cesium.Color.floatToByte(color.blue),
		 *   Cesium.Color.floatToByte(color.alpha)
		 * ];
		 */
		normalize: boolean;

		/**
		 * The values for the attributes stored in a typed array.  In the code example,
		 * every three elements in <code>values</code> defines one attributes since
		 * <code>componentsPerAttribute</code> is 3.
		 * @type {Number[]}
		 * @default undefined
		 * @example
		 * show : new Cesium.GeometryInstanceAttribute({
		 *   componentDatatype : Cesium.ComponentDatatype.UNSIGNED_BYTE,
		 *   componentsPerAttribute : 1,
		 *   normalize : true,
		 *   value : [1.0]
		 * })
		 */
		value: number[];

	}

	/**
	 * Content pipeline functions for geometries.
	 * @exports GeometryPipeline
	 * @see Geometry
	 */
	namespace GeometryPipeline {
		/**
		 * Converts a geometry's triangle indices to line indices.  If the geometry has an <code>indices</code>
		 * and its <code>primitiveType</code> is <code>TRIANGLES</code>, <code>TRIANGLE_STRIP</code>,
		 * <code>TRIANGLE_FAN</code>, it is converted to <code>LINES</code>; otherwise, the geometry is not changed.
		 * <p>
		 * This is commonly used to create a wireframe geometry for visual debugging.
		 * </p>
		 * @param {Geometry} geometry The geometry to modify.
		 * @returns {Geometry} The modified <code>geometry</code> argument, with its triangle indices converted to lines.
		 * @exception {DeveloperError} geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.
		 * @example
		 * geometry = Cesium.GeometryPipeline.toWireframe(geometry);
		 */
		function toWireframe(geometry: Geometry): Geometry;

		/**
		 * Creates a new {@link Geometry} with <code>LINES</code> representing the provided
		 * attribute (<code>attributeName</code>) for the provided geometry.  This is used to
		 * visualize vector attributes like normals, tangents, and bitangents.
		 * @param {Geometry} geometry The <code>Geometry</code> instance with the attribute.
		 * @param {String} [attributeName='normal'] The name of the attribute.
		 * @param {Number} [length=10000.0] The length of each line segment in meters.  This can be negative to point the vector in the opposite direction.
		 * @returns {Geometry} A new <code>Geometry</code> instance with line segments for the vector.
		 * @exception {DeveloperError} geometry.attributes must have an attribute with the same name as the attributeName parameter.
		 * @example
		 * var geometry = Cesium.GeometryPipeline.createLineSegmentsForVectors(instance.geometry, 'bitangent', 100000.0);
		 */
		function createLineSegmentsForVectors(geometry: Geometry, attributeName?: string, length?: number): Geometry;

		/**
		 * Creates an object that maps attribute names to unique locations (indices)
		 * for matching vertex attributes and shader programs.
		 * @param {Geometry} geometry The geometry, which is not modified, to create the object for.
		 * @returns {Object} An object with attribute name / index pairs.
		 * @example
		 * var attributeLocations = Cesium.GeometryPipeline.createAttributeLocations(geometry);
		 * // Example output
		 * // {
		 * //   'position' : 0,
		 * //   'normal' : 1
		 * // }
		 */
		function createAttributeLocations(geometry: Geometry): any;

		/**
		 * Reorders a geometry's attributes and <code>indices</code> to achieve better performance from the GPU's pre-vertex-shader cache.
		 * @param {Geometry} geometry The geometry to modify.
		 * @returns {Geometry} The modified <code>geometry</code> argument, with its attributes and indices reordered for the GPU's pre-vertex-shader cache.
		 * @exception {DeveloperError} Each attribute array in geometry.attributes must have the same number of attributes.
		 * @example
		 * geometry = Cesium.GeometryPipeline.reorderForPreVertexCache(geometry);
		 * @see GeometryPipeline.reorderForPostVertexCache
		 */
		function reorderForPreVertexCache(geometry: Geometry): Geometry;

		/**
		 * Reorders a geometry's <code>indices</code> to achieve better performance from the GPU's
		 * post vertex-shader cache by using the Tipsify algorithm.  If the geometry <code>primitiveType</code>
		 * is not <code>TRIANGLES</code> or the geometry does not have an <code>indices</code>, this function has no effect.
		 * @param {Geometry} geometry The geometry to modify.
		 * @param {Number} [cacheCapacity=24] The number of vertices that can be held in the GPU's vertex cache.
		 * @returns {Geometry} The modified <code>geometry</code> argument, with its indices reordered for the post-vertex-shader cache.
		 * @exception {DeveloperError} cacheCapacity must be greater than two.
		 * @example
		 * geometry = Cesium.GeometryPipeline.reorderForPostVertexCache(geometry);
		 * @see GeometryPipeline.reorderForPreVertexCache
		 * @see {@link http://gfx.cs.princ0eton.edu/pubs/Sander_2007_%3ETR/tipsy.pdf|Fast Triangle Reordering for Vertex Locality and Reduced Overdraw}
		 * by Sander, Nehab, and Barczak
		 */
		function reorderForPostVertexCache(geometry: Geometry, cacheCapacity?: number): Geometry;

		/**
		 * Splits a geometry into multiple geometries, if necessary, to ensure that indices in the
		 * <code>indices</code> fit into unsigned shorts.  This is used to meet the WebGL requirements
		 * when unsigned int indices are not supported.
		 * <p>
		 * If the geometry does not have any <code>indices</code>, this function has no effect.
		 * </p>
		 * @param {Geometry} geometry The geometry to be split into multiple geometries.
		 * @returns {Geometry[]} An array of geometries, each with indices that fit into unsigned shorts.
		 * @exception {DeveloperError} geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS
		 * @exception {DeveloperError} All geometry attribute lists must have the same number of attributes.
		 * @example
		 * var geometries = Cesium.GeometryPipeline.fitToUnsignedShortIndices(geometry);
		 */
		function fitToUnsignedShortIndices(geometry: Geometry): (Geometry)[];

		/**
		 * Projects a geometry's 3D <code>position</code> attribute to 2D, replacing the <code>position</code>
		 * attribute with separate <code>position3D</code> and <code>position2D</code> attributes.
		 * <p>
		 * If the geometry does not have a <code>position</code>, this function has no effect.
		 * </p>
		 * @param {Geometry} geometry The geometry to modify.
		 * @param {String} attributeName The name of the attribute.
		 * @param {String} attributeName3D The name of the attribute in 3D.
		 * @param {String} attributeName2D The name of the attribute in 2D.
		 * @param {Object} [projection=new GeographicProjection()] The projection to use.
		 * @returns {Geometry} The modified <code>geometry</code> argument with <code>position3D</code> and <code>position2D</code> attributes.
		 * @exception {DeveloperError} geometry must have attribute matching the attributeName argument.
		 * @exception {DeveloperError} The attribute componentDatatype must be ComponentDatatype.DOUBLE.
		 * @exception {DeveloperError} Could not project a point to 2D.
		 * @example
		 * geometry = Cesium.GeometryPipeline.projectTo2D(geometry, 'position', 'position3D', 'position2D');
		 */
		function projectTo2D(geometry: Geometry, attributeName: string, attributeName3D: string, attributeName2D: string, projection?: any): Geometry;

		/**
		 * Encodes floating-point geometry attribute values as two separate attributes to improve
		 * rendering precision.
		 * <p>
		 * This is commonly used to create high-precision position vertex attributes.
		 * </p>
		 * @param {Geometry} geometry The geometry to modify.
		 * @param {String} attributeName The name of the attribute.
		 * @param {String} attributeHighName The name of the attribute for the encoded high bits.
		 * @param {String} attributeLowName The name of the attribute for the encoded low bits.
		 * @returns {Geometry} The modified <code>geometry</code> argument, with its encoded attribute.
		 * @exception {DeveloperError} geometry must have attribute matching the attributeName argument.
		 * @exception {DeveloperError} The attribute componentDatatype must be ComponentDatatype.DOUBLE.
		 * @example
		 * geometry = Cesium.GeometryPipeline.encodeAttribute(geometry, 'position3D', 'position3DHigh', 'position3DLow');
		 */
		function encodeAttribute(geometry: Geometry, attributeName: string, attributeHighName: string, attributeLowName: string): Geometry;

		/**
		 * Transforms a geometry instance to world coordinates.  This changes
		 * the instance's <code>modelMatrix</code> to {@link Matrix4.IDENTITY} and transforms the
		 * following attributes if they are present: <code>position</code>, <code>normal</code>,
		 * <code>tangent</code>, and <code>bitangent</code>.
		 * @param {GeometryInstance} instance The geometry instance to modify.
		 * @returns {GeometryInstance} The modified <code>instance</code> argument, with its attributes transforms to world coordinates.
		 * @example
		 * Cesium.GeometryPipeline.transformToWorldCoordinates(instance);
		 */
		function transformToWorldCoordinates(instance: GeometryInstance): GeometryInstance;

		/**
		 * Computes per-vertex normals for a geometry containing <code>TRIANGLES</code> by averaging the normals of
		 * all triangles incident to the vertex.  The result is a new <code>normal</code> attribute added to the geometry.
		 * This assumes a counter-clockwise winding order.
		 * @param {Geometry} geometry The geometry to modify.
		 * @returns {Geometry} The modified <code>geometry</code> argument with the computed <code>normal</code> attribute.
		 * @exception {DeveloperError} geometry.indices length must be greater than 0 and be a multiple of 3.
		 * @exception {DeveloperError} geometry.primitiveType must be {@link PrimitiveType.TRIANGLES}.
		 * @example
		 * Cesium.GeometryPipeline.computeNormal(geometry);
		 */
		function computeNormal(geometry: Geometry): Geometry;

		/**
		 * Computes per-vertex tangents and bitangents for a geometry containing <code>TRIANGLES</code>.
		 * The result is new <code>tangent</code> and <code>bitangent</code> attributes added to the geometry.
		 * This assumes a counter-clockwise winding order.
		 * <p>
		 * Based on <a href="http://www.terathon.com/code/tangent.html">Computing Tangent Space Basis Vectors
		 * for an Arbitrary Mesh</a> by Eric Lengyel.
		 * </p>
		 * @param {Geometry} geometry The geometry to modify.
		 * @returns {Geometry} The modified <code>geometry</code> argument with the computed <code>tangent</code> and <code>bitangent</code> attributes.
		 * @exception {DeveloperError} geometry.indices length must be greater than 0 and be a multiple of 3.
		 * @exception {DeveloperError} geometry.primitiveType must be {@link PrimitiveType.TRIANGLES}.
		 * @example
		 * Cesium.GeometryPipeline.computeTangentAndBiTangent(geometry);
		 */
		function computeTangentAndBitangent(geometry: Geometry): Geometry;

		/**
		 * Compresses and packs geometry normal attribute values to save memory.
		 * @param {Geometry} geometry The geometry to modify.
		 * @returns {Geometry} The modified <code>geometry</code> argument, with its normals compressed and packed.
		 * @example
		 * geometry = Cesium.GeometryPipeline.compressVertices(geometry);
		 */
		function compressVertices(geometry: Geometry): Geometry;

	}

	/**
	 * Given a relative Uri and a base Uri, returns the absolute Uri of the relative Uri.
	 * @exports getAbsoluteUri
	 * @param {String} relative The relative Uri.
	 * @param {String} [base] The base Uri.
	 * @returns {String} The absolute Uri of the given relative Uri.
	 * @example
	 * //absolute Uri will be "https://test.com/awesome.png";
	 * var absoluteUri = Cesium.getAbsoluteUri('awesome.png', 'https://test.com');
	 */
	namespace getAbsoluteUri {
	}

	/**
	 * Given a URI, returns the base path of the URI.
	 * @exports getBaseUri
	 * @param {String} uri The Uri.
	 * @param {Boolean} [includeQuery = false] Whether or not to include the query string and fragment form the uri
	 * @returns {String} The base path of the Uri.
	 * @example
	 * // basePath will be "/Gallery/";
	 * var basePath = Cesium.getBaseUri('/Gallery/simple.czml?value=true&example=false');
	 * // basePath will be "/Gallery/?value=true&example=false";
	 * var basePath = Cesium.getBaseUri('/Gallery/simple.czml?value=true&example=false', true);
	 */
	namespace getBaseUri {
	}

	/**
	 * Given a URI, returns the extension of the URI.
	 * @exports getExtensionFromUri
	 * @param {String} uri The Uri.
	 * @returns {String} The extension of the Uri.
	 * @example
	 * //extension will be "czml";
	 * var extension = Cesium.getExtensionFromUri('/Gallery/simple.czml?value=true&example=false');
	 */
	namespace getExtensionFromUri {
	}

	/**
	 * Given a URI, returns the last segment of the URI, removing any path or query information.
	 * @exports getFilenameFromUri
	 * @param {String} uri The Uri.
	 * @returns {String} The last segment of the Uri.
	 * @example
	 * //fileName will be"simple.czml";
	 * var fileName = Cesium.getFilenameFromUri('/Gallery/simple.czml?value=true&example=false');
	 */
	namespace getFilenameFromUri {
	}

	/**
	 * Extract a pixel array from a loaded image.  Draws the image
	 * into a canvas so it can read the pixels back.
	 * @exports getImagePixels
	 * @param {Image} image The image to extract pixels from.
	 * @param {Number} width The width of the image. If not defined, then image.width is assigned.
	 * @param {Number} height The height of the image. If not defined, then image.height is assigned.
	 * @returns {CanvasPixelArray} The pixels of the image.
	 */
	namespace getImagePixels {
	}

	/**
	 * Gets a timestamp that can be used in measuring the time between events.  Timestamps
	 * are expressed in milliseconds, but it is not specified what the milliseconds are
	 * measured from.  This function uses performance.now() if it is available, or Date.now()
	 * otherwise.
	 * @exports getTimestamp
	 * @returns {Number} The timestamp in milliseconds since some unspecified reference time.
	 */
	namespace getTimestamp {
	}

	/**
	 * Provides metadata using the Google Earth Enterprise REST API. This is used by the GoogleEarthEnterpriseImageryProvider
	 *  and GoogleEarthEnterpriseTerrainProvider to share metadata requests.
	 * @alias GoogleEarthEnterpriseMetadata
	 * @constructor
	 * @param {Resource|String} resourceOrUrl The url of the Google Earth Enterprise server hosting the imagery
	 * @see GoogleEarthEnterpriseImageryProvider
	 * @see GoogleEarthEnterpriseTerrainProvider
	 */
	class GoogleEarthEnterpriseMetadata {
		constructor(resourceOrUrl: Resource | string);

		/**
		 * True if imagery is available.
		 * @type {Boolean}
		 * @default true
		 */
		imageryPresent: boolean;

		/**
		 * True if imagery is sent as a protocol buffer, false if sent as plain images. If undefined we will try both.
		 * @type {Boolean}
		 * @default undefined
		 */
		protoImagery: boolean;

		/**
		 * True if terrain is available.
		 * @type {Boolean}
		 * @default true
		 */
		terrainPresent: boolean;

		/**
		 * Exponent used to compute constant to calculate negative height values.
		 * @type {Number}
		 * @default 32
		 */
		negativeAltitudeExponentBias: number;

		/**
		 * Threshold where any numbers smaller are actually negative values. They are multiplied by -2^negativeAltitudeExponentBias.
		 * @type {Number}
		 * @default EPSILON12
		 */
		negativeAltitudeThreshold: number;

		/**
		 * Dictionary of provider id to copyright strings.
		 * @type {Object}
		 * @default {}
		 */
		providers: any;

		/**
		 * Key used to decode packets
		 * @type {ArrayBuffer}
		 */
		key: ArrayBuffer;

		/**
		 * Gets the name of the Google Earth Enterprise server.
		 * @memberof GoogleEarthEnterpriseMetadata.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly url: string;

		/**
		 * Gets the proxy used for metadata requests.
		 * @memberof GoogleEarthEnterpriseMetadata.prototype
		 * @type {Proxy}
		 * @readonly
		 */
		readonly proxy: Proxy;

		/**
		 * Gets the resource used for metadata requests.
		 * @memberof GoogleEarthEnterpriseMetadata.prototype
		 * @type {Resource}
		 * @readonly
		 */
		readonly resource: Resource;

		/**
		 * Gets a promise that resolves to true when the metadata is ready for use.
		 * @memberof GoogleEarthEnterpriseMetadata.prototype
		 * @type {Promise.<Boolean>}
		 * @readonly
		 */
		readonly readyPromise: any;

		/**
		 * Converts a tiles (x, y, level) position into a quadkey used to request an image
		 * from a Google Earth Enterprise server.
		 * @param {Number} x The tile's x coordinate.
		 * @param {Number} y The tile's y coordinate.
		 * @param {Number} level The tile's zoom level.
		 * @see GoogleEarthEnterpriseMetadata#quadKeyToTileXY
		 */
		static tileXYToQuadKey(x: number, y: number, level: number): void;

		/**
		 * Converts a tile's quadkey used to request an image from a Google Earth Enterprise server into the
		 * (x, y, level) position.
		 * @param {String} quadkey The tile's quad key
		 * @see GoogleEarthEnterpriseMetadata#tileXYToQuadKey
		 */
		static quadKeyToTileXY(quadkey: string): void;

	}

	/**
	 * Terrain data for a single tile from a Google Earth Enterprise server.
	 * @alias GoogleEarthEnterpriseTerrainData
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {ArrayBuffer} options.buffer The buffer containing terrain data.
	 * @param {Number} options.negativeAltitudeExponentBias Multiplier for negative terrain heights that are encoded as very small positive values.
	 * @param {Number} options.negativeElevationThreshold Threshold for negative values
	 * @param {Number} [options.childTileMask=15] A bit mask indicating which of this tile's four children exist.
	 *                 If a child's bit is set, geometry will be requested for that tile as well when it
	 *                 is needed.  If the bit is cleared, the child tile is not requested and geometry is
	 *                 instead upsampled from the parent.  The bit values are as follows:
	 *                 <table>
	 *                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>
	 *                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>
	 *                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>
	 *                  <tr><td>2</td><td>4</td><td>Northeast</td></tr>
	 *                  <tr><td>3</td><td>8</td><td>Northwest</td></tr>
	 *                 </table>
	 * @param {Boolean} [options.createdByUpsampling=false] True if this instance was created by upsampling another instance;
	 *                  otherwise, false.
	 * @param {Credit[]} [options.credits] Array of credits for this tile.
	 * @example
	 * var buffer = ...
	 * var childTileMask = ...
	 * var terrainData = new Cesium.GoogleEarthEnterpriseTerrainData({
	 *   buffer : heightBuffer,
	 *   childTileMask : childTileMask
	 * });
	 * @see TerrainData
	 * @see HeightTerrainData
	 * @see QuantizedMeshTerrainData
	 */
	class GoogleEarthEnterpriseTerrainData {
		constructor(options: {
			buffer: ArrayBuffer;
			negativeAltitudeExponentBias: number;
			negativeElevationThreshold: number;
			childTileMask?: number;
			createdByUpsampling?: boolean;
			credits?: (Credit)[];
		});

		/**
		 * An array of credits for this tile
		 * @memberof GoogleEarthEnterpriseTerrainData.prototype
		 * @type {Credit[]}
		 */
		credits: (Credit)[];

		/**
		 * The water mask included in this terrain data, if any.  A water mask is a rectangular
		 * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.
		 * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.
		 * @memberof GoogleEarthEnterpriseTerrainData.prototype
		 * @type {Uint8Array|Image|Canvas}
		 */
		waterMask: Uint8Array | any | any;

		/**
		 * Computes the terrain height at a specified longitude and latitude.
		 * @param {Rectangle} rectangle The rectangle covered by this terrain data.
		 * @param {Number} longitude The longitude in radians.
		 * @param {Number} latitude The latitude in radians.
		 * @returns {Number} The terrain height at the specified position.  If the position
		 *          is outside the rectangle, this method will extrapolate the height, which is likely to be wildly
		 *          incorrect for positions far outside the rectangle.
		 */
		interpolateHeight(rectangle: Rectangle, longitude: number, latitude: number): number;

		/**
		 * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the
		 * height samples in this instance, interpolated if necessary.
		 * @param {TilingScheme} tilingScheme The tiling scheme of this terrain data.
		 * @param {Number} thisX The X coordinate of this tile in the tiling scheme.
		 * @param {Number} thisY The Y coordinate of this tile in the tiling scheme.
		 * @param {Number} thisLevel The level of this tile in the tiling scheme.
		 * @param {Number} descendantX The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.
		 * @param {Number} descendantY The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.
		 * @param {Number} descendantLevel The level within the tiling scheme of the descendant tile for which we are upsampling.
		 * @returns {Promise.<HeightmapTerrainData>|undefined} A promise for upsampled heightmap terrain data for the descendant tile,
		 *          or undefined if too many asynchronous upsample operations are in progress and the request has been
		 *          deferred.
		 */
		upsample(tilingScheme: TilingScheme, thisX: number, thisY: number, thisLevel: number, descendantX: number, descendantY: number, descendantLevel: number): any | undefined;

		/**
		 * Determines if a given child tile is available, based on the
		 * {@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed
		 * to be one of the four children of this tile.  If non-child tile coordinates are
		 * given, the availability of the southeast child tile is returned.
		 * @param {Number} thisX The tile X coordinate of this (the parent) tile.
		 * @param {Number} thisY The tile Y coordinate of this (the parent) tile.
		 * @param {Number} childX The tile X coordinate of the child tile to check for availability.
		 * @param {Number} childY The tile Y coordinate of the child tile to check for availability.
		 * @returns {Boolean} True if the child tile is available; otherwise, false.
		 */
		isChildAvailable(thisX: number, thisY: number, childX: number, childY: number): boolean;

		/**
		 * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution
		 * terrain data.  If this value is false, the data was obtained from some other source, such
		 * as by downloading it from a remote server.  This method should return true for instances
		 * returned from a call to {@link HeightmapTerrainData#upsample}.
		 * @returns {Boolean} True if this instance was created by upsampling; otherwise, false.
		 */
		wasCreatedByUpsampling(): boolean;

	}

	/**
	 * Provides tiled terrain using the Google Earth Enterprise REST API.
	 * @alias GoogleEarthEnterpriseTerrainProvider
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Resource|String} options.url The url of the Google Earth Enterprise server hosting the imagery.
	 * @param {GoogleEarthEnterpriseMetadata} options.metadata A metadata object that can be used to share metadata requests with a GoogleEarthEnterpriseImageryProvider.
	 * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If not specified, the WGS84 ellipsoid is used.
	 * @param {Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.
	 * @see GoogleEarthEnterpriseImageryProvider
	 * @see CesiumTerrainProvider
	 * @example
	 * var geeMetadata = new GoogleEarthEnterpriseMetadata('http://www.earthenterprise.org/3d');
	 * var gee = new Cesium.GoogleEarthEnterpriseTerrainProvider({
	 *     metadata : geeMetadata
	 * });
	 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
	 */
	class GoogleEarthEnterpriseTerrainProvider {
		constructor(options: {
			url: Resource | string;
			metadata: GoogleEarthEnterpriseMetadata;
			ellipsoid?: Ellipsoid;
			credit?: Credit | string;
		});

		/**
		 * Gets the name of the Google Earth Enterprise server url hosting the imagery.
		 * @memberof GoogleEarthEnterpriseTerrainProvider.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly url: string;

		/**
		 * Gets the proxy used by this provider.
		 * @memberof GoogleEarthEnterpriseTerrainProvider.prototype
		 * @type {Proxy}
		 * @readonly
		 */
		readonly proxy: Proxy;

		/**
		 * Gets the tiling scheme used by this provider.  This function should
		 * not be called before {@link GoogleEarthEnterpriseTerrainProvider#ready} returns true.
		 * @memberof GoogleEarthEnterpriseTerrainProvider.prototype
		 * @type {TilingScheme}
		 * @readonly
		 */
		readonly tilingScheme: TilingScheme;

		/**
		 * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
		 * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
		 * are passed an instance of {@link TileProviderError}.
		 * @memberof GoogleEarthEnterpriseTerrainProvider.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly errorEvent: Event;

		/**
		 * Gets a value indicating whether or not the provider is ready for use.
		 * @memberof GoogleEarthEnterpriseTerrainProvider.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly ready: boolean;

		/**
		 * Gets a promise that resolves to true when the provider is ready for use.
		 * @memberof GoogleEarthEnterpriseTerrainProvider.prototype
		 * @type {Promise.<Boolean>}
		 * @readonly
		 */
		readonly readyPromise: any;

		/**
		 * Gets the credit to display when this terrain provider is active.  Typically this is used to credit
		 * the source of the terrain.  This function should not be called before {@link GoogleEarthEnterpriseTerrainProvider#ready} returns true.
		 * @memberof GoogleEarthEnterpriseTerrainProvider.prototype
		 * @type {Credit}
		 * @readonly
		 */
		readonly credit: Credit;

		/**
		 * Gets a value indicating whether or not the provider includes a water mask.  The water mask
		 * indicates which areas of the globe are water rather than land, so they can be rendered
		 * as a reflective surface with animated waves.  This function should not be
		 * called before {@link GoogleEarthEnterpriseTerrainProvider#ready} returns true.
		 * @memberof GoogleEarthEnterpriseTerrainProvider.prototype
		 * @type {Boolean}
		 */
		hasWaterMask: boolean;

		/**
		 * Gets a value indicating whether or not the requested tiles include vertex normals.
		 * This function should not be called before {@link GoogleEarthEnterpriseTerrainProvider#ready} returns true.
		 * @memberof GoogleEarthEnterpriseTerrainProvider.prototype
		 * @type {Boolean}
		 */
		hasVertexNormals: boolean;

		/**
		 * Gets an object that can be used to determine availability of terrain from this provider, such as
		 * at points and in rectangles.  This function should not be called before
		 * {@link GoogleEarthEnterpriseTerrainProvider#ready} returns true.  This property may be undefined if availability
		 * information is not available.
		 * @memberof GoogleEarthEnterpriseTerrainProvider.prototype
		 * @type {TileAvailability}
		 */
		availability: TileAvailability;

		/**
		 * Requests the geometry for a given tile.  This function should not be called before
		 * {@link GoogleEarthEnterpriseTerrainProvider#ready} returns true.  The result must include terrain data and
		 * may optionally include a water mask and an indication of which child tiles are available.
		 * @param {Number} x The X coordinate of the tile for which to request geometry.
		 * @param {Number} y The Y coordinate of the tile for which to request geometry.
		 * @param {Number} level The level of the tile for which to request geometry.
		 * @param {Request} [request] The request object. Intended for internal use only.
		 * @returns {Promise.<TerrainData>|undefined} A promise for the requested geometry.  If this method
		 *          returns undefined instead of a promise, it is an indication that too many requests are already
		 *          pending and the request will be retried later.
		 * @exception {DeveloperError} This function must not be called before {@link GoogleEarthEnterpriseTerrainProvider#ready}
		 *            returns true.
		 */
		requestTileGeometry(x: number, y: number, level: number, request?: Request): any | undefined;

		/**
		 * Gets the maximum geometric error allowed in a tile at a given level.
		 * @param {Number} level The tile level for which to get the maximum geometric error.
		 * @returns {Number} The maximum geometric error.
		 */
		getLevelMaximumGeometricError(level: number): number;

		/**
		 * Determines whether data for a tile is available to be loaded.
		 * @param {Number} x The X coordinate of the tile for which to request geometry.
		 * @param {Number} y The Y coordinate of the tile for which to request geometry.
		 * @param {Number} level The level of the tile for which to request geometry.
		 * @returns {Boolean} Undefined if not supported, otherwise true or false.
		 */
		getTileDataAvailable(x: number, y: number, level: number): boolean;

	}

	/**
	 * Represents a Gregorian date in a more precise format than the JavaScript Date object.
	 * In addition to submillisecond precision, this object can also represent leap seconds.
	 * @alias GregorianDate
	 * @constructor
	 * @see JulianDate#toGregorianDate
	 */
	class GregorianDate {
		constructor();

		/**
		 * Gets or sets the year as a whole number.
		 * @type {Number}
		 */
		year: number;

		/**
		 * Gets or sets the month as a whole number with range [1, 12].
		 * @type {Number}
		 */
		month: number;

		/**
		 * Gets or sets the day of the month as a whole number starting at 1.
		 * @type {Number}
		 */
		day: number;

		/**
		 * Gets or sets the hour as a whole number with range [0, 23].
		 * @type {Number}
		 */
		hour: number;

		/**
		 * Gets or sets the minute of the hour as a whole number with range [0, 59].
		 * @type {Number}
		 */
		minute: number;

		/**
		 * Gets or sets the second of the minute as a whole number with range [0, 60], with 60 representing a leap second.
		 * @type {Number}
		 */
		second: number;

		/**
		 * Gets or sets the millisecond of the second as a floating point number with range [0.0, 1000.0).
		 * @type {Number}
		 */
		millisecond: number;

		/**
		 * Gets or sets whether this time is during a leap second.
		 * @type {Boolean}
		 */
		isLeapSecond: boolean;

	}

	/**
	 * A description of a polyline on terrain. Only to be used with {@link GroundPolylinePrimitive}.
	 * @alias GroundPolylineGeometry
	 * @constructor
	 * @param {Object} options Options with the following properties:
	 * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the polyline's points. Heights above the ellipsoid will be ignored.
	 * @param {Number} [options.width=1.0] The screen space width in pixels.
	 * @param {Number} [options.granularity=9999.0] The distance interval in meters used for interpolating options.points. Defaults to 9999.0 meters. Zero indicates no interpolation.
	 * @param {Boolean} [options.loop=false] Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.
	 * @exception {DeveloperError} At least two positions are required.
	 * @see GroundPolylinePrimitive
	 * @example
	 * var positions = Cesium.Cartesian3.fromDegreesArray([
	 *   -112.1340164450331, 36.05494287836128,
	 *   -112.08821010582645, 36.097804071380715,
	 *   -112.13296079730024, 36.168769146801104
	 * ]);
	 * var geometry = new Cesium.GroundPolylineGeometry({
	 *   positions : positions
	 * });
	 */
	class GroundPolylineGeometry {
		constructor(options: {
			positions: (Cartesian3)[];
			width?: number;
			granularity?: number;
			loop?: boolean;
		});

		/**
		 * The screen space width in pixels.
		 * @type {Number}
		 */
		width: number;

		/**
		 * The distance interval used for interpolating options.points. Zero indicates no interpolation.
		 * Default of 9999.0 allows centimeter accuracy with 32 bit floating point.
		 * @type {Boolean}
		 * @default 9999.0
		 */
		granularity: boolean;

		/**
		 * Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.
		 * If the geometry has two positions this parameter will be ignored.
		 * @type {Boolean}
		 * @default false
		 */
		loop: boolean;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {PolygonGeometry} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: PolygonGeometry, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {PolygonGeometry} [result] The object into which to store the result.
		 */
		static unpack(array: number[], startingIndex?: number, result?: PolygonGeometry): void;

	}

	/**
	 * Defines a heading angle, pitch angle, and range in a local frame.
	 * Heading is the rotation from the local north direction where a positive angle is increasing eastward.
	 * Pitch is the rotation from the local xy-plane. Positive pitch angles are above the plane. Negative pitch
	 * angles are below the plane. Range is the distance from the center of the frame.
	 * @alias HeadingPitchRange
	 * @constructor
	 * @param {Number} [heading=0.0] The heading angle in radians.
	 * @param {Number} [pitch=0.0] The pitch angle in radians.
	 * @param {Number} [range=0.0] The distance from the center in meters.
	 */
	class HeadingPitchRange {
		constructor(heading?: number, pitch?: number, range?: number);

		/**
		 * Heading is the rotation from the local north direction where a positive angle is increasing eastward.
		 * @type {Number}
		 */
		heading: number;

		/**
		 * Pitch is the rotation from the local xy-plane. Positive pitch angles
		 * are above the plane. Negative pitch angles are below the plane.
		 * @type {Number}
		 */
		pitch: number;

		/**
		 * Range is the distance from the center of the local frame.
		 * @type {Number}
		 */
		range: number;

		/**
		 * Duplicates a HeadingPitchRange instance.
		 * @param {HeadingPitchRange} hpr The HeadingPitchRange to duplicate.
		 * @param {HeadingPitchRange} [result] The object onto which to store the result.
		 * @returns {HeadingPitchRange} The modified result parameter or a new HeadingPitchRange instance if one was not provided. (Returns undefined if hpr is undefined)
		 */
		static clone(hpr: HeadingPitchRange, result?: HeadingPitchRange): HeadingPitchRange;

	}

	/**
	 * A rotation expressed as a heading, pitch, and roll. Heading is the rotation about the
	 * negative z axis. Pitch is the rotation about the negative y axis. Roll is the rotation about
	 * the positive x axis.
	 * @alias HeadingPitchRoll
	 * @constructor
	 * @param {Number} [heading=0.0] The heading component in radians.
	 * @param {Number} [pitch=0.0] The pitch component in radians.
	 * @param {Number} [roll=0.0] The roll component in radians.
	 */
	class HeadingPitchRoll {
		constructor(heading?: number, pitch?: number, roll?: number);

		/**
		 * Computes the heading, pitch and roll from a quaternion (see http://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles )
		 * @param {Quaternion} quaternion The quaternion from which to retrieve heading, pitch, and roll, all expressed in radians.
		 * @param {HeadingPitchRoll} [result] The object in which to store the result. If not provided, a new instance is created and returned.
		 * @returns {HeadingPitchRoll} The modified result parameter or a new HeadingPitchRoll instance if one was not provided.
		 */
		static fromQuaternion(quaternion: Quaternion, result?: HeadingPitchRoll): HeadingPitchRoll;

		/**
		 * Returns a new HeadingPitchRoll instance from angles given in degrees.
		 * @param {Number} heading the heading in degrees
		 * @param {Number} pitch the pitch in degrees
		 * @param {Number} roll the heading in degrees
		 * @param {HeadingPitchRoll} [result] The object in which to store the result. If not provided, a new instance is created and returned.
		 * @returns {HeadingPitchRoll} A new HeadingPitchRoll instance
		 */
		static fromDegrees(heading: number, pitch: number, roll: number, result?: HeadingPitchRoll): HeadingPitchRoll;

		/**
		 * Duplicates a HeadingPitchRoll instance.
		 * @param {HeadingPitchRoll} headingPitchRoll The HeadingPitchRoll to duplicate.
		 * @param {HeadingPitchRoll} [result] The object onto which to store the result.
		 * @returns {HeadingPitchRoll} The modified result parameter or a new HeadingPitchRoll instance if one was not provided. (Returns undefined if headingPitchRoll is undefined)
		 */
		static clone(headingPitchRoll: HeadingPitchRoll, result?: HeadingPitchRoll): HeadingPitchRoll;

		/**
		 * Compares the provided HeadingPitchRolls componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {HeadingPitchRoll} [left] The first HeadingPitchRoll.
		 * @param {HeadingPitchRoll} [right] The second HeadingPitchRoll.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		static equals(left?: HeadingPitchRoll, right?: HeadingPitchRoll): boolean;

		/**
		 * Compares the provided HeadingPitchRolls componentwise and returns
		 * <code>true</code> if they pass an absolute or relative tolerance test,
		 * <code>false</code> otherwise.
		 * @param {HeadingPitchRoll} [left] The first HeadingPitchRoll.
		 * @param {HeadingPitchRoll} [right] The second HeadingPitchRoll.
		 * @param {Number} [relativeEpsilon] The relative epsilon tolerance to use for equality testing.
		 * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
		 * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
		 */
		static equalsEpsilon(left?: HeadingPitchRoll, right?: HeadingPitchRoll, relativeEpsilon?: number, absoluteEpsilon?: number): boolean;

		/**
		 * Duplicates this HeadingPitchRoll instance.
		 * @param {HeadingPitchRoll} [result] The object onto which to store the result.
		 * @returns {HeadingPitchRoll} The modified result parameter or a new HeadingPitchRoll instance if one was not provided.
		 */
		clone(result?: HeadingPitchRoll): HeadingPitchRoll;

		/**
		 * Compares this HeadingPitchRoll against the provided HeadingPitchRoll componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {HeadingPitchRoll} [right] The right hand side HeadingPitchRoll.
		 * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
		 */
		equals(right?: HeadingPitchRoll): boolean;

		/**
		 * Compares this HeadingPitchRoll against the provided HeadingPitchRoll componentwise and returns
		 * <code>true</code> if they pass an absolute or relative tolerance test,
		 * <code>false</code> otherwise.
		 * @param {HeadingPitchRoll} [right] The right hand side HeadingPitchRoll.
		 * @param {Number} [relativeEpsilon] The relative epsilon tolerance to use for equality testing.
		 * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
		 * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
		 */
		equalsEpsilon(right?: HeadingPitchRoll, relativeEpsilon?: number, absoluteEpsilon?: number): boolean;

		/**
		 * Creates a string representing this HeadingPitchRoll in the format '(heading, pitch, roll)' in radians.
		 * @returns {String} A string representing the provided HeadingPitchRoll in the format '(heading, pitch, roll)'.
		 */
		toString(): string;

	}

	/**
	 * Terrain data for a single tile where the terrain data is represented as a heightmap.  A heightmap
	 * is a rectangular array of heights in row-major order from south to north and west to east.
	 * @alias HeightmapTerrainData
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {TypedArray} options.buffer The buffer containing height data.
	 * @param {Number} options.width The width (longitude direction) of the heightmap, in samples.
	 * @param {Number} options.height The height (latitude direction) of the heightmap, in samples.
	 * @param {Number} [options.childTileMask=15] A bit mask indicating which of this tile's four children exist.
	 *                 If a child's bit is set, geometry will be requested for that tile as well when it
	 *                 is needed.  If the bit is cleared, the child tile is not requested and geometry is
	 *                 instead upsampled from the parent.  The bit values are as follows:
	 *                 <table>
	 *                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>
	 *                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>
	 *                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>
	 *                  <tr><td>2</td><td>4</td><td>Northwest</td></tr>
	 *                  <tr><td>3</td><td>8</td><td>Northeast</td></tr>
	 *                 </table>
	 * @param {Object} [options.structure] An object describing the structure of the height data.
	 * @param {Number} [options.structure.heightScale=1.0] The factor by which to multiply height samples in order to obtain
	 *                 the height above the heightOffset, in meters.  The heightOffset is added to the resulting
	 *                 height after multiplying by the scale.
	 * @param {Number} [options.structure.heightOffset=0.0] The offset to add to the scaled height to obtain the final
	 *                 height in meters.  The offset is added after the height sample is multiplied by the
	 *                 heightScale.
	 * @param {Number} [options.structure.elementsPerHeight=1] The number of elements in the buffer that make up a single height
	 *                 sample.  This is usually 1, indicating that each element is a separate height sample.  If
	 *                 it is greater than 1, that number of elements together form the height sample, which is
	 *                 computed according to the structure.elementMultiplier and structure.isBigEndian properties.
	 * @param {Number} [options.structure.stride=1] The number of elements to skip to get from the first element of
	 *                 one height to the first element of the next height.
	 * @param {Number} [options.structure.elementMultiplier=256.0] The multiplier used to compute the height value when the
	 *                 stride property is greater than 1.  For example, if the stride is 4 and the strideMultiplier
	 *                 is 256, the height is computed as follows:
	 *                 `height = buffer[index] + buffer[index + 1] * 256 + buffer[index + 2] * 256 * 256 + buffer[index + 3] * 256 * 256 * 256`
	 *                 This is assuming that the isBigEndian property is false.  If it is true, the order of the
	 *                 elements is reversed.
	 * @param {Boolean} [options.structure.isBigEndian=false] Indicates endianness of the elements in the buffer when the
	 *                  stride property is greater than 1.  If this property is false, the first element is the
	 *                  low-order element.  If it is true, the first element is the high-order element.
	 * @param {Number} [options.structure.lowestEncodedHeight] The lowest value that can be stored in the height buffer.  Any heights that are lower
	 *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height
	 *                 buffer is a `Uint16Array`, this value should be 0 because a `Uint16Array` cannot store negative numbers.  If this parameter is
	 *                 not specified, no minimum value is enforced.
	 * @param {Number} [options.structure.highestEncodedHeight] The highest value that can be stored in the height buffer.  Any heights that are higher
	 *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height
	 *                 buffer is a `Uint16Array`, this value should be `256 * 256 - 1` or 65535 because a `Uint16Array` cannot store numbers larger
	 *                 than 65535.  If this parameter is not specified, no maximum value is enforced.
	 * @param {Boolean} [options.createdByUpsampling=false] True if this instance was created by upsampling another instance;
	 *                  otherwise, false.
	 * @example
	 * var buffer = ...
	 * var heightBuffer = new Uint16Array(buffer, 0, that._heightmapWidth * that._heightmapWidth);
	 * var childTileMask = new Uint8Array(buffer, heightBuffer.byteLength, 1)[0];
	 * var waterMask = new Uint8Array(buffer, heightBuffer.byteLength + 1, buffer.byteLength - heightBuffer.byteLength - 1);
	 * var terrainData = new Cesium.HeightmapTerrainData({
	 *   buffer : heightBuffer,
	 *   width : 65,
	 *   height : 65,
	 *   childTileMask : childTileMask,
	 *   waterMask : waterMask
	 * });
	 * @see TerrainData
	 * @see QuantizedMeshTerrainData
	 */
	class HeightmapTerrainData {
		constructor(options: {
			buffer: any;
			width: number;
			height: number;
			childTileMask?: number;
			structure?: any;
			createdByUpsampling?: boolean;
		});

		/**
		 * An array of credits for this tile.
		 * @memberof HeightmapTerrainData.prototype
		 * @type {Credit[]}
		 */
		credits: (Credit)[];

		/**
		 * The water mask included in this terrain data, if any.  A water mask is a rectangular
		 * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.
		 * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.
		 * @memberof HeightmapTerrainData.prototype
		 * @type {Uint8Array|Image|Canvas}
		 */
		waterMask: Uint8Array | any | any;

		/**
		 * Computes the terrain height at a specified longitude and latitude.
		 * @param {Rectangle} rectangle The rectangle covered by this terrain data.
		 * @param {Number} longitude The longitude in radians.
		 * @param {Number} latitude The latitude in radians.
		 * @returns {Number} The terrain height at the specified position.  If the position
		 *          is outside the rectangle, this method will extrapolate the height, which is likely to be wildly
		 *          incorrect for positions far outside the rectangle.
		 */
		interpolateHeight(rectangle: Rectangle, longitude: number, latitude: number): number;

		/**
		 * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the
		 * height samples in this instance, interpolated if necessary.
		 * @param {TilingScheme} tilingScheme The tiling scheme of this terrain data.
		 * @param {Number} thisX The X coordinate of this tile in the tiling scheme.
		 * @param {Number} thisY The Y coordinate of this tile in the tiling scheme.
		 * @param {Number} thisLevel The level of this tile in the tiling scheme.
		 * @param {Number} descendantX The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.
		 * @param {Number} descendantY The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.
		 * @param {Number} descendantLevel The level within the tiling scheme of the descendant tile for which we are upsampling.
		 * @returns {Promise.<HeightmapTerrainData>|undefined} A promise for upsampled heightmap terrain data for the descendant tile,
		 *          or undefined if too many asynchronous upsample operations are in progress and the request has been
		 *          deferred.
		 */
		upsample(tilingScheme: TilingScheme, thisX: number, thisY: number, thisLevel: number, descendantX: number, descendantY: number, descendantLevel: number): any | undefined;

		/**
		 * Determines if a given child tile is available, based on the
		 * {@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed
		 * to be one of the four children of this tile.  If non-child tile coordinates are
		 * given, the availability of the southeast child tile is returned.
		 * @param {Number} thisX The tile X coordinate of this (the parent) tile.
		 * @param {Number} thisY The tile Y coordinate of this (the parent) tile.
		 * @param {Number} childX The tile X coordinate of the child tile to check for availability.
		 * @param {Number} childY The tile Y coordinate of the child tile to check for availability.
		 * @returns {Boolean} True if the child tile is available; otherwise, false.
		 */
		isChildAvailable(thisX: number, thisY: number, childX: number, childY: number): boolean;

		/**
		 * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution
		 * terrain data.  If this value is false, the data was obtained from some other source, such
		 * as by downloading it from a remote server.  This method should return true for instances
		 * returned from a call to {@link HeightmapTerrainData#upsample}.
		 * @returns {Boolean} True if this instance was created by upsampling; otherwise, false.
		 */
		wasCreatedByUpsampling(): boolean;

	}

	/**
	 * An {@link InterpolationAlgorithm} for performing Hermite interpolation.
	 * @exports HermitePolynomialApproximation
	 */
	namespace HermitePolynomialApproximation {
		/**
		 * Given the desired degree, returns the number of data points required for interpolation.
		 * @param {Number} degree The desired degree of interpolation.
		 * @param {Number} [inputOrder=0]  The order of the inputs (0 means just the data, 1 means the data and its derivative, etc).
		 * @returns {Number} The number of required data points needed for the desired degree of interpolation.
		 * @exception {DeveloperError} degree must be 0 or greater.
		 * @exception {DeveloperError} inputOrder must be 0 or greater.
		 */
		function getRequiredDataPoints(degree: number, inputOrder?: number): number;

		/**
		 * Interpolates values using Hermite Polynomial Approximation.
		 * @param {Number} x The independent variable for which the dependent variables will be interpolated.
		 * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values
		 * in this array must be in increasing order and the same value must not occur twice in the array.
		 * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three
		 * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
		 * @param {Number} yStride The number of dependent variable values in yTable corresponding to
		 * each independent variable value in xTable.
		 * @param {Number[]} [result] An existing array into which to store the result.
		 * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.
		 */
		function interpolateOrderZero(x: number, xTable: number[], yTable: number[], yStride: number, result?: number[]): number[];

		/**
		 * Interpolates values using Hermite Polynomial Approximation.
		 * @param {Number} x The independent variable for which the dependent variables will be interpolated.
		 * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values
		 * in this array must be in increasing order and the same value must not occur twice in the array.
		 * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three
		 * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
		 * @param {Number} yStride The number of dependent variable values in yTable corresponding to
		 * each independent variable value in xTable.
		 * @param {Number} inputOrder The number of derivatives supplied for input.
		 * @param {Number} outputOrder The number of derivatives desired for output.
		 * @param {Number[]} [result] An existing array into which to store the result.
		 * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.
		 */
		function interpolate(x: number, xTable: number[], yTable: number[], yStride: number, inputOrder: number, outputOrder: number, result?: number[]): number[];

	}

	/**
	 * A Hermite spline is a cubic interpolating spline. Points, incoming tangents, outgoing tangents, and times
	 * must be defined for each control point. The outgoing tangents are defined for points [0, n - 2] and the incoming
	 * tangents are defined for points [1, n - 1]. For example, when interpolating a segment of the curve between <code>points[i]</code> and
	 * <code>points[i + 1]</code>, the tangents at the points will be <code>outTangents[i]</code> and <code>inTangents[i]</code>,
	 * respectively.
	 * @alias HermiteSpline
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.
	 *                The values are in no way connected to the clock time. They are the parameterization for the curve.
	 * @param {Cartesian3[]} options.points The array of {@link Cartesian3} control points.
	 * @param {Cartesian3[]} options.inTangents The array of {@link Cartesian3} incoming tangents at each control point.
	 * @param {Cartesian3[]} options.outTangents The array of {@link Cartesian3} outgoing tangents at each control point.
	 * @exception {DeveloperError} points.length must be greater than or equal to 2.
	 * @exception {DeveloperError} times.length must be equal to points.length.
	 * @exception {DeveloperError} inTangents and outTangents must have a length equal to points.length - 1.
	 * @example
	 * // Create a G<sup>1</sup> continuous Hermite spline
	 * var times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];
	 * var spline = new Cesium.HermiteSpline({
	 *     times : times,
	 *     points : [
	 *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),
	 *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),
	 *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),
	 *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),
	 *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)
	 *     ],
	 *     outTangents : [
	 *         new Cesium.Cartesian3(1125196, -161816, 270551),
	 *         new Cesium.Cartesian3(-996690.5, -365906.5, 184028.5),
	 *         new Cesium.Cartesian3(-2096917, 48379.5, -292683.5),
	 *         new Cesium.Cartesian3(-890902.5, 408999.5, -447115)
	 *     ],
	 *     inTangents : [
	 *         new Cesium.Cartesian3(-1993381, -731813, 368057),
	 *         new Cesium.Cartesian3(-4193834, 96759, -585367),
	 *         new Cesium.Cartesian3(-1781805, 817999, -894230),
	 *         new Cesium.Cartesian3(1165345, 112641, 47281)
	 *     ]
	 * });
	 * var p0 = spline.evaluate(times[0]);
	 * @see CatmullRomSpline
	 * @see LinearSpline
	 * @see QuaternionSpline
	 * @see WeightSpline
	 */
	class HermiteSpline {
		constructor(options: {
			times: number[];
			points: (Cartesian3)[];
			inTangents: (Cartesian3)[];
			outTangents: (Cartesian3)[];
		});

		/**
		 * An array of times for the control points.
		 * @memberof HermiteSpline.prototype
		 * @type {Number[]}
		 * @readonly
		 */
		readonly times: number[];

		/**
		 * An array of {@link Cartesian3} control points.
		 * @memberof HermiteSpline.prototype
		 * @type {Cartesian3[]}
		 * @readonly
		 */
		readonly points: (Cartesian3)[];

		/**
		 * An array of {@link Cartesian3} incoming tangents at each control point.
		 * @memberof HermiteSpline.prototype
		 * @type {Cartesian3[]}
		 * @readonly
		 */
		readonly inTangents: (Cartesian3)[];

		/**
		 * An array of {@link Cartesian3} outgoing tangents at each control point.
		 * @memberof HermiteSpline.prototype
		 * @type {Cartesian3[]}
		 * @readonly
		 */
		readonly outTangents: (Cartesian3)[];

		/**
		 * Creates a spline where the tangents at each control point are the same.
		 * The curves are guaranteed to be at least in the class C<sup>1</sup>.
		 * @param {Object} options Object with the following properties:
		 * @param {Number[]} options.times The array of control point times.
		 * @param {Cartesian3[]} options.points The array of control points.
		 * @param {Cartesian3[]} options.tangents The array of tangents at the control points.
		 * @returns {HermiteSpline} A hermite spline.
		 * @exception {DeveloperError} points, times and tangents are required.
		 * @exception {DeveloperError} points.length must be greater than or equal to 2.
		 * @exception {DeveloperError} times, points and tangents must have the same length.
		 * @example
		 * var points = [
		 *     new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),
		 *     new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),
		 *     new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),
		 *     new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),
		 *     new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)
		 * ];
		 * // Add tangents
		 * var tangents = new Array(points.length);
		 * tangents[0] = new Cesium.Cartesian3(1125196, -161816, 270551);
		 * var temp = new Cesium.Cartesian3();
		 * for (var i = 1; i < tangents.length - 1; ++i) {
		 *     tangents[i] = Cesium.Cartesian3.multiplyByScalar(Cesium.Cartesian3.subtract(points[i + 1], points[i - 1], temp), 0.5, new Cesium.Cartesian3());
		 * }
		 * tangents[tangents.length - 1] = new Cesium.Cartesian3(1165345, 112641, 47281);
		 * var spline = Cesium.HermiteSpline.createC1({
		 *     times : times,
		 *     points : points,
		 *     tangents : tangents
		 * });
		 */
		static createC1(options: {
			times: number[];
			points: (Cartesian3)[];
			tangents: (Cartesian3)[];
		}): HermiteSpline;

		/**
		 * Creates a natural cubic spline. The tangents at the control points are generated
		 * to create a curve in the class C<sup>2</sup>.
		 * @param {Object} options Object with the following properties:
		 * @param {Number[]} options.times The array of control point times.
		 * @param {Cartesian3[]} options.points The array of control points.
		 * @returns {HermiteSpline|LinearSpline} A hermite spline or a linear spline if less than 3 control points were given.
		 * @exception {DeveloperError} points and times are required.
		 * @exception {DeveloperError} points.length must be greater than or equal to 2.
		 * @exception {DeveloperError} times.length must be equal to points.length.
		 * @example
		 * // Create a natural cubic spline above the earth from Philadelphia to Los Angeles.
		 * var spline = Cesium.HermiteSpline.createNaturalCubic({
		 *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],
		 *     points : [
		 *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),
		 *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),
		 *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),
		 *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),
		 *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)
		 *     ]
		 * });
		 */
		static createNaturalCubic(options: {
			times: number[];
			points: (Cartesian3)[];
		}): HermiteSpline | LinearSpline;

		/**
		 * Creates a clamped cubic spline. The tangents at the interior control points are generated
		 * to create a curve in the class C<sup>2</sup>.
		 * @param {Object} options Object with the following properties:
		 * @param {Number[]} options.times The array of control point times.
		 * @param {Cartesian3[]} options.points The array of control points.
		 * @param {Cartesian3} options.firstTangent The outgoing tangent of the first control point.
		 * @param {Cartesian3} options.lastTangent The incoming tangent of the last control point.
		 * @returns {HermiteSpline|LinearSpline} A hermite spline or a linear spline if less than 3 control points were given.
		 * @exception {DeveloperError} points, times, firstTangent and lastTangent are required.
		 * @exception {DeveloperError} points.length must be greater than or equal to 2.
		 * @exception {DeveloperError} times.length must be equal to points.length.
		 * @example
		 * // Create a clamped cubic spline above the earth from Philadelphia to Los Angeles.
		 * var spline = Cesium.HermiteSpline.createClampedCubic({
		 *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],
		 *     points : [
		 *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),
		 *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),
		 *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),
		 *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),
		 *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)
		 *     ],
		 *     firstTangent : new Cesium.Cartesian3(1125196, -161816, 270551),
		 *     lastTangent : new Cesium.Cartesian3(1165345, 112641, 47281)
		 * });
		 */
		static createClampedCubic(options: {
			times: number[];
			points: (Cartesian3)[];
			firstTangent: Cartesian3;
			lastTangent: Cartesian3;
		}): HermiteSpline | LinearSpline;

		/**
		 * Finds an index <code>i</code> in <code>times</code> such that the parameter
		 * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.
		 * @function
		 * @param {Number} time The time.
		 * @returns {Number} The index for the element at the start of the interval.
		 * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>
		 *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element
		 *                             in the array <code>times</code>.
		 */
		findTimeInterval(time: number): number;

		/**
		 * Wraps the given time to the period covered by the spline.
		 * @function
		 * @param {Number} time The time.
		 * @return {Number} The time, wrapped around to the updated animation.
		 */
		wrapTime(time: number): number;

		/**
		 * Clamps the given time to the period covered by the spline.
		 * @function
		 * @param {Number} time The time.
		 * @return {Number} The time, clamped to the animation period.
		 */
		clampTime(time: number): number;

		/**
		 * Evaluates the curve at a given time.
		 * @param {Number} time The time at which to evaluate the curve.
		 * @param {Cartesian3} [result] The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter or a new instance of the point on the curve at the given time.
		 * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>
		 *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element
		 *                             in the array <code>times</code>.
		 */
		evaluate(time: number, result?: Cartesian3): Cartesian3;

	}

	/**
	 * Constants for WebGL index datatypes.  These corresponds to the
	 * <code>type</code> parameter of {@link http://www.khronos.org/opengles/sdk/docs/man/xhtml/glDrawElements.xml|drawElements}.
	 * @exports IndexDatatype
	 */
	namespace IndexDatatype {
		/**
		 * 8-bit unsigned byte corresponding to <code>UNSIGNED_BYTE</code> and the type
		 * of an element in <code>Uint8Array</code>.
		 * @type {Number}
		 * @constant
		 */
		const UNSIGNED_BYTE: number;

		/**
		 * 16-bit unsigned short corresponding to <code>UNSIGNED_SHORT</code> and the type
		 * of an element in <code>Uint16Array</code>.
		 * @type {Number}
		 * @constant
		 */
		const UNSIGNED_SHORT: number;

		/**
		 * 32-bit unsigned int corresponding to <code>UNSIGNED_INT</code> and the type
		 * of an element in <code>Uint32Array</code>.
		 * @type {Number}
		 * @constant
		 */
		const UNSIGNED_INT: number;

		/**
		 * Returns the size, in bytes, of the corresponding datatype.
		 * @param {IndexDatatype} indexDatatype The index datatype to get the size of.
		 * @returns {Number} The size in bytes.
		 * @example
		 * // Returns 2
		 * var size = Cesium.IndexDatatype.getSizeInBytes(Cesium.IndexDatatype.UNSIGNED_SHORT);
		 */
		function getSizeInBytes(indexDatatype: any): number;

		/**
		 * Validates that the provided index datatype is a valid {@link IndexDatatype}.
		 * @param {IndexDatatype} indexDatatype The index datatype to validate.
		 * @returns {Boolean} <code>true</code> if the provided index datatype is a valid value; otherwise, <code>false</code>.
		 * @example
		 * if (!Cesium.IndexDatatype.validate(indexDatatype)) {
		 *   throw new Cesium.DeveloperError('indexDatatype must be a valid value.');
		 * }
		 */
		function validate(indexDatatype: any): boolean;

		/**
		 * Creates a typed array that will store indices, using either <code><Uint16Array</code>
		 * or <code>Uint32Array</code> depending on the number of vertices.
		 * @param {Number} numberOfVertices Number of vertices that the indices will reference.
		 * @param {Number|Array} indicesLengthOrArray Passed through to the typed array constructor.
		 * @returns {Uint16Array|Uint32Array} A <code>Uint16Array</code> or <code>Uint32Array</code> constructed with <code>indicesLengthOrArray</code>.
		 * @example
		 * this.indices = Cesium.IndexDatatype.createTypedArray(positions.length / 3, numberOfIndices);
		 */
		function createTypedArray(numberOfVertices: number, indicesLengthOrArray: number | any[]): Uint16Array | Uint32Array;

		/**
		 * Creates a typed array from a source array buffer.  The resulting typed array will store indices, using either <code><Uint16Array</code>
		 * or <code>Uint32Array</code> depending on the number of vertices.
		 * @param {Number} numberOfVertices Number of vertices that the indices will reference.
		 * @param {ArrayBuffer} sourceArray Passed through to the typed array constructor.
		 * @param {Number} byteOffset Passed through to the typed array constructor.
		 * @param {Number} length Passed through to the typed array constructor.
		 * @returns {Uint16Array|Uint32Array} A <code>Uint16Array</code> or <code>Uint32Array</code> constructed with <code>sourceArray</code>, <code>byteOffset</code>, and <code>length</code>.
		 */
		function createTypedArrayFromArrayBuffer(numberOfVertices: number, sourceArray: ArrayBuffer, byteOffset: number, length: number): Uint16Array | Uint32Array;

	}

	/**
	 * The interface for interpolation algorithms.
	 * @exports InterpolationAlgorithm
	 * @see LagrangePolynomialApproximation
	 * @see LinearApproximation
	 * @see HermitePolynomialApproximation
	 */
	namespace InterpolationAlgorithm {
		/**
		 * Gets the name of this interpolation algorithm.
		 * @type {String}
		 */
		const type: string;

		/**
		 * Given the desired degree, returns the number of data points required for interpolation.
		 * @function
		 * @param {Number} degree The desired degree of interpolation.
		 * @returns {Number} The number of required data points needed for the desired degree of interpolation.
		 */
		function getRequiredDataPoints(degree: number): number;

		/**
		 * Performs zero order interpolation.
		 * @function
		 * @param {Number} x The independent variable for which the dependent variables will be interpolated.
		 * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values
		 * in this array must be in increasing order and the same value must not occur twice in the array.
		 * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three
		 * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
		 * @param {Number} yStride The number of dependent variable values in yTable corresponding to
		 * each independent variable value in xTable.
		 * @param {Number[]} [result] An existing array into which to store the result.
		 * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.
		 */
		function interpolateOrderZero(x: number, xTable: number[], yTable: number[], yStride: number, result?: number[]): number[];

		/**
		 * Performs higher order interpolation.  Not all interpolators need to support high-order interpolation,
		 * if this function remains undefined on implementing objects, interpolateOrderZero will be used instead.
		 * @function
		 * @param {Number} x The independent variable for which the dependent variables will be interpolated.
		 * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values
		 * in this array must be in increasing order and the same value must not occur twice in the array.
		 * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three
		 * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
		 * @param {Number} yStride The number of dependent variable values in yTable corresponding to
		 * each independent variable value in xTable.
		 * @param {Number} inputOrder The number of derivatives supplied for input.
		 * @param {Number} outputOrder The number of derivatives desired for output.
		 * @param {Number[]} [result] An existing array into which to store the result.
		 * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.
		 */
		function interpolate(x: number, xTable: number[], yTable: number[], yStride: number, inputOrder: number, outputOrder: number, result?: number[]): number[];

	}

	/**
	 * Contains functions for operating on 2D triangles.
	 * @exports Intersections2D
	 */
	namespace Intersections2D {
		/**
		 * Splits a 2D triangle at given axis-aligned threshold value and returns the resulting
		 * polygon on a given side of the threshold.  The resulting polygon may have 0, 1, 2,
		 * 3, or 4 vertices.
		 * @param {Number} threshold The threshold coordinate value at which to clip the triangle.
		 * @param {Boolean} keepAbove true to keep the portion of the triangle above the threshold, or false
		 *                            to keep the portion below.
		 * @param {Number} u0 The coordinate of the first vertex in the triangle, in counter-clockwise order.
		 * @param {Number} u1 The coordinate of the second vertex in the triangle, in counter-clockwise order.
		 * @param {Number} u2 The coordinate of the third vertex in the triangle, in counter-clockwise order.
		 * @param {Number[]} [result] The array into which to copy the result.  If this parameter is not supplied,
		 *                            a new array is constructed and returned.
		 * @returns {Number[]} The polygon that results after the clip, specified as a list of
		 *                     vertices.  The vertices are specified in counter-clockwise order.
		 *                     Each vertex is either an index from the existing list (identified as
		 *                     a 0, 1, or 2) or -1 indicating a new vertex not in the original triangle.
		 *                     For new vertices, the -1 is followed by three additional numbers: the
		 *                     index of each of the two original vertices forming the line segment that
		 *                     the new vertex lies on, and the fraction of the distance from the first
		 *                     vertex to the second one.
		 * @example
		 * var result = Cesium.Intersections2D.clipTriangleAtAxisAlignedThreshold(0.5, false, 0.2, 0.6, 0.4);
		 * // result === [2, 0, -1, 1, 0, 0.25, -1, 1, 2, 0.5]
		 */
		function clipTriangleAtAxisAlignedThreshold(threshold: number, keepAbove: boolean, u0: number, u1: number, u2: number, result?: number[]): number[];

		/**
		 * Compute the barycentric coordinates of a 2D position within a 2D triangle.
		 * @param {Number} x The x coordinate of the position for which to find the barycentric coordinates.
		 * @param {Number} y The y coordinate of the position for which to find the barycentric coordinates.
		 * @param {Number} x1 The x coordinate of the triangle's first vertex.
		 * @param {Number} y1 The y coordinate of the triangle's first vertex.
		 * @param {Number} x2 The x coordinate of the triangle's second vertex.
		 * @param {Number} y2 The y coordinate of the triangle's second vertex.
		 * @param {Number} x3 The x coordinate of the triangle's third vertex.
		 * @param {Number} y3 The y coordinate of the triangle's third vertex.
		 * @param {Cartesian3} [result] The instance into to which to copy the result.  If this parameter
		 *                     is undefined, a new instance is created and returned.
		 * @returns {Cartesian3} The barycentric coordinates of the position within the triangle.
		 * @example
		 * var result = Cesium.Intersections2D.computeBarycentricCoordinates(0.0, 0.0, 0.0, 1.0, -1, -0.5, 1, -0.5);
		 * // result === new Cesium.Cartesian3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0);
		 */
		function computeBarycentricCoordinates(x: number, y: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, result?: Cartesian3): Cartesian3;

	}

	/**
	 * Functions for computing the intersection between geometries such as rays, planes, triangles, and ellipsoids.
	 * @exports IntersectionTests
	 */
	namespace IntersectionTests {
		/**
		 * Computes the intersection of a ray and a plane.
		 * @param {Ray} ray The ray.
		 * @param {Plane} plane The plane.
		 * @param {Cartesian3} [result] The object onto which to store the result.
		 * @returns {Cartesian3} The intersection point or undefined if there is no intersections.
		 */
		function rayPlane(ray: Ray, plane: Plane, result?: Cartesian3): Cartesian3;

		/**
		 * Computes the intersection points of a ray with an ellipsoid.
		 * @param {Ray} ray The ray.
		 * @param {Ellipsoid} ellipsoid The ellipsoid.
		 * @returns {Interval} The interval containing scalar points along the ray or undefined if there are no intersections.
		 */
		function rayEllipsoid(ray: Ray, ellipsoid: Ellipsoid): Interval;

		/**
		 * Provides the point along the ray which is nearest to the ellipsoid.
		 * @param {Ray} ray The ray.
		 * @param {Ellipsoid} ellipsoid The ellipsoid.
		 * @returns {Cartesian3} The nearest planetodetic point on the ray.
		 */
		function grazingAltitudeLocation(ray: Ray, ellipsoid: Ellipsoid): Cartesian3;

		/**
		 * Computes the intersection of a line segment and a plane.
		 * @param {Cartesian3} endPoint0 An end point of the line segment.
		 * @param {Cartesian3} endPoint1 The other end point of the line segment.
		 * @param {Plane} plane The plane.
		 * @param {Cartesian3} [result] The object onto which to store the result.
		 * @returns {Cartesian3} The intersection point or undefined if there is no intersection.
		 * @example
		 * var origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);
		 * var normal = ellipsoid.geodeticSurfaceNormal(origin);
		 * var plane = Cesium.Plane.fromPointNormal(origin, normal);
		 * var p0 = new Cesium.Cartesian3(...);
		 * var p1 = new Cesium.Cartesian3(...);
		 * // find the intersection of the line segment from p0 to p1 and the tangent plane at origin.
		 * var intersection = Cesium.IntersectionTests.lineSegmentPlane(p0, p1, plane);
		 */
		function lineSegmentPlane(endPoint0: Cartesian3, endPoint1: Cartesian3, plane: Plane, result?: Cartesian3): Cartesian3;

		/**
		 * Computes the intersection of a triangle and a plane
		 * @param {Cartesian3} p0 First point of the triangle
		 * @param {Cartesian3} p1 Second point of the triangle
		 * @param {Cartesian3} p2 Third point of the triangle
		 * @param {Plane} plane Intersection plane
		 * @returns {Object} An object with properties <code>positions</code> and <code>indices</code>, which are arrays that represent three triangles that do not cross the plane. (Undefined if no intersection exists)
		 * @example
		 * var origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);
		 * var normal = ellipsoid.geodeticSurfaceNormal(origin);
		 * var plane = Cesium.Plane.fromPointNormal(origin, normal);
		 * var p0 = new Cesium.Cartesian3(...);
		 * var p1 = new Cesium.Cartesian3(...);
		 * var p2 = new Cesium.Cartesian3(...);
		 * // convert the triangle composed of points (p0, p1, p2) to three triangles that don't cross the plane
		 * var triangles = Cesium.IntersectionTests.trianglePlaneIntersection(p0, p1, p2, plane);
		 */
		function trianglePlaneIntersection(p0: Cartesian3, p1: Cartesian3, p2: Cartesian3, plane: Plane): any;

	}

	/**
	 * Represents the closed interval [start, stop].
	 * @alias Interval
	 * @constructor
	 * @param {Number} [start=0.0] The beginning of the interval.
	 * @param {Number} [stop=0.0] The end of the interval.
	 */
	class Interval {
		constructor(start?: number, stop?: number);

		/**
		 * The beginning of the interval.
		 * @type {Number}
		 * @default 0.0
		 */
		start: number;

		/**
		 * The end of the interval.
		 * @type {Number}
		 * @default 0.0
		 */
		stop: number;

	}

	/**
	 * Default settings for accessing the Cesium ion API.
	 * @exports Ion
	 * An ion access token is only required if you are using any ion related APIs.
	 * A default access token is provided for evaluation purposes only.
	 * Sign up for a free ion account and get your own access token at {@link https://cesium.com}
	 * @see IonResource
	 * @see IonImageryProvider
	 * @see IonGeocoderService
	 * @see createWorldImagery
	 * @see createWorldTerrain
	 */
	namespace Ion {
		/**
		 * Gets or sets the default Cesium ion access token.
		 * @type {String}
		 */
		const defaultAccessToken: string;

		/**
		 * Gets or sets the default Cesium ion server.
		 * @type {String|Resource}
		 * @default https://api.cesium.com
		 */
		const defaultServer: string | Resource;

	}

	/**
	 * Provides geocoding through Cesium ion.
	 * @alias IonGeocoderService
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Scene} options.scene The scene
	 * @param {String} [options.accessToken=Ion.defaultAccessToken] The access token to use.
	 * @param {String} [options.accessToken=Ion.defaultAccessToken] The access token to use.
	 * @param {String|Resource} [options.server=Ion.defaultServer] The resource to the Cesium ion API server.
	 * @see Ion
	 */
	class IonGeocoderService {
		constructor(options: {
			scene: Scene;
			accessToken?: string;
			server?: string | Resource;
		});

		/**
		 * @function
		 * @param {String} query The query to be sent to the geocoder service
		 * @param {GeocodeType} [type=GeocodeType.SEARCH] The type of geocode to perform.
		 * @returns {Promise<GeocoderService~Result[]>}
		 */
		geocode(query: string, type?: any): any;

	}

	/**
	 * A {@link Resource} instance that encapsulates Cesium ion asset access.
	 * This object is normally not instantiated directly, use {@link IonResource.fromAssetId}.
	 * @alias IonResource
	 * @constructor
	 * @augments Resource
	 * @param {Object} endpoint The result of the Cesium ion asset endpoint service.
	 * @param {Resource} endpointResource The resource used to retreive the endpoint.
	 * @see Ion
	 * @see IonImageryProvider
	 * @see createWorldTerrain
	 * @see https://cesium.com
	 */
	class IonResource extends Resource {
		constructor(endpoint: any, endpointResource: Resource);

		/**
		 * Asynchronously creates an instance.
		 * @param {Number} assetId The Cesium ion asset id.
		 * @param {Object} [options] An object with the following properties:
		 * @param {String} [options.accessToken=Ion.defaultAccessToken] The access token to use.
		 * @param {String|Resource} [options.server=Ion.defaultServer] The resource to the Cesium ion API server.
		 * @returns {Promise.<IonResource>} A Promise to am instance representing the Cesium ion Asset.
		 * @example
		 * //Load a Cesium3DTileset with asset ID of 124624234
		 * viewer.scene.primitives.add(new Cesium.Cesium3DTileset({ url: Cesium.IonResource.fromAssetId(124624234) }));
		 * @example
		 * //Load a CZML file with asset ID of 10890
		 * Cesium.IonResource.fromAssetId(10890)
		 *   .then(function (resource) {
		 *     viewer.dataSources.add(Cesium.CzmlDataSource.load(resource));
		 *   });
		 */
		static fromAssetId(assetId: number, options?: {
			accessToken?: string;
			server?: string | Resource;
		}): any;

		/**
		 * Gets the credits required for attribution of the asset.
		 * @memberof IonResource.prototype
		 * @type {Credit[]}
		 * @readonly
		 */
		readonly credits: (Credit)[];

	}

	/**
	 * Determines if a given date is a leap year.
	 * @exports isLeapYear
	 * @param {Number} year The year to be tested.
	 * @returns {Boolean} True if <code>year</code> is a leap year.
	 * @example
	 * var leapYear = Cesium.isLeapYear(2000); // true
	 */
	namespace isLeapYear {
	}

	/**
	 * Constants related to ISO8601 support.
	 * @exports Iso8601
	 * @see {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601 on Wikipedia}
	 * @see JulianDate
	 * @see TimeInterval
	 */
	namespace Iso8601 {
		/**
		 * A {@link JulianDate} representing the earliest time representable by an ISO8601 date.
		 * This is equivalent to the date string '0000-01-01T00:00:00Z'
		 * @type {JulianDate}
		 * @constant
		 */
		const MINIMUM_VALUE: JulianDate;

		/**
		 * A {@link JulianDate} representing the latest time representable by an ISO8601 date.
		 * This is equivalent to the date string '9999-12-31T24:00:00Z'
		 * @type {JulianDate}
		 * @constant
		 */
		const MAXIMUM_VALUE: JulianDate;

		/**
		 * A {@link TimeInterval} representing the largest interval representable by an ISO8601 interval.
		 * This is equivalent to the interval string '0000-01-01T00:00:00Z/9999-12-31T24:00:00Z'
		 * @type {JulianDate}
		 * @constant
		 */
		const MAXIMUM_INTERVAL: JulianDate;

	}

	/**
	 * Represents an astronomical Julian date, which is the number of days since noon on January 1, -4712 (4713 BC).
	 * For increased precision, this class stores the whole number part of the date and the seconds
	 * part of the date in separate components.  In order to be safe for arithmetic and represent
	 * leap seconds, the date is always stored in the International Atomic Time standard
	 * {@link TimeStandard.TAI}.
	 * @alias JulianDate
	 * @constructor
	 * @param {Number} [julianDayNumber=0.0] The Julian Day Number representing the number of whole days.  Fractional days will also be handled correctly.
	 * @param {Number} [secondsOfDay=0.0] The number of seconds into the current Julian Day Number.  Fractional seconds, negative seconds and seconds greater than a day will be handled correctly.
	 * @param {TimeStandard} [timeStandard=TimeStandard.UTC] The time standard in which the first two parameters are defined.
	 */
	class JulianDate {
		constructor(julianDayNumber?: number, secondsOfDay?: number, timeStandard?: any);

		/**
		 * Gets or sets the number of whole days.
		 * @type {Number}
		 */
		dayNumber: number;

		/**
		 * Gets or sets the number of seconds into the current day.
		 * @type {Number}
		 */
		secondsOfDay: number;

		/**
		 * Creates a new instance from a GregorianDate.
		 * @param {GregorianDate} date A GregorianDate.
		 * @param {JulianDate} [result] An existing instance to use for the result.
		 * @returns {JulianDate} The modified result parameter or a new instance if none was provided.
		 * @exception {DeveloperError} date must be a valid GregorianDate.
		 */
		static fromGregorianDate(date: GregorianDate, result?: JulianDate): JulianDate;

		/**
		 * Creates a new instance from a JavaScript Date.
		 * @param {Date} date A JavaScript Date.
		 * @param {JulianDate} [result] An existing instance to use for the result.
		 * @returns {JulianDate} The modified result parameter or a new instance if none was provided.
		 * @exception {DeveloperError} date must be a valid JavaScript Date.
		 */
		static fromDate(date: Date, result?: JulianDate): JulianDate;

		/**
		 * Creates a new instance from a from an {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} date.
		 * This method is superior to <code>Date.parse</code> because it will handle all valid formats defined by the ISO 8601
		 * specification, including leap seconds and sub-millisecond times, which discarded by most JavaScript implementations.
		 * @param {String} iso8601String An ISO 8601 date.
		 * @param {JulianDate} [result] An existing instance to use for the result.
		 * @returns {JulianDate} The modified result parameter or a new instance if none was provided.
		 * @exception {DeveloperError} Invalid ISO 8601 date.
		 */
		static fromIso8601(iso8601String: string, result?: JulianDate): JulianDate;

		/**
		 * Creates a new instance that represents the current system time.
		 * This is equivalent to calling <code>JulianDate.fromDate(new Date());</code>.
		 * @param {JulianDate} [result] An existing instance to use for the result.
		 * @returns {JulianDate} The modified result parameter or a new instance if none was provided.
		 */
		static now(result?: JulianDate): JulianDate;

		/**
		 * Creates a {@link GregorianDate} from the provided instance.
		 * @param {JulianDate} julianDate The date to be converted.
		 * @param {GregorianDate} [result] An existing instance to use for the result.
		 * @returns {GregorianDate} The modified result parameter or a new instance if none was provided.
		 */
		static toGregorianDate(julianDate: JulianDate, result?: GregorianDate): GregorianDate;

		/**
		 * Creates a JavaScript Date from the provided instance.
		 * Since JavaScript dates are only accurate to the nearest millisecond and
		 * cannot represent a leap second, consider using {@link JulianDate.toGregorianDate} instead.
		 * If the provided JulianDate is during a leap second, the previous second is used.
		 * @param {JulianDate} julianDate The date to be converted.
		 * @returns {Date} A new instance representing the provided date.
		 */
		static toDate(julianDate: JulianDate): Date;

		/**
		 * Creates an ISO8601 representation of the provided date.
		 * @param {JulianDate} julianDate The date to be converted.
		 * @param {Number} [precision] The number of fractional digits used to represent the seconds component.  By default, the most precise representation is used.
		 * @returns {String} The ISO8601 representation of the provided date.
		 */
		static toIso8601(julianDate: JulianDate, precision?: number): string;

		/**
		 * Duplicates a JulianDate instance.
		 * @param {JulianDate} julianDate The date to duplicate.
		 * @param {JulianDate} [result] An existing instance to use for the result.
		 * @returns {JulianDate} The modified result parameter or a new instance if none was provided. Returns undefined if julianDate is undefined.
		 */
		static clone(julianDate: JulianDate, result?: JulianDate): JulianDate;

		/**
		 * Compares two instances.
		 * @param {JulianDate} left The first instance.
		 * @param {JulianDate} right The second instance.
		 * @returns {Number} A negative value if left is less than right, a positive value if left is greater than right, or zero if left and right are equal.
		 */
		static compare(left: JulianDate, right: JulianDate): number;

		/**
		 * Compares two instances and returns <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {JulianDate} [left] The first instance.
		 * @param {JulianDate} [right] The second instance.
		 * @returns {Boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.
		 */
		static equals(left?: JulianDate, right?: JulianDate): boolean;

		/**
		 * Compares two instances and returns <code>true</code> if they are within <code>epsilon</code> seconds of
		 * each other.  That is, in order for the dates to be considered equal (and for
		 * this function to return <code>true</code>), the absolute value of the difference between them, in
		 * seconds, must be less than <code>epsilon</code>.
		 * @param {JulianDate} [left] The first instance.
		 * @param {JulianDate} [right] The second instance.
		 * @param {Number} [epsilon] The maximum number of seconds that should separate the two instances.
		 * @returns {Boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.
		 */
		static equalsEpsilon(left?: JulianDate, right?: JulianDate, epsilon?: number): boolean;

		/**
		 * Computes the total number of whole and fractional days represented by the provided instance.
		 * @param {JulianDate} julianDate The date.
		 * @returns {Number} The Julian date as single floating point number.
		 */
		static totalDays(julianDate: JulianDate): number;

		/**
		 * Computes the difference in seconds between the provided instance.
		 * @param {JulianDate} left The first instance.
		 * @param {JulianDate} right The second instance.
		 * @returns {Number} The difference, in seconds, when subtracting <code>right</code> from <code>left</code>.
		 */
		static secondsDifference(left: JulianDate, right: JulianDate): number;

		/**
		 * Computes the difference in days between the provided instance.
		 * @param {JulianDate} left The first instance.
		 * @param {JulianDate} right The second instance.
		 * @returns {Number} The difference, in days, when subtracting <code>right</code> from <code>left</code>.
		 */
		static daysDifference(left: JulianDate, right: JulianDate): number;

		/**
		 * Computes the number of seconds the provided instance is ahead of UTC.
		 * @param {JulianDate} julianDate The date.
		 * @returns {Number} The number of seconds the provided instance is ahead of UTC
		 */
		static computeTaiMinusUtc(julianDate: JulianDate): number;

		/**
		 * Adds the provided number of seconds to the provided date instance.
		 * @param {JulianDate} julianDate The date.
		 * @param {Number} seconds The number of seconds to add or subtract.
		 * @param {JulianDate} result An existing instance to use for the result.
		 * @returns {JulianDate} The modified result parameter.
		 */
		static addSeconds(julianDate: JulianDate, seconds: number, result: JulianDate): JulianDate;

		/**
		 * Adds the provided number of minutes to the provided date instance.
		 * @param {JulianDate} julianDate The date.
		 * @param {Number} minutes The number of minutes to add or subtract.
		 * @param {JulianDate} result An existing instance to use for the result.
		 * @returns {JulianDate} The modified result parameter.
		 */
		static addMinutes(julianDate: JulianDate, minutes: number, result: JulianDate): JulianDate;

		/**
		 * Adds the provided number of hours to the provided date instance.
		 * @param {JulianDate} julianDate The date.
		 * @param {Number} hours The number of hours to add or subtract.
		 * @param {JulianDate} result An existing instance to use for the result.
		 * @returns {JulianDate} The modified result parameter.
		 */
		static addHours(julianDate: JulianDate, hours: number, result: JulianDate): JulianDate;

		/**
		 * Adds the provided number of days to the provided date instance.
		 * @param {JulianDate} julianDate The date.
		 * @param {Number} days The number of days to add or subtract.
		 * @param {JulianDate} result An existing instance to use for the result.
		 * @returns {JulianDate} The modified result parameter.
		 */
		static addDays(julianDate: JulianDate, days: number, result: JulianDate): JulianDate;

		/**
		 * Compares the provided instances and returns <code>true</code> if <code>left</code> is earlier than <code>right</code>, <code>false</code> otherwise.
		 * @param {JulianDate} left The first instance.
		 * @param {JulianDate} right The second instance.
		 * @returns {Boolean} <code>true</code> if <code>left</code> is earlier than <code>right</code>, <code>false</code> otherwise.
		 */
		static lessThan(left: JulianDate, right: JulianDate): boolean;

		/**
		 * Compares the provided instances and returns <code>true</code> if <code>left</code> is earlier than or equal to <code>right</code>, <code>false</code> otherwise.
		 * @param {JulianDate} left The first instance.
		 * @param {JulianDate} right The second instance.
		 * @returns {Boolean} <code>true</code> if <code>left</code> is earlier than or equal to <code>right</code>, <code>false</code> otherwise.
		 */
		static lessThanOrEquals(left: JulianDate, right: JulianDate): boolean;

		/**
		 * Compares the provided instances and returns <code>true</code> if <code>left</code> is later than <code>right</code>, <code>false</code> otherwise.
		 * @param {JulianDate} left The first instance.
		 * @param {JulianDate} right The second instance.
		 * @returns {Boolean} <code>true</code> if <code>left</code> is later than <code>right</code>, <code>false</code> otherwise.
		 */
		static greaterThan(left: JulianDate, right: JulianDate): boolean;

		/**
		 * Compares the provided instances and returns <code>true</code> if <code>left</code> is later than or equal to <code>right</code>, <code>false</code> otherwise.
		 * @param {JulianDate} left The first instance.
		 * @param {JulianDate} right The second instance.
		 * @returns {Boolean} <code>true</code> if <code>left</code> is later than or equal to <code>right</code>, <code>false</code> otherwise.
		 */
		static greaterThanOrEquals(left: JulianDate, right: JulianDate): boolean;

		/**
		 * Duplicates this instance.
		 * @param {JulianDate} [result] An existing instance to use for the result.
		 * @returns {JulianDate} The modified result parameter or a new instance if none was provided.
		 */
		clone(result?: JulianDate): JulianDate;

		/**
		 * Compares this and the provided instance and returns <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {JulianDate} [right] The second instance.
		 * @returns {Boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.
		 */
		equals(right?: JulianDate): boolean;

		/**
		 * Compares this and the provided instance and returns <code>true</code> if they are within <code>epsilon</code> seconds of
		 * each other.  That is, in order for the dates to be considered equal (and for
		 * this function to return <code>true</code>), the absolute value of the difference between them, in
		 * seconds, must be less than <code>epsilon</code>.
		 * @param {JulianDate} [right] The second instance.
		 * @param {Number} [epsilon] The maximum number of seconds that should separate the two instances.
		 * @returns {Boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.
		 */
		equalsEpsilon(right?: JulianDate, epsilon?: number): boolean;

		/**
		 * Creates a string representing this date in ISO8601 format.
		 * @returns {String} A string representing this date in ISO8601 format.
		 */
		toString(): string;

		/**
		 * Gets or sets the list of leap seconds used throughout Cesium.
		 * @memberof JulianDate
		 * @type {LeapSecond[]}
		 */
		static leapSeconds: (LeapSecond)[];

	}

	/**
	 * An {@link InterpolationAlgorithm} for performing Lagrange interpolation.
	 * @exports LagrangePolynomialApproximation
	 */
	namespace LagrangePolynomialApproximation {
		/**
		 * Given the desired degree, returns the number of data points required for interpolation.
		 * @param {Number} degree The desired degree of interpolation.
		 * @returns {Number} The number of required data points needed for the desired degree of interpolation.
		 */
		function getRequiredDataPoints(degree: number): number;

		/**
		 * Interpolates values using Lagrange Polynomial Approximation.
		 * @param {Number} x The independent variable for which the dependent variables will be interpolated.
		 * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values
		 * in this array must be in increasing order and the same value must not occur twice in the array.
		 * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three
		 * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
		 * @param {Number} yStride The number of dependent variable values in yTable corresponding to
		 * each independent variable value in xTable.
		 * @param {Number[]} [result] An existing array into which to store the result.
		 * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.
		 */
		function interpolateOrderZero(x: number, xTable: number[], yTable: number[], yStride: number, result?: number[]): number[];

	}

	/**
	 * Describes a single leap second, which is constructed from a {@link JulianDate} and a
	 * numerical offset representing the number of seconds TAI is ahead of the UTC time standard.
	 * @alias LeapSecond
	 * @constructor
	 * @param {JulianDate} [date] A Julian date representing the time of the leap second.
	 * @param {Number} [offset] The cumulative number of seconds that TAI is ahead of UTC at the provided date.
	 */
	class LeapSecond {
		constructor(date?: JulianDate, offset?: number);

		/**
		 * Gets or sets the date at which this leap second occurs.
		 * @type {JulianDate}
		 */
		julianDate: JulianDate;

		/**
		 * Gets or sets the cumulative number of seconds between the UTC and TAI time standards at the time
		 * of this leap second.
		 * @type {Number}
		 */
		offset: number;

	}

	/**
	 * An {@link InterpolationAlgorithm} for performing linear interpolation.
	 * @exports LinearApproximation
	 */
	namespace LinearApproximation {
		/**
		 * Given the desired degree, returns the number of data points required for interpolation.
		 * Since linear interpolation can only generate a first degree polynomial, this function
		 * always returns 2.
		 * @param {Number} degree The desired degree of interpolation.
		 * @returns {Number} This function always returns 2.
		 */
		function getRequiredDataPoints(degree: number): number;

		/**
		 * Interpolates values using linear approximation.
		 * @param {Number} x The independent variable for which the dependent variables will be interpolated.
		 * @param {Number[]} xTable The array of independent variables to use to interpolate.  The values
		 * in this array must be in increasing order and the same value must not occur twice in the array.
		 * @param {Number[]} yTable The array of dependent variables to use to interpolate.  For a set of three
		 * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
		 * @param {Number} yStride The number of dependent variable values in yTable corresponding to
		 * each independent variable value in xTable.
		 * @param {Number[]} [result] An existing array into which to store the result.
		 * @returns {Number[]} The array of interpolated values, or the result parameter if one was provided.
		 */
		function interpolateOrderZero(x: number, xTable: number[], yTable: number[], yStride: number, result?: number[]): number[];

	}

	/**
	 * A spline that uses piecewise linear interpolation to create a curve.
	 * @alias LinearSpline
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.
	 *                The values are in no way connected to the clock time. They are the parameterization for the curve.
	 * @param {Cartesian3[]} options.points The array of {@link Cartesian3} control points.
	 * @exception {DeveloperError} points.length must be greater than or equal to 2.
	 * @exception {DeveloperError} times.length must be equal to points.length.
	 * @example
	 * var times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];
	 * var spline = new Cesium.LinearSpline({
	 *     times : times,
	 *     points : [
	 *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),
	 *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),
	 *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),
	 *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),
	 *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)
	 *     ]
	 * });
	 * var p0 = spline.evaluate(times[0]);
	 * @see HermiteSpline
	 * @see CatmullRomSpline
	 * @see QuaternionSpline
	 * @see WeightSpline
	 */
	class LinearSpline {
		constructor(options: {
			times: number[];
			points: (Cartesian3)[];
		});

		/**
		 * An array of times for the control points.
		 * @memberof LinearSpline.prototype
		 * @type {Number[]}
		 * @readonly
		 */
		readonly times: number[];

		/**
		 * An array of {@link Cartesian3} control points.
		 * @memberof LinearSpline.prototype
		 * @type {Cartesian3[]}
		 * @readonly
		 */
		readonly points: (Cartesian3)[];

		/**
		 * Finds an index <code>i</code> in <code>times</code> such that the parameter
		 * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.
		 * @function
		 * @param {Number} time The time.
		 * @returns {Number} The index for the element at the start of the interval.
		 * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>
		 *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element
		 *                             in the array <code>times</code>.
		 */
		findTimeInterval(time: number): number;

		/**
		 * Wraps the given time to the period covered by the spline.
		 * @function
		 * @param {Number} time The time.
		 * @return {Number} The time, wrapped around to the updated animation.
		 */
		wrapTime(time: number): number;

		/**
		 * Clamps the given time to the period covered by the spline.
		 * @function
		 * @param {Number} time The time.
		 * @return {Number} The time, clamped to the animation period.
		 */
		clampTime(time: number): number;

		/**
		 * Evaluates the curve at a given time.
		 * @param {Number} time The time at which to evaluate the curve.
		 * @param {Cartesian3} [result] The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter or a new instance of the point on the curve at the given time.
		 * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>
		 *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element
		 *                             in the array <code>times</code>.
		 */
		evaluate(time: number, result?: Cartesian3): Cartesian3;

	}

	/**
	 * Asynchronously loads and parses the given URL to a CRN file or parses the raw binary data of a CRN file.
	 * Returns a promise that will resolve to an object containing the image buffer, width, height and format once loaded,
	 * or reject if the URL failed to load or failed to parse the data.  The data is loaded
	 * using XMLHttpRequest, which means that in order to make requests to another origin,
	 * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
	 * @exports loadCRN
	 * @param {Resource|String|ArrayBuffer} resourceOrUrlOrBuffer The URL of the binary data or an ArrayBuffer.
	 * @returns {Promise.<CompressedTextureBuffer>|undefined} A promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
	 * @exception {RuntimeError} Unsupported compressed format.
	 * @example
	 * // load a single URL asynchronously
	 * Cesium.loadCRN('some/url').then(function(textureData) {
	 *     var width = textureData.width;
	 *     var height = textureData.height;
	 *     var format = textureData.internalFormat;
	 *     var arrayBufferView = textureData.bufferView;
	 *     // use the data to create a texture
	 * }).otherwise(function(error) {
	 *     // an error occurred
	 * });
	 * @see {@link https://github.com/BinomialLLC/crunch|crunch DXTc texture compression and transcoding library}
	 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
	 * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
	 */
	namespace loadCRN {
	}

	/**
	 * Asynchronously loads and parses the given URL to a KTX file or parses the raw binary data of a KTX file.
	 * Returns a promise that will resolve to an object containing the image buffer, width, height and format once loaded,
	 * or reject if the URL failed to load or failed to parse the data.  The data is loaded
	 * using XMLHttpRequest, which means that in order to make requests to another origin,
	 * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
	 * <p>
	 * The following are part of the KTX format specification but are not supported:
	 * <ul>
	 *     <li>Big-endian files</li>
	 *     <li>Metadata</li>
	 *     <li>3D textures</li>
	 *     <li>Texture Arrays</li>
	 *     <li>Cubemaps</li>
	 *     <li>Mipmaps</li>
	 * </ul>
	 * </p>
	 * @exports loadKTX
	 * @param {Resource|String|ArrayBuffer} resourceOrUrlOrBuffer The URL of the binary data or an ArrayBuffer.
	 * @returns {Promise.<CompressedTextureBuffer>|undefined} A promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
	 * @exception {RuntimeError} Invalid KTX file.
	 * @exception {RuntimeError} File is the wrong endianness.
	 * @exception {RuntimeError} glInternalFormat is not a valid format.
	 * @exception {RuntimeError} glType must be zero when the texture is compressed.
	 * @exception {RuntimeError} The type size for compressed textures must be 1.
	 * @exception {RuntimeError} glFormat must be zero when the texture is compressed.
	 * @exception {RuntimeError} Generating mipmaps for a compressed texture is unsupported.
	 * @exception {RuntimeError} The base internal format must be the same as the format for uncompressed textures.
	 * @exception {RuntimeError} 3D textures are not supported.
	 * @exception {RuntimeError} Texture arrays are not supported.
	 * @exception {RuntimeError} Cubemaps are not supported.
	 * @example
	 * // load a single URL asynchronously
	 * Cesium.loadKTX('some/url').then(function(ktxData) {
	 *     var width = ktxData.width;
	 *     var height = ktxData.height;
	 *     var format = ktxData.internalFormat;
	 *     var arrayBufferView = ktxData.bufferView;
	 *     // use the data to create a texture
	 * }).otherwise(function(error) {
	 *     // an error occurred
	 * });
	 * @see {@link https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/|KTX file format}
	 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
	 * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
	 */
	namespace loadKTX {
	}

	/**
	 * Defines how geodetic ellipsoid coordinates ({@link Cartographic}) project to a
	 * flat map like Cesium's 2D and Columbus View modes.
	 * @alias MapProjection
	 * @constructor
	 * @see GeographicProjection
	 * @see WebMercatorProjection
	 */
	class MapProjection {
		constructor();

		/**
		 * Gets the {@link Ellipsoid}.
		 * @memberof MapProjection.prototype
		 * @type {Ellipsoid}
		 * @readonly
		 */
		readonly ellipsoid: Ellipsoid;

		/**
		 * Projects {@link Cartographic} coordinates, in radians, to projection-specific map coordinates, in meters.
		 * @memberof MapProjection
		 * @function
		 * @param {Cartographic} cartographic The coordinates to project.
		 * @param {Cartesian3} [result] An instance into which to copy the result.  If this parameter is
		 *        undefined, a new instance is created and returned.
		 * @returns {Cartesian3} The projected coordinates.  If the result parameter is not undefined, the
		 *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is
		 *          created and returned.
		 */
		project(cartographic: Cartographic, result?: Cartesian3): Cartesian3;

		/**
		 * Unprojects projection-specific map {@link Cartesian3} coordinates, in meters, to {@link Cartographic}
		 * coordinates, in radians.
		 * @memberof MapProjection
		 * @function
		 * @param {Cartesian3} cartesian The Cartesian position to unproject with height (z) in meters.
		 * @param {Cartographic} [result] An instance into which to copy the result.  If this parameter is
		 *        undefined, a new instance is created and returned.
		 * @returns {Cartographic} The unprojected coordinates.  If the result parameter is not undefined, the
		 *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is
		 *          created and returned.
		 */
		unproject(cartesian: Cartesian3, result?: Cartographic): Cartographic;

	}

	/**
	 * Math functions.
	 * @exports CesiumMath
	 * @alias Math
	 */
	namespace Math {
		/**
		 * 0.1
		 * @type {Number}
		 * @constant
		 */
		const EPSILON1: number;

		/**
		 * 0.01
		 * @type {Number}
		 * @constant
		 */
		const EPSILON2: number;

		/**
		 * 0.001
		 * @type {Number}
		 * @constant
		 */
		const EPSILON3: number;

		/**
		 * 0.0001
		 * @type {Number}
		 * @constant
		 */
		const EPSILON4: number;

		/**
		 * 0.00001
		 * @type {Number}
		 * @constant
		 */
		const EPSILON5: number;

		/**
		 * 0.000001
		 * @type {Number}
		 * @constant
		 */
		const EPSILON6: number;

		/**
		 * 0.0000001
		 * @type {Number}
		 * @constant
		 */
		const EPSILON7: number;

		/**
		 * 0.00000001
		 * @type {Number}
		 * @constant
		 */
		const EPSILON8: number;

		/**
		 * 0.000000001
		 * @type {Number}
		 * @constant
		 */
		const EPSILON9: number;

		/**
		 * 0.0000000001
		 * @type {Number}
		 * @constant
		 */
		const EPSILON10: number;

		/**
		 * 0.00000000001
		 * @type {Number}
		 * @constant
		 */
		const EPSILON11: number;

		/**
		 * 0.000000000001
		 * @type {Number}
		 * @constant
		 */
		const EPSILON12: number;

		/**
		 * 0.0000000000001
		 * @type {Number}
		 * @constant
		 */
		const EPSILON13: number;

		/**
		 * 0.00000000000001
		 * @type {Number}
		 * @constant
		 */
		const EPSILON14: number;

		/**
		 * 0.000000000000001
		 * @type {Number}
		 * @constant
		 */
		const EPSILON15: number;

		/**
		 * 0.0000000000000001
		 * @type {Number}
		 * @constant
		 */
		const EPSILON16: number;

		/**
		 * 0.00000000000000001
		 * @type {Number}
		 * @constant
		 */
		const EPSILON17: number;

		/**
		 * 0.000000000000000001
		 * @type {Number}
		 * @constant
		 */
		const EPSILON18: number;

		/**
		 * 0.0000000000000000001
		 * @type {Number}
		 * @constant
		 */
		const EPSILON19: number;

		/**
		 * 0.00000000000000000001
		 * @type {Number}
		 * @constant
		 */
		const EPSILON20: number;

		/**
		 * The gravitational parameter of the Earth in meters cubed
		 * per second squared as defined by the WGS84 model: 3.986004418e14
		 * @type {Number}
		 * @constant
		 */
		const GRAVITATIONALPARAMETER: number;

		/**
		 * Radius of the sun in meters: 6.955e8
		 * @type {Number}
		 * @constant
		 */
		const SOLAR_RADIUS: number;

		/**
		 * The mean radius of the moon, according to the "Report of the IAU/IAG Working Group on
		 * Cartographic Coordinates and Rotational Elements of the Planets and satellites: 2000",
		 * Celestial Mechanics 82: 83-110, 2002.
		 * @type {Number}
		 * @constant
		 */
		const LUNAR_RADIUS: number;

		/**
		 * 64 * 1024
		 * @type {Number}
		 * @constant
		 */
		const SIXTY_FOUR_KILOBYTES: number;

		/**
		 * Returns the sign of the value; 1 if the value is positive, -1 if the value is
		 * negative, or 0 if the value is 0.
		 * @function
		 * @param {Number} value The value to return the sign of.
		 * @returns {Number} The sign of value.
		 */
		function sign(value: number): number;

		/**
		 * Returns 1.0 if the given value is positive or zero, and -1.0 if it is negative.
		 * This is similar to {@link CesiumMath#sign} except that returns 1.0 instead of
		 * 0.0 when the input value is 0.0.
		 * @param {Number} value The value to return the sign of.
		 * @returns {Number} The sign of value.
		 */
		function signNotZero(value: number): number;

		/**
		 * Converts a scalar value in the range [-1.0, 1.0] to a SNORM in the range [0, rangeMax]
		 * @param {Number} value The scalar value in the range [-1.0, 1.0]
		 * @param {Number} [rangeMax=255] The maximum value in the mapped range, 255 by default.
		 * @returns {Number} A SNORM value, where 0 maps to -1.0 and rangeMax maps to 1.0.
		 * @see CesiumMath.fromSNorm
		 */
		function toSNorm(value: number, rangeMax?: number): number;

		/**
		 * Converts a SNORM value in the range [0, rangeMax] to a scalar in the range [-1.0, 1.0].
		 * @param {Number} value SNORM value in the range [0, 255]
		 * @param {Number} [rangeMax=255] The maximum value in the SNORM range, 255 by default.
		 * @returns {Number} Scalar in the range [-1.0, 1.0].
		 * @see CesiumMath.toSNorm
		 */
		function fromSNorm(value: number, rangeMax?: number): number;

		/**
		 * Returns the hyperbolic sine of a number.
		 * The hyperbolic sine of <em>value</em> is defined to be
		 * (<em>e<sup>x</sup>&nbsp;-&nbsp;e<sup>-x</sup></em>)/2.0
		 * where <i>e</i> is Euler's number, approximately 2.71828183.
		 * <p>Special cases:
		 *   <ul>
		 *     <li>If the argument is NaN, then the result is NaN.</li>
		 *     <li>If the argument is infinite, then the result is an infinity
		 *     with the same sign as the argument.</li>
		 *     <li>If the argument is zero, then the result is a zero with the
		 *     same sign as the argument.</li>
		 *   </ul>
		 * </p>
		 * @function
		 * @param {Number} value The number whose hyperbolic sine is to be returned.
		 * @returns {Number} The hyperbolic sine of <code>value</code>.
		 */
		function sinh(value: number): number;

		/**
		 * Returns the hyperbolic cosine of a number.
		 * The hyperbolic cosine of <strong>value</strong> is defined to be
		 * (<em>e<sup>x</sup>&nbsp;+&nbsp;e<sup>-x</sup></em>)/2.0
		 * where <i>e</i> is Euler's number, approximately 2.71828183.
		 * <p>Special cases:
		 *   <ul>
		 *     <li>If the argument is NaN, then the result is NaN.</li>
		 *     <li>If the argument is infinite, then the result is positive infinity.</li>
		 *     <li>If the argument is zero, then the result is 1.0.</li>
		 *   </ul>
		 * </p>
		 * @function
		 * @param {Number} value The number whose hyperbolic cosine is to be returned.
		 * @returns {Number} The hyperbolic cosine of <code>value</code>.
		 */
		function cosh(value: number): number;

		/**
		 * Computes the linear interpolation of two values.
		 * @param {Number} p The start value to interpolate.
		 * @param {Number} q The end value to interpolate.
		 * @param {Number} time The time of interpolation generally in the range <code>[0.0, 1.0]</code>.
		 * @returns {Number} The linearly interpolated value.
		 * @example
		 * var n = Cesium.Math.lerp(0.0, 2.0, 0.5); // returns 1.0
		 */
		function lerp(p: number, q: number, time: number): number;

		/**
		 * pi
		 * @type {Number}
		 * @constant
		 */
		const PI: number;

		/**
		 * 1/pi
		 * @type {Number}
		 * @constant
		 */
		const ONE_OVER_PI: number;

		/**
		 * pi/2
		 * @type {Number}
		 * @constant
		 */
		const PI_OVER_TWO: number;

		/**
		 * pi/3
		 * @type {Number}
		 * @constant
		 */
		const PI_OVER_THREE: number;

		/**
		 * pi/4
		 * @type {Number}
		 * @constant
		 */
		const PI_OVER_FOUR: number;

		/**
		 * pi/6
		 * @type {Number}
		 * @constant
		 */
		const PI_OVER_SIX: number;

		/**
		 * 3pi/2
		 * @type {Number}
		 * @constant
		 */
		const THREE_PI_OVER_TWO: number;

		/**
		 * 2pi
		 * @type {Number}
		 * @constant
		 */
		const TWO_PI: number;

		/**
		 * 1/2pi
		 * @type {Number}
		 * @constant
		 */
		const ONE_OVER_TWO_PI: number;

		/**
		 * The number of radians in a degree.
		 * @type {Number}
		 * @constant
		 * @default Math.PI / 180.0
		 */
		const RADIANS_PER_DEGREE: number;

		/**
		 * The number of degrees in a radian.
		 * @type {Number}
		 * @constant
		 * @default 180.0 / Math.PI
		 */
		const DEGREES_PER_RADIAN: number;

		/**
		 * The number of radians in an arc second.
		 * @type {Number}
		 * @constant
		 * @default {@link CesiumMath.RADIANS_PER_DEGREE} / 3600.0
		 */
		const RADIANS_PER_ARCSECOND: number;

		/**
		 * Converts degrees to radians.
		 * @param {Number} degrees The angle to convert in degrees.
		 * @returns {Number} The corresponding angle in radians.
		 */
		function toRadians(degrees: number): number;

		/**
		 * Converts radians to degrees.
		 * @param {Number} radians The angle to convert in radians.
		 * @returns {Number} The corresponding angle in degrees.
		 */
		function toDegrees(radians: number): number;

		/**
		 * Converts a longitude value, in radians, to the range [<code>-Math.PI</code>, <code>Math.PI</code>).
		 * @param {Number} angle The longitude value, in radians, to convert to the range [<code>-Math.PI</code>, <code>Math.PI</code>).
		 * @returns {Number} The equivalent longitude value in the range [<code>-Math.PI</code>, <code>Math.PI</code>).
		 * @example
		 * // Convert 270 degrees to -90 degrees longitude
		 * var longitude = Cesium.Math.convertLongitudeRange(Cesium.Math.toRadians(270.0));
		 */
		function convertLongitudeRange(angle: number): number;

		/**
		 * Convenience function that clamps a latitude value, in radians, to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).
		 * Useful for sanitizing data before use in objects requiring correct range.
		 * @param {Number} angle The latitude value, in radians, to clamp to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).
		 * @returns {Number} The latitude value clamped to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).
		 * @example
		 * // Clamp 108 degrees latitude to 90 degrees latitude
		 * var latitude = Cesium.Math.clampToLatitudeRange(Cesium.Math.toRadians(108.0));
		 */
		function clampToLatitudeRange(angle: number): number;

		/**
		 * Produces an angle in the range -Pi <= angle <= Pi which is equivalent to the provided angle.
		 * @param {Number} angle in radians
		 * @returns {Number} The angle in the range [<code>-CesiumMath.PI</code>, <code>CesiumMath.PI</code>].
		 */
		function negativePiToPi(angle: number): number;

		/**
		 * Produces an angle in the range 0 <= angle <= 2Pi which is equivalent to the provided angle.
		 * @param {Number} angle in radians
		 * @returns {Number} The angle in the range [0, <code>CesiumMath.TWO_PI</code>].
		 */
		function zeroToTwoPi(angle: number): number;

		/**
		 * The modulo operation that also works for negative dividends.
		 * @param {Number} m The dividend.
		 * @param {Number} n The divisor.
		 * @returns {Number} The remainder.
		 */
		function mod(m: number, n: number): number;

		/**
		 * Determines if two values are equal using an absolute or relative tolerance test. This is useful
		 * to avoid problems due to roundoff error when comparing floating-point values directly. The values are
		 * first compared using an absolute tolerance test. If that fails, a relative tolerance test is performed.
		 * Use this test if you are unsure of the magnitudes of left and right.
		 * @param {Number} left The first value to compare.
		 * @param {Number} right The other value to compare.
		 * @param {Number} relativeEpsilon The maximum inclusive delta between <code>left</code> and <code>right</code> for the relative tolerance test.
		 * @param {Number} [absoluteEpsilon=relativeEpsilon] The maximum inclusive delta between <code>left</code> and <code>right</code> for the absolute tolerance test.
		 * @returns {Boolean} <code>true</code> if the values are equal within the epsilon; otherwise, <code>false</code>.
		 * @example
		 * var a = Cesium.Math.equalsEpsilon(0.0, 0.01, Cesium.Math.EPSILON2); // true
		 * var b = Cesium.Math.equalsEpsilon(0.0, 0.1, Cesium.Math.EPSILON2);  // false
		 * var c = Cesium.Math.equalsEpsilon(3699175.1634344, 3699175.2, Cesium.Math.EPSILON7); // true
		 * var d = Cesium.Math.equalsEpsilon(3699175.1634344, 3699175.2, Cesium.Math.EPSILON9); // false
		 */
		function equalsEpsilon(left: number, right: number, relativeEpsilon: number, absoluteEpsilon?: number): boolean;

		/**
		 * Computes the factorial of the provided number.
		 * @param {Number} n The number whose factorial is to be computed.
		 * @returns {Number} The factorial of the provided number or undefined if the number is less than 0.
		 * @exception {DeveloperError} A number greater than or equal to 0 is required.
		 * @example
		 * //Compute 7!, which is equal to 5040
		 * var computedFactorial = Cesium.Math.factorial(7);
		 * @see {@link http://en.wikipedia.org/wiki/Factorial|Factorial on Wikipedia}
		 */
		function factorial(n: number): number;

		/**
		 * Increments a number with a wrapping to a minimum value if the number exceeds the maximum value.
		 * @param {Number} [n] The number to be incremented.
		 * @param {Number} [maximumValue] The maximum incremented value before rolling over to the minimum value.
		 * @param {Number} [minimumValue=0.0] The number reset to after the maximum value has been exceeded.
		 * @returns {Number} The incremented number.
		 * @exception {DeveloperError} Maximum value must be greater than minimum value.
		 * @example
		 * var n = Cesium.Math.incrementWrap(5, 10, 0); // returns 6
		 * var n = Cesium.Math.incrementWrap(10, 10, 0); // returns 0
		 */
		function incrementWrap(n?: number, maximumValue?: number, minimumValue?: number): number;

		/**
		 * Determines if a positive integer is a power of two.
		 * @param {Number} n The positive integer to test.
		 * @returns {Boolean} <code>true</code> if the number if a power of two; otherwise, <code>false</code>.
		 * @exception {DeveloperError} A number greater than or equal to 0 is required.
		 * @example
		 * var t = Cesium.Math.isPowerOfTwo(16); // true
		 * var f = Cesium.Math.isPowerOfTwo(20); // false
		 */
		function isPowerOfTwo(n: number): boolean;

		/**
		 * Computes the next power-of-two integer greater than or equal to the provided positive integer.
		 * @param {Number} n The positive integer to test.
		 * @returns {Number} The next power-of-two integer.
		 * @exception {DeveloperError} A number greater than or equal to 0 is required.
		 * @example
		 * var n = Cesium.Math.nextPowerOfTwo(29); // 32
		 * var m = Cesium.Math.nextPowerOfTwo(32); // 32
		 */
		function nextPowerOfTwo(n: number): number;

		/**
		 * Constraint a value to lie between two values.
		 * @param {Number} value The value to constrain.
		 * @param {Number} min The minimum value.
		 * @param {Number} max The maximum value.
		 * @returns {Number} The value clamped so that min <= value <= max.
		 */
		function clamp(value: number, min: number, max: number): number;

		/**
		 * Sets the seed used by the random number generator
		 * in {@link CesiumMath#nextRandomNumber}.
		 * @param {Number} seed An integer used as the seed.
		 */
		function setRandomNumberSeed(seed: number): void;

		/**
		 * Generates a random floating point number in the range of [0.0, 1.0)
		 * using a Mersenne twister.
		 * @returns {Number} A random number in the range of [0.0, 1.0).
		 * @see CesiumMath.setRandomNumberSeed
		 * @see {@link http://en.wikipedia.org/wiki/Mersenne_twister|Mersenne twister on Wikipedia}
		 */
		function nextRandomNumber(): number;

		/**
		 * Generates a random number between two numbers.
		 * @param {Number} min The minimum value.
		 * @param {Number} max The maximum value.
		 * @returns {Number} A random number between the min and max.
		 */
		function randomBetween(min: number, max: number): number;

		/**
		 * Computes <code>Math.acos(value)</code>, but first clamps <code>value</code> to the range [-1.0, 1.0]
		 * so that the function will never return NaN.
		 * @param {Number} value The value for which to compute acos.
		 * @returns {Number} The acos of the value if the value is in the range [-1.0, 1.0], or the acos of -1.0 or 1.0,
		 *          whichever is closer, if the value is outside the range.
		 */
		function acosClamped(value: number): number;

		/**
		 * Computes <code>Math.asin(value)</code>, but first clamps <code>value</code> to the range [-1.0, 1.0]
		 * so that the function will never return NaN.
		 * @param {Number} value The value for which to compute asin.
		 * @returns {Number} The asin of the value if the value is in the range [-1.0, 1.0], or the asin of -1.0 or 1.0,
		 *          whichever is closer, if the value is outside the range.
		 */
		function asinClamped(value: number): number;

		/**
		 * Finds the chord length between two points given the circle's radius and the angle between the points.
		 * @param {Number} angle The angle between the two points.
		 * @param {Number} radius The radius of the circle.
		 * @returns {Number} The chord length.
		 */
		function chordLength(angle: number, radius: number): number;

		/**
		 * Finds the logarithm of a number to a base.
		 * @param {Number} number The number.
		 * @param {Number} base The base.
		 * @returns {Number} The result.
		 */
		function logBase(number: number, base: number): number;

		/**
		 * Finds the cube root of a number.
		 * Returns NaN if <code>number</code> is not provided.
		 * @function
		 * @param {Number} [number] The number.
		 * @returns {Number} The result.
		 */
		function cbrt(number?: number): number;

		/**
		 * Finds the base 2 logarithm of a number.
		 * @function
		 * @param {Number} number The number.
		 * @returns {Number} The result.
		 */
		function log2(number: number): number;

		/**
		 * Computes a fast approximation of Atan for input in the range [-1, 1].
		 * Based on Michal Drobot's approximation from ShaderFastLibs,
		 * which in turn is based on "Efficient approximations for the arctangent function,"
		 * Rajan, S. Sichun Wang Inkol, R. Joyal, A., May 2006.
		 * Adapted from ShaderFastLibs under MIT License.
		 * @param {Number} x An input number in the range [-1, 1]
		 * @returns {Number} An approximation of atan(x)
		 */
		function fastApproximateAtan(x: number): number;

		/**
		 * Computes a fast approximation of Atan2(x, y) for arbitrary input scalars.
		 * Range reduction math based on nvidia's cg reference implementation: http://developer.download.nvidia.com/cg/atan2.html
		 * @param {Number} x An input number that isn't zero if y is zero.
		 * @param {Number} y An input number that isn't zero if x is zero.
		 * @returns {Number} An approximation of atan2(x, y)
		 */
		function fastApproximateAtan2(x: number, y: number): number;

	}

	/**
	 * A 2x2 matrix, indexable as a column-major order array.
	 * Constructor parameters are in row-major order for code readability.
	 * @alias Matrix2
	 * @constructor
	 * @param {Number} [column0Row0=0.0] The value for column 0, row 0.
	 * @param {Number} [column1Row0=0.0] The value for column 1, row 0.
	 * @param {Number} [column0Row1=0.0] The value for column 0, row 1.
	 * @param {Number} [column1Row1=0.0] The value for column 1, row 1.
	 * @see Matrix2.fromColumnMajorArray
	 * @see Matrix2.fromRowMajorArray
	 * @see Matrix2.fromScale
	 * @see Matrix2.fromUniformScale
	 * @see Matrix3
	 * @see Matrix4
	 */
	class Matrix2 {
		constructor(column0Row0?: number, column1Row0?: number, column0Row1?: number, column1Row1?: number);

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {Matrix2} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: Matrix2, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {Matrix2} [result] The object into which to store the result.
		 * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: Matrix2): Matrix2;

		/**
		 * Duplicates a Matrix2 instance.
		 * @param {Matrix2} matrix The matrix to duplicate.
		 * @param {Matrix2} [result] The object onto which to store the result.
		 * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided. (Returns undefined if matrix is undefined)
		 */
		static clone(matrix: Matrix2, result?: Matrix2): Matrix2;

		/**
		 * Creates a Matrix2 from 4 consecutive elements in an array.
		 * @param {Number[]} array The array whose 4 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.
		 * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.
		 * @param {Matrix2} [result] The object onto which to store the result.
		 * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.
		 * @example
		 * // Create the Matrix2:
		 * // [1.0, 2.0]
		 * // [1.0, 2.0]
		 * var v = [1.0, 1.0, 2.0, 2.0];
		 * var m = Cesium.Matrix2.fromArray(v);
		 * // Create same Matrix2 with using an offset into an array
		 * var v2 = [0.0, 0.0, 1.0, 1.0, 2.0, 2.0];
		 * var m2 = Cesium.Matrix2.fromArray(v2, 2);
		 */
		static fromArray(array: number[], startingIndex?: number, result?: Matrix2): Matrix2;

		/**
		 * Creates a Matrix2 instance from a column-major order array.
		 * @param {Number[]} values The column-major order array.
		 * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.
		 * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.
		 */
		static fromColumnMajorArray(values: number[], result?: Matrix2): Matrix2;

		/**
		 * Creates a Matrix2 instance from a row-major order array.
		 * The resulting matrix will be in column-major order.
		 * @param {Number[]} values The row-major order array.
		 * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.
		 * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.
		 */
		static fromRowMajorArray(values: number[], result?: Matrix2): Matrix2;

		/**
		 * Computes a Matrix2 instance representing a non-uniform scale.
		 * @param {Cartesian2} scale The x and y scale factors.
		 * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.
		 * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.
		 * @example
		 * // Creates
		 * //   [7.0, 0.0]
		 * //   [0.0, 8.0]
		 * var m = Cesium.Matrix2.fromScale(new Cesium.Cartesian2(7.0, 8.0));
		 */
		static fromScale(scale: Cartesian2, result?: Matrix2): Matrix2;

		/**
		 * Computes a Matrix2 instance representing a uniform scale.
		 * @param {Number} scale The uniform scale factor.
		 * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.
		 * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.
		 * @example
		 * // Creates
		 * //   [2.0, 0.0]
		 * //   [0.0, 2.0]
		 * var m = Cesium.Matrix2.fromUniformScale(2.0);
		 */
		static fromUniformScale(scale: number, result?: Matrix2): Matrix2;

		/**
		 * Creates a rotation matrix.
		 * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.
		 * @param {Matrix2} [result] The object in which the result will be stored, if undefined a new instance will be created.
		 * @returns {Matrix2} The modified result parameter, or a new Matrix2 instance if one was not provided.
		 * @example
		 * // Rotate a point 45 degrees counterclockwise.
		 * var p = new Cesium.Cartesian2(5, 6);
		 * var m = Cesium.Matrix2.fromRotation(Cesium.Math.toRadians(45.0));
		 * var rotated = Cesium.Matrix2.multiplyByVector(m, p, new Cesium.Cartesian2());
		 */
		static fromRotation(angle: number, result?: Matrix2): Matrix2;

		/**
		 * Creates an Array from the provided Matrix2 instance.
		 * The array will be in column-major order.
		 * @param {Matrix2} matrix The matrix to use..
		 * @param {Number[]} [result] The Array onto which to store the result.
		 * @returns {Number[]} The modified Array parameter or a new Array instance if one was not provided.
		 */
		static toArray(matrix: Matrix2, result?: number[]): number[];

		/**
		 * Computes the array index of the element at the provided row and column.
		 * @param {Number} row The zero-based index of the row.
		 * @param {Number} column The zero-based index of the column.
		 * @returns {Number} The index of the element at the provided row and column.
		 * @exception {DeveloperError} row must be 0 or 1.
		 * @exception {DeveloperError} column must be 0 or 1.
		 * @example
		 * var myMatrix = new Cesium.Matrix2();
		 * var column1Row0Index = Cesium.Matrix2.getElementIndex(1, 0);
		 * var column1Row0 = myMatrix[column1Row0Index]
		 * myMatrix[column1Row0Index] = 10.0;
		 */
		static getElementIndex(row: number, column: number): number;

		/**
		 * Retrieves a copy of the matrix column at the provided index as a Cartesian2 instance.
		 * @param {Matrix2} matrix The matrix to use.
		 * @param {Number} index The zero-based index of the column to retrieve.
		 * @param {Cartesian2} result The object onto which to store the result.
		 * @returns {Cartesian2} The modified result parameter.
		 * @exception {DeveloperError} index must be 0 or 1.
		 */
		static getColumn(matrix: Matrix2, index: number, result: Cartesian2): Cartesian2;

		/**
		 * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian2 instance.
		 * @param {Matrix2} matrix The matrix to use.
		 * @param {Number} index The zero-based index of the column to set.
		 * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified column.
		 * @param {Cartesian2} result The object onto which to store the result.
		 * @returns {Matrix2} The modified result parameter.
		 * @exception {DeveloperError} index must be 0 or 1.
		 */
		static setColumn(matrix: Matrix2, index: number, cartesian: Cartesian2, result: Cartesian2): Matrix2;

		/**
		 * Retrieves a copy of the matrix row at the provided index as a Cartesian2 instance.
		 * @param {Matrix2} matrix The matrix to use.
		 * @param {Number} index The zero-based index of the row to retrieve.
		 * @param {Cartesian2} result The object onto which to store the result.
		 * @returns {Cartesian2} The modified result parameter.
		 * @exception {DeveloperError} index must be 0 or 1.
		 */
		static getRow(matrix: Matrix2, index: number, result: Cartesian2): Cartesian2;

		/**
		 * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian2 instance.
		 * @param {Matrix2} matrix The matrix to use.
		 * @param {Number} index The zero-based index of the row to set.
		 * @param {Cartesian2} cartesian The Cartesian whose values will be assigned to the specified row.
		 * @param {Matrix2} result The object onto which to store the result.
		 * @returns {Matrix2} The modified result parameter.
		 * @exception {DeveloperError} index must be 0 or 1.
		 */
		static setRow(matrix: Matrix2, index: number, cartesian: Cartesian2, result: Matrix2): Matrix2;

		/**
		 * Extracts the non-uniform scale assuming the matrix is an affine transformation.
		 * @param {Matrix2} matrix The matrix.
		 * @param {Cartesian2} result The object onto which to store the result.
		 * @returns {Cartesian2} The modified result parameter.
		 */
		static getScale(matrix: Matrix2, result: Cartesian2): Cartesian2;

		/**
		 * Computes the maximum scale assuming the matrix is an affine transformation.
		 * The maximum scale is the maximum length of the column vectors.
		 * @param {Matrix2} matrix The matrix.
		 * @returns {Number} The maximum scale.
		 */
		static getMaximumScale(matrix: Matrix2): number;

		/**
		 * Computes the product of two matrices.
		 * @param {Matrix2} left The first matrix.
		 * @param {Matrix2} right The second matrix.
		 * @param {Matrix2} result The object onto which to store the result.
		 * @returns {Matrix2} The modified result parameter.
		 */
		static multiply(left: Matrix2, right: Matrix2, result: Matrix2): Matrix2;

		/**
		 * Computes the sum of two matrices.
		 * @param {Matrix2} left The first matrix.
		 * @param {Matrix2} right The second matrix.
		 * @param {Matrix2} result The object onto which to store the result.
		 * @returns {Matrix2} The modified result parameter.
		 */
		static add(left: Matrix2, right: Matrix2, result: Matrix2): Matrix2;

		/**
		 * Computes the difference of two matrices.
		 * @param {Matrix2} left The first matrix.
		 * @param {Matrix2} right The second matrix.
		 * @param {Matrix2} result The object onto which to store the result.
		 * @returns {Matrix2} The modified result parameter.
		 */
		static subtract(left: Matrix2, right: Matrix2, result: Matrix2): Matrix2;

		/**
		 * Computes the product of a matrix and a column vector.
		 * @param {Matrix2} matrix The matrix.
		 * @param {Cartesian2} cartesian The column.
		 * @param {Cartesian2} result The object onto which to store the result.
		 * @returns {Cartesian2} The modified result parameter.
		 */
		static multiplyByVector(matrix: Matrix2, cartesian: Cartesian2, result: Cartesian2): Cartesian2;

		/**
		 * Computes the product of a matrix and a scalar.
		 * @param {Matrix2} matrix The matrix.
		 * @param {Number} scalar The number to multiply by.
		 * @param {Matrix2} result The object onto which to store the result.
		 * @returns {Matrix2} The modified result parameter.
		 */
		static multiplyByScalar(matrix: Matrix2, scalar: number, result: Matrix2): Matrix2;

		/**
		 * Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.
		 * @param {Matrix2} matrix The matrix on the left-hand side.
		 * @param {Cartesian2} scale The non-uniform scale on the right-hand side.
		 * @param {Matrix2} result The object onto which to store the result.
		 * @returns {Matrix2} The modified result parameter.
		 * @example
		 * // Instead of Cesium.Matrix2.multiply(m, Cesium.Matrix2.fromScale(scale), m);
		 * Cesium.Matrix2.multiplyByScale(m, scale, m);
		 * @see Matrix2.fromScale
		 * @see Matrix2.multiplyByUniformScale
		 */
		static multiplyByScale(matrix: Matrix2, scale: Cartesian2, result: Matrix2): Matrix2;

		/**
		 * Creates a negated copy of the provided matrix.
		 * @param {Matrix2} matrix The matrix to negate.
		 * @param {Matrix2} result The object onto which to store the result.
		 * @returns {Matrix2} The modified result parameter.
		 */
		static negate(matrix: Matrix2, result: Matrix2): Matrix2;

		/**
		 * Computes the transpose of the provided matrix.
		 * @param {Matrix2} matrix The matrix to transpose.
		 * @param {Matrix2} result The object onto which to store the result.
		 * @returns {Matrix2} The modified result parameter.
		 */
		static transpose(matrix: Matrix2, result: Matrix2): Matrix2;

		/**
		 * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.
		 * @param {Matrix2} matrix The matrix with signed elements.
		 * @param {Matrix2} result The object onto which to store the result.
		 * @returns {Matrix2} The modified result parameter.
		 */
		static abs(matrix: Matrix2, result: Matrix2): Matrix2;

		/**
		 * Compares the provided matrices componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Matrix2} [left] The first matrix.
		 * @param {Matrix2} [right] The second matrix.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		static equals(left?: Matrix2, right?: Matrix2): boolean;

		/**
		 * Compares the provided matrices componentwise and returns
		 * <code>true</code> if they are within the provided epsilon,
		 * <code>false</code> otherwise.
		 * @param {Matrix2} [left] The first matrix.
		 * @param {Matrix2} [right] The second matrix.
		 * @param {Number} [epsilon] The epsilon to use for equality testing.
		 * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
		 */
		static equalsEpsilon(left?: Matrix2, right?: Matrix2, epsilon?: number): boolean;

		/**
		 * An immutable Matrix2 instance initialized to the identity matrix.
		 * @type {Matrix2}
		 * @constant
		 */
		static IDENTITY: Matrix2;

		/**
		 * An immutable Matrix2 instance initialized to the zero matrix.
		 * @type {Matrix2}
		 * @constant
		 */
		static ZERO: Matrix2;

		/**
		 * The index into Matrix2 for column 0, row 0.
		 * @type {Number}
		 * @constant
		 * @example
		 * var matrix = new Cesium.Matrix2();
		 * matrix[Cesium.Matrix2.COLUMN0ROW0] = 5.0; // set column 0, row 0 to 5.0
		 */
		static COLUMN0ROW0: number;

		/**
		 * The index into Matrix2 for column 0, row 1.
		 * @type {Number}
		 * @constant
		 * @example
		 * var matrix = new Cesium.Matrix2();
		 * matrix[Cesium.Matrix2.COLUMN0ROW1] = 5.0; // set column 0, row 1 to 5.0
		 */
		static COLUMN0ROW1: number;

		/**
		 * The index into Matrix2 for column 1, row 0.
		 * @type {Number}
		 * @constant
		 * @example
		 * var matrix = new Cesium.Matrix2();
		 * matrix[Cesium.Matrix2.COLUMN1ROW0] = 5.0; // set column 1, row 0 to 5.0
		 */
		static COLUMN1ROW0: number;

		/**
		 * The index into Matrix2 for column 1, row 1.
		 * @type {Number}
		 * @constant
		 * @example
		 * var matrix = new Cesium.Matrix2();
		 * matrix[Cesium.Matrix2.COLUMN1ROW1] = 5.0; // set column 1, row 1 to 5.0
		 */
		static COLUMN1ROW1: number;

		/**
		 * Gets the number of items in the collection.
		 * @memberof Matrix2.prototype
		 * @type {Number}
		 */
		length: number;

		/**
		 * Duplicates the provided Matrix2 instance.
		 * @param {Matrix2} [result] The object onto which to store the result.
		 * @returns {Matrix2} The modified result parameter or a new Matrix2 instance if one was not provided.
		 */
		clone(result?: Matrix2): Matrix2;

		/**
		 * Compares this matrix to the provided matrix componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Matrix2} [right] The right hand side matrix.
		 * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
		 */
		equals(right?: Matrix2): boolean;

		/**
		 * Compares this matrix to the provided matrix componentwise and returns
		 * <code>true</code> if they are within the provided epsilon,
		 * <code>false</code> otherwise.
		 * @param {Matrix2} [right] The right hand side matrix.
		 * @param {Number} [epsilon] The epsilon to use for equality testing.
		 * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
		 */
		equalsEpsilon(right?: Matrix2, epsilon?: number): boolean;

		/**
		 * Creates a string representing this Matrix with each row being
		 * on a separate line and in the format '(column0, column1)'.
		 * @returns {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1)'.
		 */
		toString(): string;

	}

	/**
	 * A 3x3 matrix, indexable as a column-major order array.
	 * Constructor parameters are in row-major order for code readability.
	 * @alias Matrix3
	 * @constructor
	 * @param {Number} [column0Row0=0.0] The value for column 0, row 0.
	 * @param {Number} [column1Row0=0.0] The value for column 1, row 0.
	 * @param {Number} [column2Row0=0.0] The value for column 2, row 0.
	 * @param {Number} [column0Row1=0.0] The value for column 0, row 1.
	 * @param {Number} [column1Row1=0.0] The value for column 1, row 1.
	 * @param {Number} [column2Row1=0.0] The value for column 2, row 1.
	 * @param {Number} [column0Row2=0.0] The value for column 0, row 2.
	 * @param {Number} [column1Row2=0.0] The value for column 1, row 2.
	 * @param {Number} [column2Row2=0.0] The value for column 2, row 2.
	 * @see Matrix3.fromColumnMajorArray
	 * @see Matrix3.fromRowMajorArray
	 * @see Matrix3.fromQuaternion
	 * @see Matrix3.fromScale
	 * @see Matrix3.fromUniformScale
	 * @see Matrix2
	 * @see Matrix4
	 */
	class Matrix3 {
		constructor(column0Row0?: number, column1Row0?: number, column2Row0?: number, column0Row1?: number, column1Row1?: number, column2Row1?: number, column0Row2?: number, column1Row2?: number, column2Row2?: number);

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {Matrix3} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: Matrix3, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {Matrix3} [result] The object into which to store the result.
		 * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: Matrix3): Matrix3;

		/**
		 * Duplicates a Matrix3 instance.
		 * @param {Matrix3} matrix The matrix to duplicate.
		 * @param {Matrix3} [result] The object onto which to store the result.
		 * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided. (Returns undefined if matrix is undefined)
		 */
		static clone(matrix: Matrix3, result?: Matrix3): Matrix3;

		/**
		 * Creates a Matrix3 from 9 consecutive elements in an array.
		 * @param {Number[]} array The array whose 9 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.
		 * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.
		 * @param {Matrix3} [result] The object onto which to store the result.
		 * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.
		 * @example
		 * // Create the Matrix3:
		 * // [1.0, 2.0, 3.0]
		 * // [1.0, 2.0, 3.0]
		 * // [1.0, 2.0, 3.0]
		 * var v = [1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];
		 * var m = Cesium.Matrix3.fromArray(v);
		 * // Create same Matrix3 with using an offset into an array
		 * var v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];
		 * var m2 = Cesium.Matrix3.fromArray(v2, 2);
		 */
		static fromArray(array: number[], startingIndex?: number, result?: Matrix3): Matrix3;

		/**
		 * Creates a Matrix3 instance from a column-major order array.
		 * @param {Number[]} values The column-major order array.
		 * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
		 * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.
		 */
		static fromColumnMajorArray(values: number[], result?: Matrix3): Matrix3;

		/**
		 * Creates a Matrix3 instance from a row-major order array.
		 * The resulting matrix will be in column-major order.
		 * @param {Number[]} values The row-major order array.
		 * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
		 * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.
		 */
		static fromRowMajorArray(values: number[], result?: Matrix3): Matrix3;

		/**
		 * Computes a 3x3 rotation matrix from the provided quaternion.
		 * @param {Quaternion} quaternion the quaternion to use.
		 * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
		 * @returns {Matrix3} The 3x3 rotation matrix from this quaternion.
		 */
		static fromQuaternion(quaternion: Quaternion, result?: Matrix3): Matrix3;

		/**
		 * Computes a 3x3 rotation matrix from the provided headingPitchRoll. (see http://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles )
		 * @param {HeadingPitchRoll} headingPitchRoll the headingPitchRoll to use.
		 * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
		 * @returns {Matrix3} The 3x3 rotation matrix from this headingPitchRoll.
		 */
		static fromHeadingPitchRoll(headingPitchRoll: HeadingPitchRoll, result?: Matrix3): Matrix3;

		/**
		 * Computes a Matrix3 instance representing a non-uniform scale.
		 * @param {Cartesian3} scale The x, y, and z scale factors.
		 * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
		 * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.
		 * @example
		 * // Creates
		 * //   [7.0, 0.0, 0.0]
		 * //   [0.0, 8.0, 0.0]
		 * //   [0.0, 0.0, 9.0]
		 * var m = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(7.0, 8.0, 9.0));
		 */
		static fromScale(scale: Cartesian3, result?: Matrix3): Matrix3;

		/**
		 * Computes a Matrix3 instance representing a uniform scale.
		 * @param {Number} scale The uniform scale factor.
		 * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
		 * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.
		 * @example
		 * // Creates
		 * //   [2.0, 0.0, 0.0]
		 * //   [0.0, 2.0, 0.0]
		 * //   [0.0, 0.0, 2.0]
		 * var m = Cesium.Matrix3.fromUniformScale(2.0);
		 */
		static fromUniformScale(scale: number, result?: Matrix3): Matrix3;

		/**
		 * Computes a Matrix3 instance representing the cross product equivalent matrix of a Cartesian3 vector.
		 * @param {Cartesian3} vector the vector on the left hand side of the cross product operation.
		 * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
		 * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.
		 * @example
		 * // Creates
		 * //   [0.0, -9.0,  8.0]
		 * //   [9.0,  0.0, -7.0]
		 * //   [-8.0, 7.0,  0.0]
		 * var m = Cesium.Matrix3.fromCrossProduct(new Cesium.Cartesian3(7.0, 8.0, 9.0));
		 */
		static fromCrossProduct(vector: Cartesian3, result?: Matrix3): Matrix3;

		/**
		 * Creates a rotation matrix around the x-axis.
		 * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.
		 * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
		 * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.
		 * @example
		 * // Rotate a point 45 degrees counterclockwise around the x-axis.
		 * var p = new Cesium.Cartesian3(5, 6, 7);
		 * var m = Cesium.Matrix3.fromRotationX(Cesium.Math.toRadians(45.0));
		 * var rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());
		 */
		static fromRotationX(angle: number, result?: Matrix3): Matrix3;

		/**
		 * Creates a rotation matrix around the y-axis.
		 * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.
		 * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
		 * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.
		 * @example
		 * // Rotate a point 45 degrees counterclockwise around the y-axis.
		 * var p = new Cesium.Cartesian3(5, 6, 7);
		 * var m = Cesium.Matrix3.fromRotationY(Cesium.Math.toRadians(45.0));
		 * var rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());
		 */
		static fromRotationY(angle: number, result?: Matrix3): Matrix3;

		/**
		 * Creates a rotation matrix around the z-axis.
		 * @param {Number} angle The angle, in radians, of the rotation.  Positive angles are counterclockwise.
		 * @param {Matrix3} [result] The object in which the result will be stored, if undefined a new instance will be created.
		 * @returns {Matrix3} The modified result parameter, or a new Matrix3 instance if one was not provided.
		 * @example
		 * // Rotate a point 45 degrees counterclockwise around the z-axis.
		 * var p = new Cesium.Cartesian3(5, 6, 7);
		 * var m = Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(45.0));
		 * var rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());
		 */
		static fromRotationZ(angle: number, result?: Matrix3): Matrix3;

		/**
		 * Creates an Array from the provided Matrix3 instance.
		 * The array will be in column-major order.
		 * @param {Matrix3} matrix The matrix to use..
		 * @param {Number[]} [result] The Array onto which to store the result.
		 * @returns {Number[]} The modified Array parameter or a new Array instance if one was not provided.
		 */
		static toArray(matrix: Matrix3, result?: number[]): number[];

		/**
		 * Computes the array index of the element at the provided row and column.
		 * @param {Number} row The zero-based index of the row.
		 * @param {Number} column The zero-based index of the column.
		 * @returns {Number} The index of the element at the provided row and column.
		 * @exception {DeveloperError} row must be 0, 1, or 2.
		 * @exception {DeveloperError} column must be 0, 1, or 2.
		 * @example
		 * var myMatrix = new Cesium.Matrix3();
		 * var column1Row0Index = Cesium.Matrix3.getElementIndex(1, 0);
		 * var column1Row0 = myMatrix[column1Row0Index]
		 * myMatrix[column1Row0Index] = 10.0;
		 */
		static getElementIndex(row: number, column: number): number;

		/**
		 * Retrieves a copy of the matrix column at the provided index as a Cartesian3 instance.
		 * @param {Matrix3} matrix The matrix to use.
		 * @param {Number} index The zero-based index of the column to retrieve.
		 * @param {Cartesian3} result The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter.
		 * @exception {DeveloperError} index must be 0, 1, or 2.
		 */
		static getColumn(matrix: Matrix3, index: number, result: Cartesian3): Cartesian3;

		/**
		 * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian3 instance.
		 * @param {Matrix3} matrix The matrix to use.
		 * @param {Number} index The zero-based index of the column to set.
		 * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified column.
		 * @param {Matrix3} result The object onto which to store the result.
		 * @returns {Matrix3} The modified result parameter.
		 * @exception {DeveloperError} index must be 0, 1, or 2.
		 */
		static setColumn(matrix: Matrix3, index: number, cartesian: Cartesian3, result: Matrix3): Matrix3;

		/**
		 * Retrieves a copy of the matrix row at the provided index as a Cartesian3 instance.
		 * @param {Matrix3} matrix The matrix to use.
		 * @param {Number} index The zero-based index of the row to retrieve.
		 * @param {Cartesian3} result The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter.
		 * @exception {DeveloperError} index must be 0, 1, or 2.
		 */
		static getRow(matrix: Matrix3, index: number, result: Cartesian3): Cartesian3;

		/**
		 * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian3 instance.
		 * @param {Matrix3} matrix The matrix to use.
		 * @param {Number} index The zero-based index of the row to set.
		 * @param {Cartesian3} cartesian The Cartesian whose values will be assigned to the specified row.
		 * @param {Matrix3} result The object onto which to store the result.
		 * @returns {Matrix3} The modified result parameter.
		 * @exception {DeveloperError} index must be 0, 1, or 2.
		 */
		static setRow(matrix: Matrix3, index: number, cartesian: Cartesian3, result: Matrix3): Matrix3;

		/**
		 * Extracts the non-uniform scale assuming the matrix is an affine transformation.
		 * @param {Matrix3} matrix The matrix.
		 * @param {Cartesian3} result The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter.
		 */
		static getScale(matrix: Matrix3, result: Cartesian3): Cartesian3;

		/**
		 * Computes the maximum scale assuming the matrix is an affine transformation.
		 * The maximum scale is the maximum length of the column vectors.
		 * @param {Matrix3} matrix The matrix.
		 * @returns {Number} The maximum scale.
		 */
		static getMaximumScale(matrix: Matrix3): number;

		/**
		 * Computes the product of two matrices.
		 * @param {Matrix3} left The first matrix.
		 * @param {Matrix3} right The second matrix.
		 * @param {Matrix3} result The object onto which to store the result.
		 * @returns {Matrix3} The modified result parameter.
		 */
		static multiply(left: Matrix3, right: Matrix3, result: Matrix3): Matrix3;

		/**
		 * Computes the sum of two matrices.
		 * @param {Matrix3} left The first matrix.
		 * @param {Matrix3} right The second matrix.
		 * @param {Matrix3} result The object onto which to store the result.
		 * @returns {Matrix3} The modified result parameter.
		 */
		static add(left: Matrix3, right: Matrix3, result: Matrix3): Matrix3;

		/**
		 * Computes the difference of two matrices.
		 * @param {Matrix3} left The first matrix.
		 * @param {Matrix3} right The second matrix.
		 * @param {Matrix3} result The object onto which to store the result.
		 * @returns {Matrix3} The modified result parameter.
		 */
		static subtract(left: Matrix3, right: Matrix3, result: Matrix3): Matrix3;

		/**
		 * Computes the product of a matrix and a column vector.
		 * @param {Matrix3} matrix The matrix.
		 * @param {Cartesian3} cartesian The column.
		 * @param {Cartesian3} result The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter.
		 */
		static multiplyByVector(matrix: Matrix3, cartesian: Cartesian3, result: Cartesian3): Cartesian3;

		/**
		 * Computes the product of a matrix and a scalar.
		 * @param {Matrix3} matrix The matrix.
		 * @param {Number} scalar The number to multiply by.
		 * @param {Matrix3} result The object onto which to store the result.
		 * @returns {Matrix3} The modified result parameter.
		 */
		static multiplyByScalar(matrix: Matrix3, scalar: number, result: Matrix3): Matrix3;

		/**
		 * Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.
		 * @param {Matrix3} matrix The matrix on the left-hand side.
		 * @param {Cartesian3} scale The non-uniform scale on the right-hand side.
		 * @param {Matrix3} result The object onto which to store the result.
		 * @returns {Matrix3} The modified result parameter.
		 * @example
		 * // Instead of Cesium.Matrix3.multiply(m, Cesium.Matrix3.fromScale(scale), m);
		 * Cesium.Matrix3.multiplyByScale(m, scale, m);
		 * @see Matrix3.fromScale
		 * @see Matrix3.multiplyByUniformScale
		 */
		static multiplyByScale(matrix: Matrix3, scale: Cartesian3, result: Matrix3): Matrix3;

		/**
		 * Creates a negated copy of the provided matrix.
		 * @param {Matrix3} matrix The matrix to negate.
		 * @param {Matrix3} result The object onto which to store the result.
		 * @returns {Matrix3} The modified result parameter.
		 */
		static negate(matrix: Matrix3, result: Matrix3): Matrix3;

		/**
		 * Computes the transpose of the provided matrix.
		 * @param {Matrix3} matrix The matrix to transpose.
		 * @param {Matrix3} result The object onto which to store the result.
		 * @returns {Matrix3} The modified result parameter.
		 */
		static transpose(matrix: Matrix3, result: Matrix3): Matrix3;

		/**
		 * Computes the eigenvectors and eigenvalues of a symmetric matrix.
		 * <p>
		 * Returns a diagonal matrix and unitary matrix such that:
		 * <code>matrix = unitary matrix * diagonal matrix * transpose(unitary matrix)</code>
		 * </p>
		 * <p>
		 * The values along the diagonal of the diagonal matrix are the eigenvalues. The columns
		 * of the unitary matrix are the corresponding eigenvectors.
		 * </p>
		 * @param {Matrix3} matrix The matrix to decompose into diagonal and unitary matrix. Expected to be symmetric.
		 * @param {Object} [result] An object with unitary and diagonal properties which are matrices onto which to store the result.
		 * @returns {Object} An object with unitary and diagonal properties which are the unitary and diagonal matrices, respectively.
		 * @example
		 * var a = //... symetric matrix
		 * var result = {
		 *     unitary : new Cesium.Matrix3(),
		 *     diagonal : new Cesium.Matrix3()
		 * };
		 * Cesium.Matrix3.computeEigenDecomposition(a, result);
		 * var unitaryTranspose = Cesium.Matrix3.transpose(result.unitary, new Cesium.Matrix3());
		 * var b = Cesium.Matrix3.multiply(result.unitary, result.diagonal, new Cesium.Matrix3());
		 * Cesium.Matrix3.multiply(b, unitaryTranspose, b); // b is now equal to a
		 * var lambda = Cesium.Matrix3.getColumn(result.diagonal, 0, new Cesium.Cartesian3()).x;  // first eigenvalue
		 * var v = Cesium.Matrix3.getColumn(result.unitary, 0, new Cesium.Cartesian3());          // first eigenvector
		 * var c = Cesium.Cartesian3.multiplyByScalar(v, lambda, new Cesium.Cartesian3());        // equal to Cesium.Matrix3.multiplyByVector(a, v)
		 */
		static computeEigenDecomposition(matrix: Matrix3, result?: any): any;

		/**
		 * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.
		 * @param {Matrix3} matrix The matrix with signed elements.
		 * @param {Matrix3} result The object onto which to store the result.
		 * @returns {Matrix3} The modified result parameter.
		 */
		static abs(matrix: Matrix3, result: Matrix3): Matrix3;

		/**
		 * Computes the determinant of the provided matrix.
		 * @param {Matrix3} matrix The matrix to use.
		 * @returns {Number} The value of the determinant of the matrix.
		 */
		static determinant(matrix: Matrix3): number;

		/**
		 * Computes the inverse of the provided matrix.
		 * @param {Matrix3} matrix The matrix to invert.
		 * @param {Matrix3} result The object onto which to store the result.
		 * @returns {Matrix3} The modified result parameter.
		 * @exception {DeveloperError} matrix is not invertible.
		 */
		static inverse(matrix: Matrix3, result: Matrix3): Matrix3;

		/**
		 * Compares the provided matrices componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Matrix3} [left] The first matrix.
		 * @param {Matrix3} [right] The second matrix.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		static equals(left?: Matrix3, right?: Matrix3): boolean;

		/**
		 * Compares the provided matrices componentwise and returns
		 * <code>true</code> if they are within the provided epsilon,
		 * <code>false</code> otherwise.
		 * @param {Matrix3} [left] The first matrix.
		 * @param {Matrix3} [right] The second matrix.
		 * @param {Number} [epsilon] The epsilon to use for equality testing.
		 * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
		 */
		static equalsEpsilon(left?: Matrix3, right?: Matrix3, epsilon?: number): boolean;

		/**
		 * An immutable Matrix3 instance initialized to the identity matrix.
		 * @type {Matrix3}
		 * @constant
		 */
		static IDENTITY: Matrix3;

		/**
		 * An immutable Matrix3 instance initialized to the zero matrix.
		 * @type {Matrix3}
		 * @constant
		 */
		static ZERO: Matrix3;

		/**
		 * The index into Matrix3 for column 0, row 0.
		 * @type {Number}
		 * @constant
		 */
		static COLUMN0ROW0: number;

		/**
		 * The index into Matrix3 for column 0, row 1.
		 * @type {Number}
		 * @constant
		 */
		static COLUMN0ROW1: number;

		/**
		 * The index into Matrix3 for column 0, row 2.
		 * @type {Number}
		 * @constant
		 */
		static COLUMN0ROW2: number;

		/**
		 * The index into Matrix3 for column 1, row 0.
		 * @type {Number}
		 * @constant
		 */
		static COLUMN1ROW0: number;

		/**
		 * The index into Matrix3 for column 1, row 1.
		 * @type {Number}
		 * @constant
		 */
		static COLUMN1ROW1: number;

		/**
		 * The index into Matrix3 for column 1, row 2.
		 * @type {Number}
		 * @constant
		 */
		static COLUMN1ROW2: number;

		/**
		 * The index into Matrix3 for column 2, row 0.
		 * @type {Number}
		 * @constant
		 */
		static COLUMN2ROW0: number;

		/**
		 * The index into Matrix3 for column 2, row 1.
		 * @type {Number}
		 * @constant
		 */
		static COLUMN2ROW1: number;

		/**
		 * The index into Matrix3 for column 2, row 2.
		 * @type {Number}
		 * @constant
		 */
		static COLUMN2ROW2: number;

		/**
		 * Gets the number of items in the collection.
		 * @memberof Matrix3.prototype
		 * @type {Number}
		 */
		length: number;

		/**
		 * Duplicates the provided Matrix3 instance.
		 * @param {Matrix3} [result] The object onto which to store the result.
		 * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if one was not provided.
		 */
		clone(result?: Matrix3): Matrix3;

		/**
		 * Compares this matrix to the provided matrix componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Matrix3} [right] The right hand side matrix.
		 * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
		 */
		equals(right?: Matrix3): boolean;

		/**
		 * Compares this matrix to the provided matrix componentwise and returns
		 * <code>true</code> if they are within the provided epsilon,
		 * <code>false</code> otherwise.
		 * @param {Matrix3} [right] The right hand side matrix.
		 * @param {Number} [epsilon] The epsilon to use for equality testing.
		 * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
		 */
		equalsEpsilon(right?: Matrix3, epsilon?: number): boolean;

		/**
		 * Creates a string representing this Matrix with each row being
		 * on a separate line and in the format '(column0, column1, column2)'.
		 * @returns {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1, column2)'.
		 */
		toString(): string;

	}

	/**
	 * A 4x4 matrix, indexable as a column-major order array.
	 * Constructor parameters are in row-major order for code readability.
	 * @alias Matrix4
	 * @constructor
	 * @param {Number} [column0Row0=0.0] The value for column 0, row 0.
	 * @param {Number} [column1Row0=0.0] The value for column 1, row 0.
	 * @param {Number} [column2Row0=0.0] The value for column 2, row 0.
	 * @param {Number} [column3Row0=0.0] The value for column 3, row 0.
	 * @param {Number} [column0Row1=0.0] The value for column 0, row 1.
	 * @param {Number} [column1Row1=0.0] The value for column 1, row 1.
	 * @param {Number} [column2Row1=0.0] The value for column 2, row 1.
	 * @param {Number} [column3Row1=0.0] The value for column 3, row 1.
	 * @param {Number} [column0Row2=0.0] The value for column 0, row 2.
	 * @param {Number} [column1Row2=0.0] The value for column 1, row 2.
	 * @param {Number} [column2Row2=0.0] The value for column 2, row 2.
	 * @param {Number} [column3Row2=0.0] The value for column 3, row 2.
	 * @param {Number} [column0Row3=0.0] The value for column 0, row 3.
	 * @param {Number} [column1Row3=0.0] The value for column 1, row 3.
	 * @param {Number} [column2Row3=0.0] The value for column 2, row 3.
	 * @param {Number} [column3Row3=0.0] The value for column 3, row 3.
	 * @see Matrix4.fromColumnMajorArray
	 * @see Matrix4.fromRowMajorArray
	 * @see Matrix4.fromRotationTranslation
	 * @see Matrix4.fromTranslationRotationScale
	 * @see Matrix4.fromTranslationQuaternionRotationScale
	 * @see Matrix4.fromTranslation
	 * @see Matrix4.fromScale
	 * @see Matrix4.fromUniformScale
	 * @see Matrix4.fromCamera
	 * @see Matrix4.computePerspectiveFieldOfView
	 * @see Matrix4.computeOrthographicOffCenter
	 * @see Matrix4.computePerspectiveOffCenter
	 * @see Matrix4.computeInfinitePerspectiveOffCenter
	 * @see Matrix4.computeViewportTransformation
	 * @see Matrix4.computeView
	 * @see Matrix2
	 * @see Matrix3
	 * @see Packable
	 */
	class Matrix4 {
		constructor(column0Row0?: number, column1Row0?: number, column2Row0?: number, column3Row0?: number, column0Row1?: number, column1Row1?: number, column2Row1?: number, column3Row1?: number, column0Row2?: number, column1Row2?: number, column2Row2?: number, column3Row2?: number, column0Row3?: number, column1Row3?: number, column2Row3?: number, column3Row3?: number);

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {Matrix4} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: Matrix4, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {Matrix4} [result] The object into which to store the result.
		 * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: Matrix4): Matrix4;

		/**
		 * Duplicates a Matrix4 instance.
		 * @param {Matrix4} matrix The matrix to duplicate.
		 * @param {Matrix4} [result] The object onto which to store the result.
		 * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided. (Returns undefined if matrix is undefined)
		 */
		static clone(matrix: Matrix4, result?: Matrix4): Matrix4;

		/**
		 * Creates a Matrix4 from 16 consecutive elements in an array.
		 * @function
		 * @param {Number[]} array The array whose 16 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.
		 * @param {Number} [startingIndex=0] The offset into the array of the first element, which corresponds to first column first row position in the matrix.
		 * @param {Matrix4} [result] The object onto which to store the result.
		 * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.
		 * @example
		 * // Create the Matrix4:
		 * // [1.0, 2.0, 3.0, 4.0]
		 * // [1.0, 2.0, 3.0, 4.0]
		 * // [1.0, 2.0, 3.0, 4.0]
		 * // [1.0, 2.0, 3.0, 4.0]
		 * var v = [1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0, 4.0];
		 * var m = Cesium.Matrix4.fromArray(v);
		 * // Create same Matrix4 with using an offset into an array
		 * var v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0, 4.0];
		 * var m2 = Cesium.Matrix4.fromArray(v2, 2);
		 */
		static fromArray(array: number[], startingIndex?: number, result?: Matrix4): Matrix4;

		/**
		 * Computes a Matrix4 instance from a column-major order array.
		 * @param {Number[]} values The column-major order array.
		 * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
		 * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.
		 */
		static fromColumnMajorArray(values: number[], result?: Matrix4): Matrix4;

		/**
		 * Computes a Matrix4 instance from a row-major order array.
		 * The resulting matrix will be in column-major order.
		 * @param {Number[]} values The row-major order array.
		 * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
		 * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.
		 */
		static fromRowMajorArray(values: number[], result?: Matrix4): Matrix4;

		/**
		 * Computes a Matrix4 instance from a Matrix3 representing the rotation
		 * and a Cartesian3 representing the translation.
		 * @param {Matrix3} rotation The upper left portion of the matrix representing the rotation.
		 * @param {Cartesian3} [translation=Cartesian3.ZERO] The upper right portion of the matrix representing the translation.
		 * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
		 * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.
		 */
		static fromRotationTranslation(rotation: Matrix3, translation?: Cartesian3, result?: Matrix4): Matrix4;

		/**
		 * Computes a Matrix4 instance from a translation, rotation, and scale (TRS)
		 * representation with the rotation represented as a quaternion.
		 * @param {Cartesian3} translation The translation transformation.
		 * @param {Quaternion} rotation The rotation transformation.
		 * @param {Cartesian3} scale The non-uniform scale transformation.
		 * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
		 * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.
		 * @example
		 * var result = Cesium.Matrix4.fromTranslationQuaternionRotationScale(
		 *   new Cesium.Cartesian3(1.0, 2.0, 3.0), // translation
		 *   Cesium.Quaternion.IDENTITY,           // rotation
		 *   new Cesium.Cartesian3(7.0, 8.0, 9.0), // scale
		 *   result);
		 */
		static fromTranslationQuaternionRotationScale(translation: Cartesian3, rotation: Quaternion, scale: Cartesian3, result?: Matrix4): Matrix4;

		/**
		 * Creates a Matrix4 instance from a {@link TranslationRotationScale} instance.
		 * @param {TranslationRotationScale} translationRotationScale The instance.
		 * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
		 * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.
		 */
		static fromTranslationRotationScale(translationRotationScale: TranslationRotationScale, result?: Matrix4): Matrix4;

		/**
		 * Creates a Matrix4 instance from a Cartesian3 representing the translation.
		 * @param {Cartesian3} translation The upper right portion of the matrix representing the translation.
		 * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
		 * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.
		 * @see Matrix4.multiplyByTranslation
		 */
		static fromTranslation(translation: Cartesian3, result?: Matrix4): Matrix4;

		/**
		 * Computes a Matrix4 instance representing a non-uniform scale.
		 * @param {Cartesian3} scale The x, y, and z scale factors.
		 * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
		 * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.
		 * @example
		 * // Creates
		 * //   [7.0, 0.0, 0.0, 0.0]
		 * //   [0.0, 8.0, 0.0, 0.0]
		 * //   [0.0, 0.0, 9.0, 0.0]
		 * //   [0.0, 0.0, 0.0, 1.0]
		 * var m = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(7.0, 8.0, 9.0));
		 */
		static fromScale(scale: Cartesian3, result?: Matrix4): Matrix4;

		/**
		 * Computes a Matrix4 instance representing a uniform scale.
		 * @param {Number} scale The uniform scale factor.
		 * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
		 * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.
		 * @example
		 * // Creates
		 * //   [2.0, 0.0, 0.0, 0.0]
		 * //   [0.0, 2.0, 0.0, 0.0]
		 * //   [0.0, 0.0, 2.0, 0.0]
		 * //   [0.0, 0.0, 0.0, 1.0]
		 * var m = Cesium.Matrix4.fromUniformScale(2.0);
		 */
		static fromUniformScale(scale: number, result?: Matrix4): Matrix4;

		/**
		 * Computes a Matrix4 instance from a Camera.
		 * @param {Camera} camera The camera to use.
		 * @param {Matrix4} [result] The object in which the result will be stored, if undefined a new instance will be created.
		 * @returns {Matrix4} The modified result parameter, or a new Matrix4 instance if one was not provided.
		 */
		static fromCamera(camera: Camera, result?: Matrix4): Matrix4;

		/**
		 * Computes a Matrix4 instance representing a perspective transformation matrix.
		 * @param {Number} fovY The field of view along the Y axis in radians.
		 * @param {Number} aspectRatio The aspect ratio.
		 * @param {Number} near The distance to the near plane in meters.
		 * @param {Number} far The distance to the far plane in meters.
		 * @param {Matrix4} result The object in which the result will be stored.
		 * @returns {Matrix4} The modified result parameter.
		 * @exception {DeveloperError} fovY must be in (0, PI].
		 * @exception {DeveloperError} aspectRatio must be greater than zero.
		 * @exception {DeveloperError} near must be greater than zero.
		 * @exception {DeveloperError} far must be greater than zero.
		 */
		static computePerspectiveFieldOfView(fovY: number, aspectRatio: number, near: number, far: number, result: Matrix4): Matrix4;

		/**
		 * Computes a Matrix4 instance representing an orthographic transformation matrix.
		 * @param {Number} left The number of meters to the left of the camera that will be in view.
		 * @param {Number} right The number of meters to the right of the camera that will be in view.
		 * @param {Number} bottom The number of meters below of the camera that will be in view.
		 * @param {Number} top The number of meters above of the camera that will be in view.
		 * @param {Number} near The distance to the near plane in meters.
		 * @param {Number} far The distance to the far plane in meters.
		 * @param {Matrix4} result The object in which the result will be stored.
		 * @returns {Matrix4} The modified result parameter.
		 */
		static computeOrthographicOffCenter(left: number, right: number, bottom: number, top: number, near: number, far: number, result: Matrix4): Matrix4;

		/**
		 * Computes a Matrix4 instance representing an off center perspective transformation.
		 * @param {Number} left The number of meters to the left of the camera that will be in view.
		 * @param {Number} right The number of meters to the right of the camera that will be in view.
		 * @param {Number} bottom The number of meters below of the camera that will be in view.
		 * @param {Number} top The number of meters above of the camera that will be in view.
		 * @param {Number} near The distance to the near plane in meters.
		 * @param {Number} far The distance to the far plane in meters.
		 * @param {Matrix4} result The object in which the result will be stored.
		 * @returns {Matrix4} The modified result parameter.
		 */
		static computePerspectiveOffCenter(left: number, right: number, bottom: number, top: number, near: number, far: number, result: Matrix4): Matrix4;

		/**
		 * Computes a Matrix4 instance representing an infinite off center perspective transformation.
		 * @param {Number} left The number of meters to the left of the camera that will be in view.
		 * @param {Number} right The number of meters to the right of the camera that will be in view.
		 * @param {Number} bottom The number of meters below of the camera that will be in view.
		 * @param {Number} top The number of meters above of the camera that will be in view.
		 * @param {Number} near The distance to the near plane in meters.
		 * @param {Matrix4} result The object in which the result will be stored.
		 * @returns {Matrix4} The modified result parameter.
		 */
		static computeInfinitePerspectiveOffCenter(left: number, right: number, bottom: number, top: number, near: number, result: Matrix4): Matrix4;

		/**
		 * Computes a Matrix4 instance that transforms from normalized device coordinates to window coordinates.
		 * @param {Object}[viewport = { x : 0.0, y : 0.0, width : 0.0, height : 0.0 }] The viewport's corners as shown in Example 1.
		 * @param {Number}[nearDepthRange=0.0] The near plane distance in window coordinates.
		 * @param {Number}[farDepthRange=1.0] The far plane distance in window coordinates.
		 * @param {Matrix4} [result] The object in which the result will be stored.
		 * @returns {Matrix4} The modified result parameter.
		 * @example
		 * // Create viewport transformation using an explicit viewport and depth range.
		 * var m = Cesium.Matrix4.computeViewportTransformation({
		 *     x : 0.0,
		 *     y : 0.0,
		 *     width : 1024.0,
		 *     height : 768.0
		 * }, 0.0, 1.0, new Cesium.Matrix4());
		 */
		static computeViewportTransformation(viewport?: any, nearDepthRange?: number, farDepthRange?: number, result?: Matrix4): Matrix4;

		/**
		 * Computes a Matrix4 instance that transforms from world space to view space.
		 * @param {Cartesian3} position The position of the camera.
		 * @param {Cartesian3} direction The forward direction.
		 * @param {Cartesian3} up The up direction.
		 * @param {Cartesian3} right The right direction.
		 * @param {Matrix4} result The object in which the result will be stored.
		 * @returns {Matrix4} The modified result parameter.
		 */
		static computeView(position: Cartesian3, direction: Cartesian3, up: Cartesian3, right: Cartesian3, result: Matrix4): Matrix4;

		/**
		 * Computes an Array from the provided Matrix4 instance.
		 * The array will be in column-major order.
		 * @param {Matrix4} matrix The matrix to use..
		 * @param {Number[]} [result] The Array onto which to store the result.
		 * @returns {Number[]} The modified Array parameter or a new Array instance if one was not provided.
		 * @example
		 * //create an array from an instance of Matrix4
		 * // m = [10.0, 14.0, 18.0, 22.0]
		 * //     [11.0, 15.0, 19.0, 23.0]
		 * //     [12.0, 16.0, 20.0, 24.0]
		 * //     [13.0, 17.0, 21.0, 25.0]
		 * var a = Cesium.Matrix4.toArray(m);
		 * // m remains the same
		 * //creates a = [10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0, 25.0]
		 */
		static toArray(matrix: Matrix4, result?: number[]): number[];

		/**
		 * Computes the array index of the element at the provided row and column.
		 * @param {Number} row The zero-based index of the row.
		 * @param {Number} column The zero-based index of the column.
		 * @returns {Number} The index of the element at the provided row and column.
		 * @exception {DeveloperError} row must be 0, 1, 2, or 3.
		 * @exception {DeveloperError} column must be 0, 1, 2, or 3.
		 * @example
		 * var myMatrix = new Cesium.Matrix4();
		 * var column1Row0Index = Cesium.Matrix4.getElementIndex(1, 0);
		 * var column1Row0 = myMatrix[column1Row0Index];
		 * myMatrix[column1Row0Index] = 10.0;
		 */
		static getElementIndex(row: number, column: number): number;

		/**
		 * Retrieves a copy of the matrix column at the provided index as a Cartesian4 instance.
		 * @param {Matrix4} matrix The matrix to use.
		 * @param {Number} index The zero-based index of the column to retrieve.
		 * @param {Cartesian4} result The object onto which to store the result.
		 * @returns {Cartesian4} The modified result parameter.
		 * @exception {DeveloperError} index must be 0, 1, 2, or 3.
		 * @example
		 * //returns a Cartesian4 instance with values from the specified column
		 * // m = [10.0, 11.0, 12.0, 13.0]
		 * //     [14.0, 15.0, 16.0, 17.0]
		 * //     [18.0, 19.0, 20.0, 21.0]
		 * //     [22.0, 23.0, 24.0, 25.0]
		 * //Example 1: Creates an instance of Cartesian
		 * var a = Cesium.Matrix4.getColumn(m, 2, new Cesium.Cartesian4());
		 * @example
		 * //Example 2: Sets values for Cartesian instance
		 * var a = new Cesium.Cartesian4();
		 * Cesium.Matrix4.getColumn(m, 2, a);
		 * // a.x = 12.0; a.y = 16.0; a.z = 20.0; a.w = 24.0;
		 */
		static getColumn(matrix: Matrix4, index: number, result: Cartesian4): Cartesian4;

		/**
		 * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian4 instance.
		 * @param {Matrix4} matrix The matrix to use.
		 * @param {Number} index The zero-based index of the column to set.
		 * @param {Cartesian4} cartesian The Cartesian whose values will be assigned to the specified column.
		 * @param {Matrix4} result The object onto which to store the result.
		 * @returns {Matrix4} The modified result parameter.
		 * @exception {DeveloperError} index must be 0, 1, 2, or 3.
		 * @example
		 * //creates a new Matrix4 instance with new column values from the Cartesian4 instance
		 * // m = [10.0, 11.0, 12.0, 13.0]
		 * //     [14.0, 15.0, 16.0, 17.0]
		 * //     [18.0, 19.0, 20.0, 21.0]
		 * //     [22.0, 23.0, 24.0, 25.0]
		 * var a = Cesium.Matrix4.setColumn(m, 2, new Cesium.Cartesian4(99.0, 98.0, 97.0, 96.0), new Cesium.Matrix4());
		 * // m remains the same
		 * // a = [10.0, 11.0, 99.0, 13.0]
		 * //     [14.0, 15.0, 98.0, 17.0]
		 * //     [18.0, 19.0, 97.0, 21.0]
		 * //     [22.0, 23.0, 96.0, 25.0]
		 */
		static setColumn(matrix: Matrix4, index: number, cartesian: Cartesian4, result: Matrix4): Matrix4;

		/**
		 * Computes a new matrix that replaces the translation in the rightmost column of the provided
		 * matrix with the provided translation.  This assumes the matrix is an affine transformation
		 * @param {Matrix4} matrix The matrix to use.
		 * @param {Cartesian3} translation The translation that replaces the translation of the provided matrix.
		 * @param {Matrix4} result The object onto which to store the result.
		 * @returns {Matrix4} The modified result parameter.
		 */
		static setTranslation(matrix: Matrix4, translation: Cartesian3, result: Matrix4): Matrix4;

		/**
		 * Computes a new matrix that replaces the scale with the provided scale.  This assumes the matrix is an affine transformation
		 * @param {Matrix4} matrix The matrix to use.
		 * @param {Cartesian3} scale The scale that replaces the scale of the provided matrix.
		 * @param {Matrix4} result The object onto which to store the result.
		 * @returns {Matrix4} The modified result parameter.
		 */
		static setScale(matrix: Matrix4, scale: Cartesian3, result: Matrix4): Matrix4;

		/**
		 * Retrieves a copy of the matrix row at the provided index as a Cartesian4 instance.
		 * @param {Matrix4} matrix The matrix to use.
		 * @param {Number} index The zero-based index of the row to retrieve.
		 * @param {Cartesian4} result The object onto which to store the result.
		 * @returns {Cartesian4} The modified result parameter.
		 * @exception {DeveloperError} index must be 0, 1, 2, or 3.
		 * @example
		 * //returns a Cartesian4 instance with values from the specified column
		 * // m = [10.0, 11.0, 12.0, 13.0]
		 * //     [14.0, 15.0, 16.0, 17.0]
		 * //     [18.0, 19.0, 20.0, 21.0]
		 * //     [22.0, 23.0, 24.0, 25.0]
		 * //Example 1: Returns an instance of Cartesian
		 * var a = Cesium.Matrix4.getRow(m, 2, new Cesium.Cartesian4());
		 * @example
		 * //Example 2: Sets values for a Cartesian instance
		 * var a = new Cesium.Cartesian4();
		 * Cesium.Matrix4.getRow(m, 2, a);
		 * // a.x = 18.0; a.y = 19.0; a.z = 20.0; a.w = 21.0;
		 */
		static getRow(matrix: Matrix4, index: number, result: Cartesian4): Cartesian4;

		/**
		 * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian4 instance.
		 * @param {Matrix4} matrix The matrix to use.
		 * @param {Number} index The zero-based index of the row to set.
		 * @param {Cartesian4} cartesian The Cartesian whose values will be assigned to the specified row.
		 * @param {Matrix4} result The object onto which to store the result.
		 * @returns {Matrix4} The modified result parameter.
		 * @exception {DeveloperError} index must be 0, 1, 2, or 3.
		 * @example
		 * //create a new Matrix4 instance with new row values from the Cartesian4 instance
		 * // m = [10.0, 11.0, 12.0, 13.0]
		 * //     [14.0, 15.0, 16.0, 17.0]
		 * //     [18.0, 19.0, 20.0, 21.0]
		 * //     [22.0, 23.0, 24.0, 25.0]
		 * var a = Cesium.Matrix4.setRow(m, 2, new Cesium.Cartesian4(99.0, 98.0, 97.0, 96.0), new Cesium.Matrix4());
		 * // m remains the same
		 * // a = [10.0, 11.0, 12.0, 13.0]
		 * //     [14.0, 15.0, 16.0, 17.0]
		 * //     [99.0, 98.0, 97.0, 96.0]
		 * //     [22.0, 23.0, 24.0, 25.0]
		 */
		static setRow(matrix: Matrix4, index: number, cartesian: Cartesian4, result: Matrix4): Matrix4;

		/**
		 * Extracts the non-uniform scale assuming the matrix is an affine transformation.
		 * @param {Matrix4} matrix The matrix.
		 * @param {Cartesian3} result The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter
		 */
		static getScale(matrix: Matrix4, result: Cartesian3): Cartesian3;

		/**
		 * Computes the maximum scale assuming the matrix is an affine transformation.
		 * The maximum scale is the maximum length of the column vectors in the upper-left
		 * 3x3 matrix.
		 * @param {Matrix4} matrix The matrix.
		 * @returns {Number} The maximum scale.
		 */
		static getMaximumScale(matrix: Matrix4): number;

		/**
		 * Computes the product of two matrices.
		 * @param {Matrix4} left The first matrix.
		 * @param {Matrix4} right The second matrix.
		 * @param {Matrix4} result The object onto which to store the result.
		 * @returns {Matrix4} The modified result parameter.
		 */
		static multiply(left: Matrix4, right: Matrix4, result: Matrix4): Matrix4;

		/**
		 * Computes the sum of two matrices.
		 * @param {Matrix4} left The first matrix.
		 * @param {Matrix4} right The second matrix.
		 * @param {Matrix4} result The object onto which to store the result.
		 * @returns {Matrix4} The modified result parameter.
		 */
		static add(left: Matrix4, right: Matrix4, result: Matrix4): Matrix4;

		/**
		 * Computes the difference of two matrices.
		 * @param {Matrix4} left The first matrix.
		 * @param {Matrix4} right The second matrix.
		 * @param {Matrix4} result The object onto which to store the result.
		 * @returns {Matrix4} The modified result parameter.
		 */
		static subtract(left: Matrix4, right: Matrix4, result: Matrix4): Matrix4;

		/**
		 * Computes the product of two matrices assuming the matrices are
		 * affine transformation matrices, where the upper left 3x3 elements
		 * are a rotation matrix, and the upper three elements in the fourth
		 * column are the translation.  The bottom row is assumed to be [0, 0, 0, 1].
		 * The matrix is not verified to be in the proper form.
		 * This method is faster than computing the product for general 4x4
		 * matrices using {@link Matrix4.multiply}.
		 * @param {Matrix4} left The first matrix.
		 * @param {Matrix4} right The second matrix.
		 * @param {Matrix4} result The object onto which to store the result.
		 * @returns {Matrix4} The modified result parameter.
		 * @example
		 * var m1 = new Cesium.Matrix4(1.0, 6.0, 7.0, 0.0, 2.0, 5.0, 8.0, 0.0, 3.0, 4.0, 9.0, 0.0, 0.0, 0.0, 0.0, 1.0);
		 * var m2 = Cesium.Transforms.eastNorthUpToFixedFrame(new Cesium.Cartesian3(1.0, 1.0, 1.0));
		 * var m3 = Cesium.Matrix4.multiplyTransformation(m1, m2, new Cesium.Matrix4());
		 */
		static multiplyTransformation(left: Matrix4, right: Matrix4, result: Matrix4): Matrix4;

		/**
		 * Multiplies a transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)
		 * by a 3x3 rotation matrix.  This is an optimization
		 * for <code>Matrix4.multiply(m, Matrix4.fromRotationTranslation(rotation), m);</code> with less allocations and arithmetic operations.
		 * @param {Matrix4} matrix The matrix on the left-hand side.
		 * @param {Matrix3} rotation The 3x3 rotation matrix on the right-hand side.
		 * @param {Matrix4} result The object onto which to store the result.
		 * @returns {Matrix4} The modified result parameter.
		 * @example
		 * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromRotationTranslation(rotation), m);
		 * Cesium.Matrix4.multiplyByMatrix3(m, rotation, m);
		 */
		static multiplyByMatrix3(matrix: Matrix4, rotation: Matrix3, result: Matrix4): Matrix4;

		/**
		 * Multiplies a transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)
		 * by an implicit translation matrix defined by a {@link Cartesian3}.  This is an optimization
		 * for <code>Matrix4.multiply(m, Matrix4.fromTranslation(position), m);</code> with less allocations and arithmetic operations.
		 * @param {Matrix4} matrix The matrix on the left-hand side.
		 * @param {Cartesian3} translation The translation on the right-hand side.
		 * @param {Matrix4} result The object onto which to store the result.
		 * @returns {Matrix4} The modified result parameter.
		 * @example
		 * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromTranslation(position), m);
		 * Cesium.Matrix4.multiplyByTranslation(m, position, m);
		 */
		static multiplyByTranslation(matrix: Matrix4, translation: Cartesian3, result: Matrix4): Matrix4;

		/**
		 * Multiplies an affine transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)
		 * by an implicit uniform scale matrix.  This is an optimization
		 * for <code>Matrix4.multiply(m, Matrix4.fromUniformScale(scale), m);</code>, where
		 * <code>m</code> must be an affine matrix.
		 * This function performs fewer allocations and arithmetic operations.
		 * @param {Matrix4} matrix The affine matrix on the left-hand side.
		 * @param {Number} scale The uniform scale on the right-hand side.
		 * @param {Matrix4} result The object onto which to store the result.
		 * @returns {Matrix4} The modified result parameter.
		 * @example
		 * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromUniformScale(scale), m);
		 * Cesium.Matrix4.multiplyByUniformScale(m, scale, m);
		 * @see Matrix4.fromUniformScale
		 * @see Matrix4.multiplyByScale
		 */
		static multiplyByUniformScale(matrix: Matrix4, scale: number, result: Matrix4): Matrix4;

		/**
		 * Multiplies an affine transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)
		 * by an implicit non-uniform scale matrix.  This is an optimization
		 * for <code>Matrix4.multiply(m, Matrix4.fromUniformScale(scale), m);</code>, where
		 * <code>m</code> must be an affine matrix.
		 * This function performs fewer allocations and arithmetic operations.
		 * @param {Matrix4} matrix The affine matrix on the left-hand side.
		 * @param {Cartesian3} scale The non-uniform scale on the right-hand side.
		 * @param {Matrix4} result The object onto which to store the result.
		 * @returns {Matrix4} The modified result parameter.
		 * @example
		 * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromScale(scale), m);
		 * Cesium.Matrix4.multiplyByScale(m, scale, m);
		 * @see Matrix4.fromScale
		 * @see Matrix4.multiplyByUniformScale
		 */
		static multiplyByScale(matrix: Matrix4, scale: Cartesian3, result: Matrix4): Matrix4;

		/**
		 * Computes the product of a matrix and a column vector.
		 * @param {Matrix4} matrix The matrix.
		 * @param {Cartesian4} cartesian The vector.
		 * @param {Cartesian4} result The object onto which to store the result.
		 * @returns {Cartesian4} The modified result parameter.
		 */
		static multiplyByVector(matrix: Matrix4, cartesian: Cartesian4, result: Cartesian4): Cartesian4;

		/**
		 * Computes the product of a matrix and a {@link Cartesian3}.  This is equivalent to calling {@link Matrix4.multiplyByVector}
		 * with a {@link Cartesian4} with a <code>w</code> component of zero.
		 * @param {Matrix4} matrix The matrix.
		 * @param {Cartesian3} cartesian The point.
		 * @param {Cartesian3} result The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter.
		 * @example
		 * var p = new Cesium.Cartesian3(1.0, 2.0, 3.0);
		 * var result = Cesium.Matrix4.multiplyByPointAsVector(matrix, p, new Cesium.Cartesian3());
		 * // A shortcut for
		 * //   Cartesian3 p = ...
		 * //   Cesium.Matrix4.multiplyByVector(matrix, new Cesium.Cartesian4(p.x, p.y, p.z, 0.0), result);
		 */
		static multiplyByPointAsVector(matrix: Matrix4, cartesian: Cartesian3, result: Cartesian3): Cartesian3;

		/**
		 * Computes the product of a matrix and a {@link Cartesian3}. This is equivalent to calling {@link Matrix4.multiplyByVector}
		 * with a {@link Cartesian4} with a <code>w</code> component of 1, but returns a {@link Cartesian3} instead of a {@link Cartesian4}.
		 * @param {Matrix4} matrix The matrix.
		 * @param {Cartesian3} cartesian The point.
		 * @param {Cartesian3} result The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter.
		 * @example
		 * var p = new Cesium.Cartesian3(1.0, 2.0, 3.0);
		 * var result = Cesium.Matrix4.multiplyByPoint(matrix, p, new Cesium.Cartesian3());
		 */
		static multiplyByPoint(matrix: Matrix4, cartesian: Cartesian3, result: Cartesian3): Cartesian3;

		/**
		 * Computes the product of a matrix and a scalar.
		 * @param {Matrix4} matrix The matrix.
		 * @param {Number} scalar The number to multiply by.
		 * @param {Matrix4} result The object onto which to store the result.
		 * @returns {Matrix4} The modified result parameter.
		 * @example
		 * //create a Matrix4 instance which is a scaled version of the supplied Matrix4
		 * // m = [10.0, 11.0, 12.0, 13.0]
		 * //     [14.0, 15.0, 16.0, 17.0]
		 * //     [18.0, 19.0, 20.0, 21.0]
		 * //     [22.0, 23.0, 24.0, 25.0]
		 * var a = Cesium.Matrix4.multiplyByScalar(m, -2, new Cesium.Matrix4());
		 * // m remains the same
		 * // a = [-20.0, -22.0, -24.0, -26.0]
		 * //     [-28.0, -30.0, -32.0, -34.0]
		 * //     [-36.0, -38.0, -40.0, -42.0]
		 * //     [-44.0, -46.0, -48.0, -50.0]
		 */
		static multiplyByScalar(matrix: Matrix4, scalar: number, result: Matrix4): Matrix4;

		/**
		 * Computes a negated copy of the provided matrix.
		 * @param {Matrix4} matrix The matrix to negate.
		 * @param {Matrix4} result The object onto which to store the result.
		 * @returns {Matrix4} The modified result parameter.
		 * @example
		 * //create a new Matrix4 instance which is a negation of a Matrix4
		 * // m = [10.0, 11.0, 12.0, 13.0]
		 * //     [14.0, 15.0, 16.0, 17.0]
		 * //     [18.0, 19.0, 20.0, 21.0]
		 * //     [22.0, 23.0, 24.0, 25.0]
		 * var a = Cesium.Matrix4.negate(m, new Cesium.Matrix4());
		 * // m remains the same
		 * // a = [-10.0, -11.0, -12.0, -13.0]
		 * //     [-14.0, -15.0, -16.0, -17.0]
		 * //     [-18.0, -19.0, -20.0, -21.0]
		 * //     [-22.0, -23.0, -24.0, -25.0]
		 */
		static negate(matrix: Matrix4, result: Matrix4): Matrix4;

		/**
		 * Computes the transpose of the provided matrix.
		 * @param {Matrix4} matrix The matrix to transpose.
		 * @param {Matrix4} result The object onto which to store the result.
		 * @returns {Matrix4} The modified result parameter.
		 * @example
		 * //returns transpose of a Matrix4
		 * // m = [10.0, 11.0, 12.0, 13.0]
		 * //     [14.0, 15.0, 16.0, 17.0]
		 * //     [18.0, 19.0, 20.0, 21.0]
		 * //     [22.0, 23.0, 24.0, 25.0]
		 * var a = Cesium.Matrix4.transpose(m, new Cesium.Matrix4());
		 * // m remains the same
		 * // a = [10.0, 14.0, 18.0, 22.0]
		 * //     [11.0, 15.0, 19.0, 23.0]
		 * //     [12.0, 16.0, 20.0, 24.0]
		 * //     [13.0, 17.0, 21.0, 25.0]
		 */
		static transpose(matrix: Matrix4, result: Matrix4): Matrix4;

		/**
		 * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.
		 * @param {Matrix4} matrix The matrix with signed elements.
		 * @param {Matrix4} result The object onto which to store the result.
		 * @returns {Matrix4} The modified result parameter.
		 */
		static abs(matrix: Matrix4, result: Matrix4): Matrix4;

		/**
		 * Compares the provided matrices componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Matrix4} [left] The first matrix.
		 * @param {Matrix4} [right] The second matrix.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 * @example
		 * //compares two Matrix4 instances
		 * // a = [10.0, 14.0, 18.0, 22.0]
		 * //     [11.0, 15.0, 19.0, 23.0]
		 * //     [12.0, 16.0, 20.0, 24.0]
		 * //     [13.0, 17.0, 21.0, 25.0]
		 * // b = [10.0, 14.0, 18.0, 22.0]
		 * //     [11.0, 15.0, 19.0, 23.0]
		 * //     [12.0, 16.0, 20.0, 24.0]
		 * //     [13.0, 17.0, 21.0, 25.0]
		 * if(Cesium.Matrix4.equals(a,b)) {
		 *      console.log("Both matrices are equal");
		 * } else {
		 *      console.log("They are not equal");
		 * }
		 * //Prints "Both matrices are equal" on the console
		 */
		static equals(left?: Matrix4, right?: Matrix4): boolean;

		/**
		 * Compares the provided matrices componentwise and returns
		 * <code>true</code> if they are within the provided epsilon,
		 * <code>false</code> otherwise.
		 * @param {Matrix4} [left] The first matrix.
		 * @param {Matrix4} [right] The second matrix.
		 * @param {Number} [epsilon] The epsilon to use for equality testing.
		 * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
		 * @example
		 * //compares two Matrix4 instances
		 * // a = [10.5, 14.5, 18.5, 22.5]
		 * //     [11.5, 15.5, 19.5, 23.5]
		 * //     [12.5, 16.5, 20.5, 24.5]
		 * //     [13.5, 17.5, 21.5, 25.5]
		 * // b = [10.0, 14.0, 18.0, 22.0]
		 * //     [11.0, 15.0, 19.0, 23.0]
		 * //     [12.0, 16.0, 20.0, 24.0]
		 * //     [13.0, 17.0, 21.0, 25.0]
		 * if(Cesium.Matrix4.equalsEpsilon(a,b,0.1)){
		 *      console.log("Difference between both the matrices is less than 0.1");
		 * } else {
		 *      console.log("Difference between both the matrices is not less than 0.1");
		 * }
		 * //Prints "Difference between both the matrices is not less than 0.1" on the console
		 */
		static equalsEpsilon(left?: Matrix4, right?: Matrix4, epsilon?: number): boolean;

		/**
		 * Gets the translation portion of the provided matrix, assuming the matrix is a affine transformation matrix.
		 * @param {Matrix4} matrix The matrix to use.
		 * @param {Cartesian3} result The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter.
		 */
		static getTranslation(matrix: Matrix4, result: Cartesian3): Cartesian3;

		/**
		 * Gets the upper left 3x3 rotation matrix of the provided matrix, assuming the matrix is a affine transformation matrix.
		 * @param {Matrix4} matrix The matrix to use.
		 * @param {Matrix3} result The object onto which to store the result.
		 * @returns {Matrix3} The modified result parameter.
		 * @example
		 * // returns a Matrix3 instance from a Matrix4 instance
		 * // m = [10.0, 14.0, 18.0, 22.0]
		 * //     [11.0, 15.0, 19.0, 23.0]
		 * //     [12.0, 16.0, 20.0, 24.0]
		 * //     [13.0, 17.0, 21.0, 25.0]
		 * var b = new Cesium.Matrix3();
		 * Cesium.Matrix4.getRotation(m,b);
		 * // b = [10.0, 14.0, 18.0]
		 * //     [11.0, 15.0, 19.0]
		 * //     [12.0, 16.0, 20.0]
		 */
		static getRotation(matrix: Matrix4, result: Matrix3): Matrix3;

		/**
		 * Computes the inverse of the provided matrix using Cramers Rule.
		 * If the determinant is zero, the matrix can not be inverted, and an exception is thrown.
		 * If the matrix is an affine transformation matrix, it is more efficient
		 * to invert it with {@link Matrix4.inverseTransformation}.
		 * @param {Matrix4} matrix The matrix to invert.
		 * @param {Matrix4} result The object onto which to store the result.
		 * @returns {Matrix4} The modified result parameter.
		 * @exception {RuntimeError} matrix is not invertible because its determinate is zero.
		 */
		static inverse(matrix: Matrix4, result: Matrix4): Matrix4;

		/**
		 * Computes the inverse of the provided matrix assuming it is
		 * an affine transformation matrix, where the upper left 3x3 elements
		 * are a rotation matrix, and the upper three elements in the fourth
		 * column are the translation.  The bottom row is assumed to be [0, 0, 0, 1].
		 * The matrix is not verified to be in the proper form.
		 * This method is faster than computing the inverse for a general 4x4
		 * matrix using {@link Matrix4.inverse}.
		 * @param {Matrix4} matrix The matrix to invert.
		 * @param {Matrix4} result The object onto which to store the result.
		 * @returns {Matrix4} The modified result parameter.
		 */
		static inverseTransformation(matrix: Matrix4, result: Matrix4): Matrix4;

		/**
		 * An immutable Matrix4 instance initialized to the identity matrix.
		 * @type {Matrix4}
		 * @constant
		 */
		static IDENTITY: Matrix4;

		/**
		 * An immutable Matrix4 instance initialized to the zero matrix.
		 * @type {Matrix4}
		 * @constant
		 */
		static ZERO: Matrix4;

		/**
		 * The index into Matrix4 for column 0, row 0.
		 * @type {Number}
		 * @constant
		 */
		static COLUMN0ROW0: number;

		/**
		 * The index into Matrix4 for column 0, row 1.
		 * @type {Number}
		 * @constant
		 */
		static COLUMN0ROW1: number;

		/**
		 * The index into Matrix4 for column 0, row 2.
		 * @type {Number}
		 * @constant
		 */
		static COLUMN0ROW2: number;

		/**
		 * The index into Matrix4 for column 0, row 3.
		 * @type {Number}
		 * @constant
		 */
		static COLUMN0ROW3: number;

		/**
		 * The index into Matrix4 for column 1, row 0.
		 * @type {Number}
		 * @constant
		 */
		static COLUMN1ROW0: number;

		/**
		 * The index into Matrix4 for column 1, row 1.
		 * @type {Number}
		 * @constant
		 */
		static COLUMN1ROW1: number;

		/**
		 * The index into Matrix4 for column 1, row 2.
		 * @type {Number}
		 * @constant
		 */
		static COLUMN1ROW2: number;

		/**
		 * The index into Matrix4 for column 1, row 3.
		 * @type {Number}
		 * @constant
		 */
		static COLUMN1ROW3: number;

		/**
		 * The index into Matrix4 for column 2, row 0.
		 * @type {Number}
		 * @constant
		 */
		static COLUMN2ROW0: number;

		/**
		 * The index into Matrix4 for column 2, row 1.
		 * @type {Number}
		 * @constant
		 */
		static COLUMN2ROW1: number;

		/**
		 * The index into Matrix4 for column 2, row 2.
		 * @type {Number}
		 * @constant
		 */
		static COLUMN2ROW2: number;

		/**
		 * The index into Matrix4 for column 2, row 3.
		 * @type {Number}
		 * @constant
		 */
		static COLUMN2ROW3: number;

		/**
		 * The index into Matrix4 for column 3, row 0.
		 * @type {Number}
		 * @constant
		 */
		static COLUMN3ROW0: number;

		/**
		 * The index into Matrix4 for column 3, row 1.
		 * @type {Number}
		 * @constant
		 */
		static COLUMN3ROW1: number;

		/**
		 * The index into Matrix4 for column 3, row 2.
		 * @type {Number}
		 * @constant
		 */
		static COLUMN3ROW2: number;

		/**
		 * The index into Matrix4 for column 3, row 3.
		 * @type {Number}
		 * @constant
		 */
		static COLUMN3ROW3: number;

		/**
		 * Gets the number of items in the collection.
		 * @memberof Matrix4.prototype
		 * @type {Number}
		 */
		length: number;

		/**
		 * Duplicates the provided Matrix4 instance.
		 * @param {Matrix4} [result] The object onto which to store the result.
		 * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if one was not provided.
		 */
		clone(result?: Matrix4): Matrix4;

		/**
		 * Compares this matrix to the provided matrix componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Matrix4} [right] The right hand side matrix.
		 * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
		 */
		equals(right?: Matrix4): boolean;

		/**
		 * Compares this matrix to the provided matrix componentwise and returns
		 * <code>true</code> if they are within the provided epsilon,
		 * <code>false</code> otherwise.
		 * @param {Matrix4} [right] The right hand side matrix.
		 * @param {Number} [epsilon] The epsilon to use for equality testing.
		 * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
		 */
		equalsEpsilon(right?: Matrix4, epsilon?: number): boolean;

		/**
		 * Computes a string representing this Matrix with each row being
		 * on a separate line and in the format '(column0, column1, column2, column3)'.
		 * @returns {String} A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1, column2, column3)'.
		 */
		toString(): string;

	}

	/**
	 * A stable merge sort.
	 * @exports mergeSort
	 * @param {Array} array The array to sort.
	 * @param {mergeSort~Function} comparator The function to use to compare elements in the array.
	 * @param {*} [userDefinedObject] Any item to pass as the third parameter to <code>comparator</code>.
	 * @example
	 * // Assume array contains BoundingSpheres in world coordinates.
	 * // Sort them in ascending order of distance from the camera.
	 * var position = camera.positionWC;
	 * Cesium.mergeSort(array, function(a, b, position) {
	 *     return Cesium.BoundingSphere.distanceSquaredTo(b, position) - Cesium.BoundingSphere.distanceSquaredTo(a, position);
	 * }, position);
	 */
	namespace mergeSort {
	}

	/**
	 * Represents a scalar value's lower and upper bound at a near distance and far distance in eye space.
	 * @alias NearFarScalar
	 * @constructor
	 * @param {Number} [near=0.0] The lower bound of the camera range.
	 * @param {Number} [nearValue=0.0] The value at the lower bound of the camera range.
	 * @param {Number} [far=1.0] The upper bound of the camera range.
	 * @param {Number} [farValue=0.0] The value at the upper bound of the camera range.
	 * @see Packable
	 */
	class NearFarScalar {
		constructor(near?: number, nearValue?: number, far?: number, farValue?: number);

		/**
		 * The lower bound of the camera range.
		 * @type {Number}
		 * @default 0.0
		 */
		near: number;

		/**
		 * The value at the lower bound of the camera range.
		 * @type {Number}
		 * @default 0.0
		 */
		nearValue: number;

		/**
		 * The upper bound of the camera range.
		 * @type {Number}
		 * @default 1.0
		 */
		far: number;

		/**
		 * The value at the upper bound of the camera range.
		 * @type {Number}
		 * @default 0.0
		 */
		farValue: number;

		/**
		 * Duplicates a NearFarScalar instance.
		 * @param {NearFarScalar} nearFarScalar The NearFarScalar to duplicate.
		 * @param {NearFarScalar} [result] The object onto which to store the result.
		 * @returns {NearFarScalar} The modified result parameter or a new NearFarScalar instance if one was not provided. (Returns undefined if nearFarScalar is undefined)
		 */
		static clone(nearFarScalar: NearFarScalar, result?: NearFarScalar): NearFarScalar;

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {NearFarScalar} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: NearFarScalar, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {NearFarScalar} [result] The object into which to store the result.
		 * @returns {NearFarScalar} The modified result parameter or a new NearFarScalar instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: NearFarScalar): NearFarScalar;

		/**
		 * Compares the provided NearFarScalar and returns <code>true</code> if they are equal,
		 * <code>false</code> otherwise.
		 * @param {NearFarScalar} [left] The first NearFarScalar.
		 * @param {NearFarScalar} [right] The second NearFarScalar.
		 * @returns {Boolean} <code>true</code> if left and right are equal; otherwise <code>false</code>.
		 */
		static equals(left?: NearFarScalar, right?: NearFarScalar): boolean;

		/**
		 * Duplicates this instance.
		 * @param {NearFarScalar} [result] The object onto which to store the result.
		 * @returns {NearFarScalar} The modified result parameter or a new NearFarScalar instance if one was not provided.
		 */
		clone(result?: NearFarScalar): NearFarScalar;

		/**
		 * Compares this instance to the provided NearFarScalar and returns <code>true</code> if they are equal,
		 * <code>false</code> otherwise.
		 * @param {NearFarScalar} [right] The right hand side NearFarScalar.
		 * @returns {Boolean} <code>true</code> if left and right are equal; otherwise <code>false</code>.
		 */
		equals(right?: NearFarScalar): boolean;

	}

	/**
	 * Converts an object representing a set of name/value pairs into a query string,
	 * with names and values encoded properly for use in a URL.  Values that are arrays
	 * will produce multiple values with the same name.
	 * @exports objectToQuery
	 * @param {Object} obj The object containing data to encode.
	 * @returns {String} An encoded query string.
	 * @example
	 * var str = Cesium.objectToQuery({
	 *     key1 : 'some value',
	 *     key2 : 'a/b',
	 *     key3 : ['x', 'y']
	 * });
	 * @see queryToObject
	 * // str will be:
	 * // 'key1=some%20value&key2=a%2Fb&key3=x&key3=y'
	 */
	namespace objectToQuery {
	}

	/**
	 * Creates an Occluder derived from an object's position and radius, as well as the camera position.
	 * The occluder can be used to determine whether or not other objects are visible or hidden behind the
	 * visible horizon defined by the occluder and camera position.
	 * @alias Occluder
	 * @param {BoundingSphere} occluderBoundingSphere The bounding sphere surrounding the occluder.
	 * @param {Cartesian3} cameraPosition The coordinate of the viewer/camera.
	 * @constructor
	 * @example
	 * // Construct an occluder one unit away from the origin with a radius of one.
	 * var cameraPosition = Cesium.Cartesian3.ZERO;
	 * var occluderBoundingSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1), 1);
	 * var occluder = new Cesium.Occluder(occluderBoundingSphere, cameraPosition);
	 */
	class Occluder {
		constructor(occluderBoundingSphere: BoundingSphere, cameraPosition: Cartesian3);

		/**
		 * The position of the occluder.
		 * @memberof Occluder.prototype
		 * @type {Cartesian3}
		 */
		position: Cartesian3;

		/**
		 * The radius of the occluder.
		 * @memberof Occluder.prototype
		 * @type {Number}
		 */
		radius: number;

		/**
		 * The position of the camera.
		 * @memberof Occluder.prototype
		 * @type {Cartesian3}
		 */
		cameraPosition: Cartesian3;

		/**
		 * Creates an occluder from a bounding sphere and the camera position.
		 * @param {BoundingSphere} occluderBoundingSphere The bounding sphere surrounding the occluder.
		 * @param {Cartesian3} cameraPosition The coordinate of the viewer/camera.
		 * @param {Occluder} [result] The object onto which to store the result.
		 * @returns {Occluder} The occluder derived from an object's position and radius, as well as the camera position.
		 */
		static fromBoundingSphere(occluderBoundingSphere: BoundingSphere, cameraPosition: Cartesian3, result?: Occluder): Occluder;

		/**
		 * Determines whether or not a point, the <code>occludee</code>, is hidden from view by the occluder.
		 * @param {Cartesian3} occludee The point surrounding the occludee object.
		 * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.
		 * @example
		 * var cameraPosition = new Cesium.Cartesian3(0, 0, 0);
		 * var littleSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1), 0.25);
		 * var occluder = new Cesium.Occluder(littleSphere, cameraPosition);
		 * var point = new Cesium.Cartesian3(0, 0, -3);
		 * occluder.isPointVisible(point); //returns true
		 * @see Occluder#computeVisibility
		 */
		isPointVisible(occludee: Cartesian3): boolean;

		/**
		 * Determines whether or not a sphere, the <code>occludee</code>, is hidden from view by the occluder.
		 * @param {BoundingSphere} occludee The bounding sphere surrounding the occludee object.
		 * @returns {Boolean} <code>true</code> if the occludee is visible; otherwise <code>false</code>.
		 * @example
		 * var cameraPosition = new Cesium.Cartesian3(0, 0, 0);
		 * var littleSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1), 0.25);
		 * var occluder = new Cesium.Occluder(littleSphere, cameraPosition);
		 * var bigSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -3), 1);
		 * occluder.isBoundingSphereVisible(bigSphere); //returns true
		 * @see Occluder#computeVisibility
		 */
		isBoundingSphereVisible(occludee: BoundingSphere): boolean;

		/**
		 * Determine to what extent an occludee is visible (not visible, partially visible,  or fully visible).
		 * @param {BoundingSphere} occludeeBS The bounding sphere of the occludee.
		 * @returns {Number} Visibility.NONE if the occludee is not visible,
		 *                       Visibility.PARTIAL if the occludee is partially visible, or
		 *                       Visibility.FULL if the occludee is fully visible.
		 * @example
		 * var sphere1 = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1.5), 0.5);
		 * var sphere2 = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -2.5), 0.5);
		 * var cameraPosition = new Cesium.Cartesian3(0, 0, 0);
		 * var occluder = new Cesium.Occluder(sphere1, cameraPosition);
		 * occluder.computeVisibility(sphere2); //returns Visibility.NONE
		 * @see Occluder#isVisible
		 */
		computeVisibility(occludeeBS: BoundingSphere): number;

		/**
		 * Computes a point that can be used as the occludee position to the visibility functions.
		 * Use a radius of zero for the occludee radius.  Typically, a user computes a bounding sphere around
		 * an object that is used for visibility; however it is also possible to compute a point that if
		 * seen/not seen would also indicate if an object is visible/not visible.  This function is better
		 * called for objects that do not move relative to the occluder and is large, such as a chunk of
		 * terrain.  You are better off not calling this and using the object's bounding sphere for objects
		 * such as a satellite or ground vehicle.
		 * @param {BoundingSphere} occluderBoundingSphere The bounding sphere surrounding the occluder.
		 * @param {Cartesian3} occludeePosition The point where the occludee (bounding sphere of radius 0) is located.
		 * @param {Cartesian3[]} positions List of altitude points on the horizon near the surface of the occluder.
		 * @returns {Object} An object containing two attributes: <code>occludeePoint</code> and <code>valid</code>
		 * which is a boolean value.
		 * @exception {DeveloperError} <code>positions</code> must contain at least one element.
		 * @exception {DeveloperError} <code>occludeePosition</code> must have a value other than <code>occluderBoundingSphere.center</code>.
		 * @example
		 * var cameraPosition = new Cesium.Cartesian3(0, 0, 0);
		 * var occluderBoundingSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -8), 2);
		 * var occluder = new Cesium.Occluder(occluderBoundingSphere, cameraPosition);
		 * var positions = [new Cesium.Cartesian3(-0.25, 0, -5.3), new Cesium.Cartesian3(0.25, 0, -5.3)];
		 * var tileOccluderSphere = Cesium.BoundingSphere.fromPoints(positions);
		 * var occludeePosition = tileOccluderSphere.center;
		 * var occludeePt = Cesium.Occluder.computeOccludeePoint(occluderBoundingSphere, occludeePosition, positions);
		 */
		static computeOccludeePoint(occluderBoundingSphere: BoundingSphere, occludeePosition: Cartesian3, positions: (Cartesian3)[]): any;

		/**
		 * Computes a point that can be used as the occludee position to the visibility functions from a rectangle.
		 * @param {Rectangle} rectangle The rectangle used to create a bounding sphere.
		 * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid used to determine positions of the rectangle.
		 * @returns {Object} An object containing two attributes: <code>occludeePoint</code> and <code>valid</code>
		 * which is a boolean value.
		 */
		static computeOccludeePointFromRectangle(rectangle: Rectangle, ellipsoid?: Ellipsoid): any;

	}

	/**
	 * Creates an instance of an OrientedBoundingBox.
	 * An OrientedBoundingBox of some object is a closed and convex cuboid. It can provide a tighter bounding volume than {@link BoundingSphere} or {@link AxisAlignedBoundingBox} in many cases.
	 * @alias OrientedBoundingBox
	 * @constructor
	 * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the box.
	 * @param {Matrix3} [halfAxes=Matrix3.ZERO] The three orthogonal half-axes of the bounding box.
	 *                                          Equivalently, the transformation matrix, to rotate and scale a 0x0x0
	 *                                          cube centered at the origin.
	 * @example
	 * // Create an OrientedBoundingBox using a transformation matrix, a position where the box will be translated, and a scale.
	 * var center = new Cesium.Cartesian3(1.0, 0.0, 0.0);
	 * var halfAxes = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(1.0, 3.0, 2.0), new Cesium.Matrix3());
	 * var obb = new Cesium.OrientedBoundingBox(center, halfAxes);
	 * @see BoundingSphere
	 * @see BoundingRectangle
	 */
	class OrientedBoundingBox {
		constructor(center?: Cartesian3, halfAxes?: Matrix3);

		/**
		 * The center of the box.
		 * @type {Cartesian3}
		 * @default {@link Cartesian3.ZERO}
		 */
		center: Cartesian3;

		/**
		 * The transformation matrix, to rotate the box to the right position.
		 * @type {Matrix3}
		 * @default {@link Matrix3.ZERO}
		 */
		halfAxes: Matrix3;

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {OrientedBoundingBox} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: OrientedBoundingBox, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {OrientedBoundingBox} [result] The object into which to store the result.
		 * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: OrientedBoundingBox): OrientedBoundingBox;

		/**
		 * Computes an instance of an OrientedBoundingBox of the given positions.
		 * This is an implementation of Stefan Gottschalk's Collision Queries using Oriented Bounding Boxes solution (PHD thesis).
		 * Reference: http://gamma.cs.unc.edu/users/gottschalk/main.pdf
		 * @param {Cartesian3[]} [positions] List of {@link Cartesian3} points that the bounding box will enclose.
		 * @param {OrientedBoundingBox} [result] The object onto which to store the result.
		 * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.
		 * @example
		 * // Compute an object oriented bounding box enclosing two points.
		 * var box = Cesium.OrientedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);
		 */
		static fromPoints(positions?: (Cartesian3)[], result?: OrientedBoundingBox): OrientedBoundingBox;

		/**
		 * Computes an OrientedBoundingBox that bounds a {@link Rectangle} on the surface of an {@link Ellipsoid}.
		 * There are no guarantees about the orientation of the bounding box.
		 * @param {Rectangle} rectangle The cartographic rectangle on the surface of the ellipsoid.
		 * @param {Number} [minimumHeight=0.0] The minimum height (elevation) within the tile.
		 * @param {Number} [maximumHeight=0.0] The maximum height (elevation) within the tile.
		 * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle is defined.
		 * @param {OrientedBoundingBox} [result] The object onto which to store the result.
		 * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided.
		 * @exception {DeveloperError} rectangle.width must be between 0 and pi.
		 * @exception {DeveloperError} rectangle.height must be between 0 and pi.
		 * @exception {DeveloperError} ellipsoid must be an ellipsoid of revolution (<code>radii.x == radii.y</code>)
		 */
		static fromRectangle(rectangle: Rectangle, minimumHeight?: number, maximumHeight?: number, ellipsoid?: Ellipsoid, result?: OrientedBoundingBox): OrientedBoundingBox;

		/**
		 * Duplicates a OrientedBoundingBox instance.
		 * @param {OrientedBoundingBox} box The bounding box to duplicate.
		 * @param {OrientedBoundingBox} [result] The object onto which to store the result.
		 * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided. (Returns undefined if box is undefined)
		 */
		static clone(box: OrientedBoundingBox, result?: OrientedBoundingBox): OrientedBoundingBox;

		/**
		 * Determines which side of a plane the oriented bounding box is located.
		 * @param {OrientedBoundingBox} box The oriented bounding box to test.
		 * @param {Plane} plane The plane to test against.
		 * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane
		 *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is
		 *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box
		 *                      intersects the plane.
		 */
		static intersectPlane(box: OrientedBoundingBox, plane: Plane): any;

		/**
		 * Computes the estimated distance squared from the closest point on a bounding box to a point.
		 * @param {OrientedBoundingBox} box The box.
		 * @param {Cartesian3} cartesian The point
		 * @returns {Number} The estimated distance squared from the bounding sphere to the point.
		 * @example
		 * // Sort bounding boxes from back to front
		 * boxes.sort(function(a, b) {
		 *     return Cesium.OrientedBoundingBox.distanceSquaredTo(b, camera.positionWC) - Cesium.OrientedBoundingBox.distanceSquaredTo(a, camera.positionWC);
		 * });
		 */
		static distanceSquaredTo(box: OrientedBoundingBox, cartesian: Cartesian3): number;

		/**
		 * The distances calculated by the vector from the center of the bounding box to position projected onto direction.
		 * <br>
		 * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the
		 * closest and farthest planes from position that intersect the bounding box.
		 * @param {OrientedBoundingBox} box The bounding box to calculate the distance to.
		 * @param {Cartesian3} position The position to calculate the distance from.
		 * @param {Cartesian3} direction The direction from position.
		 * @param {Interval} [result] A Interval to store the nearest and farthest distances.
		 * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.
		 */
		static computePlaneDistances(box: OrientedBoundingBox, position: Cartesian3, direction: Cartesian3, result?: Interval): Interval;

		/**
		 * Determines whether or not a bounding box is hidden from view by the occluder.
		 * @param {OrientedBoundingBox} box The bounding box surrounding the occludee object.
		 * @param {Occluder} occluder The occluder.
		 * @returns {Boolean} <code>true</code> if the box is not visible; otherwise <code>false</code>.
		 */
		static isOccluded(box: OrientedBoundingBox, occluder: Occluder): boolean;

		/**
		 * Determines which side of a plane the oriented bounding box is located.
		 * @param {Plane} plane The plane to test against.
		 * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane
		 *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is
		 *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box
		 *                      intersects the plane.
		 */
		intersectPlane(plane: Plane): any;

		/**
		 * Computes the estimated distance squared from the closest point on a bounding box to a point.
		 * @param {Cartesian3} cartesian The point
		 * @returns {Number} The estimated distance squared from the bounding sphere to the point.
		 * @example
		 * // Sort bounding boxes from back to front
		 * boxes.sort(function(a, b) {
		 *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);
		 * });
		 */
		distanceSquaredTo(cartesian: Cartesian3): number;

		/**
		 * The distances calculated by the vector from the center of the bounding box to position projected onto direction.
		 * <br>
		 * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the
		 * closest and farthest planes from position that intersect the bounding box.
		 * @param {Cartesian3} position The position to calculate the distance from.
		 * @param {Cartesian3} direction The direction from position.
		 * @param {Interval} [result] A Interval to store the nearest and farthest distances.
		 * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.
		 */
		computePlaneDistances(position: Cartesian3, direction: Cartesian3, result?: Interval): Interval;

		/**
		 * Determines whether or not a bounding box is hidden from view by the occluder.
		 * @param {Occluder} occluder The occluder.
		 * @returns {Boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.
		 */
		isOccluded(occluder: Occluder): boolean;

		/**
		 * Compares the provided OrientedBoundingBox componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {OrientedBoundingBox} left The first OrientedBoundingBox.
		 * @param {OrientedBoundingBox} right The second OrientedBoundingBox.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		static equals(left: OrientedBoundingBox, right: OrientedBoundingBox): boolean;

		/**
		 * Duplicates this OrientedBoundingBox instance.
		 * @param {OrientedBoundingBox} [result] The object onto which to store the result.
		 * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.
		 */
		clone(result?: OrientedBoundingBox): OrientedBoundingBox;

		/**
		 * Compares this OrientedBoundingBox against the provided OrientedBoundingBox componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {OrientedBoundingBox} [right] The right hand side OrientedBoundingBox.
		 * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
		 */
		equals(right?: OrientedBoundingBox): boolean;

	}

	/**
	 * The viewing frustum is defined by 6 planes.
	 * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components
	 * define the unit vector normal to the plane, and the w component is the distance of the
	 * plane from the origin/camera position.
	 * @alias OrthographicFrustum
	 * @constructor
	 * @param {Object} [options] An object with the following properties:
	 * @param {Number} [options.width] The width of the frustum in meters.
	 * @param {Number} [options.aspectRatio] The aspect ratio of the frustum's width to it's height.
	 * @param {Number} [options.near=1.0] The distance of the near plane.
	 * @param {Number} [options.far=500000000.0] The distance of the far plane.
	 * @example
	 * var maxRadii = ellipsoid.maximumRadius;
	 * var frustum = new Cesium.OrthographicFrustum();
	 * frustum.near = 0.01 * maxRadii;
	 * frustum.far = 50.0 * maxRadii;
	 */
	class OrthographicFrustum {
		constructor(options?: {
			width?: number;
			aspectRatio?: number;
			near?: number;
			far?: number;
		});

		/**
		 * The horizontal width of the frustum in meters.
		 * @type {Number}
		 * @default undefined
		 */
		width: number;

		/**
		 * The aspect ratio of the frustum's width to it's height.
		 * @type {Number}
		 * @default undefined
		 */
		aspectRatio: number;

		/**
		 * The distance of the near plane.
		 * @type {Number}
		 * @default 1.0
		 */
		near: number;

		/**
		 * The distance of the far plane.
		 * @type {Number}
		 * @default 500000000.0;
		 */
		far: number;

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {OrthographicFrustum} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: OrthographicFrustum, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {OrthographicFrustum} [result] The object into which to store the result.
		 * @returns {OrthographicFrustum} The modified result parameter or a new OrthographicFrustum instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: OrthographicFrustum): OrthographicFrustum;

		/**
		 * Gets the orthographic projection matrix computed from the view frustum.
		 * @memberof OrthographicFrustum.prototype
		 * @type {Matrix4}
		 * @readonly
		 */
		readonly projectionMatrix: Matrix4;

		/**
		 * Creates a culling volume for this frustum.
		 * @param {Cartesian3} position The eye position.
		 * @param {Cartesian3} direction The view direction.
		 * @param {Cartesian3} up The up direction.
		 * @returns {CullingVolume} A culling volume at the given position and orientation.
		 * @example
		 * // Check if a bounding volume intersects the frustum.
		 * var cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);
		 * var intersect = cullingVolume.computeVisibility(boundingVolume);
		 */
		computeCullingVolume(position: Cartesian3, direction: Cartesian3, up: Cartesian3): CullingVolume;

		/**
		 * Returns the pixel's width and height in meters.
		 * @param {Number} drawingBufferWidth The width of the drawing buffer.
		 * @param {Number} drawingBufferHeight The height of the drawing buffer.
		 * @param {Number} distance The distance to the near plane in meters.
		 * @param {Cartesian2} result The object onto which to store the result.
		 * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.
		 * @exception {DeveloperError} drawingBufferWidth must be greater than zero.
		 * @exception {DeveloperError} drawingBufferHeight must be greater than zero.
		 * @example
		 * // Example 1
		 * // Get the width and height of a pixel.
		 * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 0.0, new Cesium.Cartesian2());
		 */
		getPixelDimensions(drawingBufferWidth: number, drawingBufferHeight: number, distance: number, result: Cartesian2): Cartesian2;

		/**
		 * Returns a duplicate of a OrthographicFrustum instance.
		 * @param {OrthographicFrustum} [result] The object onto which to store the result.
		 * @returns {OrthographicFrustum} The modified result parameter or a new OrthographicFrustum instance if one was not provided.
		 */
		clone(result?: OrthographicFrustum): OrthographicFrustum;

		/**
		 * Compares the provided OrthographicFrustum componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {OrthographicFrustum} [other] The right hand side OrthographicFrustum.
		 * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
		 */
		equals(other?: OrthographicFrustum): boolean;

		/**
		 * Compares the provided OrthographicFrustum componentwise and returns
		 * <code>true</code> if they pass an absolute or relative tolerance test,
		 * <code>false</code> otherwise.
		 * @param {OrthographicFrustum} other The right hand side OrthographicFrustum.
		 * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.
		 * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
		 * @returns {Boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.
		 */
		equalsEpsilon(other: OrthographicFrustum, relativeEpsilon: number, absoluteEpsilon?: number): boolean;

	}

	/**
	 * The viewing frustum is defined by 6 planes.
	 * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components
	 * define the unit vector normal to the plane, and the w component is the distance of the
	 * plane from the origin/camera position.
	 * @alias OrthographicOffCenterFrustum
	 * @constructor
	 * @param {Object} [options] An object with the following properties:
	 * @param {Number} [options.left] The left clipping plane distance.
	 * @param {Number} [options.right] The right clipping plane distance.
	 * @param {Number} [options.top] The top clipping plane distance.
	 * @param {Number} [options.bottom] The bottom clipping plane distance.
	 * @param {Number} [options.near=1.0] The near clipping plane distance.
	 * @param {Number} [options.far=500000000.0] The far clipping plane distance.
	 * @example
	 * var maxRadii = ellipsoid.maximumRadius;
	 * var frustum = new Cesium.OrthographicOffCenterFrustum();
	 * frustum.right = maxRadii * Cesium.Math.PI;
	 * frustum.left = -c.frustum.right;
	 * frustum.top = c.frustum.right * (canvas.clientHeight / canvas.clientWidth);
	 * frustum.bottom = -c.frustum.top;
	 * frustum.near = 0.01 * maxRadii;
	 * frustum.far = 50.0 * maxRadii;
	 */
	class OrthographicOffCenterFrustum {
		constructor(options?: {
			left?: number;
			right?: number;
			top?: number;
			bottom?: number;
			near?: number;
			far?: number;
		});

		/**
		 * The left clipping plane.
		 * @type {Number}
		 * @default undefined
		 */
		left: number;

		/**
		 * The right clipping plane.
		 * @type {Number}
		 * @default undefined
		 */
		right: number;

		/**
		 * The top clipping plane.
		 * @type {Number}
		 * @default undefined
		 */
		top: number;

		/**
		 * The bottom clipping plane.
		 * @type {Number}
		 * @default undefined
		 */
		bottom: number;

		/**
		 * The distance of the near plane.
		 * @type {Number}
		 * @default 1.0
		 */
		near: number;

		/**
		 * The distance of the far plane.
		 * @type {Number}
		 * @default 500000000.0;
		 */
		far: number;

		/**
		 * Gets the orthographic projection matrix computed from the view frustum.
		 * @memberof OrthographicOffCenterFrustum.prototype
		 * @type {Matrix4}
		 * @readonly
		 */
		readonly projectionMatrix: Matrix4;

		/**
		 * Creates a culling volume for this frustum.
		 * @param {Cartesian3} position The eye position.
		 * @param {Cartesian3} direction The view direction.
		 * @param {Cartesian3} up The up direction.
		 * @returns {CullingVolume} A culling volume at the given position and orientation.
		 * @example
		 * // Check if a bounding volume intersects the frustum.
		 * var cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);
		 * var intersect = cullingVolume.computeVisibility(boundingVolume);
		 */
		computeCullingVolume(position: Cartesian3, direction: Cartesian3, up: Cartesian3): CullingVolume;

		/**
		 * Returns the pixel's width and height in meters.
		 * @param {Number} drawingBufferWidth The width of the drawing buffer.
		 * @param {Number} drawingBufferHeight The height of the drawing buffer.
		 * @param {Number} distance The distance to the near plane in meters.
		 * @param {Cartesian2} result The object onto which to store the result.
		 * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.
		 * @exception {DeveloperError} drawingBufferWidth must be greater than zero.
		 * @exception {DeveloperError} drawingBufferHeight must be greater than zero.
		 * @example
		 * // Example 1
		 * // Get the width and height of a pixel.
		 * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 0.0, new Cesium.Cartesian2());
		 */
		getPixelDimensions(drawingBufferWidth: number, drawingBufferHeight: number, distance: number, result: Cartesian2): Cartesian2;

		/**
		 * Returns a duplicate of a OrthographicOffCenterFrustum instance.
		 * @param {OrthographicOffCenterFrustum} [result] The object onto which to store the result.
		 * @returns {OrthographicOffCenterFrustum} The modified result parameter or a new OrthographicOffCenterFrustum instance if one was not provided.
		 */
		clone(result?: OrthographicOffCenterFrustum): OrthographicOffCenterFrustum;

		/**
		 * Compares the provided OrthographicOffCenterFrustum componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {OrthographicOffCenterFrustum} [other] The right hand side OrthographicOffCenterFrustum.
		 * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
		 */
		equals(other?: OrthographicOffCenterFrustum): boolean;

		/**
		 * Compares the provided OrthographicOffCenterFrustum componentwise and returns
		 * <code>true</code> if they pass an absolute or relative tolerance test,
		 * <code>false</code> otherwise.
		 * @param {OrthographicOffCenterFrustum} other The right hand side OrthographicOffCenterFrustum.
		 * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.
		 * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
		 * @returns {Boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.
		 */
		equalsEpsilon(other: OrthographicOffCenterFrustum, relativeEpsilon: number, absoluteEpsilon?: number): boolean;

	}

	/**
	 * Static interface for types which can store their values as packed
	 * elements in an array.  These methods and properties are expected to be
	 * defined on a constructor function.
	 * @exports Packable
	 * @see PackableForInterpolation
	 */
	namespace Packable {
		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		const packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @function
		 * @param {*} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 */
		function pack(value: any, array: number[], startingIndex?: number): void;

		/**
		 * Retrieves an instance from a packed array.
		 * @function
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {Object} [result] The object into which to store the result.
		 * @returns {Object} The modified result parameter or a new Object instance if one was not provided.
		 */
		function unpack(array: number[], startingIndex?: number, result?: any): any;

	}

	/**
	 * Static interface for {@link Packable} types which are interpolated in a
	 * different representation than their packed value.  These methods and
	 * properties are expected to be defined on a constructor function.
	 * @exports PackableForInterpolation
	 * @see Packable
	 */
	namespace PackableForInterpolation {
		/**
		 * The number of elements used to store the object into an array in its interpolatable form.
		 * @type {Number}
		 */
		const packedInterpolationLength: number;

		/**
		 * Converts a packed array into a form suitable for interpolation.
		 * @function
		 * @param {Number[]} packedArray The packed array.
		 * @param {Number} [startingIndex=0] The index of the first element to be converted.
		 * @param {Number} [lastIndex=packedArray.length] The index of the last element to be converted.
		 * @param {Number[]} [result] The object into which to store the result.
		 */
		function convertPackedArrayForInterpolation(packedArray: number[], startingIndex?: number, lastIndex?: number, result?: number[]): void;

		/**
		 * Retrieves an instance from a packed array converted with {@link PackableForInterpolation.convertPackedArrayForInterpolation}.
		 * @function
		 * @param {Number[]} array The array previously packed for interpolation.
		 * @param {Number[]} sourceArray The original packed array.
		 * @param {Number} [startingIndex=0] The startingIndex used to convert the array.
		 * @param {Number} [lastIndex=packedArray.length] The lastIndex used to convert the array.
		 * @param {Object} [result] The object into which to store the result.
		 * @returns {Object} The modified result parameter or a new Object instance if one was not provided.
		 */
		function unpackInterpolationResult(array: number[], sourceArray: number[], startingIndex?: number, lastIndex?: number, result?: any): any;

	}

	/**
	 * Provides geocoding via a {@link https://pelias.io/|Pelias} server.
	 * @alias PeliasGeocoderService
	 * @constructor
	 * @param {Resource|String} url The endpoint to the Pelias server.
	 * @example
	 * // Configure a Viewer to use the Pelias server hosted by https://geocode.earth/
	 * var viewer = new Cesium.Viewer('cesiumContainer', {
	 *   geocoder: new Cesium.PeliasGeocoderService(new Cesium.Resource({
	 *     url: 'https://api.geocode.earth/v1/',
	 *       queryParameters: {
	 *         api_key: '<Your geocode.earth API key>'
	 *     }
	 *   }))
	 * });
	 */
	class PeliasGeocoderService {
		constructor(url: Resource | string);

		/**
		 * @function
		 * @param {String} query The query to be sent to the geocoder service
		 * @param {GeocodeType} [type=GeocodeType.SEARCH] The type of geocode to perform.
		 * @returns {Promise<GeocoderService~Result[]>}
		 */
		geocode(query: string, type?: any): any;

	}

	/**
	 * The viewing frustum is defined by 6 planes.
	 * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components
	 * define the unit vector normal to the plane, and the w component is the distance of the
	 * plane from the origin/camera position.
	 * @alias PerspectiveFrustum
	 * @constructor
	 * @param {Object} [options] An object with the following properties:
	 * @param {Number} [options.fov] The angle of the field of view (FOV), in radians.
	 * @param {Number} [options.aspectRatio] The aspect ratio of the frustum's width to it's height.
	 * @param {Number} [options.near=1.0] The distance of the near plane.
	 * @param {Number} [options.far=500000000.0] The distance of the far plane.
	 * @param {Number} [options.xOffset=0.0] The offset in the x direction.
	 * @param {Number} [options.yOffset=0.0] The offset in the y direction.
	 * @example
	 * var frustum = new Cesium.PerspectiveFrustum({
	 *     fov : Cesium.Math.PI_OVER_THREE,
	 *     aspectRatio : canvas.clientWidth / canvas.clientHeight
	 *     near : 1.0,
	 *     far : 1000.0
	 * });
	 * @see PerspectiveOffCenterFrustum
	 */
	class PerspectiveFrustum {
		constructor(options?: {
			fov?: number;
			aspectRatio?: number;
			near?: number;
			far?: number;
			xOffset?: number;
			yOffset?: number;
			width?:any;
		});

		/**
		 * The angle of the field of view (FOV), in radians.  This angle will be used
		 * as the horizontal FOV if the width is greater than the height, otherwise
		 * it will be the vertical FOV.
		 * @type {Number}
		 * @default undefined
		 */
		fov: number;

		/**
		 * The aspect ratio of the frustum's width to it's height.
		 * @type {Number}
		 * @default undefined
		 */
		aspectRatio: number;

		/**
		 * The distance of the near plane.
		 * @type {Number}
		 * @default 1.0
		 */
		near: number;

		/**
		 * The distance of the far plane.
		 * @type {Number}
		 * @default 500000000.0
		 */
		far: number;

		/**
		 * Offsets the frustum in the x direction.
		 * @type {Number}
		 * @default 0.0
		 */
		xOffset: number;

		/**
		 * Offsets the frustum in the y direction.
		 * @type {Number}
		 * @default 0.0
		 */
		yOffset: number;

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {PerspectiveFrustum} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: PerspectiveFrustum, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {PerspectiveFrustum} [result] The object into which to store the result.
		 * @returns {PerspectiveFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: PerspectiveFrustum): PerspectiveFrustum;

		/**
		 * Gets the perspective projection matrix computed from the view frustum.
		 * @memberof PerspectiveFrustum.prototype
		 * @type {Matrix4}
		 * @readonly
		 * @see PerspectiveFrustum#infiniteProjectionMatrix
		 */
		readonly projectionMatrix: Matrix4;

		/**
		 * The perspective projection matrix computed from the view frustum with an infinite far plane.
		 * @memberof PerspectiveFrustum.prototype
		 * @type {Matrix4}
		 * @readonly
		 * @see PerspectiveFrustum#projectionMatrix
		 */
		readonly infiniteProjectionMatrix: Matrix4;

		/**
		 * Gets the angle of the vertical field of view, in radians.
		 * @memberof PerspectiveFrustum.prototype
		 * @type {Number}
		 * @readonly
		 * @default undefined
		 */
		readonly fovy: number;

		/**
		 * Creates a culling volume for this frustum.
		 * @param {Cartesian3} position The eye position.
		 * @param {Cartesian3} direction The view direction.
		 * @param {Cartesian3} up The up direction.
		 * @returns {CullingVolume} A culling volume at the given position and orientation.
		 * @example
		 * // Check if a bounding volume intersects the frustum.
		 * var cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);
		 * var intersect = cullingVolume.computeVisibility(boundingVolume);
		 */
		computeCullingVolume(position: Cartesian3, direction: Cartesian3, up: Cartesian3): CullingVolume;

		/**
		 * Returns the pixel's width and height in meters.
		 * @param {Number} drawingBufferWidth The width of the drawing buffer.
		 * @param {Number} drawingBufferHeight The height of the drawing buffer.
		 * @param {Number} distance The distance to the near plane in meters.
		 * @param {Cartesian2} result The object onto which to store the result.
		 * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.
		 * @exception {DeveloperError} drawingBufferWidth must be greater than zero.
		 * @exception {DeveloperError} drawingBufferHeight must be greater than zero.
		 * @example
		 * // Example 1
		 * // Get the width and height of a pixel.
		 * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, new Cesium.Cartesian2());
		 * @example
		 * // Example 2
		 * // Get the width and height of a pixel if the near plane was set to 'distance'.
		 * // For example, get the size of a pixel of an image on a billboard.
		 * var position = camera.position;
		 * var direction = camera.direction;
		 * var toCenter = Cesium.Cartesian3.subtract(primitive.boundingVolume.center, position, new Cesium.Cartesian3());      // vector from camera to a primitive
		 * var toCenterProj = Cesium.Cartesian3.multiplyByScalar(direction, Cesium.Cartesian3.dot(direction, toCenter), new Cesium.Cartesian3()); // project vector onto camera direction vector
		 * var distance = Cesium.Cartesian3.magnitude(toCenterProj);
		 * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, new Cesium.Cartesian2());
		 */
		getPixelDimensions(drawingBufferWidth: number, drawingBufferHeight: number, distance: number, result: Cartesian2): Cartesian2;

		/**
		 * Returns a duplicate of a PerspectiveFrustum instance.
		 * @param {PerspectiveFrustum} [result] The object onto which to store the result.
		 * @returns {PerspectiveFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.
		 */
		clone(result?: PerspectiveFrustum): PerspectiveFrustum;

		/**
		 * Compares the provided PerspectiveFrustum componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {PerspectiveFrustum} [other] The right hand side PerspectiveFrustum.
		 * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
		 */
		equals(other?: PerspectiveFrustum): boolean;

		/**
		 * Compares the provided PerspectiveFrustum componentwise and returns
		 * <code>true</code> if they pass an absolute or relative tolerance test,
		 * <code>false</code> otherwise.
		 * @param {PerspectiveFrustum} other The right hand side PerspectiveFrustum.
		 * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.
		 * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
		 * @returns {Boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.
		 */
		equalsEpsilon(other: PerspectiveFrustum, relativeEpsilon: number, absoluteEpsilon?: number): boolean;

	}

	/**
	 * The viewing frustum is defined by 6 planes.
	 * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components
	 * define the unit vector normal to the plane, and the w component is the distance of the
	 * plane from the origin/camera position.
	 * @alias PerspectiveOffCenterFrustum
	 * @constructor
	 * @param {Object} [options] An object with the following properties:
	 * @param {Number} [options.left] The left clipping plane distance.
	 * @param {Number} [options.right] The right clipping plane distance.
	 * @param {Number} [options.top] The top clipping plane distance.
	 * @param {Number} [options.bottom] The bottom clipping plane distance.
	 * @param {Number} [options.near=1.0] The near clipping plane distance.
	 * @param {Number} [options.far=500000000.0] The far clipping plane distance.
	 * @example
	 * var frustum = new Cesium.PerspectiveOffCenterFrustum({
	 *     left : -1.0,
	 *     right : 1.0,
	 *     top : 1.0,
	 *     bottom : -1.0,
	 *     near : 1.0,
	 *     far : 100.0
	 * });
	 * @see PerspectiveFrustum
	 */
	class PerspectiveOffCenterFrustum {
		constructor(options?: {
			left?: number;
			right?: number;
			top?: number;
			bottom?: number;
			near?: number;
			far?: number;
		});

		/**
		 * Defines the left clipping plane.
		 * @type {Number}
		 * @default undefined
		 */
		left: number;

		/**
		 * Defines the right clipping plane.
		 * @type {Number}
		 * @default undefined
		 */
		right: number;

		/**
		 * Defines the top clipping plane.
		 * @type {Number}
		 * @default undefined
		 */
		top: number;

		/**
		 * Defines the bottom clipping plane.
		 * @type {Number}
		 * @default undefined
		 */
		bottom: number;

		/**
		 * The distance of the near plane.
		 * @type {Number}
		 * @default 1.0
		 */
		near: number;

		/**
		 * The distance of the far plane.
		 * @type {Number}
		 * @default 500000000.0
		 */
		far: number;

		/**
		 * Gets the perspective projection matrix computed from the view frustum.
		 * @memberof PerspectiveOffCenterFrustum.prototype
		 * @type {Matrix4}
		 * @readonly
		 * @see PerspectiveOffCenterFrustum#infiniteProjectionMatrix
		 */
		readonly projectionMatrix: Matrix4;

		/**
		 * Gets the perspective projection matrix computed from the view frustum with an infinite far plane.
		 * @memberof PerspectiveOffCenterFrustum.prototype
		 * @type {Matrix4}
		 * @readonly
		 * @see PerspectiveOffCenterFrustum#projectionMatrix
		 */
		readonly infiniteProjectionMatrix: Matrix4;

		/**
		 * Creates a culling volume for this frustum.
		 * @param {Cartesian3} position The eye position.
		 * @param {Cartesian3} direction The view direction.
		 * @param {Cartesian3} up The up direction.
		 * @returns {CullingVolume} A culling volume at the given position and orientation.
		 * @example
		 * // Check if a bounding volume intersects the frustum.
		 * var cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);
		 * var intersect = cullingVolume.computeVisibility(boundingVolume);
		 */
		computeCullingVolume(position: Cartesian3, direction: Cartesian3, up: Cartesian3): CullingVolume;

		/**
		 * Returns the pixel's width and height in meters.
		 * @param {Number} drawingBufferWidth The width of the drawing buffer.
		 * @param {Number} drawingBufferHeight The height of the drawing buffer.
		 * @param {Number} distance The distance to the near plane in meters.
		 * @param {Cartesian2} result The object onto which to store the result.
		 * @returns {Cartesian2} The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.
		 * @exception {DeveloperError} drawingBufferWidth must be greater than zero.
		 * @exception {DeveloperError} drawingBufferHeight must be greater than zero.
		 * @example
		 * // Example 1
		 * // Get the width and height of a pixel.
		 * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, new Cesium.Cartesian2());
		 * @example
		 * // Example 2
		 * // Get the width and height of a pixel if the near plane was set to 'distance'.
		 * // For example, get the size of a pixel of an image on a billboard.
		 * var position = camera.position;
		 * var direction = camera.direction;
		 * var toCenter = Cesium.Cartesian3.subtract(primitive.boundingVolume.center, position, new Cesium.Cartesian3());      // vector from camera to a primitive
		 * var toCenterProj = Cesium.Cartesian3.multiplyByScalar(direction, Cesium.Cartesian3.dot(direction, toCenter), new Cesium.Cartesian3()); // project vector onto camera direction vector
		 * var distance = Cesium.Cartesian3.magnitude(toCenterProj);
		 * var pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, new Cesium.Cartesian2());
		 */
		getPixelDimensions(drawingBufferWidth: number, drawingBufferHeight: number, distance: number, result: Cartesian2): Cartesian2;

		/**
		 * Returns a duplicate of a PerspectiveOffCenterFrustum instance.
		 * @param {PerspectiveOffCenterFrustum} [result] The object onto which to store the result.
		 * @returns {PerspectiveOffCenterFrustum} The modified result parameter or a new PerspectiveFrustum instance if one was not provided.
		 */
		clone(result?: PerspectiveOffCenterFrustum): PerspectiveOffCenterFrustum;

		/**
		 * Compares the provided PerspectiveOffCenterFrustum componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {PerspectiveOffCenterFrustum} [other] The right hand side PerspectiveOffCenterFrustum.
		 * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
		 */
		equals(other?: PerspectiveOffCenterFrustum): boolean;

		/**
		 * Compares the provided PerspectiveOffCenterFrustum componentwise and returns
		 * <code>true</code> if they pass an absolute or relative tolerance test,
		 * <code>false</code> otherwise.
		 * @param {PerspectiveOffCenterFrustum} other The right hand side PerspectiveOffCenterFrustum.
		 * @param {Number} relativeEpsilon The relative epsilon tolerance to use for equality testing.
		 * @param {Number} [absoluteEpsilon=relativeEpsilon] The absolute epsilon tolerance to use for equality testing.
		 * @returns {Boolean} <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.
		 */
		equalsEpsilon(other: PerspectiveOffCenterFrustum, relativeEpsilon: number, absoluteEpsilon?: number): boolean;

	}

	/**
	 * A utility class for generating custom map pins as canvas elements.
	 * <br /><br />
	 * <div align='center'>
	 * <img src='Images/PinBuilder.png' width='500'/><br />
	 * Example pins generated using both the maki icon set, which ships with Cesium, and single character text.
	 * </div>
	 * @alias PinBuilder
	 * @constructor
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Map%20Pins.html|Cesium Sandcastle PinBuilder Demo}
	 */
	class PinBuilder {
		constructor();

		/**
		 * Creates an empty pin of the specified color and size.
		 * @param {Color} color The color of the pin.
		 * @param {Number} size The size of the pin, in pixels.
		 * @returns {Canvas} The canvas element that represents the generated pin.
		 */
		fromColor(color: Color, size: number): any;

		/**
		 * Creates a pin with the specified icon, color, and size.
		 * @param {Resource|String} url The url of the image to be stamped onto the pin.
		 * @param {Color} color The color of the pin.
		 * @param {Number} size The size of the pin, in pixels.
		 * @returns {Canvas|Promise.<Canvas>} The canvas element or a Promise to the canvas element that represents the generated pin.
		 */
		fromUrl(url: Resource | string, color: Color, size: number): any | any;

		/**
		 * Creates a pin with the specified {@link https://www.mapbox.com/maki/|maki} icon identifier, color, and size.
		 * @param {String} id The id of the maki icon to be stamped onto the pin.
		 * @param {Color} color The color of the pin.
		 * @param {Number} size The size of the pin, in pixels.
		 * @returns {Canvas|Promise.<Canvas>} The canvas element or a Promise to the canvas element that represents the generated pin.
		 */
		fromMakiIconId(id: string, color: Color, size: number): any | any;

		/**
		 * Creates a pin with the specified text, color, and size.  The text will be sized to be as large as possible
		 * while still being contained completely within the pin.
		 * @param {String} text The text to be stamped onto the pin.
		 * @param {Color} color The color of the pin.
		 * @param {Number} size The size of the pin, in pixels.
		 * @returns {Canvas} The canvas element that represents the generated pin.
		 */
		fromText(text: string, color: Color, size: number): any;

	}

	/**
	 * A plane in Hessian Normal Form defined by
	 * <pre>
	 * ax + by + cz + d = 0
	 * </pre>
	 * where (a, b, c) is the plane's <code>normal</code>, d is the signed
	 * <code>distance</code> to the plane, and (x, y, z) is any point on
	 * the plane.
	 * @alias Plane
	 * @constructor
	 * @param {Cartesian3} normal The plane's normal (normalized).
	 * @param {Number} distance The shortest distance from the origin to the plane.  The sign of
	 * <code>distance</code> determines which side of the plane the origin
	 * is on.  If <code>distance</code> is positive, the origin is in the half-space
	 * in the direction of the normal; if negative, the origin is in the half-space
	 * opposite to the normal; if zero, the plane passes through the origin.
	 * @example
	 * // The plane x=0
	 * var plane = new Cesium.Plane(Cesium.Cartesian3.UNIT_X, 0.0);
	 * @exception {DeveloperError} Normal must be normalized
	 */
	class Plane {
		constructor(normal: Cartesian3, distance: number);

		/**
		 * The plane's normal.
		 * @type {Cartesian3}
		 */
		normal: Cartesian3;

		/**
		 * The shortest distance from the origin to the plane.  The sign of
		 * <code>distance</code> determines which side of the plane the origin
		 * is on.  If <code>distance</code> is positive, the origin is in the half-space
		 * in the direction of the normal; if negative, the origin is in the half-space
		 * opposite to the normal; if zero, the plane passes through the origin.
		 * @type {Number}
		 */
		distance: number;

		/**
		 * Creates a plane from a normal and a point on the plane.
		 * @param {Cartesian3} point The point on the plane.
		 * @param {Cartesian3} normal The plane's normal (normalized).
		 * @param {Plane} [result] The object onto which to store the result.
		 * @returns {Plane} A new plane instance or the modified result parameter.
		 * @example
		 * var point = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);
		 * var normal = ellipsoid.geodeticSurfaceNormal(point);
		 * var tangentPlane = Cesium.Plane.fromPointNormal(point, normal);
		 * @exception {DeveloperError} Normal must be normalized
		 */
		static fromPointNormal(point: Cartesian3, normal: Cartesian3, result?: Plane): Plane;

		/**
		 * Creates a plane from the general equation
		 * @param {Cartesian4} coefficients The plane's normal (normalized).
		 * @param {Plane} [result] The object onto which to store the result.
		 * @returns {Plane} A new plane instance or the modified result parameter.
		 * @exception {DeveloperError} Normal must be normalized
		 */
		static fromCartesian4(coefficients: Cartesian4, result?: Plane): Plane;

		/**
		 * Computes the signed shortest distance of a point to a plane.
		 * The sign of the distance determines which side of the plane the point
		 * is on.  If the distance is positive, the point is in the half-space
		 * in the direction of the normal; if negative, the point is in the half-space
		 * opposite to the normal; if zero, the plane passes through the point.
		 * @param {Plane} plane The plane.
		 * @param {Cartesian3} point The point.
		 * @returns {Number} The signed shortest distance of the point to the plane.
		 */
		static getPointDistance(plane: Plane, point: Cartesian3): number;

		/**
		 * Projects a point onto the plane.
		 * @param {Plane} plane The plane to project the point onto
		 * @param {Cartesian3} point The point to project onto the plane
		 * @param {Cartesian3} [result] The result point.  If undefined, a new Cartesian3 will be created.
		 * @returns {Cartesian3} The modified result parameter or a new Cartesian3 instance if one was not provided.
		 */
		static projectPointOntoPlane(plane: Plane, point: Cartesian3, result?: Cartesian3): Cartesian3;

		/**
		 * Transforms the plane by the given transformation matrix.
		 * @param {Plane} plane The plane.
		 * @param {Matrix4} transform The transformation matrix.
		 * @param {Plane} [result] The object into which to store the result.
		 * @returns {Plane} The plane transformed by the given transformation matrix.
		 */
		static transform(plane: Plane, transform: Matrix4, result?: Plane): Plane;

		/**
		 * Duplicates a Plane instance.
		 * @param {Plane} plane The plane to duplicate.
		 * @param {Plane} [result] The object onto which to store the result.
		 * @returns {Plane} The modified result parameter or a new Plane instance if one was not provided.
		 */
		static clone(plane: Plane, result?: Plane): Plane;

		/**
		 * Compares the provided Planes by normal and distance and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Plane} left The first plane.
		 * @param {Plane} right The second plane.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		static equals(left: Plane, right: Plane): boolean;

		/**
		 * A constant initialized to the XY plane passing through the origin, with normal in positive Z.
		 * @type {Plane}
		 * @constant
		 */
		static ORIGIN_XY_PLANE: Plane;

		/**
		 * A constant initialized to the YZ plane passing through the origin, with normal in positive X.
		 * @type {Plane}
		 * @constant
		 */
		static ORIGIN_YZ_PLANE: Plane;

		/**
		 * A constant initialized to the ZX plane passing through the origin, with normal in positive Y.
		 * @type {Plane}
		 * @constant
		 */
		static ORIGIN_ZX_PLANE: Plane;

	}

	/**
	 * Describes geometry representing a plane centered at the origin, with a unit width and length.
	 * @alias PlaneGeometry
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
	 * @example
	 * var planeGeometry = new Cesium.PlaneGeometry({
	 *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY
	 * });
	 */
	class PlaneGeometry {
		constructor(options: {
			vertexFormat?: VertexFormat;
		});

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {PlaneGeometry} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: PlaneGeometry, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {PlaneGeometry} [result] The object into which to store the result.
		 * @returns {PlaneGeometry} The modified result parameter or a new PlaneGeometry instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: PlaneGeometry): PlaneGeometry;

		/**
		 * Computes the geometric representation of a plane, including its vertices, indices, and a bounding sphere.
		 * @param {PlaneGeometry} planeGeometry A description of the plane.
		 * @returns {Geometry|undefined} The computed vertices and indices.
		 */
		static createGeometry(planeGeometry: PlaneGeometry): Geometry | undefined;

	}

	/**
	 * Describes geometry representing the outline of a plane centered at the origin, with a unit width and length.
	 * @alias PlaneOutlineGeometry
	 * @constructor
	 */
	class PlaneOutlineGeometry {
		constructor();

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {PlaneOutlineGeometry} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: PlaneOutlineGeometry, array: number[]): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {PlaneOutlineGeometry} [result] The object into which to store the result.
		 * @returns {PlaneOutlineGeometry} The modified result parameter or a new PlaneOutlineGeometry instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: PlaneOutlineGeometry): PlaneOutlineGeometry;

		/**
		 * Computes the geometric representation of an outline of a plane, including its vertices, indices, and a bounding sphere.
		 * @returns {Geometry|undefined} The computed vertices and indices.
		 */
		static createGeometry(): Geometry | undefined;

	}

	/**
	 * Determines if a point is inside a triangle.
	 * @exports pointInsideTriangle
	 * @param {Cartesian2|Cartesian3} point The point to test.
	 * @param {Cartesian2|Cartesian3} p0 The first point of the triangle.
	 * @param {Cartesian2|Cartesian3} p1 The second point of the triangle.
	 * @param {Cartesian2|Cartesian3} p2 The third point of the triangle.
	 * @returns {Boolean} <code>true</code> if the point is inside the triangle; otherwise, <code>false</code>.
	 * @example
	 * // Returns true
	 * var p = new Cesium.Cartesian2(0.25, 0.25);
	 * var b = Cesium.pointInsideTriangle(p,
	 *   new Cesium.Cartesian2(0.0, 0.0),
	 *   new Cesium.Cartesian2(1.0, 0.0),
	 *   new Cesium.Cartesian2(0.0, 1.0));
	 */
	namespace pointInsideTriangle {
	}

	/**
	 * A description of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
	 * @alias PolygonGeometry
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.
	 * @param {Number} [options.height=0.0] The distance in meters between the polygon and the ellipsoid surface.
	 * @param {Number} [options.extrudedHeight] The distance in meters between the polygon's extruded face and the ellipsoid surface.
	 * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
	 * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.
	 * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.
	 * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
	 * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.
	 * @param {Boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.
	 * @param {Boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.
	 * @see PolygonGeometry#createGeometry
	 * @see PolygonGeometry#fromPositions
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Polygon.html|Cesium Sandcastle Polygon Demo}
	 * @example
	 * // 1. create a polygon from points
	 * var polygon = new Cesium.PolygonGeometry({
	 *   polygonHierarchy : new Cesium.PolygonHierarchy(
	 *     Cesium.Cartesian3.fromDegreesArray([
	 *       -72.0, 40.0,
	 *       -70.0, 35.0,
	 *       -75.0, 30.0,
	 *       -70.0, 30.0,
	 *       -68.0, 40.0
	 *     ])
	 *   )
	 * });
	 * var geometry = Cesium.PolygonGeometry.createGeometry(polygon);
	 * // 2. create a nested polygon with holes
	 * var polygonWithHole = new Cesium.PolygonGeometry({
	 *   polygonHierarchy : new Cesium.PolygonHierarchy(
	 *     Cesium.Cartesian3.fromDegreesArray([
	 *       -109.0, 30.0,
	 *       -95.0, 30.0,
	 *       -95.0, 40.0,
	 *       -109.0, 40.0
	 *     ]),
	 *     [new Cesium.PolygonHierarchy(
	 *       Cesium.Cartesian3.fromDegreesArray([
	 *         -107.0, 31.0,
	 *         -107.0, 39.0,
	 *         -97.0, 39.0,
	 *         -97.0, 31.0
	 *       ]),
	 *       [new Cesium.PolygonHierarchy(
	 *         Cesium.Cartesian3.fromDegreesArray([
	 *           -105.0, 33.0,
	 *           -99.0, 33.0,
	 *           -99.0, 37.0,
	 *           -105.0, 37.0
	 *         ]),
	 *         [new Cesium.PolygonHierarchy(
	 *           Cesium.Cartesian3.fromDegreesArray([
	 *             -103.0, 34.0,
	 *             -101.0, 34.0,
	 *             -101.0, 36.0,
	 *             -103.0, 36.0
	 *           ])
	 *         )]
	 *       )]
	 *     )]
	 *   )
	 * });
	 * var geometry = Cesium.PolygonGeometry.createGeometry(polygonWithHole);
	 * // 3. create extruded polygon
	 * var extrudedPolygon = new Cesium.PolygonGeometry({
	 *   polygonHierarchy : new Cesium.PolygonHierarchy(
	 *     Cesium.Cartesian3.fromDegreesArray([
	 *       -72.0, 40.0,
	 *       -70.0, 35.0,
	 *       -75.0, 30.0,
	 *       -70.0, 30.0,
	 *       -68.0, 40.0
	 *     ])
	 *   ),
	 *   extrudedHeight: 300000
	 * });
	 * var geometry = Cesium.PolygonGeometry.createGeometry(extrudedPolygon);
	 */
	class PolygonGeometry {
		constructor(options: {
			polygonHierarchy: PolygonHierarchy;
			height?: number;
			extrudedHeight?: number;
			vertexFormat?: VertexFormat;
			stRotation?: number;
			ellipsoid?: Ellipsoid;
			granularity?: number;
			perPositionHeight?: boolean;
			closeTop?: boolean;
			closeBottom?: boolean;
		});

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		packedLength: number;

		/**
		 * A description of a polygon from an array of positions. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
		 * @param {Object} options Object with the following properties:
		 * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.
		 * @param {Number} [options.height=0.0] The height of the polygon.
		 * @param {Number} [options.extrudedHeight] The height of the polygon extrusion.
		 * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
		 * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.
		 * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.
		 * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
		 * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.
		 * @param {Boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.
		 * @param {Boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.
		 * @returns {PolygonGeometry}
		 * @example
		 * // create a polygon from points
		 * var polygon = Cesium.PolygonGeometry.fromPositions({
		 *   positions : Cesium.Cartesian3.fromDegreesArray([
		 *     -72.0, 40.0,
		 *     -70.0, 35.0,
		 *     -75.0, 30.0,
		 *     -70.0, 30.0,
		 *     -68.0, 40.0
		 *   ])
		 * });
		 * var geometry = Cesium.PolygonGeometry.createGeometry(polygon);
		 * @see PolygonGeometry#createGeometry
		 */
		static fromPositions(options: {
			positions: (Cartesian3)[];
			height?: number;
			extrudedHeight?: number;
			vertexFormat?: VertexFormat;
			stRotation?: number;
			ellipsoid?: Ellipsoid;
			granularity?: number;
			perPositionHeight?: boolean;
			closeTop?: boolean;
			closeBottom?: boolean;
		}): PolygonGeometry;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {PolygonGeometry} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: PolygonGeometry, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {PolygonGeometry} [result] The object into which to store the result.
		 */
		static unpack(array: number[], startingIndex?: number, result?: PolygonGeometry): void;

		/**
		 * Returns the bounding rectangle given the provided options
		 * @param {Object} options Object with the following properties:
		 * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.
		 * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.
		 * @param {Rectangle} [result] An object in which to store the result.
		 * @returns {Rectangle} The result rectangle
		 */
		static computeRectangle(options: {
			polygonHierarchy: PolygonHierarchy;
			ellipsoid?: Ellipsoid;
		}, result?: Rectangle): Rectangle;

		/**
		 * Computes the geometric representation of a polygon, including its vertices, indices, and a bounding sphere.
		 * @param {PolygonGeometry} polygonGeometry A description of the polygon.
		 * @returns {Geometry|undefined} The computed vertices and indices.
		 */
		static createGeometry(polygonGeometry: PolygonGeometry): Geometry | undefined;

	}

	/**
	 * An hierarchy of linear rings which define a polygon and its holes.
	 * The holes themselves may also have holes which nest inner polygons.
	 * @alias PolygonHierarchy
	 * @constructor
	 * @param {Cartesian3[]} [positions] A linear ring defining the outer boundary of the polygon or hole.
	 * @param {PolygonHierarchy[]} [holes] An array of polygon hierarchies defining holes in the polygon.
	 */
	class PolygonHierarchy {
		constructor(positions?: (Cartesian3)[], holes?: (PolygonHierarchy)[]);

		/**
		 * A linear ring defining the outer boundary of the polygon or hole.
		 * @type {Cartesian3[]}
		 */
		positions: (Cartesian3)[];

		/**
		 * An array of polygon hierarchies defining holes in the polygon.
		 * @type {PolygonHierarchy[]}
		 */
		holes: (PolygonHierarchy)[];

	}

	/**
	 * A description of the outline of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy.
	 * @alias PolygonOutlineGeometry
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.
	 * @param {Number} [options.height=0.0] The distance in meters between the polygon and the ellipsoid surface.
	 * @param {Number} [options.extrudedHeight] The distance in meters between the polygon's extruded face and the ellipsoid surface.
	 * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
	 * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.
	 * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
	 * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.
	 * @see PolygonOutlineGeometry#createGeometry
	 * @see PolygonOutlineGeometry#fromPositions
	 * @example
	 * // 1. create a polygon outline from points
	 * var polygon = new Cesium.PolygonOutlineGeometry({
	 *   polygonHierarchy : new Cesium.PolygonHierarchy(
	 *     Cesium.Cartesian3.fromDegreesArray([
	 *       -72.0, 40.0,
	 *       -70.0, 35.0,
	 *       -75.0, 30.0,
	 *       -70.0, 30.0,
	 *       -68.0, 40.0
	 *     ])
	 *   )
	 * });
	 * var geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);
	 * // 2. create a nested polygon with holes outline
	 * var polygonWithHole = new Cesium.PolygonOutlineGeometry({
	 *   polygonHierarchy : new Cesium.PolygonHierarchy(
	 *     Cesium.Cartesian3.fromDegreesArray([
	 *       -109.0, 30.0,
	 *       -95.0, 30.0,
	 *       -95.0, 40.0,
	 *       -109.0, 40.0
	 *     ]),
	 *     [new Cesium.PolygonHierarchy(
	 *       Cesium.Cartesian3.fromDegreesArray([
	 *         -107.0, 31.0,
	 *         -107.0, 39.0,
	 *         -97.0, 39.0,
	 *         -97.0, 31.0
	 *       ]),
	 *       [new Cesium.PolygonHierarchy(
	 *         Cesium.Cartesian3.fromDegreesArray([
	 *           -105.0, 33.0,
	 *           -99.0, 33.0,
	 *           -99.0, 37.0,
	 *           -105.0, 37.0
	 *         ]),
	 *         [new Cesium.PolygonHierarchy(
	 *           Cesium.Cartesian3.fromDegreesArray([
	 *             -103.0, 34.0,
	 *             -101.0, 34.0,
	 *             -101.0, 36.0,
	 *             -103.0, 36.0
	 *           ])
	 *         )]
	 *       )]
	 *     )]
	 *   )
	 * });
	 * var geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygonWithHole);
	 * // 3. create extruded polygon outline
	 * var extrudedPolygon = new Cesium.PolygonOutlineGeometry({
	 *   polygonHierarchy : new Cesium.PolygonHierarchy(
	 *     Cesium.Cartesian3.fromDegreesArray([
	 *       -72.0, 40.0,
	 *       -70.0, 35.0,
	 *       -75.0, 30.0,
	 *       -70.0, 30.0,
	 *       -68.0, 40.0
	 *     ])
	 *   ),
	 *   extrudedHeight: 300000
	 * });
	 * var geometry = Cesium.PolygonOutlineGeometry.createGeometry(extrudedPolygon);
	 */
	class PolygonOutlineGeometry {
		constructor(options: {
			polygonHierarchy: PolygonHierarchy;
			height?: number;
			extrudedHeight?: number;
			vertexFormat?: VertexFormat;
			ellipsoid?: Ellipsoid;
			granularity?: number;
			perPositionHeight?: boolean;
		});

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {PolygonOutlineGeometry} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: PolygonOutlineGeometry, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {PolygonOutlineGeometry} [result] The object into which to store the result.
		 * @returns {PolygonOutlineGeometry} The modified result parameter or a new PolygonOutlineGeometry instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: PolygonOutlineGeometry): PolygonOutlineGeometry;

		/**
		 * A description of a polygon outline from an array of positions.
		 * @param {Object} options Object with the following properties:
		 * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.
		 * @param {Number} [options.height=0.0] The height of the polygon.
		 * @param {Number} [options.extrudedHeight] The height of the polygon extrusion.
		 * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.
		 * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
		 * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.
		 * @returns {PolygonOutlineGeometry}
		 * @example
		 * // create a polygon from points
		 * var polygon = Cesium.PolygonOutlineGeometry.fromPositions({
		 *   positions : Cesium.Cartesian3.fromDegreesArray([
		 *     -72.0, 40.0,
		 *     -70.0, 35.0,
		 *     -75.0, 30.0,
		 *     -70.0, 30.0,
		 *     -68.0, 40.0
		 *   ])
		 * });
		 * var geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);
		 * @see PolygonOutlineGeometry#createGeometry
		 */
		static fromPositions(options: {
			positions: (Cartesian3)[];
			height?: number;
			extrudedHeight?: number;
			ellipsoid?: Ellipsoid;
			granularity?: number;
			perPositionHeight?: boolean;
		}): PolygonOutlineGeometry;

		/**
		 * Computes the geometric representation of a polygon outline, including its vertices, indices, and a bounding sphere.
		 * @param {PolygonOutlineGeometry} polygonGeometry A description of the polygon outline.
		 * @returns {Geometry|undefined} The computed vertices and indices.
		 */
		static createGeometry(polygonGeometry: PolygonOutlineGeometry): Geometry | undefined;

	}

	/**
	 * A description of a polyline modeled as a line strip; the first two positions define a line segment,
	 * and each additional position defines a line segment from the previous position. The polyline is capable of
	 * displaying with a material.
	 * @alias PolylineGeometry
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the positions in the polyline as a line strip.
	 * @param {Number} [options.width=1.0] The width in pixels.
	 * @param {Color[]} [options.colors] An Array of {@link Color} defining the per vertex or per segment colors.
	 * @param {Boolean} [options.colorsPerVertex=false] A boolean that determines whether the colors will be flat across each segment of the line or interpolated across the vertices.
	 * @param {Boolean} [options.followSurface=true] A boolean that determines whether positions will be adjusted to the surface of the ellipsoid via a great arc.
	 * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude if options.followSurface=true. Determines the number of positions in the buffer.
	 * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
	 * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.
	 * @exception {DeveloperError} At least two positions are required.
	 * @exception {DeveloperError} width must be greater than or equal to one.
	 * @exception {DeveloperError} colors has an invalid length.
	 * @see PolylineGeometry#createGeometry
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Polyline.html|Cesium Sandcastle Polyline Demo}
	 * @example
	 * // A polyline with two connected line segments
	 * var polyline = new Cesium.PolylineGeometry({
	 *   positions : Cesium.Cartesian3.fromDegreesArray([
	 *     0.0, 0.0,
	 *     5.0, 0.0,
	 *     5.0, 5.0
	 *   ]),
	 *   width : 10.0
	 * });
	 * var geometry = Cesium.PolylineGeometry.createGeometry(polyline);
	 */
	class PolylineGeometry {
		constructor(options: {
			positions: (Cartesian3)[];
			width?: number;
			colors?: (Color)[];
			colorsPerVertex?: boolean;
			followSurface?: boolean;
			granularity?: number;
			vertexFormat?: VertexFormat;
			ellipsoid?: Ellipsoid;
			hMax?: number;
		});

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {PolylineGeometry} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: PolylineGeometry, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {PolylineGeometry} [result] The object into which to store the result.
		 * @returns {PolylineGeometry} The modified result parameter or a new PolylineGeometry instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: PolylineGeometry): PolylineGeometry;

		/**
		 * Computes the geometric representation of a polyline, including its vertices, indices, and a bounding sphere.
		 * @param {PolylineGeometry} polylineGeometry A description of the polyline.
		 * @returns {Geometry|undefined} The computed vertices and indices.
		 */
		static createGeometry(polylineGeometry: PolylineGeometry): Geometry | undefined;

	}

	/**
	 * A description of a polyline with a volume (a 2D shape extruded along a polyline).
	 * @alias PolylineVolumeGeometry
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Cartesian3[]} options.polylinePositions An array of {@link Cartesain3} positions that define the center of the polyline volume.
	 * @param {Cartesian2[]} options.shapePositions An array of {@link Cartesian2} positions that define the shape to be extruded along the polyline
	 * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.
	 * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
	 * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
	 * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.
	 * @see PolylineVolumeGeometry#createGeometry
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Polyline%20Volume.html|Cesium Sandcastle Polyline Volume Demo}
	 * @example
	 * function computeCircle(radius) {
	 *   var positions = [];
	 *   for (var i = 0; i < 360; i++) {
	 *     var radians = Cesium.Math.toRadians(i);
	 *     positions.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));
	 *   }
	 *   return positions;
	 * }
	 * var volume = new Cesium.PolylineVolumeGeometry({
	 *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,
	 *   polylinePositions : Cesium.Cartesian3.fromDegreesArray([
	 *     -72.0, 40.0,
	 *     -70.0, 35.0
	 *   ]),
	 *   shapePositions : computeCircle(100000.0)
	 * });
	 */
	class PolylineVolumeGeometry {
		constructor(options: {
			polylinePositions: (Cartesian3)[];
			shapePositions: (Cartesian2)[];
			ellipsoid?: Ellipsoid;
			granularity?: number;
			vertexFormat?: VertexFormat;
			cornerType?: any;
		});

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {PolylineVolumeGeometry} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: PolylineVolumeGeometry, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {PolylineVolumeGeometry} [result] The object into which to store the result.
		 * @returns {PolylineVolumeGeometry} The modified result parameter or a new PolylineVolumeGeometry instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: PolylineVolumeGeometry): PolylineVolumeGeometry;

		/**
		 * Computes the geometric representation of a polyline with a volume, including its vertices, indices, and a bounding sphere.
		 * @param {PolylineVolumeGeometry} polylineVolumeGeometry A description of the polyline volume.
		 * @returns {Geometry|undefined} The computed vertices and indices.
		 */
		static createGeometry(polylineVolumeGeometry: PolylineVolumeGeometry): Geometry | undefined;

	}

	/**
	 * A description of a polyline with a volume (a 2D shape extruded along a polyline).
	 * @alias PolylineVolumeOutlineGeometry
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Cartesian3[]} options.polylinePositions An array of positions that define the center of the polyline volume.
	 * @param {Cartesian2[]} options.shapePositions An array of positions that define the shape to be extruded along the polyline
	 * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.
	 * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
	 * @param {CornerType} [options.cornerType=CornerType.ROUNDED] Determines the style of the corners.
	 * @see PolylineVolumeOutlineGeometry#createGeometry
	 * @example
	 * function computeCircle(radius) {
	 *   var positions = [];
	 *   for (var i = 0; i < 360; i++) {
	 *     var radians = Cesium.Math.toRadians(i);
	 *     positions.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));
	 *   }
	 *   return positions;
	 * }
	 * var volumeOutline = new Cesium.PolylineVolumeOutlineGeometry({
	 *   polylinePositions : Cesium.Cartesian3.fromDegreesArray([
	 *     -72.0, 40.0,
	 *     -70.0, 35.0
	 *   ]),
	 *   shapePositions : computeCircle(100000.0)
	 * });
	 */
	class PolylineVolumeOutlineGeometry {
		constructor(options: {
			polylinePositions: (Cartesian3)[];
			shapePositions: (Cartesian2)[];
			ellipsoid?: Ellipsoid;
			granularity?: number;
			cornerType?: any;
		});

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {PolylineVolumeOutlineGeometry} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: PolylineVolumeOutlineGeometry, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {PolylineVolumeOutlineGeometry} [result] The object into which to store the result.
		 * @returns {PolylineVolumeOutlineGeometry} The modified result parameter or a new PolylineVolumeOutlineGeometry instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: PolylineVolumeOutlineGeometry): PolylineVolumeOutlineGeometry;

		/**
		 * Computes the geometric representation of the outline of a polyline with a volume, including its vertices, indices, and a bounding sphere.
		 * @param {PolylineVolumeOutlineGeometry} polylineVolumeOutlineGeometry A description of the polyline volume outline.
		 * @returns {Geometry|undefined} The computed vertices and indices.
		 */
		static createGeometry(polylineVolumeOutlineGeometry: PolylineVolumeOutlineGeometry): Geometry | undefined;

	}

	/**
	 * Defines functions for 2nd order polynomial functions of one variable with only real coefficients.
	 * @exports QuadraticRealPolynomial
	 */
	namespace QuadraticRealPolynomial {
		/**
		 * Provides the discriminant of the quadratic equation from the supplied coefficients.
		 * @param {Number} a The coefficient of the 2nd order monomial.
		 * @param {Number} b The coefficient of the 1st order monomial.
		 * @param {Number} c The coefficient of the 0th order monomial.
		 * @returns {Number} The value of the discriminant.
		 */
		function computeDiscriminant(a: number, b: number, c: number): number;

		/**
		 * Provides the real valued roots of the quadratic polynomial with the provided coefficients.
		 * @param {Number} a The coefficient of the 2nd order monomial.
		 * @param {Number} b The coefficient of the 1st order monomial.
		 * @param {Number} c The coefficient of the 0th order monomial.
		 * @returns {Number[]} The real valued roots.
		 */
		function computeRealRoots(a: number, b: number, c: number): number[];

	}

	/**
	 * Terrain data for a single tile where the terrain data is represented as a quantized mesh.  A quantized
	 * mesh consists of three vertex attributes, longitude, latitude, and height.  All attributes are expressed
	 * as 16-bit values in the range 0 to 32767.  Longitude and latitude are zero at the southwest corner
	 * of the tile and 32767 at the northeast corner.  Height is zero at the minimum height in the tile
	 * and 32767 at the maximum height in the tile.
	 * @alias QuantizedMeshTerrainData
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Uint16Array} options.quantizedVertices The buffer containing the quantized mesh.
	 * @param {Uint16Array|Uint32Array} options.indices The indices specifying how the quantized vertices are linked
	 *                      together into triangles.  Each three indices specifies one triangle.
	 * @param {Number} options.minimumHeight The minimum terrain height within the tile, in meters above the ellipsoid.
	 * @param {Number} options.maximumHeight The maximum terrain height within the tile, in meters above the ellipsoid.
	 * @param {BoundingSphere} options.boundingSphere A sphere bounding all of the vertices in the mesh.
	 * @param {OrientedBoundingBox} [options.orientedBoundingBox] An OrientedBoundingBox bounding all of the vertices in the mesh.
	 * @param {Cartesian3} options.horizonOcclusionPoint The horizon occlusion point of the mesh.  If this point
	 *                      is below the horizon, the entire tile is assumed to be below the horizon as well.
	 *                      The point is expressed in ellipsoid-scaled coordinates.
	 * @param {Number[]} options.westIndices The indices of the vertices on the western edge of the tile.
	 * @param {Number[]} options.southIndices The indices of the vertices on the southern edge of the tile.
	 * @param {Number[]} options.eastIndices The indices of the vertices on the eastern edge of the tile.
	 * @param {Number[]} options.northIndices The indices of the vertices on the northern edge of the tile.
	 * @param {Number} options.westSkirtHeight The height of the skirt to add on the western edge of the tile.
	 * @param {Number} options.southSkirtHeight The height of the skirt to add on the southern edge of the tile.
	 * @param {Number} options.eastSkirtHeight The height of the skirt to add on the eastern edge of the tile.
	 * @param {Number} options.northSkirtHeight The height of the skirt to add on the northern edge of the tile.
	 * @param {Number} [options.childTileMask=15] A bit mask indicating which of this tile's four children exist.
	 *                 If a child's bit is set, geometry will be requested for that tile as well when it
	 *                 is needed.  If the bit is cleared, the child tile is not requested and geometry is
	 *                 instead upsampled from the parent.  The bit values are as follows:
	 *                 <table>
	 *                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>
	 *                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>
	 *                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>
	 *                  <tr><td>2</td><td>4</td><td>Northwest</td></tr>
	 *                  <tr><td>3</td><td>8</td><td>Northeast</td></tr>
	 *                 </table>
	 * @param {Boolean} [options.createdByUpsampling=false] True if this instance was created by upsampling another instance;
	 *                  otherwise, false.
	 * @param {Uint8Array} [options.encodedNormals] The buffer containing per vertex normals, encoded using 'oct' encoding
	 * @param {Uint8Array} [options.waterMask] The buffer containing the watermask.
	 * @param {Credit[]} [options.credits] Array of credits for this tile.
	 * @example
	 * var data = new Cesium.QuantizedMeshTerrainData({
	 *     minimumHeight : -100,
	 *     maximumHeight : 2101,
	 *     quantizedVertices : new Uint16Array([// order is SW NW SE NE
	 *                                          // longitude
	 *                                          0, 0, 32767, 32767,
	 *                                          // latitude
	 *                                          0, 32767, 0, 32767,
	 *                                          // heights
	 *                                          16384, 0, 32767, 16384]),
	 *     indices : new Uint16Array([0, 3, 1,
	 *                                0, 2, 3]),
	 *     boundingSphere : new Cesium.BoundingSphere(new Cesium.Cartesian3(1.0, 2.0, 3.0), 10000),
	 *     orientedBoundingBox : new Cesium.OrientedBoundingBox(new Cesium.Cartesian3(1.0, 2.0, 3.0), Cesium.Matrix3.fromRotationX(Cesium.Math.PI, new Cesium.Matrix3())),
	 *     horizonOcclusionPoint : new Cesium.Cartesian3(3.0, 2.0, 1.0),
	 *     westIndices : [0, 1],
	 *     southIndices : [0, 1],
	 *     eastIndices : [2, 3],
	 *     northIndices : [1, 3],
	 *     westSkirtHeight : 1.0,
	 *     southSkirtHeight : 1.0,
	 *     eastSkirtHeight : 1.0,
	 *     northSkirtHeight : 1.0
	 * });
	 * @see TerrainData
	 * @see HeightmapTerrainData
	 */
	class QuantizedMeshTerrainData {
		constructor(options: {
			quantizedVertices: Uint16Array;
			indices: Uint16Array | Uint32Array;
			minimumHeight: number;
			maximumHeight: number;
			boundingSphere: BoundingSphere;
			orientedBoundingBox?: OrientedBoundingBox;
			horizonOcclusionPoint: Cartesian3;
			westIndices: number[];
			southIndices: number[];
			eastIndices: number[];
			northIndices: number[];
			westSkirtHeight: number;
			southSkirtHeight: number;
			eastSkirtHeight: number;
			northSkirtHeight: number;
			childTileMask?: number;
			createdByUpsampling?: boolean;
			encodedNormals?: Uint8Array;
			waterMask?: Uint8Array;
			credits?: (Credit)[];
		});

		/**
		 * An array of credits for this tile.
		 * @memberof QuantizedMeshTerrainData.prototype
		 * @type {Credit[]}
		 */
		credits: (Credit)[];

		/**
		 * The water mask included in this terrain data, if any.  A water mask is a rectangular
		 * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.
		 * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.
		 * @memberof QuantizedMeshTerrainData.prototype
		 * @type {Uint8Array|Image|Canvas}
		 */
		waterMask: Uint8Array | any | any;

		/**
		 * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the
		 * vertices in this instance, interpolated if necessary.
		 * @param {TilingScheme} tilingScheme The tiling scheme of this terrain data.
		 * @param {Number} thisX The X coordinate of this tile in the tiling scheme.
		 * @param {Number} thisY The Y coordinate of this tile in the tiling scheme.
		 * @param {Number} thisLevel The level of this tile in the tiling scheme.
		 * @param {Number} descendantX The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.
		 * @param {Number} descendantY The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.
		 * @param {Number} descendantLevel The level within the tiling scheme of the descendant tile for which we are upsampling.
		 * @returns {Promise.<QuantizedMeshTerrainData>|undefined} A promise for upsampled heightmap terrain data for the descendant tile,
		 *          or undefined if too many asynchronous upsample operations are in progress and the request has been
		 *          deferred.
		 */
		upsample(tilingScheme: TilingScheme, thisX: number, thisY: number, thisLevel: number, descendantX: number, descendantY: number, descendantLevel: number): any | undefined;

		/**
		 * Computes the terrain height at a specified longitude and latitude.
		 * @param {Rectangle} rectangle The rectangle covered by this terrain data.
		 * @param {Number} longitude The longitude in radians.
		 * @param {Number} latitude The latitude in radians.
		 * @returns {Number} The terrain height at the specified position.  The position is clamped to
		 *          the rectangle, so expect incorrect results for positions far outside the rectangle.
		 */
		interpolateHeight(rectangle: Rectangle, longitude: number, latitude: number): number;

		/**
		 * Determines if a given child tile is available, based on the
		 * {@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed
		 * to be one of the four children of this tile.  If non-child tile coordinates are
		 * given, the availability of the southeast child tile is returned.
		 * @param {Number} thisX The tile X coordinate of this (the parent) tile.
		 * @param {Number} thisY The tile Y coordinate of this (the parent) tile.
		 * @param {Number} childX The tile X coordinate of the child tile to check for availability.
		 * @param {Number} childY The tile Y coordinate of the child tile to check for availability.
		 * @returns {Boolean} True if the child tile is available; otherwise, false.
		 */
		isChildAvailable(thisX: number, thisY: number, childX: number, childY: number): boolean;

		/**
		 * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution
		 * terrain data.  If this value is false, the data was obtained from some other source, such
		 * as by downloading it from a remote server.  This method should return true for instances
		 * returned from a call to {@link HeightmapTerrainData#upsample}.
		 * @returns {Boolean} True if this instance was created by upsampling; otherwise, false.
		 */
		wasCreatedByUpsampling(): boolean;

	}

	/**
	 * Defines functions for 4th order polynomial functions of one variable with only real coefficients.
	 * @exports QuarticRealPolynomial
	 */
	namespace QuarticRealPolynomial {
		/**
		 * Provides the discriminant of the quartic equation from the supplied coefficients.
		 * @param {Number} a The coefficient of the 4th order monomial.
		 * @param {Number} b The coefficient of the 3rd order monomial.
		 * @param {Number} c The coefficient of the 2nd order monomial.
		 * @param {Number} d The coefficient of the 1st order monomial.
		 * @param {Number} e The coefficient of the 0th order monomial.
		 * @returns {Number} The value of the discriminant.
		 */
		function computeDiscriminant(a: number, b: number, c: number, d: number, e: number): number;

		/**
		 * Provides the real valued roots of the quartic polynomial with the provided coefficients.
		 * @param {Number} a The coefficient of the 4th order monomial.
		 * @param {Number} b The coefficient of the 3rd order monomial.
		 * @param {Number} c The coefficient of the 2nd order monomial.
		 * @param {Number} d The coefficient of the 1st order monomial.
		 * @param {Number} e The coefficient of the 0th order monomial.
		 * @returns {Number[]} The real valued roots.
		 */
		function computeRealRoots(a: number, b: number, c: number, d: number, e: number): number[];

	}

	/**
	 * A set of 4-dimensional coordinates used to represent rotation in 3-dimensional space.
	 * @alias Quaternion
	 * @constructor
	 * @param {Number} [x=0.0] The X component.
	 * @param {Number} [y=0.0] The Y component.
	 * @param {Number} [z=0.0] The Z component.
	 * @param {Number} [w=0.0] The W component.
	 * @see PackableForInterpolation
	 */
	class Quaternion {
		constructor(x?: number, y?: number, z?: number, w?: number);

		/**
		 * The X component.
		 * @type {Number}
		 * @default 0.0
		 */
		x: number;

		/**
		 * The Y component.
		 * @type {Number}
		 * @default 0.0
		 */
		y: number;

		/**
		 * The Z component.
		 * @type {Number}
		 * @default 0.0
		 */
		z: number;

		/**
		 * The W component.
		 * @type {Number}
		 * @default 0.0
		 */
		w: number;

		/**
		 * Computes a quaternion representing a rotation around an axis.
		 * @param {Cartesian3} axis The axis of rotation.
		 * @param {Number} angle The angle in radians to rotate around the axis.
		 * @param {Quaternion} [result] The object onto which to store the result.
		 * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
		 */
		static fromAxisAngle(axis: Cartesian3, angle: number, result?: Quaternion): Quaternion;

		/**
		 * Computes a Quaternion from the provided Matrix3 instance.
		 * @param {Matrix3} matrix The rotation matrix.
		 * @param {Quaternion} [result] The object onto which to store the result.
		 * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
		 * @see Matrix3.fromQuaternion
		 */
		static fromRotationMatrix(matrix: Matrix3, result?: Quaternion): Quaternion;

		/**
		 * Computes a rotation from the given heading, pitch and roll angles. Heading is the rotation about the
		 * negative z axis. Pitch is the rotation about the negative y axis. Roll is the rotation about
		 * the positive x axis.
		 * @param {HeadingPitchRoll} headingPitchRoll The rotation expressed as a heading, pitch and roll.
		 * @param {Quaternion} [result] The object onto which to store the result.
		 * @returns {Quaternion} The modified result parameter or a new Quaternion instance if none was provided.
		 */
		static fromHeadingPitchRoll(headingPitchRoll: HeadingPitchRoll, result?: Quaternion): Quaternion;

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {Quaternion} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: Quaternion, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {Quaternion} [result] The object into which to store the result.
		 * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: Quaternion): Quaternion;

		/**
		 * The number of elements used to store the object into an array in its interpolatable form.
		 * @type {Number}
		 */
		static packedInterpolationLength: number;

		/**
		 * Converts a packed array into a form suitable for interpolation.
		 * @param {Number[]} packedArray The packed array.
		 * @param {Number} [startingIndex=0] The index of the first element to be converted.
		 * @param {Number} [lastIndex=packedArray.length] The index of the last element to be converted.
		 * @param {Number[]} [result] The object into which to store the result.
		 */
		static convertPackedArrayForInterpolation(packedArray: number[], startingIndex?: number, lastIndex?: number, result?: number[]): void;

		/**
		 * Retrieves an instance from a packed array converted with {@link convertPackedArrayForInterpolation}.
		 * @param {Number[]} array The array previously packed for interpolation.
		 * @param {Number[]} sourceArray The original packed array.
		 * @param {Number} [firstIndex=0] The firstIndex used to convert the array.
		 * @param {Number} [lastIndex=packedArray.length] The lastIndex used to convert the array.
		 * @param {Quaternion} [result] The object into which to store the result.
		 * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
		 */
		static unpackInterpolationResult(array: number[], sourceArray: number[], firstIndex?: number, lastIndex?: number, result?: Quaternion): Quaternion;

		/**
		 * Duplicates a Quaternion instance.
		 * @param {Quaternion} quaternion The quaternion to duplicate.
		 * @param {Quaternion} [result] The object onto which to store the result.
		 * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided. (Returns undefined if quaternion is undefined)
		 */
		static clone(quaternion: Quaternion, result?: Quaternion): Quaternion;

		/**
		 * Computes the conjugate of the provided quaternion.
		 * @param {Quaternion} quaternion The quaternion to conjugate.
		 * @param {Quaternion} result The object onto which to store the result.
		 * @returns {Quaternion} The modified result parameter.
		 */
		static conjugate(quaternion: Quaternion, result: Quaternion): Quaternion;

		/**
		 * Computes magnitude squared for the provided quaternion.
		 * @param {Quaternion} quaternion The quaternion to conjugate.
		 * @returns {Number} The magnitude squared.
		 */
		static magnitudeSquared(quaternion: Quaternion): number;

		/**
		 * Computes magnitude for the provided quaternion.
		 * @param {Quaternion} quaternion The quaternion to conjugate.
		 * @returns {Number} The magnitude.
		 */
		static magnitude(quaternion: Quaternion): number;

		/**
		 * Computes the normalized form of the provided quaternion.
		 * @param {Quaternion} quaternion The quaternion to normalize.
		 * @param {Quaternion} result The object onto which to store the result.
		 * @returns {Quaternion} The modified result parameter.
		 */
		static normalize(quaternion: Quaternion, result: Quaternion): Quaternion;

		/**
		 * Computes the inverse of the provided quaternion.
		 * @param {Quaternion} quaternion The quaternion to normalize.
		 * @param {Quaternion} result The object onto which to store the result.
		 * @returns {Quaternion} The modified result parameter.
		 */
		static inverse(quaternion: Quaternion, result: Quaternion): Quaternion;

		/**
		 * Computes the componentwise sum of two quaternions.
		 * @param {Quaternion} left The first quaternion.
		 * @param {Quaternion} right The second quaternion.
		 * @param {Quaternion} result The object onto which to store the result.
		 * @returns {Quaternion} The modified result parameter.
		 */
		static add(left: Quaternion, right: Quaternion, result: Quaternion): Quaternion;

		/**
		 * Computes the componentwise difference of two quaternions.
		 * @param {Quaternion} left The first quaternion.
		 * @param {Quaternion} right The second quaternion.
		 * @param {Quaternion} result The object onto which to store the result.
		 * @returns {Quaternion} The modified result parameter.
		 */
		static subtract(left: Quaternion, right: Quaternion, result: Quaternion): Quaternion;

		/**
		 * Negates the provided quaternion.
		 * @param {Quaternion} quaternion The quaternion to be negated.
		 * @param {Quaternion} result The object onto which to store the result.
		 * @returns {Quaternion} The modified result parameter.
		 */
		static negate(quaternion: Quaternion, result: Quaternion): Quaternion;

		/**
		 * Computes the dot (scalar) product of two quaternions.
		 * @param {Quaternion} left The first quaternion.
		 * @param {Quaternion} right The second quaternion.
		 * @returns {Number} The dot product.
		 */
		static dot(left: Quaternion, right: Quaternion): number;

		/**
		 * Computes the product of two quaternions.
		 * @param {Quaternion} left The first quaternion.
		 * @param {Quaternion} right The second quaternion.
		 * @param {Quaternion} result The object onto which to store the result.
		 * @returns {Quaternion} The modified result parameter.
		 */
		static multiply(left: Quaternion, right: Quaternion, result: Quaternion): Quaternion;

		/**
		 * Multiplies the provided quaternion componentwise by the provided scalar.
		 * @param {Quaternion} quaternion The quaternion to be scaled.
		 * @param {Number} scalar The scalar to multiply with.
		 * @param {Quaternion} result The object onto which to store the result.
		 * @returns {Quaternion} The modified result parameter.
		 */
		static multiplyByScalar(quaternion: Quaternion, scalar: number, result: Quaternion): Quaternion;

		/**
		 * Divides the provided quaternion componentwise by the provided scalar.
		 * @param {Quaternion} quaternion The quaternion to be divided.
		 * @param {Number} scalar The scalar to divide by.
		 * @param {Quaternion} result The object onto which to store the result.
		 * @returns {Quaternion} The modified result parameter.
		 */
		static divideByScalar(quaternion: Quaternion, scalar: number, result: Quaternion): Quaternion;

		/**
		 * Computes the axis of rotation of the provided quaternion.
		 * @param {Quaternion} quaternion The quaternion to use.
		 * @param {Cartesian3} result The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter.
		 */
		static computeAxis(quaternion: Quaternion, result: Cartesian3): Cartesian3;

		/**
		 * Computes the angle of rotation of the provided quaternion.
		 * @param {Quaternion} quaternion The quaternion to use.
		 * @returns {Number} The angle of rotation.
		 */
		static computeAngle(quaternion: Quaternion): number;

		/**
		 * Computes the linear interpolation or extrapolation at t using the provided quaternions.
		 * @param {Quaternion} start The value corresponding to t at 0.0.
		 * @param {Quaternion} end The value corresponding to t at 1.0.
		 * @param {Number} t The point along t at which to interpolate.
		 * @param {Quaternion} result The object onto which to store the result.
		 * @returns {Quaternion} The modified result parameter.
		 */
		static lerp(start: Quaternion, end: Quaternion, t: number, result: Quaternion): Quaternion;

		/**
		 * Computes the spherical linear interpolation or extrapolation at t using the provided quaternions.
		 * @param {Quaternion} start The value corresponding to t at 0.0.
		 * @param {Quaternion} end The value corresponding to t at 1.0.
		 * @param {Number} t The point along t at which to interpolate.
		 * @param {Quaternion} result The object onto which to store the result.
		 * @returns {Quaternion} The modified result parameter.
		 * @see Quaternion#fastSlerp
		 */
		static slerp(start: Quaternion, end: Quaternion, t: number, result: Quaternion): Quaternion;

		/**
		 * The logarithmic quaternion function.
		 * @param {Quaternion} quaternion The unit quaternion.
		 * @param {Cartesian3} result The object onto which to store the result.
		 * @returns {Cartesian3} The modified result parameter.
		 */
		static log(quaternion: Quaternion, result: Cartesian3): Cartesian3;

		/**
		 * The exponential quaternion function.
		 * @param {Cartesian3} cartesian The cartesian.
		 * @param {Quaternion} result The object onto which to store the result.
		 * @returns {Quaternion} The modified result parameter.
		 */
		static exp(cartesian: Cartesian3, result: Quaternion): Quaternion;

		/**
		 * Computes an inner quadrangle point.
		 * <p>This will compute quaternions that ensure a squad curve is C<sup>1</sup>.</p>
		 * @param {Quaternion} q0 The first quaternion.
		 * @param {Quaternion} q1 The second quaternion.
		 * @param {Quaternion} q2 The third quaternion.
		 * @param {Quaternion} result The object onto which to store the result.
		 * @returns {Quaternion} The modified result parameter.
		 * @see Quaternion#squad
		 */
		static computeInnerQuadrangle(q0: Quaternion, q1: Quaternion, q2: Quaternion, result: Quaternion): Quaternion;

		/**
		 * Computes the spherical quadrangle interpolation between quaternions.
		 * @param {Quaternion} q0 The first quaternion.
		 * @param {Quaternion} q1 The second quaternion.
		 * @param {Quaternion} s0 The first inner quadrangle.
		 * @param {Quaternion} s1 The second inner quadrangle.
		 * @param {Number} t The time in [0,1] used to interpolate.
		 * @param {Quaternion} result The object onto which to store the result.
		 * @returns {Quaternion} The modified result parameter.
		 * @example
		 * // 1. compute the squad interpolation between two quaternions on a curve
		 * var s0 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[i - 1], quaternions[i], quaternions[i + 1], new Cesium.Quaternion());
		 * var s1 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[i], quaternions[i + 1], quaternions[i + 2], new Cesium.Quaternion());
		 * var q = Cesium.Quaternion.squad(quaternions[i], quaternions[i + 1], s0, s1, t, new Cesium.Quaternion());
		 * // 2. compute the squad interpolation as above but where the first quaternion is a end point.
		 * var s1 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[0], quaternions[1], quaternions[2], new Cesium.Quaternion());
		 * var q = Cesium.Quaternion.squad(quaternions[0], quaternions[1], quaternions[0], s1, t, new Cesium.Quaternion());
		 * @see Quaternion#computeInnerQuadrangle
		 */
		static squad(q0: Quaternion, q1: Quaternion, s0: Quaternion, s1: Quaternion, t: number, result: Quaternion): Quaternion;

		/**
		 * Computes the spherical linear interpolation or extrapolation at t using the provided quaternions.
		 * This implementation is faster than {@link Quaternion#slerp}, but is only accurate up to 10<sup>-6</sup>.
		 * @param {Quaternion} start The value corresponding to t at 0.0.
		 * @param {Quaternion} end The value corresponding to t at 1.0.
		 * @param {Number} t The point along t at which to interpolate.
		 * @param {Quaternion} result The object onto which to store the result.
		 * @returns {Quaternion} The modified result parameter.
		 * @see Quaternion#slerp
		 */
		static fastSlerp(start: Quaternion, end: Quaternion, t: number, result: Quaternion): Quaternion;

		/**
		 * Computes the spherical quadrangle interpolation between quaternions.
		 * An implementation that is faster than {@link Quaternion#squad}, but less accurate.
		 * @param {Quaternion} q0 The first quaternion.
		 * @param {Quaternion} q1 The second quaternion.
		 * @param {Quaternion} s0 The first inner quadrangle.
		 * @param {Quaternion} s1 The second inner quadrangle.
		 * @param {Number} t The time in [0,1] used to interpolate.
		 * @param {Quaternion} result The object onto which to store the result.
		 * @returns {Quaternion} The modified result parameter or a new instance if none was provided.
		 * @see Quaternion#squad
		 */
		static fastSquad(q0: Quaternion, q1: Quaternion, s0: Quaternion, s1: Quaternion, t: number, result: Quaternion): Quaternion;

		/**
		 * Compares the provided quaternions componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Quaternion} [left] The first quaternion.
		 * @param {Quaternion} [right] The second quaternion.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		static equals(left?: Quaternion, right?: Quaternion): boolean;

		/**
		 * Compares the provided quaternions componentwise and returns
		 * <code>true</code> if they are within the provided epsilon,
		 * <code>false</code> otherwise.
		 * @param {Quaternion} [left] The first quaternion.
		 * @param {Quaternion} [right] The second quaternion.
		 * @param {Number} [epsilon] The epsilon to use for equality testing.
		 * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
		 */
		static equalsEpsilon(left?: Quaternion, right?: Quaternion, epsilon?: number): boolean;

		/**
		 * An immutable Quaternion instance initialized to (0.0, 0.0, 0.0, 0.0).
		 * @type {Quaternion}
		 * @constant
		 */
		static ZERO: Quaternion;

		/**
		 * An immutable Quaternion instance initialized to (0.0, 0.0, 0.0, 1.0).
		 * @type {Quaternion}
		 * @constant
		 */
		static IDENTITY: Quaternion;

		/**
		 * Duplicates this Quaternion instance.
		 * @param {Quaternion} [result] The object onto which to store the result.
		 * @returns {Quaternion} The modified result parameter or a new Quaternion instance if one was not provided.
		 */
		clone(result?: Quaternion): Quaternion;

		/**
		 * Compares this and the provided quaternion componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Quaternion} [right] The right hand side quaternion.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		equals(right?: Quaternion): boolean;

		/**
		 * Compares this and the provided quaternion componentwise and returns
		 * <code>true</code> if they are within the provided epsilon,
		 * <code>false</code> otherwise.
		 * @param {Quaternion} [right] The right hand side quaternion.
		 * @param {Number} [epsilon] The epsilon to use for equality testing.
		 * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
		 */
		equalsEpsilon(right?: Quaternion, epsilon?: number): boolean;

		/**
		 * Returns a string representing this quaternion in the format (x, y, z, w).
		 * @returns {String} A string representing this Quaternion.
		 */
		toString(): string;

	}

	/**
	 * A spline that uses spherical linear (slerp) interpolation to create a quaternion curve.
	 * The generated curve is in the class C<sup>1</sup>.
	 * @alias QuaternionSpline
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.
	 *                The values are in no way connected to the clock time. They are the parameterization for the curve.
	 * @param {Quaternion[]} options.points The array of {@link Quaternion} control points.
	 * @exception {DeveloperError} points.length must be greater than or equal to 2.
	 * @exception {DeveloperError} times.length must be equal to points.length.
	 * @see HermiteSpline
	 * @see CatmullRomSpline
	 * @see LinearSpline
	 * @see WeightSpline
	 */
	class QuaternionSpline {
		constructor(options: {
			times: number[];
			points: (Quaternion)[];
		});

		/**
		 * An array of times for the control points.
		 * @memberof QuaternionSpline.prototype
		 * @type {Number[]}
		 * @readonly
		 */
		readonly times: number[];

		/**
		 * An array of {@link Quaternion} control points.
		 * @memberof QuaternionSpline.prototype
		 * @type {Quaternion[]}
		 * @readonly
		 */
		readonly points: (Quaternion)[];

		/**
		 * Finds an index <code>i</code> in <code>times</code> such that the parameter
		 * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.
		 * @function
		 * @param {Number} time The time.
		 * @returns {Number} The index for the element at the start of the interval.
		 * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>
		 *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element
		 *                             in the array <code>times</code>.
		 */
		findTimeInterval(time: number): number;

		/**
		 * Wraps the given time to the period covered by the spline.
		 * @function
		 * @param {Number} time The time.
		 * @return {Number} The time, wrapped around to the updated animation.
		 */
		wrapTime(time: number): number;

		/**
		 * Clamps the given time to the period covered by the spline.
		 * @function
		 * @param {Number} time The time.
		 * @return {Number} The time, clamped to the animation period.
		 */
		clampTime(time: number): number;

		/**
		 * Evaluates the curve at a given time.
		 * @param {Number} time The time at which to evaluate the curve.
		 * @param {Quaternion} [result] The object onto which to store the result.
		 * @returns {Quaternion} The modified result parameter or a new instance of the point on the curve at the given time.
		 * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>
		 *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element
		 *                             in the array <code>times</code>.
		 */
		evaluate(time: number, result?: Quaternion): Quaternion;

	}

	/**
	 * Parses a query string into an object, where the keys and values of the object are the
	 * name/value pairs from the query string, decoded. If a name appears multiple times,
	 * the value in the object will be an array of values.
	 * @exports queryToObject
	 * @param {String} queryString The query string.
	 * @returns {Object} An object containing the parameters parsed from the query string.
	 * @example
	 * var obj = Cesium.queryToObject('key1=some%20value&key2=a%2Fb&key3=x&key3=y');
	 * // obj will be:
	 * // {
	 * //   key1 : 'some value',
	 * //   key2 : 'a/b',
	 * //   key3 : ['x', 'y']
	 * // }
	 * @see objectToQuery
	 */
	namespace queryToObject {
	}

	/**
	 * A queue that can enqueue items at the end, and dequeue items from the front.
	 * @alias Queue
	 * @constructor
	 */
	class EngineQueue {
		constructor();

		/**
		 * The length of the queue.
		 * @memberof Queue.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly length: number;

		/**
		 * Enqueues the specified item.
		 * @param {*} item The item to enqueue.
		 */
		enqueue(item: any): void;

		/**
		 * Dequeues an item.  Returns undefined if the queue is empty.
		 * @returns {*} The the dequeued item.
		 */
		dequeue(): any;

		/**
		 * Returns the item at the front of the queue.  Returns undefined if the queue is empty.
		 * @returns {*} The item at the front of the queue.
		 */
		peek(): any;

		/**
		 * Check whether this queue contains the specified item.
		 * @param {*} item The item to search for.
		 */
		contains(item: any): void;

		/**
		 * Remove all items from the queue.
		 */
		clear(): void;

		/**
		 * Sort the items in the queue in-place.
		 * @param {Function} compareFunction A function that defines the sort order.
		 */
		sort(compareFunction: Function): void;

	}

	/**
	 * Represents a ray that extends infinitely from the provided origin in the provided direction.
	 * @alias Ray
	 * @constructor
	 * @param {Cartesian3} [origin=Cartesian3.ZERO] The origin of the ray.
	 * @param {Cartesian3} [direction=Cartesian3.ZERO] The direction of the ray.
	 */
	class Ray {
		constructor(origin?: Cartesian3, direction?: Cartesian3);

		/**
		 * The origin of the ray.
		 * @type {Cartesian3}
		 * @default {@link Cartesian3.ZERO}
		 */
		origin: Cartesian3;

		/**
		 * The direction of the ray.
		 * @type {Cartesian3}
		 */
		direction: Cartesian3;

		/**
		 * Computes the point along the ray given by r(t) = o + t*d,
		 * where o is the origin of the ray and d is the direction.
		 * @param {Ray} ray The ray.
		 * @param {Number} t A scalar value.
		 * @param {Cartesian3} [result] The object in which the result will be stored.
		 * @returns {Cartesian3} The modified result parameter, or a new instance if none was provided.
		 * @example
		 * //Get the first intersection point of a ray and an ellipsoid.
		 * var intersection = Cesium.IntersectionTests.rayEllipsoid(ray, ellipsoid);
		 * var point = Cesium.Ray.getPoint(ray, intersection.start);
		 */
		static getPoint(ray: Ray, t: number, result?: Cartesian3): Cartesian3;

	}

	/**
	 * A two dimensional region specified as longitude and latitude coordinates.
	 * @alias Rectangle
	 * @constructor
	 * @param {Number} [west=0.0] The westernmost longitude, in radians, in the range [-Pi, Pi].
	 * @param {Number} [south=0.0] The southernmost latitude, in radians, in the range [-Pi/2, Pi/2].
	 * @param {Number} [east=0.0] The easternmost longitude, in radians, in the range [-Pi, Pi].
	 * @param {Number} [north=0.0] The northernmost latitude, in radians, in the range [-Pi/2, Pi/2].
	 * @see Packable
	 */
	class Rectangle {
		constructor(west?: number, south?: number, east?: number, north?: number);

		/**
		 * The westernmost longitude in radians in the range [-Pi, Pi].
		 * @type {Number}
		 * @default 0.0
		 */
		west: number;

		/**
		 * The southernmost latitude in radians in the range [-Pi/2, Pi/2].
		 * @type {Number}
		 * @default 0.0
		 */
		south: number;

		/**
		 * The easternmost longitude in radians in the range [-Pi, Pi].
		 * @type {Number}
		 * @default 0.0
		 */
		east: number;

		/**
		 * The northernmost latitude in radians in the range [-Pi/2, Pi/2].
		 * @type {Number}
		 * @default 0.0
		 */
		north: number;

		/**
		 * Gets the width of the rectangle in radians.
		 * @memberof Rectangle.prototype
		 * @type {Number}
		 */
		width: number;

		/**
		 * Gets the height of the rectangle in radians.
		 * @memberof Rectangle.prototype
		 * @type {Number}
		 */
		height: number;

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {Rectangle} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: Rectangle, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {Rectangle} [result] The object into which to store the result.
		 * @returns {Rectangle} The modified result parameter or a new Rectangle instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: Rectangle): Rectangle;

		/**
		 * Computes the width of a rectangle in radians.
		 * @param {Rectangle} rectangle The rectangle to compute the width of.
		 * @returns {Number} The width.
		 */
		static computeWidth(rectangle: Rectangle): number;

		/**
		 * Computes the height of a rectangle in radians.
		 * @param {Rectangle} rectangle The rectangle to compute the height of.
		 * @returns {Number} The height.
		 */
		static computeHeight(rectangle: Rectangle): number;

		/**
		 * Creates a rectangle given the boundary longitude and latitude in degrees.
		 * @param {Number} [west=0.0] The westernmost longitude in degrees in the range [-180.0, 180.0].
		 * @param {Number} [south=0.0] The southernmost latitude in degrees in the range [-90.0, 90.0].
		 * @param {Number} [east=0.0] The easternmost longitude in degrees in the range [-180.0, 180.0].
		 * @param {Number} [north=0.0] The northernmost latitude in degrees in the range [-90.0, 90.0].
		 * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.
		 * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.
		 * @example
		 * var rectangle = Cesium.Rectangle.fromDegrees(0.0, 20.0, 10.0, 30.0);
		 */
		static fromDegrees(west?: number, south?: number, east?: number, north?: number, result?: Rectangle): Rectangle;

		/**
		 * Creates a rectangle given the boundary longitude and latitude in radians.
		 * @param {Number} [west=0.0] The westernmost longitude in radians in the range [-Math.PI, Math.PI].
		 * @param {Number} [south=0.0] The southernmost latitude in radians in the range [-Math.PI/2, Math.PI/2].
		 * @param {Number} [east=0.0] The easternmost longitude in radians in the range [-Math.PI, Math.PI].
		 * @param {Number} [north=0.0] The northernmost latitude in radians in the range [-Math.PI/2, Math.PI/2].
		 * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.
		 * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.
		 * @example
		 * var rectangle = Cesium.Rectangle.fromRadians(0.0, Math.PI/4, Math.PI/8, 3*Math.PI/4);
		 */
		static fromRadians(west?: number, south?: number, east?: number, north?: number, result?: Rectangle): Rectangle;

		/**
		 * Creates the smallest possible Rectangle that encloses all positions in the provided array.
		 * @param {Cartographic[]} cartographics The list of Cartographic instances.
		 * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.
		 * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.
		 */
		static fromCartographicArray(cartographics: (Cartographic)[], result?: Rectangle): Rectangle;

		/**
		 * Creates the smallest possible Rectangle that encloses all positions in the provided array.
		 * @param {Cartesian3[]} cartesians The list of Cartesian instances.
		 * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid the cartesians are on.
		 * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.
		 * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.
		 */
		static fromCartesianArray(cartesians: (Cartesian3)[], ellipsoid?: Ellipsoid, result?: Rectangle): Rectangle;

		/**
		 * Duplicates a Rectangle.
		 * @param {Rectangle} rectangle The rectangle to clone.
		 * @param {Rectangle} [result] The object onto which to store the result, or undefined if a new instance should be created.
		 * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided. (Returns undefined if rectangle is undefined)
		 */
		static clone(rectangle: Rectangle, result?: Rectangle): Rectangle;

		/**
		 * Compares the provided Rectangles componentwise and returns
		 * <code>true</code> if they pass an absolute or relative tolerance test,
		 * <code>false</code> otherwise.
		 * @param {Rectangle} [left] The first Rectangle.
		 * @param {Rectangle} [right] The second Rectangle.
		 * @param {Number} [absoluteEpsilon] The absolute epsilon tolerance to use for equality testing.
		 * @returns {Boolean} <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
		 */
		static equalsEpsilon(left?: Rectangle, right?: Rectangle, absoluteEpsilon?: number): boolean;

		/**
		 * Duplicates this Rectangle.
		 * @param {Rectangle} [result] The object onto which to store the result.
		 * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.
		 */
		clone(result?: Rectangle): Rectangle;

		/**
		 * Compares the provided Rectangle with this Rectangle componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Rectangle} [other] The Rectangle to compare.
		 * @returns {Boolean} <code>true</code> if the Rectangles are equal, <code>false</code> otherwise.
		 */
		equals(other?: Rectangle): boolean;

		/**
		 * Compares the provided rectangles and returns <code>true</code> if they are equal,
		 * <code>false</code> otherwise.
		 * @param {Rectangle} [left] The first Rectangle.
		 * @param {Rectangle} [right] The second Rectangle.
		 * @returns {Boolean} <code>true</code> if left and right are equal; otherwise <code>false</code>.
		 */
		static equals(left?: Rectangle, right?: Rectangle): boolean;

		/**
		 * Compares the provided Rectangle with this Rectangle componentwise and returns
		 * <code>true</code> if they are within the provided epsilon,
		 * <code>false</code> otherwise.
		 * @param {Rectangle} [other] The Rectangle to compare.
		 * @param {Number} [epsilon] The epsilon to use for equality testing.
		 * @returns {Boolean} <code>true</code> if the Rectangles are within the provided epsilon, <code>false</code> otherwise.
		 */
		equalsEpsilon(other?: Rectangle, epsilon?: number): boolean;

		/**
		 * Checks a Rectangle's properties and throws if they are not in valid ranges.
		 * @param {Rectangle} rectangle The rectangle to validate
		 * @exception {DeveloperError} <code>north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].
		 * @exception {DeveloperError} <code>south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].
		 * @exception {DeveloperError} <code>east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].
		 * @exception {DeveloperError} <code>west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].
		 */
		static validate(rectangle: Rectangle): void;

		/**
		 * Computes the southwest corner of a rectangle.
		 * @param {Rectangle} rectangle The rectangle for which to find the corner
		 * @param {Cartographic} [result] The object onto which to store the result.
		 * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.
		 */
		static southwest(rectangle: Rectangle, result?: Cartographic): Cartographic;

		/**
		 * Computes the northwest corner of a rectangle.
		 * @param {Rectangle} rectangle The rectangle for which to find the corner
		 * @param {Cartographic} [result] The object onto which to store the result.
		 * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.
		 */
		static northwest(rectangle: Rectangle, result?: Cartographic): Cartographic;

		/**
		 * Computes the northeast corner of a rectangle.
		 * @param {Rectangle} rectangle The rectangle for which to find the corner
		 * @param {Cartographic} [result] The object onto which to store the result.
		 * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.
		 */
		static northeast(rectangle: Rectangle, result?: Cartographic): Cartographic;

		/**
		 * Computes the southeast corner of a rectangle.
		 * @param {Rectangle} rectangle The rectangle for which to find the corner
		 * @param {Cartographic} [result] The object onto which to store the result.
		 * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.
		 */
		static southeast(rectangle: Rectangle, result?: Cartographic): Cartographic;

		/**
		 * Computes the center of a rectangle.
		 * @param {Rectangle} rectangle The rectangle for which to find the center
		 * @param {Cartographic} [result] The object onto which to store the result.
		 * @returns {Cartographic} The modified result parameter or a new Cartographic instance if none was provided.
		 */
		static center(rectangle: Rectangle, result?: Cartographic): Cartographic;

		/**
		 * Computes the intersection of two rectangles.  This function assumes that the rectangle's coordinates are
		 * latitude and longitude in radians and produces a correct intersection, taking into account the fact that
		 * the same angle can be represented with multiple values as well as the wrapping of longitude at the
		 * anti-meridian.  For a simple intersection that ignores these factors and can be used with projected
		 * coordinates, see {@link Rectangle.simpleIntersection}.
		 * @param {Rectangle} rectangle On rectangle to find an intersection
		 * @param {Rectangle} otherRectangle Another rectangle to find an intersection
		 * @param {Rectangle} [result] The object onto which to store the result.
		 * @returns {Rectangle|undefined} The modified result parameter, a new Rectangle instance if none was provided or undefined if there is no intersection.
		 */
		static intersection(rectangle: Rectangle, otherRectangle: Rectangle, result?: Rectangle): Rectangle | undefined;

		/**
		 * Computes a simple intersection of two rectangles.  Unlike {@link Rectangle.intersection}, this function
		 * does not attempt to put the angular coordinates into a consistent range or to account for crossing the
		 * anti-meridian.  As such, it can be used for rectangles where the coordinates are not simply latitude
		 * and longitude (i.e. projected coordinates).
		 * @param {Rectangle} rectangle On rectangle to find an intersection
		 * @param {Rectangle} otherRectangle Another rectangle to find an intersection
		 * @param {Rectangle} [result] The object onto which to store the result.
		 * @returns {Rectangle|undefined} The modified result parameter, a new Rectangle instance if none was provided or undefined if there is no intersection.
		 */
		static simpleIntersection(rectangle: Rectangle, otherRectangle: Rectangle, result?: Rectangle): Rectangle | undefined;

		/**
		 * Computes a rectangle that is the union of two rectangles.
		 * @param {Rectangle} rectangle A rectangle to enclose in rectangle.
		 * @param {Rectangle} otherRectangle A rectangle to enclose in a rectangle.
		 * @param {Rectangle} [result] The object onto which to store the result.
		 * @returns {Rectangle} The modified result parameter or a new Rectangle instance if none was provided.
		 */
		static union(rectangle: Rectangle, otherRectangle: Rectangle, result?: Rectangle): Rectangle;

		/**
		 * Computes a rectangle by enlarging the provided rectangle until it contains the provided cartographic.
		 * @param {Rectangle} rectangle A rectangle to expand.
		 * @param {Cartographic} cartographic A cartographic to enclose in a rectangle.
		 * @param {Rectangle} [result] The object onto which to store the result.
		 * @returns {Rectangle} The modified result parameter or a new Rectangle instance if one was not provided.
		 */
		static expand(rectangle: Rectangle, cartographic: Cartographic, result?: Rectangle): Rectangle;

		/**
		 * Returns true if the cartographic is on or inside the rectangle, false otherwise.
		 * @param {Rectangle} rectangle The rectangle
		 * @param {Cartographic} cartographic The cartographic to test.
		 * @returns {Boolean} true if the provided cartographic is inside the rectangle, false otherwise.
		 */
		static contains(rectangle: Rectangle, cartographic: Cartographic): boolean;

		/**
		 * Samples a rectangle so that it includes a list of Cartesian points suitable for passing to
		 * {@link BoundingSphere#fromPoints}.  Sampling is necessary to account
		 * for rectangles that cover the poles or cross the equator.
		 * @param {Rectangle} rectangle The rectangle to subsample.
		 * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use.
		 * @param {Number} [surfaceHeight=0.0] The height of the rectangle above the ellipsoid.
		 * @param {Cartesian3[]} [result] The array of Cartesians onto which to store the result.
		 * @returns {Cartesian3[]} The modified result parameter or a new Array of Cartesians instances if none was provided.
		 */
		static subsample(rectangle: Rectangle, ellipsoid?: Ellipsoid, surfaceHeight?: number, result?: (Cartesian3)[]): (Cartesian3)[];

		/**
		 * The largest possible rectangle.
		 * @type {Rectangle}
		 * @constant
		 */
		static MAX_VALUE: Rectangle;

	}

	/**
	 * A description of a cartographic rectangle on an ellipsoid centered at the origin. Rectangle geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
	 * @alias RectangleGeometry
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.
	 * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
	 * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle lies.
	 * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
	 * @param {Number} [options.height=0.0] The distance in meters between the rectangle and the ellipsoid surface.
	 * @param {Number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.
	 * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.
	 * @param {Number} [options.extrudedHeight] The distance in meters between the rectangle's extruded face and the ellipsoid surface.
	 * @exception {DeveloperError} <code>options.rectangle.north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].
	 * @exception {DeveloperError} <code>options.rectangle.south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].
	 * @exception {DeveloperError} <code>options.rectangle.east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].
	 * @exception {DeveloperError} <code>options.rectangle.west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].
	 * @exception {DeveloperError} <code>options.rectangle.north</code> must be greater than <code>options.rectangle.south</code>.
	 * @see RectangleGeometry#createGeometry
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Rectangle.html|Cesium Sandcastle Rectangle Demo}
	 * @example
	 * // 1. create a rectangle
	 * var rectangle = new Cesium.RectangleGeometry({
	 *   ellipsoid : Cesium.Ellipsoid.WGS84,
	 *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),
	 *   height : 10000.0
	 * });
	 * var geometry = Cesium.RectangleGeometry.createGeometry(rectangle);
	 * // 2. create an extruded rectangle without a top
	 * var rectangle = new Cesium.RectangleGeometry({
	 *   ellipsoid : Cesium.Ellipsoid.WGS84,
	 *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),
	 *   height : 10000.0,
	 *   extrudedHeight: 300000
	 * });
	 * var geometry = Cesium.RectangleGeometry.createGeometry(rectangle);
	 */
	class RectangleGeometry {
		constructor(options: {
			rectangle: Rectangle;
			vertexFormat?: VertexFormat;
			ellipsoid?: Ellipsoid;
			granularity?: number;
			height?: number;
			rotation?: number;
			stRotation?: number;
			extrudedHeight?: number;
		});

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {RectangleGeometry} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: RectangleGeometry, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {RectangleGeometry} [result] The object into which to store the result.
		 * @returns {RectangleGeometry} The modified result parameter or a new RectangleGeometry instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: RectangleGeometry): RectangleGeometry;

		/**
		 * Computes the bounding rectangle based on the provided options
		 * @param {Object} options Object with the following properties:
		 * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.
		 * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle lies.
		 * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
		 * @param {Number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.
		 * @param {Rectangle} [result] An object in which to store the result.
		 * @returns {Rectangle} The result rectangle
		 */
		static computeRectangle(options: {
			rectangle: Rectangle;
			ellipsoid?: Ellipsoid;
			granularity?: number;
			rotation?: number;
		}, result?: Rectangle): Rectangle;

		/**
		 * Computes the geometric representation of a rectangle, including its vertices, indices, and a bounding sphere.
		 * @param {RectangleGeometry} rectangleGeometry A description of the rectangle.
		 * @returns {Geometry|undefined} The computed vertices and indices.
		 * @exception {DeveloperError} Rotated rectangle is invalid.
		 */
		static createGeometry(rectangleGeometry: RectangleGeometry): Geometry | undefined;

	}

	/**
	 * A description of the outline of a a cartographic rectangle on an ellipsoid centered at the origin.
	 * @alias RectangleOutlineGeometry
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Rectangle} options.rectangle A cartographic rectangle with north, south, east and west properties in radians.
	 * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle lies.
	 * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
	 * @param {Number} [options.height=0.0] The distance in meters between the rectangle and the ellipsoid surface.
	 * @param {Number} [options.rotation=0.0] The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.
	 * @param {Number} [options.extrudedHeight] The distance in meters between the rectangle's extruded face and the ellipsoid surface.
	 * @exception {DeveloperError} <code>options.rectangle.north</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].
	 * @exception {DeveloperError} <code>options.rectangle.south</code> must be in the interval [<code>-Pi/2</code>, <code>Pi/2</code>].
	 * @exception {DeveloperError} <code>options.rectangle.east</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].
	 * @exception {DeveloperError} <code>options.rectangle.west</code> must be in the interval [<code>-Pi</code>, <code>Pi</code>].
	 * @exception {DeveloperError} <code>options.rectangle.north</code> must be greater than <code>rectangle.south</code>.
	 * @see RectangleOutlineGeometry#createGeometry
	 * @example
	 * var rectangle = new Cesium.RectangleOutlineGeometry({
	 *   ellipsoid : Cesium.Ellipsoid.WGS84,
	 *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),
	 *   height : 10000.0
	 * });
	 * var geometry = Cesium.RectangleOutlineGeometry.createGeometry(rectangle);
	 */
	class RectangleOutlineGeometry {
		constructor(options: {
			rectangle: Rectangle;
			ellipsoid?: Ellipsoid;
			granularity?: number;
			height?: number;
			rotation?: number;
			extrudedHeight?: number;
		});

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {RectangleOutlineGeometry} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: RectangleOutlineGeometry, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {RectangleOutlineGeometry} [result] The object into which to store the result.
		 * @returns {RectangleOutlineGeometry} The modified result parameter or a new Quaternion instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: RectangleOutlineGeometry): RectangleOutlineGeometry;

		/**
		 * Computes the geometric representation of an outline of a rectangle, including its vertices, indices, and a bounding sphere.
		 * @param {RectangleOutlineGeometry} rectangleGeometry A description of the rectangle outline.
		 * @returns {Geometry|undefined} The computed vertices and indices.
		 * @exception {DeveloperError} Rotated rectangle is invalid.
		 */
		static createGeometry(rectangleGeometry: RectangleOutlineGeometry): Geometry | undefined;

	}

	/**
	 * A browser-independent function to request a new animation frame.  This is used to create
	 * an application's draw loop as shown in the example below.
	 * @exports requestAnimationFrame
	 * @param {requestAnimationFrame~Function} callback The function to call when the next frame should be drawn.
	 * @returns {Number} An ID that can be passed to {@link cancelAnimationFrame} to cancel the request.
	 * @example
	 * // Create a draw loop using requestAnimationFrame. The
	 * // tick callback function is called for every animation frame.
	 * function tick() {
	 *   scene.render();
	 *   Cesium.requestAnimationFrame(tick);
	 * }
	 * tick();
	 * @see {@link https://www.w3.org/TR/html51/webappapis.html#animation-frames|The Web API Animation Frames interface}
	 */
	namespace requestAnimationFrame {
	}

	/**
	 * An event that is raised when a request encounters an error.
	 * @constructor
	 * @alias RequestErrorEvent
	 * @param {Number} [statusCode] The HTTP error status code, such as 404.
	 * @param {Object} [response] The response included along with the error.
	 * @param {String|Object} [responseHeaders] The response headers, represented either as an object literal or as a
	 *                        string in the format returned by XMLHttpRequest's getAllResponseHeaders() function.
	 */
	class RequestErrorEvent {
		constructor(statusCode?: number, response?: any, responseHeaders?: string | any);

		/**
		 * The HTTP error status code, such as 404.  If the error does not have a particular
		 * HTTP code, this property will be undefined.
		 * @type {Number}
		 */
		statusCode: number;

		/**
		 * The response included along with the error.  If the error does not include a response,
		 * this property will be undefined.
		 * @type {Object}
		 */
		response: any;

		/**
		 * The headers included in the response, represented as an object literal of key/value pairs.
		 * If the error does not include any headers, this property will be undefined.
		 * @type {Object}
		 */
		responseHeaders: any;

		/**
		 * Creates a string representing this RequestErrorEvent.
		 * @memberof RequestErrorEvent
		 * @returns {String} A string representing the provided RequestErrorEvent.
		 */
		toString(): string;

	}

	/**
	 * State of the request.
	 * @exports RequestState
	 */
	namespace RequestState {
		/**
		 * Initial unissued state.
		 * @type Number
		 * @constant
		 */
		const UNISSUED: number;

		/**
		 * Issued but not yet active. Will become active when open slots are available.
		 * @type Number
		 * @constant
		 */
		const ISSUED: number;

		/**
		 * Actual http request has been sent.
		 * @type Number
		 * @constant
		 */
		const ACTIVE: number;

		/**
		 * Request completed successfully.
		 * @type Number
		 * @constant
		 */
		const RECEIVED: number;

		/**
		 * Request was cancelled, either explicitly or automatically because of low priority.
		 * @type Number
		 * @constant
		 */
		const CANCELLED: number;

		/**
		 * Request failed.
		 * @type Number
		 * @constant
		 */
		const FAILED: number;

	}

	/**
	 * An enum identifying the type of request. Used for finer grained logging and priority sorting.
	 * @exports RequestType
	 */
	namespace RequestType {
		/**
		 * Terrain request.
		 * @type Number
		 * @constant
		 */
		const TERRAIN: number;

		/**
		 * Imagery request.
		 * @type Number
		 * @constant
		 */
		const IMAGERY: number;

		/**
		 * 3D Tiles request.
		 * @type Number
		 * @constant
		 */
		const TILES3D: number;

		/**
		 * Other request.
		 * @type Number
		 * @constant
		 */
		const OTHER: number;

	}

	/**
	 * A resource that includes the location and any other parameters we need to retrieve it or create derived resources. It also provides the ability to retry requests.
	 * @alias Resource
	 * @constructor
	 * @param {String|Object} options A url or an object with the following properties
	 * @param {String} options.url The url of the resource.
	 * @param {Object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.
	 * @param {Object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).
	 * @param {Object} [options.headers={}] Additional HTTP headers that will be sent.
	 * @param {DefaultProxy} [options.proxy] A proxy to be used when loading the resource.
	 * @param {Resource~Function} [options.retryFunction] The Function to call when a request for this resource fails. If it returns true, the request will be retried.
	 * @param {Number} [options.retryAttempts=0] The number of times the retryFunction should be called before giving up.
	 * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.
	 * @example
	 * function refreshTokenFunction(resource, error) {
	 *   if (error.statusCode === 403) {
	 *     // 403 status code means a new token should be generated
	 *     return getNewAccessToken()
	 *       .then(function(token) {
	 *         resource.queryParameters.access_token = token;
	 *         return true;
	 *       })
	 *       .otherwise(function() {
	 *         return false;
	 *       });
	 *   }
	 *   return false;
	 * }
	 * var resource = new Resource({
	 *    url: 'http://server.com/path/to/resource.json',
	 *    proxy: new DefaultProxy('/proxy/'),
	 *    headers: {
	 *      'X-My-Header': 'valueOfHeader'
	 *    },
	 *    queryParameters: {
	 *      'access_token': '123-435-456-000'
	 *    },
	 *    retryFunction: refreshTokenFunction,
	 *    retryAttempts: 1
	 * });
	 */
	class Resource {
		constructor(options: {
			url: string;
			queryParameters?: any;
			templateValues?: any;
			headers?: any;
			proxy?: DefaultProxy;
			retryFunction?: Function;
			retryAttempts?: number;
			request?: Request;
		});

		/**
		 * Additional HTTP headers that will be sent with the request.
		 * @type {Object}
		 */
		headers: any;

		/**
		 * A Request object that will be used. Intended for internal use only.
		 * @type {Request}
		 */
		request: Request;

		/**
		 * A proxy to be used when loading the resource.
		 * @type {DefaultProxy}
		 */
		proxy: DefaultProxy;

		/**
		 * Function to call when a request for this resource fails. If it returns true or a Promise that resolves to true, the request will be retried.
		 * @type {Function}
		 */
		retryFunction: Function;

		/**
		 * The number of times the retryFunction should be called before giving up.
		 * @type {Number}
		 */
		retryAttempts: number;

		/**
		 * Returns true if blobs are supported.
		 * @memberof Resource
		 * @type {Boolean}
		 * @readonly
		 */
		static readonly isBlobSupported: boolean;

		/**
		 * Query parameters appended to the url.
		 * @memberof Resource.prototype
		 * @type {Object}
		 * @readonly
		 */
		readonly queryParameters: any;

		/**
		 * The key/value pairs used to replace template parameters in the url.
		 * @memberof Resource.prototype
		 * @type {Object}
		 * @readonly
		 */
		readonly templateValues: any;

		/**
		 * The url to the resource with template values replaced, query string appended and encoded by proxy if one was set.
		 * @memberof Resource.prototype
		 * @type {String}
		 */
		url: string;

		/**
		 * The file extension of the resource.
		 * @memberof Resource.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly extension: string;

		/**
		 * True if the Resource refers to a data URI.
		 * @memberof Resource.prototype
		 * @type {Boolean}
		 */
		isDataUri: boolean;

		/**
		 * True if the Resource refers to a blob URI.
		 * @memberof Resource.prototype
		 * @type {Boolean}
		 */
		isBlobUri: boolean;

		/**
		 * True if the Resource refers to a cross origin URL.
		 * @memberof Resource.prototype
		 * @type {Boolean}
		 */
		isCrossOriginUrl: boolean;

		/**
		 * True if the Resource has request headers. This is equivalent to checking if the headers property has any keys.
		 * @memberof Resource.prototype
		 * @type {Boolean}
		 */
		hasHeaders: boolean;

		/**
		 * Returns the url, optional with the query string and processed by a proxy.
		 * @param {Boolean} [query=false] If true, the query string is included.
		 * @param {Boolean} [proxy=false] If true, the url is processed the proxy object if defined.
		 * @returns {String} The url with all the requested components.
		 */
		getUrlComponent(query?: boolean, proxy?: boolean): string;

		/**
		 * Combines the specified object and the existing query parameters. This allows you to add many parameters at once,
		 *  as opposed to adding them one at a time to the queryParameters property. If a value is already set, it will be replaced with the new value.
		 * @param {Object} params The query parameters
		 * @param {Boolean} [useAsDefault=false] If true the params will be used as the default values, so they will only be set if they are undefined.
		 */
		setQueryParameters(params: any, useAsDefault?: boolean): void;

		/**
		 * Combines the specified object and the existing query parameters. This allows you to add many parameters at once,
		 *  as opposed to adding them one at a time to the queryParameters property. If a value is already set, it will be replaced with the new value.
		 * @param {Object} params The query parameters
		 * @param {Boolean} [useAsDefault=false] If true the params will be used as the default values, so they will only be set if they are undefined.
		 * @deprecated
		 */
		addQueryParameters(params: any, useAsDefault?: boolean): void;

		/**
		 * Combines the specified object and the existing query parameters. This allows you to add many parameters at once,
		 *  as opposed to adding them one at a time to the queryParameters property.
		 * @param {Object} params The query parameters
		 */
		appendQueryParameters(params: any): void;

		/**
		 * Combines the specified object and the existing template values. This allows you to add many values at once,
		 *  as opposed to adding them one at a time to the templateValues property. If a value is already set, it will become an array and the new value will be appended.
		 * @param {Object} template The template values
		 * @param {Boolean} [useAsDefault=false] If true the values will be used as the default values, so they will only be set if they are undefined.
		 */
		setTemplateValues(template: any, useAsDefault?: boolean): void;

		/**
		 * Combines the specified object and the existing template values. This allows you to add many values at once,
		 *  as opposed to adding them one at a time to the templateValues property. If a value is already set, it will become an array and the new value will be appended.
		 * @param {Object} template The template values
		 * @param {Boolean} [useAsDefault=false] If true the values will be used as the default values, so they will only be set if they are undefined.
		 * @deprecated
		 */
		addTemplateValues(template: any, useAsDefault?: boolean): void;

		/**
		 * Returns a resource relative to the current instance. All properties remain the same as the current instance unless overridden in options.
		 * @param {Object} options An object with the following properties
		 * @param {String} [options.url]  The url that will be resolved relative to the url of the current instance.
		 * @param {Object} [options.queryParameters] An object containing query parameters that will be combined with those of the current instance.
		 * @param {Object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}). These will be combined with those of the current instance.
		 * @param {Object} [options.headers={}] Additional HTTP headers that will be sent.
		 * @param {DefaultProxy} [options.proxy] A proxy to be used when loading the resource.
		 * @param {Resource~Function} [options.retryFunction] The function to call when loading the resource fails.
		 * @param {Number} [options.retryAttempts] The number of times the retryFunction should be called before giving up.
		 * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.
		 * @param {Boolean} [options.preserveQueryParameters=false] If true, this will keep all query parameters from the current resource and derived resource. If false, derived parameters will replace those of the current resource.
		 * @returns {Resource} The resource derived from the current one.
		 */
		getDerivedResource(options: {
			url?: string;
			queryParameters?: any;
			templateValues?: any;
			headers?: any;
			proxy?: DefaultProxy;
			retryFunction?: Function;
			retryAttempts?: number;
			request?: Request;
			preserveQueryParameters?: boolean;
		}): Resource;

		/**
		 * Duplicates a Resource instance.
		 * @param {Resource} [result] The object onto which to store the result.
		 * @returns {Resource} The modified result parameter or a new Resource instance if one was not provided.
		 */
		clone(result?: Resource): Resource;

		/**
		 * Returns the base path of the Resource.
		 * @param {Boolean} [includeQuery = false] Whether or not to include the query string and fragment form the uri
		 * @returns {String} The base URI of the resource
		 */
		getBaseUri(includeQuery?: boolean): string;

		/**
		 * Appends a forward slash to the URL.
		 */
		appendForwardSlash(): void;

		/**
		 * Asynchronously loads the resource as raw binary data.  Returns a promise that will resolve to
		 * an ArrayBuffer once loaded, or reject if the resource failed to load.  The data is loaded
		 * using XMLHttpRequest, which means that in order to make requests to another origin,
		 * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
		 * @returns {Promise.<ArrayBuffer>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
		 * @example
		 * // load a single URL asynchronously
		 * resource.fetchArrayBuffer().then(function(arrayBuffer) {
		 *     // use the data
		 * }).otherwise(function(error) {
		 *     // an error occurred
		 * });
		 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
		 * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
		 */
		fetchArrayBuffer(): any | undefined;

		/**
		 * Creates a Resource and calls fetchArrayBuffer() on it.
		 * @param {String|Object} options A url or an object with the following properties
		 * @param {String} options.url The url of the resource.
		 * @param {Object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.
		 * @param {Object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).
		 * @param {Object} [options.headers={}] Additional HTTP headers that will be sent.
		 * @param {DefaultProxy} [options.proxy] A proxy to be used when loading the resource.
		 * @param {Resource~Function} [options.retryFunction] The Function to call when a request for this resource fails. If it returns true, the request will be retried.
		 * @param {Number} [options.retryAttempts=0] The number of times the retryFunction should be called before giving up.
		 * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.
		 * @returns {Promise.<ArrayBuffer>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
		 */
		static fetchArrayBuffer(options: {
			url: string;
			queryParameters?: any;
			templateValues?: any;
			headers?: any;
			proxy?: DefaultProxy;
			retryFunction?: Function;
			retryAttempts?: number;
			request?: Request;
		}): any | undefined;

		/**
		 * Asynchronously loads the given resource as a blob.  Returns a promise that will resolve to
		 * a Blob once loaded, or reject if the resource failed to load.  The data is loaded
		 * using XMLHttpRequest, which means that in order to make requests to another origin,
		 * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
		 * @returns {Promise.<Blob>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
		 * @example
		 * // load a single URL asynchronously
		 * resource.fetchBlob().then(function(blob) {
		 *     // use the data
		 * }).otherwise(function(error) {
		 *     // an error occurred
		 * });
		 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
		 * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
		 */
		fetchBlob(): any | undefined;

		/**
		 * Creates a Resource and calls fetchBlob() on it.
		 * @param {String|Object} options A url or an object with the following properties
		 * @param {String} options.url The url of the resource.
		 * @param {Object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.
		 * @param {Object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).
		 * @param {Object} [options.headers={}] Additional HTTP headers that will be sent.
		 * @param {DefaultProxy} [options.proxy] A proxy to be used when loading the resource.
		 * @param {Resource~Function} [options.retryFunction] The Function to call when a request for this resource fails. If it returns true, the request will be retried.
		 * @param {Number} [options.retryAttempts=0] The number of times the retryFunction should be called before giving up.
		 * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.
		 * @returns {Promise.<Blob>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
		 */
		static fetchBlob(options: {
			url: string;
			queryParameters?: any;
			templateValues?: any;
			headers?: any;
			proxy?: DefaultProxy;
			retryFunction?: Function;
			retryAttempts?: number;
			request?: Request;
		}): any | undefined;

		/**
		 * Asynchronously loads the given image resource.  Returns a promise that will resolve to
		 * an {@link Image} once loaded, or reject if the image failed to load.
		 * @param {Boolean} [preferBlob = false]  If true, we will load the image via a blob.
		 * @returns {Promise.<Image>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
		 * @example
		 * // load a single image asynchronously
		 * resource.fetchImage().then(function(image) {
		 *     // use the loaded image
		 * }).otherwise(function(error) {
		 *     // an error occurred
		 * });
		 * // load several images in parallel
		 * when.all([resource1.fetchImage(), resource2.fetchImage()]).then(function(images) {
		 *     // images is an array containing all the loaded images
		 * });
		 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
		 * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
		 */
		fetchImage(preferBlob?: boolean): any | undefined;

		/**
		 * Creates a Resource and calls fetchImage() on it.
		 * @param {String|Object} options A url or an object with the following properties
		 * @param {String} options.url The url of the resource.
		 * @param {Object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.
		 * @param {Object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).
		 * @param {Object} [options.headers={}] Additional HTTP headers that will be sent.
		 * @param {DefaultProxy} [options.proxy] A proxy to be used when loading the resource.
		 * @param {Resource~Function} [options.retryFunction] The Function to call when a request for this resource fails. If it returns true, the request will be retried.
		 * @param {Number} [options.retryAttempts=0] The number of times the retryFunction should be called before giving up.
		 * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.
		 * @param {Boolean} [options.preferBlob = false]  If true, we will load the image via a blob.
		 * @returns {Promise.<Image>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
		 */
		static fetchImage(options: {
			url: string;
			queryParameters?: any;
			templateValues?: any;
			headers?: any;
			proxy?: DefaultProxy;
			retryFunction?: Function;
			retryAttempts?: number;
			request?: Request;
			preferBlob?: boolean;
		}): any | undefined;

		/**
		 * Asynchronously loads the given resource as text.  Returns a promise that will resolve to
		 * a String once loaded, or reject if the resource failed to load.  The data is loaded
		 * using XMLHttpRequest, which means that in order to make requests to another origin,
		 * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
		 * @returns {Promise.<String>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
		 * @example
		 * // load text from a URL, setting a custom header
		 * var resource = new Resource({
		 *   url: 'http://someUrl.com/someJson.txt',
		 *   headers: {
		 *     'X-Custom-Header' : 'some value'
		 *   }
		 * });
		 * resource.fetchText().then(function(text) {
		 *     // Do something with the text
		 * }).otherwise(function(error) {
		 *     // an error occurred
		 * });
		 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest|XMLHttpRequest}
		 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
		 * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
		 */
		fetchText(): any | undefined;

		/**
		 * Creates a Resource and calls fetchText() on it.
		 * @param {String|Object} options A url or an object with the following properties
		 * @param {String} options.url The url of the resource.
		 * @param {Object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.
		 * @param {Object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).
		 * @param {Object} [options.headers={}] Additional HTTP headers that will be sent.
		 * @param {DefaultProxy} [options.proxy] A proxy to be used when loading the resource.
		 * @param {Resource~Function} [options.retryFunction] The Function to call when a request for this resource fails. If it returns true, the request will be retried.
		 * @param {Number} [options.retryAttempts=0] The number of times the retryFunction should be called before giving up.
		 * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.
		 * @returns {Promise.<String>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
		 */
		static fetchText(options: {
			url: string;
			queryParameters?: any;
			templateValues?: any;
			headers?: any;
			proxy?: DefaultProxy;
			retryFunction?: Function;
			retryAttempts?: number;
			request?: Request;
		}): any | undefined;

		/**
		 * Asynchronously loads the given resource as JSON.  Returns a promise that will resolve to
		 * a JSON object once loaded, or reject if the resource failed to load.  The data is loaded
		 * using XMLHttpRequest, which means that in order to make requests to another origin,
		 * the server must have Cross-Origin Resource Sharing (CORS) headers enabled. This function
		 * adds 'Accept: application/json,&#42;&#47;&#42;;q=0.01' to the request headers, if not
		 * already specified.
		 * @returns {Promise.<Object>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
		 * @example
		 * resource.fetchJson().then(function(jsonData) {
		 *     // Do something with the JSON object
		 * }).otherwise(function(error) {
		 *     // an error occurred
		 * });
		 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
		 * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
		 */
		fetchJson(): any | undefined;

		/**
		 * Creates a Resource and calls fetchJson() on it.
		 * @param {String|Object} options A url or an object with the following properties
		 * @param {String} options.url The url of the resource.
		 * @param {Object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.
		 * @param {Object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).
		 * @param {Object} [options.headers={}] Additional HTTP headers that will be sent.
		 * @param {DefaultProxy} [options.proxy] A proxy to be used when loading the resource.
		 * @param {Resource~Function} [options.retryFunction] The Function to call when a request for this resource fails. If it returns true, the request will be retried.
		 * @param {Number} [options.retryAttempts=0] The number of times the retryFunction should be called before giving up.
		 * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.
		 * @returns {Promise.<Object>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
		 */
		static fetchJson(options: {
			url: string;
			queryParameters?: any;
			templateValues?: any;
			headers?: any;
			proxy?: DefaultProxy;
			retryFunction?: Function;
			retryAttempts?: number;
			request?: Request;
		}): any | undefined;

		/**
		 * Asynchronously loads the given resource as XML.  Returns a promise that will resolve to
		 * an XML Document once loaded, or reject if the resource failed to load.  The data is loaded
		 * using XMLHttpRequest, which means that in order to make requests to another origin,
		 * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
		 * @returns {Promise.<XMLDocument>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
		 * @example
		 * // load XML from a URL, setting a custom header
		 * Cesium.loadXML('http://someUrl.com/someXML.xml', {
		 *   'X-Custom-Header' : 'some value'
		 * }).then(function(document) {
		 *     // Do something with the document
		 * }).otherwise(function(error) {
		 *     // an error occurred
		 * });
		 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest|XMLHttpRequest}
		 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
		 * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
		 */
		fetchXML(): any | undefined;

		/**
		 * Creates a Resource and calls fetchXML() on it.
		 * @param {String|Object} options A url or an object with the following properties
		 * @param {String} options.url The url of the resource.
		 * @param {Object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.
		 * @param {Object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).
		 * @param {Object} [options.headers={}] Additional HTTP headers that will be sent.
		 * @param {DefaultProxy} [options.proxy] A proxy to be used when loading the resource.
		 * @param {Resource~Function} [options.retryFunction] The Function to call when a request for this resource fails. If it returns true, the request will be retried.
		 * @param {Number} [options.retryAttempts=0] The number of times the retryFunction should be called before giving up.
		 * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.
		 * @returns {Promise.<XMLDocument>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
		 */
		static fetchXML(options: {
			url: string;
			queryParameters?: any;
			templateValues?: any;
			headers?: any;
			proxy?: DefaultProxy;
			retryFunction?: Function;
			retryAttempts?: number;
			request?: Request;
		}): any | undefined;

		/**
		 * Requests a resource using JSONP.
		 * @param {String} [callbackParameterName='callback'] The callback parameter name that the server expects.
		 * @returns {Promise.<Object>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
		 * @example
		 * // load a data asynchronously
		 * resource.fetchJsonp().then(function(data) {
		 *     // use the loaded data
		 * }).otherwise(function(error) {
		 *     // an error occurred
		 * });
		 * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
		 */
		fetchJsonp(callbackParameterName?: string): any | undefined;

		/**
		 * Creates a Resource from a URL and calls fetchJsonp() on it.
		 * @param {String|Object} options A url or an object with the following properties
		 * @param {String} options.url The url of the resource.
		 * @param {Object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.
		 * @param {Object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).
		 * @param {Object} [options.headers={}] Additional HTTP headers that will be sent.
		 * @param {DefaultProxy} [options.proxy] A proxy to be used when loading the resource.
		 * @param {Resource~Function} [options.retryFunction] The Function to call when a request for this resource fails. If it returns true, the request will be retried.
		 * @param {Number} [options.retryAttempts=0] The number of times the retryFunction should be called before giving up.
		 * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.
		 * @param {String} [options.callbackParameterName='callback'] The callback parameter name that the server expects.
		 * @returns {Promise.<Object>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
		 */
		static fetchJsonp(options: {
			url: string;
			queryParameters?: any;
			templateValues?: any;
			headers?: any;
			proxy?: DefaultProxy;
			retryFunction?: Function;
			retryAttempts?: number;
			request?: Request;
			callbackParameterName?: string;
		}): any | undefined;

		/**
		 * Asynchronously loads the given resource.  Returns a promise that will resolve to
		 * the result once loaded, or reject if the resource failed to load.  The data is loaded
		 * using XMLHttpRequest, which means that in order to make requests to another origin,
		 * the server must have Cross-Origin Resource Sharing (CORS) headers enabled. It's recommended that you use
		 * the more specific functions eg. fetchJson, fetchBlob, etc.
		 * @param {Object} [options] Object with the following properties:
		 * @param {String} [options.responseType] The type of response.  This controls the type of item returned.
		 * @param {Object} [options.headers] Additional HTTP headers to send with the request, if any.
		 * @param {String} [options.overrideMimeType] Overrides the MIME type returned by the server.
		 * @returns {Promise.<Object>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
		 * @example
		 * resource.fetch()
		 *   .then(function(body) {
		 *       // use the data
		 *   }).otherwise(function(error) {
		 *       // an error occurred
		 *   });
		 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
		 * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
		 */
		fetch(options?: {
			responseType?: string;
			headers?: any;
			overrideMimeType?: string;
		}): any | undefined;

		/**
		 * Creates a Resource from a URL and calls fetch() on it.
		 * @param {String|Object} options A url or an object with the following properties
		 * @param {String} options.url The url of the resource.
		 * @param {Object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.
		 * @param {Object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).
		 * @param {Object} [options.headers={}] Additional HTTP headers that will be sent.
		 * @param {DefaultProxy} [options.proxy] A proxy to be used when loading the resource.
		 * @param {Resource~Function} [options.retryFunction] The Function to call when a request for this resource fails. If it returns true, the request will be retried.
		 * @param {Number} [options.retryAttempts=0] The number of times the retryFunction should be called before giving up.
		 * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.
		 * @param {String} [options.responseType] The type of response.  This controls the type of item returned.
		 * @param {String} [options.overrideMimeType] Overrides the MIME type returned by the server.
		 * @returns {Promise.<Object>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
		 */
		static fetch(options: {
			url: string;
			queryParameters?: any;
			templateValues?: any;
			headers?: any;
			proxy?: DefaultProxy;
			retryFunction?: Function;
			retryAttempts?: number;
			request?: Request;
			responseType?: string;
			overrideMimeType?: string;
		}): any | undefined;

		/**
		 * Asynchronously deletes the given resource.  Returns a promise that will resolve to
		 * the result once loaded, or reject if the resource failed to load.  The data is loaded
		 * using XMLHttpRequest, which means that in order to make requests to another origin,
		 * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
		 * @param {Object} [options] Object with the following properties:
		 * @param {String} [options.responseType] The type of response.  This controls the type of item returned.
		 * @param {Object} [options.headers] Additional HTTP headers to send with the request, if any.
		 * @param {String} [options.overrideMimeType] Overrides the MIME type returned by the server.
		 * @returns {Promise.<Object>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
		 * @example
		 * resource.delete()
		 *   .then(function(body) {
		 *       // use the data
		 *   }).otherwise(function(error) {
		 *       // an error occurred
		 *   });
		 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
		 * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
		 */
		delete(options?: {
			responseType?: string;
			headers?: any;
			overrideMimeType?: string;
		}): any | undefined;

		/**
		 * Creates a Resource from a URL and calls delete() on it.
		 * @param {String|Object} options A url or an object with the following properties
		 * @param {String} options.url The url of the resource.
		 * @param {Object} [options.data] Data that is posted with the resource.
		 * @param {Object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.
		 * @param {Object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).
		 * @param {Object} [options.headers={}] Additional HTTP headers that will be sent.
		 * @param {DefaultProxy} [options.proxy] A proxy to be used when loading the resource.
		 * @param {Resource~Function} [options.retryFunction] The Function to call when a request for this resource fails. If it returns true, the request will be retried.
		 * @param {Number} [options.retryAttempts=0] The number of times the retryFunction should be called before giving up.
		 * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.
		 * @param {String} [options.responseType] The type of response.  This controls the type of item returned.
		 * @param {String} [options.overrideMimeType] Overrides the MIME type returned by the server.
		 * @returns {Promise.<Object>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
		 */
		static delete(options: {
			url: string;
			data?: any;
			queryParameters?: any;
			templateValues?: any;
			headers?: any;
			proxy?: DefaultProxy;
			retryFunction?: Function;
			retryAttempts?: number;
			request?: Request;
			responseType?: string;
			overrideMimeType?: string;
		}): any | undefined;

		/**
		 * Asynchronously gets headers the given resource.  Returns a promise that will resolve to
		 * the result once loaded, or reject if the resource failed to load.  The data is loaded
		 * using XMLHttpRequest, which means that in order to make requests to another origin,
		 * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
		 * @param {Object} [options] Object with the following properties:
		 * @param {String} [options.responseType] The type of response.  This controls the type of item returned.
		 * @param {Object} [options.headers] Additional HTTP headers to send with the request, if any.
		 * @param {String} [options.overrideMimeType] Overrides the MIME type returned by the server.
		 * @returns {Promise.<Object>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
		 * @example
		 * resource.head()
		 *   .then(function(headers) {
		 *       // use the data
		 *   }).otherwise(function(error) {
		 *       // an error occurred
		 *   });
		 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
		 * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
		 */
		head(options?: {
			responseType?: string;
			headers?: any;
			overrideMimeType?: string;
		}): any | undefined;

		/**
		 * Creates a Resource from a URL and calls head() on it.
		 * @param {String|Object} options A url or an object with the following properties
		 * @param {String} options.url The url of the resource.
		 * @param {Object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.
		 * @param {Object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).
		 * @param {Object} [options.headers={}] Additional HTTP headers that will be sent.
		 * @param {DefaultProxy} [options.proxy] A proxy to be used when loading the resource.
		 * @param {Resource~Function} [options.retryFunction] The Function to call when a request for this resource fails. If it returns true, the request will be retried.
		 * @param {Number} [options.retryAttempts=0] The number of times the retryFunction should be called before giving up.
		 * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.
		 * @param {String} [options.responseType] The type of response.  This controls the type of item returned.
		 * @param {String} [options.overrideMimeType] Overrides the MIME type returned by the server.
		 * @returns {Promise.<Object>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
		 */
		static head(options: {
			url: string;
			queryParameters?: any;
			templateValues?: any;
			headers?: any;
			proxy?: DefaultProxy;
			retryFunction?: Function;
			retryAttempts?: number;
			request?: Request;
			responseType?: string;
			overrideMimeType?: string;
		}): any | undefined;

		/**
		 * Asynchronously gets options the given resource.  Returns a promise that will resolve to
		 * the result once loaded, or reject if the resource failed to load.  The data is loaded
		 * using XMLHttpRequest, which means that in order to make requests to another origin,
		 * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
		 * @param {Object} [options] Object with the following properties:
		 * @param {String} [options.responseType] The type of response.  This controls the type of item returned.
		 * @param {Object} [options.headers] Additional HTTP headers to send with the request, if any.
		 * @param {String} [options.overrideMimeType] Overrides the MIME type returned by the server.
		 * @returns {Promise.<Object>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
		 * @example
		 * resource.options()
		 *   .then(function(headers) {
		 *       // use the data
		 *   }).otherwise(function(error) {
		 *       // an error occurred
		 *   });
		 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
		 * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
		 */
		options(options?: {
			responseType?: string;
			headers?: any;
			overrideMimeType?: string;
		}): any | undefined;

		/**
		 * Creates a Resource from a URL and calls options() on it.
		 * @param {String|Object} options A url or an object with the following properties
		 * @param {String} options.url The url of the resource.
		 * @param {Object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.
		 * @param {Object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).
		 * @param {Object} [options.headers={}] Additional HTTP headers that will be sent.
		 * @param {DefaultProxy} [options.proxy] A proxy to be used when loading the resource.
		 * @param {Resource~Function} [options.retryFunction] The Function to call when a request for this resource fails. If it returns true, the request will be retried.
		 * @param {Number} [options.retryAttempts=0] The number of times the retryFunction should be called before giving up.
		 * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.
		 * @param {String} [options.responseType] The type of response.  This controls the type of item returned.
		 * @param {String} [options.overrideMimeType] Overrides the MIME type returned by the server.
		 * @returns {Promise.<Object>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
		 */
		static options(options: {
			url: string;
			queryParameters?: any;
			templateValues?: any;
			headers?: any;
			proxy?: DefaultProxy;
			retryFunction?: Function;
			retryAttempts?: number;
			request?: Request;
			responseType?: string;
			overrideMimeType?: string;
		}): any | undefined;

		/**
		 * Asynchronously posts data to the given resource.  Returns a promise that will resolve to
		 * the result once loaded, or reject if the resource failed to load.  The data is loaded
		 * using XMLHttpRequest, which means that in order to make requests to another origin,
		 * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
		 * @param {Object} data Data that is posted with the resource.
		 * @param {Object} [options] Object with the following properties:
		 * @param {Object} [options.data] Data that is posted with the resource.
		 * @param {String} [options.responseType] The type of response.  This controls the type of item returned.
		 * @param {Object} [options.headers] Additional HTTP headers to send with the request, if any.
		 * @param {String} [options.overrideMimeType] Overrides the MIME type returned by the server.
		 * @returns {Promise.<Object>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
		 * @example
		 * resource.post(data)
		 *   .then(function(result) {
		 *       // use the result
		 *   }).otherwise(function(error) {
		 *       // an error occurred
		 *   });
		 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
		 * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
		 */
		post(data: any, options?: {
			data?: any;
			responseType?: string;
			headers?: any;
			overrideMimeType?: string;
		}): any | undefined;

		/**
		 * Creates a Resource from a URL and calls post() on it.
		 * @param {Object} options A url or an object with the following properties
		 * @param {String} options.url The url of the resource.
		 * @param {Object} options.data Data that is posted with the resource.
		 * @param {Object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.
		 * @param {Object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).
		 * @param {Object} [options.headers={}] Additional HTTP headers that will be sent.
		 * @param {DefaultProxy} [options.proxy] A proxy to be used when loading the resource.
		 * @param {Resource~Function} [options.retryFunction] The Function to call when a request for this resource fails. If it returns true, the request will be retried.
		 * @param {Number} [options.retryAttempts=0] The number of times the retryFunction should be called before giving up.
		 * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.
		 * @param {String} [options.responseType] The type of response.  This controls the type of item returned.
		 * @param {String} [options.overrideMimeType] Overrides the MIME type returned by the server.
		 * @returns {Promise.<Object>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
		 */
		static post(options: {
			url: string;
			data: any;
			queryParameters?: any;
			templateValues?: any;
			headers?: any;
			proxy?: DefaultProxy;
			retryFunction?: Function;
			retryAttempts?: number;
			request?: Request;
			responseType?: string;
			overrideMimeType?: string;
		}): any | undefined;

		/**
		 * Asynchronously puts data to the given resource.  Returns a promise that will resolve to
		 * the result once loaded, or reject if the resource failed to load.  The data is loaded
		 * using XMLHttpRequest, which means that in order to make requests to another origin,
		 * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
		 * @param {Object} data Data that is posted with the resource.
		 * @param {Object} [options] Object with the following properties:
		 * @param {String} [options.responseType] The type of response.  This controls the type of item returned.
		 * @param {Object} [options.headers] Additional HTTP headers to send with the request, if any.
		 * @param {String} [options.overrideMimeType] Overrides the MIME type returned by the server.
		 * @returns {Promise.<Object>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
		 * @example
		 * resource.put(data)
		 *   .then(function(result) {
		 *       // use the result
		 *   }).otherwise(function(error) {
		 *       // an error occurred
		 *   });
		 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
		 * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
		 */
		put(data: any, options?: {
			responseType?: string;
			headers?: any;
			overrideMimeType?: string;
		}): any | undefined;

		/**
		 * Creates a Resource from a URL and calls put() on it.
		 * @param {Object} options A url or an object with the following properties
		 * @param {String} options.url The url of the resource.
		 * @param {Object} options.data Data that is posted with the resource.
		 * @param {Object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.
		 * @param {Object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).
		 * @param {Object} [options.headers={}] Additional HTTP headers that will be sent.
		 * @param {DefaultProxy} [options.proxy] A proxy to be used when loading the resource.
		 * @param {Resource~Function} [options.retryFunction] The Function to call when a request for this resource fails. If it returns true, the request will be retried.
		 * @param {Number} [options.retryAttempts=0] The number of times the retryFunction should be called before giving up.
		 * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.
		 * @param {String} [options.responseType] The type of response.  This controls the type of item returned.
		 * @param {String} [options.overrideMimeType] Overrides the MIME type returned by the server.
		 * @returns {Promise.<Object>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
		 */
		static put(options: {
			url: string;
			data: any;
			queryParameters?: any;
			templateValues?: any;
			headers?: any;
			proxy?: DefaultProxy;
			retryFunction?: Function;
			retryAttempts?: number;
			request?: Request;
			responseType?: string;
			overrideMimeType?: string;
		}): any | undefined;

		/**
		 * Asynchronously patches data to the given resource.  Returns a promise that will resolve to
		 * the result once loaded, or reject if the resource failed to load.  The data is loaded
		 * using XMLHttpRequest, which means that in order to make requests to another origin,
		 * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
		 * @param {Object} data Data that is posted with the resource.
		 * @param {Object} [options] Object with the following properties:
		 * @param {String} [options.responseType] The type of response.  This controls the type of item returned.
		 * @param {Object} [options.headers] Additional HTTP headers to send with the request, if any.
		 * @param {String} [options.overrideMimeType] Overrides the MIME type returned by the server.
		 * @returns {Promise.<Object>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
		 * @example
		 * resource.patch(data)
		 *   .then(function(result) {
		 *       // use the result
		 *   }).otherwise(function(error) {
		 *       // an error occurred
		 *   });
		 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
		 * @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
		 */
		patch(data: any, options?: {
			responseType?: string;
			headers?: any;
			overrideMimeType?: string;
		}): any | undefined;

		/**
		 * Creates a Resource from a URL and calls patch() on it.
		 * @param {Object} options A url or an object with the following properties
		 * @param {String} options.url The url of the resource.
		 * @param {Object} options.data Data that is posted with the resource.
		 * @param {Object} [options.queryParameters] An object containing query parameters that will be sent when retrieving the resource.
		 * @param {Object} [options.templateValues] Key/Value pairs that are used to replace template values (eg. {x}).
		 * @param {Object} [options.headers={}] Additional HTTP headers that will be sent.
		 * @param {DefaultProxy} [options.proxy] A proxy to be used when loading the resource.
		 * @param {Resource~Function} [options.retryFunction] The Function to call when a request for this resource fails. If it returns true, the request will be retried.
		 * @param {Number} [options.retryAttempts=0] The number of times the retryFunction should be called before giving up.
		 * @param {Request} [options.request] A Request object that will be used. Intended for internal use only.
		 * @param {String} [options.responseType] The type of response.  This controls the type of item returned.
		 * @param {String} [options.overrideMimeType] Overrides the MIME type returned by the server.
		 * @returns {Promise.<Object>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
		 */
		static patch(options: {
			url: string;
			data: any;
			queryParameters?: any;
			templateValues?: any;
			headers?: any;
			proxy?: DefaultProxy;
			retryFunction?: Function;
			retryAttempts?: number;
			request?: Request;
			responseType?: string;
			overrideMimeType?: string;
		}): any | undefined;

		/**
		 * A resource instance initialized to the current browser location
		 * @type {Resource}
		 * @constant
		 */
		static DEFAULT: Resource;

	}

	/**
	 * Constructs an exception object that is thrown due to an error that can occur at runtime, e.g.,
	 * out of memory, could not compile shader, etc.  If a function may throw this
	 * exception, the calling code should be prepared to catch it.
	 * <br /><br />
	 * On the other hand, a {@link DeveloperError} indicates an exception due
	 * to a developer error, e.g., invalid argument, that usually indicates a bug in the
	 * calling code.
	 * @alias RuntimeError
	 * @constructor
	 * @extends Error
	 * @param {String} [message] The error message for this exception.
	 * @see DeveloperError
	 */
	class RuntimeError extends Error {
		constructor(message?: string);

		/**
		 * 'RuntimeError' indicating that this exception was thrown due to a runtime error.
		 * @type {String}
		 * @readonly
		 */
		readonly name: string;

		/**
		 * The explanation for why this exception was thrown.
		 * @type {String}
		 * @readonly
		 */
		readonly message: string;

		/**
		 * The stack trace of this exception, if available.
		 * @type {String}
		 * @readonly
		 */
		readonly stack: string;

	}

	/**
	 * Initiates a terrain height query for an array of {@link Cartographic} positions by
	 * requesting tiles from a terrain provider, sampling, and interpolating.  The interpolation
	 * matches the triangles used to render the terrain at the specified level.  The query
	 * happens asynchronously, so this function returns a promise that is resolved when
	 * the query completes.  Each point height is modified in place.  If a height can not be
	 * determined because no terrain data is available for the specified level at that location,
	 * or another error occurs, the height is set to undefined.  As is typical of the
	 * {@link Cartographic} type, the supplied height is a height above the reference ellipsoid
	 * (such as {@link Ellipsoid.WGS84}) rather than an altitude above mean sea level.  In other
	 * words, it will not necessarily be 0.0 if sampled in the ocean. This function needs the
	 * terrain level of detail as input, if you need to get the altitude of the terrain as precisely
	 * as possible (i.e. with maximum level of detail) use {@link sampleTerrainMostDetailed}.
	 * @exports sampleTerrain
	 * @param {TerrainProvider} terrainProvider The terrain provider from which to query heights.
	 * @param {Number} level The terrain level-of-detail from which to query terrain heights.
	 * @param {Cartographic[]} positions The positions to update with terrain heights.
	 * @returns {Promise.<Cartographic[]>} A promise that resolves to the provided list of positions when terrain the query has completed.
	 * @see sampleTerrainMostDetailed
	 * @example
	 * // Query the terrain height of two Cartographic positions
	 * var terrainProvider = Cesium.createWorldTerrain();
	 * var positions = [
	 *     Cesium.Cartographic.fromDegrees(86.925145, 27.988257),
	 *     Cesium.Cartographic.fromDegrees(87.0, 28.0)
	 * ];
	 * var promise = Cesium.sampleTerrain(terrainProvider, 11, positions);
	 * Cesium.when(promise, function(updatedPositions) {
	 *     // positions[0].height and positions[1].height have been updated.
	 *     // updatedPositions is just a reference to positions.
	 * });
	 */
	namespace sampleTerrain {
	}

	/**
	 * Initiates a sampleTerrain() request at the maximum available tile level for a terrain dataset.
	 * @exports sampleTerrainMostDetailed
	 * @param {TerrainProvider} terrainProvider The terrain provider from which to query heights.
	 * @param {Cartographic[]} positions The positions to update with terrain heights.
	 * @returns {Promise.<Cartographic[]>} A promise that resolves to the provided list of positions when terrain the query has completed.  This
	 *                                     promise will reject if the terrain provider's `availability` property is undefined.
	 * @example
	 * // Query the terrain height of two Cartographic positions
	 * var terrainProvider = Cesium.createWorldTerrain();
	 * var positions = [
	 *     Cesium.Cartographic.fromDegrees(86.925145, 27.988257),
	 *     Cesium.Cartographic.fromDegrees(87.0, 28.0)
	 * ];
	 * var promise = Cesium.sampleTerrainMostDetailed(terrainProvider, positions);
	 * Cesium.when(promise, function(updatedPositions) {
	 *     // positions[0].height and positions[1].height have been updated.
	 *     // updatedPositions is just a reference to positions.
	 * });
	 */
	namespace sampleTerrainMostDetailed {
	}

	/**
	 * Handles user input events. Custom functions can be added to be executed on
	 * when the user enters input.
	 * @alias ScreenSpaceEventHandler
	 * @param {Canvas} [element=document] The element to add events to.
	 * @constructor
	 */
	class ScreenSpaceEventHandler {
		constructor(element?: any);

		/**
		 * Set a function to be executed on an input event.
		 * @param {Function} action Function to be executed when the input event occurs.
		 * @param {Number} type The ScreenSpaceEventType of input event.
		 * @param {Number} [modifier] A KeyboardEventModifier key that is held when a <code>type</code>
		 * event occurs.
		 * @see ScreenSpaceEventHandler#getInputAction
		 * @see ScreenSpaceEventHandler#removeInputAction
		 */
		setInputAction(action: Function, type: number, modifier?: number): void;

		/**
		 * Returns the function to be executed on an input event.
		 * @param {Number} type The ScreenSpaceEventType of input event.
		 * @param {Number} [modifier] A KeyboardEventModifier key that is held when a <code>type</code>
		 * event occurs.
		 * @see ScreenSpaceEventHandler#setInputAction
		 * @see ScreenSpaceEventHandler#removeInputAction
		 */
		getInputAction(type: number, modifier?: number): void;

		/**
		 * Removes the function to be executed on an input event.
		 * @param {Number} type The ScreenSpaceEventType of input event.
		 * @param {Number} [modifier] A KeyboardEventModifier key that is held when a <code>type</code>
		 * event occurs.
		 * @see ScreenSpaceEventHandler#getInputAction
		 * @see ScreenSpaceEventHandler#setInputAction
		 */
		removeInputAction(type: number, modifier?: number): void;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <br /><br />
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
		 * @see ScreenSpaceEventHandler#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Removes listeners held by this object.
		 * <br /><br />
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * handler = handler && handler.destroy();
		 * @see ScreenSpaceEventHandler#isDestroyed
		 */
		destroy(): void;

		/**
		 * The amount of time, in milliseconds, that mouse events will be disabled after
		 * receiving any touch events, such that any emulated mouse events will be ignored.
		 * @type {Number}
		 * @default 800
		 */
		static mouseEmulationIgnoreMilliseconds: number;

	}

	/**
	 * Value and type information for per-instance geometry attribute that determines if the geometry instance will be shown.
	 * @alias ShowGeometryInstanceAttribute
	 * @constructor
	 * @param {Boolean} [show=true] Determines if the geometry instance will be shown.
	 * @example
	 * var instance = new Cesium.GeometryInstance({
	 *   geometry : new Cesium.BoxGeometry({
	 *     vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL,
	 *     minimum : new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0),
	 *     maximum : new Cesium.Cartesian3(250000.0, 250000.0, 250000.0)
	 *   }),
	 *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(
	 *     Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),
	 *   id : 'box',
	 *   attributes : {
	 *     show : new Cesium.ShowGeometryInstanceAttribute(false)
	 *   }
	 * });
	 * @see GeometryInstance
	 * @see GeometryInstanceAttribute
	 */
	class ShowGeometryInstanceAttribute {
		constructor(show?: boolean);

		/**
		 * The values for the attributes stored in a typed array.
		 * @type Uint8Array
		 * @default [1.0]
		 */
		value: Uint8Array;

		/**
		 * The datatype of each component in the attribute, e.g., individual elements in
		 * {@link ColorGeometryInstanceAttribute#value}.
		 * @memberof ShowGeometryInstanceAttribute.prototype
		 * @type {ComponentDatatype}
		 * @readonly
		 * @default {@link ComponentDatatype.UNSIGNED_BYTE}
		 */
		readonly componentDatatype: any;

		/**
		 * The number of components in the attributes, i.e., {@link ColorGeometryInstanceAttribute#value}.
		 * @memberof ShowGeometryInstanceAttribute.prototype
		 * @type {Number}
		 * @readonly
		 * @default 1
		 */
		readonly componentsPerAttribute: number;

		/**
		 * When <code>true</code> and <code>componentDatatype</code> is an integer format,
		 * indicate that the components should be mapped to the range [0, 1] (unsigned)
		 * or [-1, 1] (signed) when they are accessed as floating-point for rendering.
		 * @memberof ShowGeometryInstanceAttribute.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		readonly normalize: boolean;

		/**
		 * Converts a boolean show to a typed array that can be used to assign a show attribute.
		 * @param {Boolean} show The show value.
		 * @param {Uint8Array} [result] The array to store the result in, if undefined a new instance will be created.
		 * @returns {Uint8Array} The modified result parameter or a new instance if result was undefined.
		 * @example
		 * var attributes = primitive.getGeometryInstanceAttributes('an id');
		 * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true, attributes.show);
		 */
		static toValue(show: boolean, result?: Uint8Array): Uint8Array;

	}

	/**
	 * Contains functions for finding the Cartesian coordinates of the sun and the moon in the
	 * Earth-centered inertial frame.
	 * @exports Simon1994PlanetaryPositions
	 */
	namespace Simon1994PlanetaryPositions {
		/**
		 * Computes the position of the Sun in the Earth-centered inertial frame
		 * @param {JulianDate} [julianDate] The time at which to compute the Sun's position, if not provided the current system time is used.
		 * @param {Cartesian3} [result] The object onto which to store the result.
		 * @returns {Cartesian3} Calculated sun position
		 */
		function computeSunPositionInEarthInertialFrame(julianDate?: JulianDate, result?: Cartesian3): Cartesian3;

		/**
		 * Computes the position of the Moon in the Earth-centered inertial frame
		 * @param {JulianDate} [julianDate] The time at which to compute the Sun's position, if not provided the current system time is used.
		 * @param {Cartesian3} [result] The object onto which to store the result.
		 * @returns {Cartesian3} Calculated moon position
		 */
		function computeMoonPositionInEarthInertialFrame(julianDate?: JulianDate, result?: Cartesian3): Cartesian3;

	}

	/**
	 * A description of a polyline modeled as a line strip; the first two positions define a line segment,
	 * and each additional position defines a line segment from the previous position.
	 * @alias SimplePolylineGeometry
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the positions in the polyline as a line strip.
	 * @param {Color[]} [options.colors] An Array of {@link Color} defining the per vertex or per segment colors.
	 * @param {Boolean} [options.colorsPerVertex=false] A boolean that determines whether the colors will be flat across each segment of the line or interpolated across the vertices.
	 * @param {Boolean} [options.followSurface=true] A boolean that determines whether positions will be adjusted to the surface of the ellipsoid via a great arc.
	 * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude if options.followSurface=true. Determines the number of positions in the buffer.
	 * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.
	 * @exception {DeveloperError} At least two positions are required.
	 * @exception {DeveloperError} colors has an invalid length.
	 * @see SimplePolylineGeometry#createGeometry
	 * @example
	 * // A polyline with two connected line segments
	 * var polyline = new Cesium.SimplePolylineGeometry({
	 *   positions : Cesium.Cartesian3.fromDegreesArray([
	 *     0.0, 0.0,
	 *     5.0, 0.0,
	 *     5.0, 5.0
	 *   ])
	 * });
	 * var geometry = Cesium.SimplePolylineGeometry.createGeometry(polyline);
	 */
	class SimplePolylineGeometry {
		constructor(options: {
			positions: (Cartesian3)[];
			colors?: (Color)[];
			colorsPerVertex?: boolean;
			followSurface?: boolean;
			granularity?: number;
			ellipsoid?: Ellipsoid;
		});

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {SimplePolylineGeometry} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: SimplePolylineGeometry, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {SimplePolylineGeometry} [result] The object into which to store the result.
		 * @returns {SimplePolylineGeometry} The modified result parameter or a new SimplePolylineGeometry instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: SimplePolylineGeometry): SimplePolylineGeometry;

		/**
		 * Computes the geometric representation of a simple polyline, including its vertices, indices, and a bounding sphere.
		 * @param {SimplePolylineGeometry} simplePolylineGeometry A description of the polyline.
		 * @returns {Geometry} The computed vertices and indices.
		 */
		static createGeometry(simplePolylineGeometry: SimplePolylineGeometry): Geometry;

	}

	/**
	 * A description of a sphere centered at the origin.
	 * @alias SphereGeometry
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Number} [options.radius=1.0] The radius of the sphere.
	 * @param {Number} [options.stackPartitions=64] The number of times to partition the ellipsoid into stacks.
	 * @param {Number} [options.slicePartitions=64] The number of times to partition the ellipsoid into radial slices.
	 * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
	 * @exception {DeveloperError} options.slicePartitions cannot be less than three.
	 * @exception {DeveloperError} options.stackPartitions cannot be less than three.
	 * @see SphereGeometry#createGeometry
	 * @example
	 * var sphere = new Cesium.SphereGeometry({
	 *   radius : 100.0,
	 *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY
	 * });
	 * var geometry = Cesium.SphereGeometry.createGeometry(sphere);
	 */
	class SphereGeometry {
		constructor(options?: {
			radius?: number;
			stackPartitions?: number;
			slicePartitions?: number;
			vertexFormat?: VertexFormat;
		});

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {SphereGeometry} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: SphereGeometry, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {SphereGeometry} [result] The object into which to store the result.
		 * @returns {SphereGeometry} The modified result parameter or a new SphereGeometry instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: SphereGeometry): SphereGeometry;

		/**
		 * Computes the geometric representation of a sphere, including its vertices, indices, and a bounding sphere.
		 * @param {SphereGeometry} sphereGeometry A description of the sphere.
		 * @returns {Geometry} The computed vertices and indices.
		 */
		static createGeometry(sphereGeometry: SphereGeometry): Geometry;

	}

	/**
	 * A description of the outline of a sphere.
	 * @alias SphereOutlineGeometry
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Number} [options.radius=1.0] The radius of the sphere.
	 * @param {Number} [options.stackPartitions=10] The count of stacks for the sphere (1 greater than the number of parallel lines).
	 * @param {Number} [options.slicePartitions=8] The count of slices for the sphere (Equal to the number of radial lines).
	 * @param {Number} [options.subdivisions=200] The number of points per line, determining the granularity of the curvature .
	 * @exception {DeveloperError} options.stackPartitions must be greater than or equal to one.
	 * @exception {DeveloperError} options.slicePartitions must be greater than or equal to zero.
	 * @exception {DeveloperError} options.subdivisions must be greater than or equal to zero.
	 * @example
	 * var sphere = new Cesium.SphereOutlineGeometry({
	 *   radius : 100.0,
	 *   stackPartitions : 6,
	 *   slicePartitions: 5
	 * });
	 * var geometry = Cesium.SphereOutlineGeometry.createGeometry(sphere);
	 */
	class SphereOutlineGeometry {
		constructor(options?: {
			radius?: number;
			stackPartitions?: number;
			slicePartitions?: number;
			subdivisions?: number;
		});

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {SphereOutlineGeometry} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: SphereOutlineGeometry, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {SphereOutlineGeometry} [result] The object into which to store the result.
		 * @returns {SphereOutlineGeometry} The modified result parameter or a new SphereOutlineGeometry instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: SphereOutlineGeometry): SphereOutlineGeometry;

		/**
		 * Computes the geometric representation of an outline of a sphere, including its vertices, indices, and a bounding sphere.
		 * @param {SphereOutlineGeometry} sphereGeometry A description of the sphere outline.
		 * @returns {Geometry} The computed vertices and indices.
		 */
		static createGeometry(sphereGeometry: SphereOutlineGeometry): Geometry;

	}

	/**
	 * A set of curvilinear 3-dimensional coordinates.
	 * @alias Spherical
	 * @constructor
	 * @param {Number} [clock=0.0] The angular coordinate lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.
	 * @param {Number} [cone=0.0] The angular coordinate measured from the positive z-axis and toward the negative z-axis.
	 * @param {Number} [magnitude=1.0] The linear coordinate measured from the origin.
	 */
	class Spherical {
		constructor(clock?: number, cone?: number, magnitude?: number);

		/**
		 * Converts the provided Cartesian3 into Spherical coordinates.
		 * @param {Cartesian3} cartesian3 The Cartesian3 to be converted to Spherical.
		 * @param {Spherical} [result] The object in which the result will be stored, if undefined a new instance will be created.
		 * @returns {Spherical} The modified result parameter, or a new instance if one was not provided.
		 */
		static fromCartesian3(cartesian3: Cartesian3, result?: Spherical): Spherical;

		/**
		 * Creates a duplicate of a Spherical.
		 * @param {Spherical} spherical The spherical to clone.
		 * @param {Spherical} [result] The object to store the result into, if undefined a new instance will be created.
		 * @returns {Spherical} The modified result parameter or a new instance if result was undefined. (Returns undefined if spherical is undefined)
		 */
		static clone(spherical: Spherical, result?: Spherical): Spherical;

		/**
		 * Computes the normalized version of the provided spherical.
		 * @param {Spherical} spherical The spherical to be normalized.
		 * @param {Spherical} [result] The object to store the result into, if undefined a new instance will be created.
		 * @returns {Spherical} The modified result parameter or a new instance if result was undefined.
		 */
		static normalize(spherical: Spherical, result?: Spherical): Spherical;

		/**
		 * Returns true if the first spherical is equal to the second spherical, false otherwise.
		 * @param {Spherical} left The first Spherical to be compared.
		 * @param {Spherical} right The second Spherical to be compared.
		 * @returns {Boolean} true if the first spherical is equal to the second spherical, false otherwise.
		 */
		static equals(left: Spherical, right: Spherical): boolean;

		/**
		 * Returns true if the first spherical is within the provided epsilon of the second spherical, false otherwise.
		 * @param {Spherical} left The first Spherical to be compared.
		 * @param {Spherical} right The second Spherical to be compared.
		 * @param {Number} [epsilon=0.0] The epsilon to compare against.
		 * @returns {Boolean} true if the first spherical is within the provided epsilon of the second spherical, false otherwise.
		 */
		static equalsEpsilon(left: Spherical, right: Spherical, epsilon?: number): boolean;

		/**
		 * Returns true if this spherical is equal to the provided spherical, false otherwise.
		 * @param {Spherical} other The Spherical to be compared.
		 * @returns {Boolean} true if this spherical is equal to the provided spherical, false otherwise.
		 */
		equals(other: Spherical): boolean;

		/**
		 * Creates a duplicate of this Spherical.
		 * @param {Spherical} [result] The object to store the result into, if undefined a new instance will be created.
		 * @returns {Spherical} The modified result parameter or a new instance if result was undefined.
		 */
		clone(result?: Spherical): Spherical;

		/**
		 * Returns true if this spherical is within the provided epsilon of the provided spherical, false otherwise.
		 * @param {Spherical} other The Spherical to be compared.
		 * @param {Number} epsilon The epsilon to compare against.
		 * @returns {Boolean} true if this spherical is within the provided epsilon of the provided spherical, false otherwise.
		 */
		equalsEpsilon(other: Spherical, epsilon: number): boolean;

		/**
		 * Returns a string representing this instance in the format (clock, cone, magnitude).
		 * @returns {String} A string representing this instance.
		 */
		toString(): string;

	}

	/**
	 * Creates a curve parameterized and evaluated by time. This type describes an interface
	 * and is not intended to be instantiated directly.
	 * @alias Spline
	 * @constructor
	 * @see CatmullRomSpline
	 * @see HermiteSpline
	 * @see LinearSpline
	 * @see QuaternionSpline
	 */
	class Spline {
		constructor();

		/**
		 * An array of times for the control points.
		 * @type {Number[]}
		 * @default undefined
		 */
		times: number[];

		/**
		 * An array of control points.
		 * @type {Cartesian3[]|Quaternion[]}
		 * @default undefined
		 */
		points: (Cartesian3)[] | (Quaternion)[];

		/**
		 * Evaluates the curve at a given time.
		 * @function
		 * @param {Number} time The time at which to evaluate the curve.
		 * @param {Cartesian3|Quaternion|Number[]} [result] The object onto which to store the result.
		 * @returns {Cartesian3|Quaternion|Number[]} The modified result parameter or a new instance of the point on the curve at the given time.
		 * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>
		 *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element
		 *                             in the array <code>times</code>.
		 */
		evaluate(time: number, result?: Cartesian3 | Quaternion | number[]): Cartesian3 | Quaternion | number[];

		/**
		 * Finds an index <code>i</code> in <code>times</code> such that the parameter
		 * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.
		 * @param {Number} time The time.
		 * @param {Number} startIndex The index from which to start the search.
		 * @returns {Number} The index for the element at the start of the interval.
		 * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>
		 *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element
		 *                             in the array <code>times</code>.
		 */
		findTimeInterval(time: number, startIndex: number): number;

		/**
		 * Wraps the given time to the period covered by the spline.
		 * @function
		 * @param {Number} time The time.
		 * @return {Number} The time, wrapped around the animation period.
		 */
		wrapTime(time: number): number;

		/**
		 * Clamps the given time to the period covered by the spline.
		 * @function
		 * @param {Number} time The time.
		 * @return {Number} The time, clamped to the animation period.
		 */
		clampTime(time: number): number;

	}

	/**
	 * Subdivides an array into a number of smaller, equal sized arrays.
	 * @exports subdivideArray
	 * @param {Array} array The array to divide.
	 * @param {Number} numberOfArrays The number of arrays to divide the provided array into.
	 * @exception {DeveloperError} numberOfArrays must be greater than 0.
	 */
	namespace subdivideArray {
	}

	/**
	 * A wrapper around a web worker that allows scheduling tasks for a given worker,
	 * returning results asynchronously via a promise.
	 * The Worker is not constructed until a task is scheduled.
	 * @alias TaskProcessor
	 * @constructor
	 * @param {String} workerName The name of the worker.  This is expected to be a script
	 *                            in the Workers folder.
	 * @param {Number} [maximumActiveTasks=5] The maximum number of active tasks.  Once exceeded,
	 *                                        scheduleTask will not queue any more tasks, allowing
	 *                                        work to be rescheduled in future frames.
	 */
	class TaskProcessor {
		constructor(workerName: string, maximumActiveTasks?: number);

		/**
		 * Schedule a task to be processed by the web worker asynchronously.  If there are currently more
		 * tasks active than the maximum set by the constructor, will immediately return undefined.
		 * Otherwise, returns a promise that will resolve to the result posted back by the worker when
		 * finished.
		 * @param {Object} parameters Any input data that will be posted to the worker.
		 * @param {Object[]} [transferableObjects] An array of objects contained in parameters that should be
		 *                                      transferred to the worker instead of copied.
		 * @returns {Promise.<Object>|undefined} Either a promise that will resolve to the result when available, or undefined
		 *                    if there are too many active tasks,
		 * @example
		 * var taskProcessor = new Cesium.TaskProcessor('myWorkerName');
		 * var promise = taskProcessor.scheduleTask({
		 *     someParameter : true,
		 *     another : 'hello'
		 * });
		 * if (!Cesium.defined(promise)) {
		 *     // too many active tasks - try again later
		 * } else {
		 *     Cesium.when(promise, function(result) {
		 *         // use the result of the task
		 *     });
		 * }
		 */
		scheduleTask(parameters: any, transferableObjects?: any[]): any | undefined;

		/**
		 * Posts a message to a web worker with configuration to initialize loading
		 * and compiling a web assembly module asychronously, as well as an optional
		 * fallback JavaScript module to use if Web Assembly is not supported.
		 * @param {Object} [webAssemblyOptions] An object with the following properties:
		 * @param {String} [webAssemblyOptions.modulePath] The path of the web assembly JavaScript wrapper module.
		 * @param {String} [webAssemblyOptions.wasmBinaryFile] The path of the web assembly binary file.
		 * @param {String} [webAssemblyOptions.fallbackModulePath] The path of the fallback JavaScript module to use if web assembly is not supported.
		 * @returns {Promise.<Object>} A promise that resolves to the result when the web worker has loaded and compiled the web assembly module and is ready to process tasks.
		 */
		initWebAssemblyModule(webAssemblyOptions?: {
			modulePath?: string;
			wasmBinaryFile?: string;
			fallbackModulePath?: string;
		}): any;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <br /><br />
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * @returns {Boolean} True if this object was destroyed; otherwise, false.
		 * @see TaskProcessor#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys this object.  This will immediately terminate the Worker.
		 * <br /><br />
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 */
		destroy(): void;

	}

	/**
	 * Terrain data for a single tile.  This type describes an
	 * interface and is not intended to be instantiated directly.
	 * @alias TerrainData
	 * @constructor
	 * @see HeightmapTerrainData
	 * @see QuantizedMeshTerrainData
	 */
	class TerrainData {
		constructor();

		/**
		 * An array of credits for this tile.
		 * @memberof TerrainData.prototype
		 * @type {Credit[]}
		 */
		credits: (Credit)[];

		/**
		 * The water mask included in this terrain data, if any.  A water mask is a rectangular
		 * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.
		 * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.
		 * @memberof TerrainData.prototype
		 * @type {Uint8Array|Image|Canvas}
		 */
		waterMask: Uint8Array | any | any;

		/**
		 * Computes the terrain height at a specified longitude and latitude.
		 * @function
		 * @param {Rectangle} rectangle The rectangle covered by this terrain data.
		 * @param {Number} longitude The longitude in radians.
		 * @param {Number} latitude The latitude in radians.
		 * @returns {Number} The terrain height at the specified position.  If the position
		 *          is outside the rectangle, this method will extrapolate the height, which is likely to be wildly
		 *          incorrect for positions far outside the rectangle.
		 */
		interpolateHeight(rectangle: Rectangle, longitude: number, latitude: number): number;

		/**
		 * Determines if a given child tile is available, based on the
		 * {@link TerrainData#childTileMask}.  The given child tile coordinates are assumed
		 * to be one of the four children of this tile.  If non-child tile coordinates are
		 * given, the availability of the southeast child tile is returned.
		 * @function
		 * @param {Number} thisX The tile X coordinate of this (the parent) tile.
		 * @param {Number} thisY The tile Y coordinate of this (the parent) tile.
		 * @param {Number} childX The tile X coordinate of the child tile to check for availability.
		 * @param {Number} childY The tile Y coordinate of the child tile to check for availability.
		 * @returns {Boolean} True if the child tile is available; otherwise, false.
		 */
		isChildAvailable(thisX: number, thisY: number, childX: number, childY: number): boolean;

		/**
		 * Upsamples this terrain data for use by a descendant tile.
		 * @function
		 * @param {TilingScheme} tilingScheme The tiling scheme of this terrain data.
		 * @param {Number} thisX The X coordinate of this tile in the tiling scheme.
		 * @param {Number} thisY The Y coordinate of this tile in the tiling scheme.
		 * @param {Number} thisLevel The level of this tile in the tiling scheme.
		 * @param {Number} descendantX The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.
		 * @param {Number} descendantY The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.
		 * @param {Number} descendantLevel The level within the tiling scheme of the descendant tile for which we are upsampling.
		 * @returns {Promise.<TerrainData>|undefined} A promise for upsampled terrain data for the descendant tile,
		 *          or undefined if too many asynchronous upsample operations are in progress and the request has been
		 *          deferred.
		 */
		upsample(tilingScheme: TilingScheme, thisX: number, thisY: number, thisLevel: number, descendantX: number, descendantY: number, descendantLevel: number): any | undefined;

		/**
		 * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution
		 * terrain data.  If this value is false, the data was obtained from some other source, such
		 * as by downloading it from a remote server.  This method should return true for instances
		 * returned from a call to {@link TerrainData#upsample}.
		 * @function
		 * @returns {Boolean} True if this instance was created by upsampling; otherwise, false.
		 */
		wasCreatedByUpsampling(): boolean;

	}

	/**
	 * Provides terrain or other geometry for the surface of an ellipsoid.  The surface geometry is
	 * organized into a pyramid of tiles according to a {@link TilingScheme}.  This type describes an
	 * interface and is not intended to be instantiated directly.
	 * @alias TerrainProvider
	 * @constructor
	 * @see EllipsoidTerrainProvider
	 * @see CesiumTerrainProvider
	 * @see VRTheWorldTerrainProvider
	 * @see GoogleEarthEnterpriseTerrainProvider
	 */
	class TerrainProvider {
		constructor();

		/**
		 * Gets an event that is raised when the terrain provider encounters an asynchronous error..  By subscribing
		 * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
		 * are passed an instance of {@link TileProviderError}.
		 * @memberof TerrainProvider.prototype
		 * @type {Event}
		 */
		errorEvent: Event;

		/**
		 * Gets the credit to display when this terrain provider is active.  Typically this is used to credit
		 * the source of the terrain. This function should
		 * not be called before {@link TerrainProvider#ready} returns true.
		 * @memberof TerrainProvider.prototype
		 * @type {Credit}
		 */
		credit: Credit;

		/**
		 * Gets the tiling scheme used by the provider.  This function should
		 * not be called before {@link TerrainProvider#ready} returns true.
		 * @memberof TerrainProvider.prototype
		 * @type {TilingScheme}
		 */
		tilingScheme: TilingScheme;

		/**
		 * Gets a value indicating whether or not the provider is ready for use.
		 * @memberof TerrainProvider.prototype
		 * @type {Boolean}
		 */
		ready: boolean;

		/**
		 * Gets a promise that resolves to true when the provider is ready for use.
		 * @memberof TerrainProvider.prototype
		 * @type {Promise.<Boolean>}
		 * @readonly
		 */
		readonly readyPromise: any;

		/**
		 * Gets a value indicating whether or not the provider includes a water mask.  The water mask
		 * indicates which areas of the globe are water rather than land, so they can be rendered
		 * as a reflective surface with animated waves.  This function should not be
		 * called before {@link TerrainProvider#ready} returns true.
		 * @memberof TerrainProvider.prototype
		 * @type {Boolean}
		 */
		hasWaterMask: boolean;

		/**
		 * Gets a value indicating whether or not the requested tiles include vertex normals.
		 * This function should not be called before {@link TerrainProvider#ready} returns true.
		 * @memberof TerrainProvider.prototype
		 * @type {Boolean}
		 */
		hasVertexNormals: boolean;

		/**
		 * Gets an object that can be used to determine availability of terrain from this provider, such as
		 * at points and in rectangles.  This function should not be called before
		 * {@link TerrainProvider#ready} returns true.  This property may be undefined if availability
		 * information is not available.
		 * @memberof TerrainProvider.prototype
		 * @type {TileAvailability}
		 */
		availability: TileAvailability;

		/**
		 * Gets a list of indices for a triangle mesh representing a regular grid.  Calling
		 * this function multiple times with the same grid width and height returns the
		 * same list of indices.  The total number of vertices must be less than or equal
		 * to 65536.
		 * @param {Number} width The number of vertices in the regular grid in the horizontal direction.
		 * @param {Number} height The number of vertices in the regular grid in the vertical direction.
		 * @returns {Uint16Array} The list of indices.
		 */
		static getRegularGridIndices(width: number, height: number): Uint16Array;

		/**
		 * Specifies the quality of terrain created from heightmaps.  A value of 1.0 will
		 * ensure that adjacent heightmap vertices are separated by no more than
		 * {@link Globe.maximumScreenSpaceError} screen pixels and will probably go very slowly.
		 * A value of 0.5 will cut the estimated level zero geometric error in half, allowing twice the
		 * screen pixels between adjacent heightmap vertices and thus rendering more quickly.
		 * @type {Number}
		 */
		static heightmapTerrainQuality: number;

		/**
		 * Determines an appropriate geometric error estimate when the geometry comes from a heightmap.
		 * @param {Ellipsoid} ellipsoid The ellipsoid to which the terrain is attached.
		 * @param {Number} tileImageWidth The width, in pixels, of the heightmap associated with a single tile.
		 * @param {Number} numberOfTilesAtLevelZero The number of tiles in the horizontal direction at tile level zero.
		 * @returns {Number} An estimated geometric error.
		 */
		static getEstimatedLevelZeroGeometricErrorForAHeightmap(ellipsoid: Ellipsoid, tileImageWidth: number, numberOfTilesAtLevelZero: number): number;

		/**
		 * Requests the geometry for a given tile.  This function should not be called before
		 * {@link TerrainProvider#ready} returns true.  The result must include terrain data and
		 * may optionally include a water mask and an indication of which child tiles are available.
		 * @function
		 * @param {Number} x The X coordinate of the tile for which to request geometry.
		 * @param {Number} y The Y coordinate of the tile for which to request geometry.
		 * @param {Number} level The level of the tile for which to request geometry.
		 * @param {Request} [request] The request object. Intended for internal use only.
		 * @returns {Promise.<TerrainData>|undefined} A promise for the requested geometry.  If this method
		 *          returns undefined instead of a promise, it is an indication that too many requests are already
		 *          pending and the request will be retried later.
		 */
		requestTileGeometry(x: number, y: number, level: number, request?: Request): any | undefined;

		/**
		 * Gets the maximum geometric error allowed in a tile at a given level.  This function should not be
		 * called before {@link TerrainProvider#ready} returns true.
		 * @function
		 * @param {Number} level The tile level for which to get the maximum geometric error.
		 * @returns {Number} The maximum geometric error.
		 */
		getLevelMaximumGeometricError(level: number): number;

		/**
		 * Determines whether data for a tile is available to be loaded.
		 * @function
		 * @param {Number} x The X coordinate of the tile for which to request geometry.
		 * @param {Number} y The Y coordinate of the tile for which to request geometry.
		 * @param {Number} level The level of the tile for which to request geometry.
		 * @returns {Boolean} Undefined if not supported by the terrain provider, otherwise true or false.
		 */
		getTileDataAvailable(x: number, y: number, level: number): boolean;

	}

	/**
	 * Reports the availability of tiles in a {@link TilingScheme}.
	 * @alias TileAvailability
	 * @constructor
	 * @param {TilingScheme} tilingScheme The tiling scheme in which to report availability.
	 * @param {Number} maximumLevel The maximum tile level that is potentially available.
	 */
	class TileAvailability {
		constructor(tilingScheme: TilingScheme, maximumLevel: number);

		/**
		 * Marks a rectangular range of tiles in a particular level as being available.  For best performance,
		 * add your ranges in order of increasing level.
		 * @param {Number} level The level.
		 * @param {Number} startX The X coordinate of the first available tiles at the level.
		 * @param {Number} startY The Y coordinate of the first available tiles at the level.
		 * @param {Number} endX The X coordinate of the last available tiles at the level.
		 * @param {Number} endY The Y coordinate of the last available tiles at the level.
		 */
		addAvailableTileRange(level: number, startX: number, startY: number, endX: number, endY: number): void;

		/**
		 * Determines the level of the most detailed tile covering the position.  This function
		 * usually completes in time logarithmic to the number of rectangles added with
		 * {@link TileAvailability#addAvailableTileRange}.
		 * @param {Cartographic} position The position for which to determine the maximum available level.  The height component is ignored.
		 * @return {Number} The level of the most detailed tile covering the position.
		 * @throws {DeveloperError} If position is outside any tile according to the tiling scheme.
		 */
		computeMaximumLevelAtPosition(position: Cartographic): number;

		/**
		 * Finds the most detailed level that is available _everywhere_ within a given rectangle.  More detailed
		 * tiles may be available in parts of the rectangle, but not the whole thing.  The return value of this
		 * function may be safely passed to {@link sampleTerrain} for any position within the rectangle.  This function
		 * usually completes in time logarithmic to the number of rectangles added with
		 * {@link TileAvailability#addAvailableTileRange}.
		 * @param {Rectangle} rectangle The rectangle.
		 * @return {Number} The best available level for the entire rectangle.
		 */
		computeBestAvailableLevelOverRectangle(rectangle: Rectangle): number;

		/**
		 * Determines if a particular tile is available.
		 * @param {Number} level The tile level to check.
		 * @param {Number} x The X coordinate of the tile to check.
		 * @param {Number} y The Y coordinate of the tile to check.
		 * @return {Boolean} True if the tile is available; otherwise, false.
		 */
		isTileAvailable(level: number, x: number, y: number): boolean;

		/**
		 * Computes a bit mask indicating which of a tile's four children exist.
		 * If a child's bit is set, a tile is available for that child.  If it is cleared,
		 * the tile is not available.  The bit values are as follows:
		 * <table>
		 *     <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>
		 *     <tr><td>0</td><td>1</td><td>Southwest</td></tr>
		 *     <tr><td>1</td><td>2</td><td>Southeast</td></tr>
		 *     <tr><td>2</td><td>4</td><td>Northwest</td></tr>
		 *     <tr><td>3</td><td>8</td><td>Northeast</td></tr>
		 * </table>
		 * @param {Number} level The level of the parent tile.
		 * @param {Number} x The X coordinate of the parent tile.
		 * @param {Number} y The Y coordinate of the parent tile.
		 * @return {Number} The bit mask indicating child availability.
		 */
		computeChildMaskForTile(level: number, x: number, y: number): number;

	}

	/**
	 * Provides details about an error that occurred in an {@link ImageryProvider} or a {@link TerrainProvider}.
	 * @alias TileProviderError
	 * @constructor
	 * @param {ImageryProvider|TerrainProvider} provider The imagery or terrain provider that experienced the error.
	 * @param {String} message A message describing the error.
	 * @param {Number} [x] The X coordinate of the tile that experienced the error, or undefined if the error
	 *        is not specific to a particular tile.
	 * @param {Number} [y] The Y coordinate of the tile that experienced the error, or undefined if the error
	 *        is not specific to a particular tile.
	 * @param {Number} [level] The level of the tile that experienced the error, or undefined if the error
	 *        is not specific to a particular tile.
	 * @param {Number} [timesRetried=0] The number of times this operation has been retried.
	 * @param {Error} [error] The error or exception that occurred, if any.
	 */
	class TileProviderError {
		constructor(provider: ImageryProvider | TerrainProvider, message: string, x?: number, y?: number, level?: number, timesRetried?: number, error?: Error);

		/**
		 * The {@link ImageryProvider} or {@link TerrainProvider} that experienced the error.
		 * @type {ImageryProvider|TerrainProvider}
		 */
		provider: ImageryProvider | TerrainProvider;

		/**
		 * The message describing the error.
		 * @type {String}
		 */
		message: string;

		/**
		 * The X coordinate of the tile that experienced the error.  If the error is not specific
		 * to a particular tile, this property will be undefined.
		 * @type {Number}
		 */
		x: number;

		/**
		 * The Y coordinate of the tile that experienced the error.  If the error is not specific
		 * to a particular tile, this property will be undefined.
		 * @type {Number}
		 */
		y: number;

		/**
		 * The level-of-detail of the tile that experienced the error.  If the error is not specific
		 * to a particular tile, this property will be undefined.
		 * @type {Number}
		 */
		level: number;

		/**
		 * The number of times this operation has been retried.
		 * @type {Number}
		 * @default 0
		 */
		timesRetried: number;

		/**
		 * True if the failed operation should be retried; otherwise, false.  The imagery or terrain provider
		 * will set the initial value of this property before raising the event, but any listeners
		 * can change it.  The value after the last listener is invoked will be acted upon.
		 * @type {Boolean}
		 * @default false
		 */
		retry: boolean;

		/**
		 * The error or exception that occurred, if any.
		 * @type {Error}
		 */
		error: Error;

		/**
		 * Handles an error in an {@link ImageryProvider} or {@link TerrainProvider} by raising an event if it has any listeners, or by
		 * logging the error to the console if the event has no listeners.  This method also tracks the number
		 * of times the operation has been retried and will automatically retry if requested to do so by the
		 * event listeners.
		 * @param {TileProviderError} previousError The error instance returned by this function the last
		 *        time it was called for this error, or undefined if this is the first time this error has
		 *        occurred.
		 * @param {ImageryProvider|TerrainProvider} provider The imagery or terrain provider that encountered the error.
		 * @param {Event} event The event to raise to inform listeners of the error.
		 * @param {String} message The message describing the error.
		 * @param {Number} x The X coordinate of the tile that experienced the error, or undefined if the
		 *        error is not specific to a particular tile.
		 * @param {Number} y The Y coordinate of the tile that experienced the error, or undefined if the
		 *        error is not specific to a particular tile.
		 * @param {Number} level The level-of-detail of the tile that experienced the error, or undefined if the
		 *        error is not specific to a particular tile.
		 * @param {TileProviderError~Function} retryFunction The function to call to retry the operation.  If undefined, the
		 *        operation will not be retried.
		 * @param {Error} [errorDetails] The error or exception that occurred, if any.
		 * @returns {TileProviderError} The error instance that was passed to the event listeners and that
		 *          should be passed to this function the next time it is called for the same error in order
		 *          to track retry counts.
		 */
		static handleError(previousError: TileProviderError, provider: ImageryProvider | TerrainProvider, event: Event, message: string, x: number, y: number, level: number, retryFunction: Function, errorDetails?: Error): TileProviderError;

		/**
		 * Handles success of an operation by resetting the retry count of a previous error, if any.  This way,
		 * if the error occurs again in the future, the listeners will be informed that it has not yet been retried.
		 * @param {TileProviderError} previousError The previous error, or undefined if this operation has
		 *        not previously resulted in an error.
		 */
		static handleSuccess(previousError: TileProviderError): void;

	}

	/**
	 * A tiling scheme for geometry or imagery on the surface of an ellipsoid.  At level-of-detail zero,
	 * the coarsest, least-detailed level, the number of tiles is configurable.
	 * At level of detail one, each of the level zero tiles has four children, two in each direction.
	 * At level of detail two, each of the level one tiles has four children, two in each direction.
	 * This continues for as many levels as are present in the geometry or imagery source.
	 * @alias TilingScheme
	 * @constructor
	 * @see WebMercatorTilingScheme
	 * @see GeographicTilingScheme
	 */
	class TilingScheme {
		constructor();

		/**
		 * Gets the ellipsoid that is tiled by the tiling scheme.
		 * @memberof TilingScheme.prototype
		 * @type {Ellipsoid}
		 */
		ellipsoid: Ellipsoid;

		/**
		 * Gets the rectangle, in radians, covered by this tiling scheme.
		 * @memberof TilingScheme.prototype
		 * @type {Rectangle}
		 */
		rectangle: Rectangle;

		/**
		 * Gets the map projection used by the tiling scheme.
		 * @memberof TilingScheme.prototype
		 * @type {MapProjection}
		 */
		projection: MapProjection;

		/**
		 * Gets the total number of tiles in the X direction at a specified level-of-detail.
		 * @function
		 * @param {Number} level The level-of-detail.
		 * @returns {Number} The number of tiles in the X direction at the given level.
		 */
		getNumberOfXTilesAtLevel(level: number): number;

		/**
		 * Gets the total number of tiles in the Y direction at a specified level-of-detail.
		 * @function
		 * @param {Number} level The level-of-detail.
		 * @returns {Number} The number of tiles in the Y direction at the given level.
		 */
		getNumberOfYTilesAtLevel(level: number): number;

		/**
		 * Transforms a rectangle specified in geodetic radians to the native coordinate system
		 * of this tiling scheme.
		 * @function
		 * @param {Rectangle} rectangle The rectangle to transform.
		 * @param {Rectangle} [result] The instance to which to copy the result, or undefined if a new instance
		 *        should be created.
		 * @returns {Rectangle} The specified 'result', or a new object containing the native rectangle if 'result'
		 *          is undefined.
		 */
		rectangleToNativeRectangle(rectangle: Rectangle, result?: Rectangle): Rectangle;

		/**
		 * Converts tile x, y coordinates and level to a rectangle expressed in the native coordinates
		 * of the tiling scheme.
		 * @function
		 * @param {Number} x The integer x coordinate of the tile.
		 * @param {Number} y The integer y coordinate of the tile.
		 * @param {Number} level The tile level-of-detail.  Zero is the least detailed.
		 * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance
		 *        should be created.
		 * @returns {Rectangle} The specified 'result', or a new object containing the rectangle
		 *          if 'result' is undefined.
		 */
		tileXYToNativeRectangle(x: number, y: number, level: number, result?: any): Rectangle;

		/**
		 * Converts tile x, y coordinates and level to a cartographic rectangle in radians.
		 * @function
		 * @param {Number} x The integer x coordinate of the tile.
		 * @param {Number} y The integer y coordinate of the tile.
		 * @param {Number} level The tile level-of-detail.  Zero is the least detailed.
		 * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance
		 *        should be created.
		 * @returns {Rectangle} The specified 'result', or a new object containing the rectangle
		 *          if 'result' is undefined.
		 */
		tileXYToRectangle(x: number, y: number, level: number, result?: any): Rectangle;

		/**
		 * Calculates the tile x, y coordinates of the tile containing
		 * a given cartographic position.
		 * @function
		 * @param {Cartographic} position The position.
		 * @param {Number} level The tile level-of-detail.  Zero is the least detailed.
		 * @param {Cartesian2} [result] The instance to which to copy the result, or undefined if a new instance
		 *        should be created.
		 * @returns {Cartesian2} The specified 'result', or a new object containing the tile x, y coordinates
		 *          if 'result' is undefined.
		 */
		positionToTileXY(position: Cartographic, level: number, result?: Cartesian2): Cartesian2;

	}

	/**
	 * An interval defined by a start and a stop time; optionally including those times as part of the interval.
	 * Arbitrary data can optionally be associated with each instance for used with {@link TimeIntervalCollection}.
	 * @alias TimeInterval
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {JulianDate} [options.start=new JulianDate()] The start time of the interval.
	 * @param {JulianDate} [options.stop=new JulianDate()] The stop time of the interval.
	 * @param {Boolean} [options.isStartIncluded=true] <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.
	 * @param {Boolean} [options.isStopIncluded=true] <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.
	 * @param {Object} [options.data] Arbitrary data associated with this interval.
	 * @example
	 * // Create an instance that spans August 1st, 1980 and is associated
	 * // with a Cartesian position.
	 * var timeInterval = new Cesium.TimeInterval({
	 *     start : Cesium.JulianDate.fromIso8601('1980-08-01T00:00:00Z'),
	 *     stop : Cesium.JulianDate.fromIso8601('1980-08-02T00:00:00Z'),
	 *     isStartIncluded : true,
	 *     isStopIncluded : false,
	 *     data : Cesium.Cartesian3.fromDegrees(39.921037, -75.170082)
	 * });
	 * @example
	 * // Create two instances from ISO 8601 intervals with associated numeric data
	 * // then compute their intersection, summing the data they contain.
	 * var left = Cesium.TimeInterval.fromIso8601({
	 *     iso8601 : '2000/2010',
	 *     data : 2
	 * });
	 * var right = Cesium.TimeInterval.fromIso8601({
	 *     iso8601 : '1995/2005',
	 *     data : 3
	 * });
	 * //The result of the below intersection will be an interval equivalent to
	 * //var intersection = Cesium.TimeInterval.fromIso8601({
	 * //  iso8601 : '2000/2005',
	 * //  data : 5
	 * //});
	 * var intersection = new Cesium.TimeInterval();
	 * Cesium.TimeInterval.intersect(left, right, intersection, function(leftData, rightData) {
	 *     return leftData + rightData;
	 * });
	 * @example
	 * // Check if an interval contains a specific time.
	 * var dateToCheck = Cesium.JulianDate.fromIso8601('1982-09-08T11:30:00Z');
	 * var containsDate = Cesium.TimeInterval.contains(timeInterval, dateToCheck);
	 */
	class TimeInterval {
		constructor(options?: {
			start?: JulianDate;
			stop?: JulianDate;
			isStartIncluded?: boolean;
			isStopIncluded?: boolean;
			data?: any;
		});

		/**
		 * Gets or sets the start time of this interval.
		 * @type {JulianDate}
		 */
		start: JulianDate;

		/**
		 * Gets or sets the stop time of this interval.
		 * @type {JulianDate}
		 */
		stop: JulianDate;

		/**
		 * Gets or sets the data associated with this interval.
		 * @type {*}
		 */
		data: any;

		/**
		 * Gets or sets whether or not the start time is included in this interval.
		 * @type {Boolean}
		 * @default true
		 */
		isStartIncluded: boolean;

		/**
		 * Gets or sets whether or not the stop time is included in this interval.
		 * @type {Boolean}
		 * @default true
		 */
		isStopIncluded: boolean;

		/**
		 * Gets whether or not this interval is empty.
		 * @memberof TimeInterval.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isEmpty: boolean;

		/**
		 * Creates a new instance from a {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} interval.
		 * @throws DeveloperError if options.iso8601 does not match proper formatting.
		 * @param {Object} options Object with the following properties:
		 * @param {String} options.iso8601 An ISO 8601 interval.
		 * @param {Boolean} [options.isStartIncluded=true] <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.
		 * @param {Boolean} [options.isStopIncluded=true] <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.
		 * @param {Object} [options.data] Arbitrary data associated with this interval.
		 * @param {TimeInterval} [result] An existing instance to use for the result.
		 * @returns {TimeInterval} The modified result parameter or a new instance if none was provided.
		 */
		static fromIso8601(options: {
			iso8601: string;
			isStartIncluded?: boolean;
			isStopIncluded?: boolean;
			data?: any;
		}, result?: TimeInterval): TimeInterval;

		/**
		 * Creates an ISO8601 representation of the provided interval.
		 * @param {TimeInterval} timeInterval The interval to be converted.
		 * @param {Number} [precision] The number of fractional digits used to represent the seconds component.  By default, the most precise representation is used.
		 * @returns {String} The ISO8601 representation of the provided interval.
		 */
		static toIso8601(timeInterval: TimeInterval, precision?: number): string;

		/**
		 * Duplicates the provided instance.
		 * @param {TimeInterval} [timeInterval] The instance to clone.
		 * @param {TimeInterval} [result] An existing instance to use for the result.
		 * @returns {TimeInterval} The modified result parameter or a new instance if none was provided.
		 */
		static clone(timeInterval?: TimeInterval, result?: TimeInterval): TimeInterval;

		/**
		 * Compares two instances and returns <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {TimeInterval} [left] The first instance.
		 * @param {TimeInterval} [right] The second instance.
		 * @param {Function} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.
		 * @returns {Boolean} <code>true</code> if the dates are equal; otherwise, <code>false</code>.
		 */
		static equals(left?: TimeInterval, right?: TimeInterval, dataComparer?: Function): boolean;

		/**
		 * Compares two instances and returns <code>true</code> if they are within <code>epsilon</code> seconds of
		 * each other.  That is, in order for the dates to be considered equal (and for
		 * this function to return <code>true</code>), the absolute value of the difference between them, in
		 * seconds, must be less than <code>epsilon</code>.
		 * @param {TimeInterval} [left] The first instance.
		 * @param {TimeInterval} [right] The second instance.
		 * @param {Number} [epsilon] The maximum number of seconds that should separate the two instances.
		 * @param {Function} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.
		 * @returns {Boolean} <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.
		 */
		static equalsEpsilon(left?: TimeInterval, right?: TimeInterval, epsilon?: number, dataComparer?: Function): boolean;

		/**
		 * Computes the intersection of two intervals, optionally merging their data.
		 * @param {TimeInterval} left The first interval.
		 * @param {TimeInterval} [right] The second interval.
		 * @param {TimeInterval} [result] An existing instance to use for the result.
		 * @param {Function} [mergeFunction] A function which merges the data of the two intervals. If omitted, the data from the left interval will be used.
		 * @returns {TimeInterval} The modified result parameter.
		 */
		static intersect(left: TimeInterval, right?: TimeInterval, result?: TimeInterval, mergeFunction?: Function): TimeInterval;

		/**
		 * Checks if the specified date is inside the provided interval.
		 * @param {TimeInterval} timeInterval The interval.
		 * @param {JulianDate} julianDate The date to check.
		 * @returns {Boolean} <code>true</code> if the interval contains the specified date, <code>false</code> otherwise.
		 */
		static contains(timeInterval: TimeInterval, julianDate: JulianDate): boolean;

		/**
		 * Duplicates this instance.
		 * @param {TimeInterval} [result] An existing instance to use for the result.
		 * @returns {TimeInterval} The modified result parameter or a new instance if none was provided.
		 */
		clone(result?: TimeInterval): TimeInterval;

		/**
		 * Compares this instance against the provided instance componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {TimeInterval} [right] The right hand side interval.
		 * @param {Function} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.
		 * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
		 */
		equals(right?: TimeInterval, dataComparer?: Function): boolean;

		/**
		 * Compares this instance against the provided instance componentwise and returns
		 * <code>true</code> if they are within the provided epsilon,
		 * <code>false</code> otherwise.
		 * @param {TimeInterval} [right] The right hand side interval.
		 * @param {Number} [epsilon] The epsilon to use for equality testing.
		 * @param {Function} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.
		 * @returns {Boolean} <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
		 */
		equalsEpsilon(right?: TimeInterval, epsilon?: number, dataComparer?: Function): boolean;

		/**
		 * Creates a string representing this TimeInterval in ISO8601 format.
		 * @returns {String} A string representing this TimeInterval in ISO8601 format.
		 */
		toString(): string;

		/**
		 * An immutable empty interval.
		 * @type {TimeInterval}
		 * @constant
		 */
		static EMPTY: TimeInterval;


	}

	/**
	 * A non-overlapping collection of {@link TimeInterval} instances sorted by start time.
	 * @alias TimeIntervalCollection
	 * @constructor
	 * @param {TimeInterval[]} [intervals] An array of intervals to add to the collection.
	 */
	class TimeIntervalCollection {
		constructor(intervals?: (TimeInterval)[]);

		/**
		 * Gets an event that is raised whenever the collection of intervals change.
		 * @memberof TimeIntervalCollection.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly changedEvent: Event;

		/**
		 * Gets the start time of the collection.
		 * @memberof TimeIntervalCollection.prototype
		 * @type {JulianDate}
		 * @readonly
		 */
		readonly start: JulianDate;

		/**
		 * Gets whether or not the start time is included in the collection.
		 * @memberof TimeIntervalCollection.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isStartIncluded: boolean;

		/**
		 * Gets the stop time of the collection.
		 * @memberof TimeIntervalCollection.prototype
		 * @type {JulianDate}
		 * @readonly
		 */
		readonly stop: JulianDate;

		/**
		 * Gets whether or not the stop time is included in the collection.
		 * @memberof TimeIntervalCollection.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isStopIncluded: boolean;

		/**
		 * Gets the number of intervals in the collection.
		 * @memberof TimeIntervalCollection.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly length: number;

		/**
		 * Gets whether or not the collection is empty.
		 * @memberof TimeIntervalCollection.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isEmpty: boolean;

		/**
		 * Compares this instance against the provided instance componentwise and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {TimeIntervalCollection} [right] The right hand side collection.
		 * @param {Function} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.
		 * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
		 */
		equals(right?: TimeIntervalCollection, dataComparer?: Function): boolean;

		/**
		 * Gets the interval at the specified index.
		 * @param {Number} index The index of the interval to retrieve.
		 * @returns {TimeInterval} The interval at the specified index, or <code>undefined</code> if no interval exists as that index.
		 */
		get(index: number): TimeInterval;

		/**
		 * Removes all intervals from the collection.
		 */
		removeAll(): void;

		/**
		 * Finds and returns the interval that contains the specified date.
		 * @param {JulianDate} date The date to search for.
		 * @returns {TimeInterval|undefined} The interval containing the specified date, <code>undefined</code> if no such interval exists.
		 */
		findIntervalContainingDate(date: JulianDate): TimeInterval | undefined;

		/**
		 * Finds and returns the data for the interval that contains the specified date.
		 * @param {JulianDate} date The date to search for.
		 * @returns {Object} The data for the interval containing the specified date, or <code>undefined</code> if no such interval exists.
		 */
		findDataForIntervalContainingDate(date: JulianDate): any;

		/**
		 * Checks if the specified date is inside this collection.
		 * @param {JulianDate} julianDate The date to check.
		 * @returns {Boolean} <code>true</code> if the collection contains the specified date, <code>false</code> otherwise.
		 */
		contains(julianDate: JulianDate): boolean;

		/**
		 * Finds and returns the index of the interval in the collection that contains the specified date.
		 * @param {JulianDate} date The date to search for.
		 * @returns {Number} The index of the interval that contains the specified date, if no such interval exists,
		 * it returns a negative number which is the bitwise complement of the index of the next interval that
		 * starts after the date, or if no interval starts after the specified date, the bitwise complement of
		 * the length of the collection.
		 */
		indexOf(date: JulianDate): number;

		/**
		 * Returns the first interval in the collection that matches the specified parameters.
		 * All parameters are optional and <code>undefined</code> parameters are treated as a don't care condition.
		 * @param {Object} [options] Object with the following properties:
		 * @param {JulianDate} [options.start] The start time of the interval.
		 * @param {JulianDate} [options.stop] The stop time of the interval.
		 * @param {Boolean} [options.isStartIncluded] <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.
		 * @param {Boolean} [options.isStopIncluded] <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.
		 * @returns {TimeInterval} The first interval in the collection that matches the specified parameters.
		 */
		findInterval(options?: {
			start?: JulianDate;
			stop?: JulianDate;
			isStartIncluded?: boolean;
			isStopIncluded?: boolean;
		}): TimeInterval;

		/**
		 * Adds an interval to the collection, merging intervals that contain the same data and
		 * splitting intervals of different data as needed in order to maintain a non-overlapping collection.
		 * The data in the new interval takes precedence over any existing intervals in the collection.
		 * @param {TimeInterval} interval The interval to add.
		 * @param {Function} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.
		 */
		addInterval(interval: TimeInterval, dataComparer?: Function): void;

		/**
		 * Removes the specified interval from this interval collection, creating a hole over the specified interval.
		 * The data property of the input interval is ignored.
		 * @param {TimeInterval} interval The interval to remove.
		 * @returns <code>true</code> if the interval was removed, <code>false</code> if no part of the interval was in the collection.
		 */
		removeInterval(interval: TimeInterval): any;

		/**
		 * Creates a new instance that is the intersection of this collection and the provided collection.
		 * @param {TimeIntervalCollection} other The collection to intersect with.
		 * @param {Function} [dataComparer] A function which compares the data of the two intervals.  If omitted, reference equality is used.
		 * @param {Function} [mergeFunction] A function which merges the data of the two intervals. If omitted, the data from the left interval will be used.
		 * @returns {TimeIntervalCollection} A new TimeIntervalCollection which is the intersection of this collection and the provided collection.
		 */
		intersect(other: TimeIntervalCollection, dataComparer?: Function, mergeFunction?: Function): TimeIntervalCollection;

		/**
		 * Creates a new instance from a JulianDate array.
		 * @param {Object} options Object with the following properties:
		 * @param {JulianDate[]} options.julianDates An array of ISO 8601 dates.
		 * @param {Boolean} [options.isStartIncluded=true] <code>true</code> if start time is included in the interval, <code>false</code> otherwise.
		 * @param {Boolean} [options.isStopIncluded=true] <code>true</code> if stop time is included in the interval, <code>false</code> otherwise.
		 * @param {Boolean} [options.leadingInterval=false] <code>true</code> if you want to add a interval from Iso8601.MINIMUM_VALUE to start time,  <code>false</code> otherwise.
		 * @param {Boolean} [options.trailingInterval=false] <code>true</code> if you want to add a interval from stop time to Iso8601.MAXIMUM_VALUE,  <code>false</code> otherwise.
		 * @param {Function} [options.dataFunction] A function that will be return the data that is called with each interval before it is added to the collection. If unspecified, the data will be the index in the collection.
		 * @param {TimeIntervalCollection} [result] An existing instance to use for the result.
		 * @returns {TimeIntervalCollection} The modified result parameter or a new instance if none was provided.
		 */
		static fromJulianDateArray(options: {
			julianDates: (JulianDate)[];
			isStartIncluded?: boolean;
			isStopIncluded?: boolean;
			leadingInterval?: boolean;
			trailingInterval?: boolean;
			dataFunction?: Function;
		}, result?: TimeIntervalCollection): TimeIntervalCollection;

		/**
		 * Creates a new instance from an {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} time interval (start/end/duration).
		 * @param {Object} options Object with the following properties:
		 * @param {String} options.iso8601 An ISO 8601 interval.
		 * @param {Boolean} [options.isStartIncluded=true] <code>true</code> if start time is included in the interval, <code>false</code> otherwise.
		 * @param {Boolean} [options.isStopIncluded=true] <code>true</code> if stop time is included in the interval, <code>false</code> otherwise.
		 * @param {Boolean} [options.leadingInterval=false] <code>true</code> if you want to add a interval from Iso8601.MINIMUM_VALUE to start time,  <code>false</code> otherwise.
		 * @param {Boolean} [options.trailingInterval=false] <code>true</code> if you want to add a interval from stop time to Iso8601.MAXIMUM_VALUE,  <code>false</code> otherwise.
		 * @param {Function} [options.dataFunction] A function that will be return the data that is called with each interval before it is added to the collection. If unspecified, the data will be the index in the collection.
		 * @param {TimeIntervalCollection} [result] An existing instance to use for the result.
		 * @returns {TimeIntervalCollection} The modified result parameter or a new instance if none was provided.
		 */
		static fromIso8601(options: {
			iso8601: string;
			isStartIncluded?: boolean;
			isStopIncluded?: boolean;
			leadingInterval?: boolean;
			trailingInterval?: boolean;
			dataFunction?: Function;
		}, result?: TimeIntervalCollection): TimeIntervalCollection;

		/**
		 * Creates a new instance from a {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} date array.
		 * @param {Object} options Object with the following properties:
		 * @param {String[]} options.iso8601Dates An array of ISO 8601 dates.
		 * @param {Boolean} [options.isStartIncluded=true] <code>true</code> if start time is included in the interval, <code>false</code> otherwise.
		 * @param {Boolean} [options.isStopIncluded=true] <code>true</code> if stop time is included in the interval, <code>false</code> otherwise.
		 * @param {Boolean} [options.leadingInterval=false] <code>true</code> if you want to add a interval from Iso8601.MINIMUM_VALUE to start time,  <code>false</code> otherwise.
		 * @param {Boolean} [options.trailingInterval=false] <code>true</code> if you want to add a interval from stop time to Iso8601.MAXIMUM_VALUE,  <code>false</code> otherwise.
		 * @param {Function} [options.dataFunction] A function that will be return the data that is called with each interval before it is added to the collection. If unspecified, the data will be the index in the collection.
		 * @param {TimeIntervalCollection} [result] An existing instance to use for the result.
		 * @returns {TimeIntervalCollection} The modified result parameter or a new instance if none was provided.
		 */
		static fromIso8601DateArray(options: {
			iso8601Dates: string[];
			isStartIncluded?: boolean;
			isStopIncluded?: boolean;
			leadingInterval?: boolean;
			trailingInterval?: boolean;
			dataFunction?: Function;
		}, result?: TimeIntervalCollection): TimeIntervalCollection;

		/**
		 * Creates a new instance from a {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} duration array.
		 * @param {Object} options Object with the following properties:
		 * @param {JulianDate} options.epoch An date that the durations are relative to.
		 * @param {String} options.iso8601Durations An array of ISO 8601 durations.
		 * @param {Boolean} [options.relativeToPrevious=false] <code>true</code> if durations are relative to previous date, <code>false</code> if always relative to the epoch.
		 * @param {Boolean} [options.isStartIncluded=true] <code>true</code> if start time is included in the interval, <code>false</code> otherwise.
		 * @param {Boolean} [options.isStopIncluded=true] <code>true</code> if stop time is included in the interval, <code>false</code> otherwise.
		 * @param {Boolean} [options.leadingInterval=false] <code>true</code> if you want to add a interval from Iso8601.MINIMUM_VALUE to start time,  <code>false</code> otherwise.
		 * @param {Boolean} [options.trailingInterval=false] <code>true</code> if you want to add a interval from stop time to Iso8601.MAXIMUM_VALUE,  <code>false</code> otherwise.
		 * @param {Function} [options.dataFunction] A function that will be return the data that is called with each interval before it is added to the collection. If unspecified, the data will be the index in the collection.
		 * @param {TimeIntervalCollection} [result] An existing instance to use for the result.
		 * @returns {TimeIntervalCollection} The modified result parameter or a new instance if none was provided.
		 */
		static fromIso8601DurationArray(options: {
			epoch: JulianDate;
			iso8601Durations: string;
			relativeToPrevious?: boolean;
			isStartIncluded?: boolean;
			isStopIncluded?: boolean;
			leadingInterval?: boolean;
			trailingInterval?: boolean;
			dataFunction?: Function;
		}, result?: TimeIntervalCollection): TimeIntervalCollection;

	}

	/**
	 * Contains functions for transforming positions to various reference frames.
	 * @exports Transforms
	 */
	namespace Transforms {
		/**
		 * Generates a function that computes a 4x4 transformation matrix from a reference frame
		 * centered at the provided origin to the provided ellipsoid's fixed reference frame.
		 * @param  {String} firstAxis  name of the first axis of the local reference frame. Must be
		 *  'east', 'north', 'up', 'west', 'south' or 'down'.
		 * @param  {String} secondAxis  name of the second axis of the local reference frame. Must be
		 *  'east', 'north', 'up', 'west', 'south' or 'down'.
		 * @return {localFrameToFixedFrameGenerator~resultat} The function that will computes a
		 * 4x4 transformation matrix from a reference frame, with first axis and second axis compliant with the parameters,
		 */
		function localFrameToFixedFrameGenerator(firstAxis: string, secondAxis: string): any;

		/**
		 * Computes a 4x4 transformation matrix from a reference frame with an east-north-up axes
		 * centered at the provided origin to the provided ellipsoid's fixed reference frame.
		 * The local axes are defined as:
		 * <ul>
		 * <li>The <code>x</code> axis points in the local east direction.</li>
		 * <li>The <code>y</code> axis points in the local north direction.</li>
		 * <li>The <code>z</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>
		 * </ul>
		 * @function
		 * @param {Cartesian3} origin The center point of the local reference frame.
		 * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.
		 * @param {Matrix4} [result] The object onto which to store the result.
		 * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.
		 * @example
		 * // Get the transform from local east-north-up at cartographic (0.0, 0.0) to Earth's fixed frame.
		 * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
		 * var transform = Cesium.Transforms.eastNorthUpToFixedFrame(center);
		 */
		function eastNorthUpToFixedFrame(origin: Cartesian3, ellipsoid?: Ellipsoid, result?: Matrix4): Matrix4;

		/**
		 * Computes a 4x4 transformation matrix from a reference frame with an north-east-down axes
		 * centered at the provided origin to the provided ellipsoid's fixed reference frame.
		 * The local axes are defined as:
		 * <ul>
		 * <li>The <code>x</code> axis points in the local north direction.</li>
		 * <li>The <code>y</code> axis points in the local east direction.</li>
		 * <li>The <code>z</code> axis points in the opposite direction of the ellipsoid surface normal which passes through the position.</li>
		 * </ul>
		 * @function
		 * @param {Cartesian3} origin The center point of the local reference frame.
		 * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.
		 * @param {Matrix4} [result] The object onto which to store the result.
		 * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.
		 * @example
		 * // Get the transform from local north-east-down at cartographic (0.0, 0.0) to Earth's fixed frame.
		 * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
		 * var transform = Cesium.Transforms.northEastDownToFixedFrame(center);
		 */
		function northEastDownToFixedFrame(origin: Cartesian3, ellipsoid?: Ellipsoid, result?: Matrix4): Matrix4;

		/**
		 * Computes a 4x4 transformation matrix from a reference frame with an north-up-east axes
		 * centered at the provided origin to the provided ellipsoid's fixed reference frame.
		 * The local axes are defined as:
		 * <ul>
		 * <li>The <code>x</code> axis points in the local north direction.</li>
		 * <li>The <code>y</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>
		 * <li>The <code>z</code> axis points in the local east direction.</li>
		 * </ul>
		 * @function
		 * @param {Cartesian3} origin The center point of the local reference frame.
		 * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.
		 * @param {Matrix4} [result] The object onto which to store the result.
		 * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.
		 * @example
		 * // Get the transform from local north-up-east at cartographic (0.0, 0.0) to Earth's fixed frame.
		 * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
		 * var transform = Cesium.Transforms.northUpEastToFixedFrame(center);
		 */
		function northUpEastToFixedFrame(origin: Cartesian3, ellipsoid?: Ellipsoid, result?: Matrix4): Matrix4;

		/**
		 * Computes a 4x4 transformation matrix from a reference frame with an north-west-up axes
		 * centered at the provided origin to the provided ellipsoid's fixed reference frame.
		 * The local axes are defined as:
		 * <ul>
		 * <li>The <code>x</code> axis points in the local north direction.</li>
		 * <li>The <code>y</code> axis points in the local west direction.</li>
		 * <li>The <code>z</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>
		 * </ul>
		 * @function
		 * @param {Cartesian3} origin The center point of the local reference frame.
		 * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.
		 * @param {Matrix4} [result] The object onto which to store the result.
		 * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.
		 * @example
		 * // Get the transform from local north-West-Up at cartographic (0.0, 0.0) to Earth's fixed frame.
		 * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
		 * var transform = Cesium.Transforms.northWestUpToFixedFrame(center);
		 */
		function northWestUpToFixedFrame(origin: Cartesian3, ellipsoid?: Ellipsoid, result?: Matrix4): Matrix4;

		/**
		 * Computes a 4x4 transformation matrix from a reference frame with axes computed from the heading-pitch-roll angles
		 * centered at the provided origin to the provided ellipsoid's fixed reference frame. Heading is the rotation from the local north
		 * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles
		 * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.
		 * @param {Cartesian3} origin The center point of the local reference frame.
		 * @param {HeadingPitchRoll} headingPitchRoll The heading, pitch, and roll.
		 * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.
		 * @param {Function} [fixedFrameTransform=Transforms.eastNorthUpToFixedFrame] A 4x4 transformation
		 *  matrix from a reference frame to the provided ellipsoid's fixed reference frame
		 * @param {Matrix4} [result] The object onto which to store the result.
		 * @returns {Matrix4} The modified result parameter or a new Matrix4 instance if none was provided.
		 * @example
		 * // Get the transform from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth's fixed frame.
		 * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
		 * var heading = -Cesium.Math.PI_OVER_TWO;
		 * var pitch = Cesium.Math.PI_OVER_FOUR;
		 * var roll = 0.0;
		 * var hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);
		 * var transform = Cesium.Transforms.headingPitchRollToFixedFrame(center, hpr);
		 */
		function headingPitchRollToFixedFrame(origin: Cartesian3, headingPitchRoll: HeadingPitchRoll, ellipsoid?: Ellipsoid, fixedFrameTransform?: Function, result?: Matrix4): Matrix4;

		/**
		 * Computes a quaternion from a reference frame with axes computed from the heading-pitch-roll angles
		 * centered at the provided origin. Heading is the rotation from the local north
		 * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles
		 * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.
		 * @param {Cartesian3} origin The center point of the local reference frame.
		 * @param {HeadingPitchRoll} headingPitchRoll The heading, pitch, and roll.
		 * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid whose fixed frame is used in the transformation.
		 * @param {Function} [fixedFrameTransform=Transforms.eastNorthUpToFixedFrame] A 4x4 transformation
		 *  matrix from a reference frame to the provided ellipsoid's fixed reference frame
		 * @param {Quaternion} [result] The object onto which to store the result.
		 * @returns {Quaternion} The modified result parameter or a new Quaternion instance if none was provided.
		 * @example
		 * // Get the quaternion from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth's fixed frame.
		 * var center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
		 * var heading = -Cesium.Math.PI_OVER_TWO;
		 * var pitch = Cesium.Math.PI_OVER_FOUR;
		 * var roll = 0.0;
		 * var hpr = new HeadingPitchRoll(heading, pitch, roll);
		 * var quaternion = Cesium.Transforms.headingPitchRollQuaternion(center, hpr);
		 */
		function headingPitchRollQuaternion(origin: Cartesian3, headingPitchRoll: HeadingPitchRoll, ellipsoid?: Ellipsoid, fixedFrameTransform?: Function, result?: Quaternion): Quaternion;

		/**
		 * Computes a rotation matrix to transform a point or vector from True Equator Mean Equinox (TEME) axes to the
		 * pseudo-fixed axes at a given time.  This method treats the UT1 time standard as equivalent to UTC.
		 * @param {JulianDate} date The time at which to compute the rotation matrix.
		 * @param {Matrix3} [result] The object onto which to store the result.
		 * @returns {Matrix3} The modified result parameter or a new Matrix3 instance if none was provided.
		 * @example
		 * //Set the view to in the inertial frame.
		 * scene.postUpdate.addEventListener(function(scene, time) {
		 *    var now = Cesium.JulianDate.now();
		 *    var offset = Cesium.Matrix4.multiplyByPoint(camera.transform, camera.position, new Cesium.Cartesian3());
		 *    var transform = Cesium.Matrix4.fromRotationTranslation(Cesium.Transforms.computeTemeToPseudoFixedMatrix(now));
		 *    var inverseTransform = Cesium.Matrix4.inverseTransformation(transform, new Cesium.Matrix4());
		 *    Cesium.Matrix4.multiplyByPoint(inverseTransform, offset, offset);
		 *    camera.lookAtTransform(transform, offset);
		 * });
		 */
		function computeTemeToPseudoFixedMatrix(date: JulianDate, result?: Matrix3): Matrix3;

		/**
		 * Preloads the data necessary to transform between the ICRF and Fixed axes, in either
		 * direction, over a given interval.  This function returns a promise that, when resolved,
		 * indicates that the preload has completed.
		 * @param {TimeInterval} timeInterval The interval to preload.
		 * @returns {Promise.<undefined>} A promise that, when resolved, indicates that the preload has completed
		 *          and evaluation of the transformation between the fixed and ICRF axes will
		 *          no longer return undefined for a time inside the interval.
		 * @example
		 * var interval = new Cesium.TimeInterval(...);
		 * when(Cesium.Transforms.preloadIcrfFixed(interval), function() {
		 *     // the data is now loaded
		 * });
		 * @see Transforms.computeIcrfToFixedMatrix
		 * @see Transforms.computeFixedToIcrfMatrix
		 * @see when
		 */
		function preloadIcrfFixed(timeInterval: TimeInterval): any;

		/**
		 * Computes a rotation matrix to transform a point or vector from the International Celestial
		 * Reference Frame (GCRF/ICRF) inertial frame axes to the Earth-Fixed frame axes (ITRF)
		 * at a given time.  This function may return undefined if the data necessary to
		 * do the transformation is not yet loaded.
		 * @param {JulianDate} date The time at which to compute the rotation matrix.
		 * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is
		 *                  not specified, a new instance is created and returned.
		 * @returns {Matrix3} The rotation matrix, or undefined if the data necessary to do the
		 *                   transformation is not yet loaded.
		 * @example
		 * scene.postUpdate.addEventListener(function(scene, time) {
		 *   var icrfToFixed = Cesium.Transforms.computeIcrfToFixedMatrix(time);
		 *   if (Cesium.defined(icrfToFixed)) {
		 *     var offset = Cesium.Matrix4.multiplyByPoint(camera.transform, camera.position, new Cesium.Cartesian3());
		 *     var transform = Cesium.Matrix4.fromRotationTranslation(icrfToFixed)
		 *     var inverseTransform = Cesium.Matrix4.inverseTransformation(transform, new Cesium.Matrix4());
		 *     Cesium.Matrix4.multiplyByPoint(inverseTransform, offset, offset);
		 *     camera.lookAtTransform(transform, offset);
		 *   }
		 * });
		 * @see Transforms.preloadIcrfFixed
		 */
		function computeIcrfToFixedMatrix(date: JulianDate, result?: Matrix3): Matrix3;

		/**
		 * Computes a rotation matrix to transform a point or vector from the Earth-Fixed frame axes (ITRF)
		 * to the International Celestial Reference Frame (GCRF/ICRF) inertial frame axes
		 * at a given time.  This function may return undefined if the data necessary to
		 * do the transformation is not yet loaded.
		 * @param {JulianDate} date The time at which to compute the rotation matrix.
		 * @param {Matrix3} [result] The object onto which to store the result.  If this parameter is
		 *                  not specified, a new instance is created and returned.
		 * @returns {Matrix3} The rotation matrix, or undefined if the data necessary to do the
		 *                   transformation is not yet loaded.
		 * @example
		 * // Transform a point from the ICRF axes to the Fixed axes.
		 * var now = Cesium.JulianDate.now();
		 * var pointInFixed = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
		 * var fixedToIcrf = Cesium.Transforms.computeIcrfToFixedMatrix(now);
		 * var pointInInertial = new Cesium.Cartesian3();
		 * if (Cesium.defined(fixedToIcrf)) {
		 *     pointInInertial = Cesium.Matrix3.multiplyByVector(fixedToIcrf, pointInFixed, pointInInertial);
		 * }
		 * @see Transforms.preloadIcrfFixed
		 */
		function computeFixedToIcrfMatrix(date: JulianDate, result?: Matrix3): Matrix3;

		/**
		 * Transform a point from model coordinates to window coordinates.
		 * @param {Matrix4} modelViewProjectionMatrix The 4x4 model-view-projection matrix.
		 * @param {Matrix4} viewportTransformation The 4x4 viewport transformation.
		 * @param {Cartesian3} point The point to transform.
		 * @param {Cartesian2} [result] The object onto which to store the result.
		 * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if none was provided.
		 */
		function pointToWindowCoordinates(modelViewProjectionMatrix: Matrix4, viewportTransformation: Matrix4, point: Cartesian3, result?: Cartesian2): Cartesian2;

	}

	/**
	 * An affine transformation defined by a translation, rotation, and scale.
	 * @alias TranslationRotationScale
	 * @constructor
	 * @param {Cartesian3} [translation=Cartesian3.ZERO] A {@link Cartesian3} specifying the (x, y, z) translation to apply to the node.
	 * @param {Quaternion} [rotation=Quaternion.IDENTITY] A {@link Quaternion} specifying the (x, y, z, w) rotation to apply to the node.
	 * @param {Cartesian3} [scale=new Cartesian3(1.0, 1.0, 1.0)] A {@link Cartesian3} specifying the (x, y, z) scaling to apply to the node.
	 */
	class TranslationRotationScale {
		constructor(translation?: Cartesian3, rotation?: Quaternion, scale?: Cartesian3);

		/**
		 * Gets or sets the (x, y, z) translation to apply to the node.
		 * @type {Cartesian3}
		 * @default Cartesian3.ZERO
		 */
		translation: Cartesian3;

		/**
		 * Gets or sets the (x, y, z, w) rotation to apply to the node.
		 * @type {Quaternion}
		 * @default Quaternion.IDENTITY
		 */
		rotation: Quaternion;

		/**
		 * Gets or sets the (x, y, z) scaling to apply to the node.
		 * @type {Cartesian3}
		 * @default new Cartesian3(1.0, 1.0, 1.0)
		 */
		scale: Cartesian3;

		/**
		 * Compares this instance against the provided instance and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {TranslationRotationScale} [right] The right hand side TranslationRotationScale.
		 * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.
		 */
		equals(right?: TranslationRotationScale): boolean;

	}

	/**
	 * Uses the Tridiagonal Matrix Algorithm, also known as the Thomas Algorithm, to solve
	 * a system of linear equations where the coefficient matrix is a tridiagonal matrix.
	 * @exports TridiagonalSystemSolver
	 */
	namespace TridiagonalSystemSolver {
		/**
		 * Solves a tridiagonal system of linear equations.
		 * @param {Number[]} diagonal An array with length <code>n</code> that contains the diagonal of the coefficient matrix.
		 * @param {Number[]} lower An array with length <code>n - 1</code> that contains the lower diagonal of the coefficient matrix.
		 * @param {Number[]} upper An array with length <code>n - 1</code> that contains the upper diagonal of the coefficient matrix.
		 * @param {Cartesian3[]} right An array of Cartesians with length <code>n</code> that is the right side of the system of equations.
		 * @exception {DeveloperError} diagonal and right must have the same lengths.
		 * @exception {DeveloperError} lower and upper must have the same lengths.
		 * @exception {DeveloperError} lower and upper must be one less than the length of diagonal.
		 * @performance Linear time.
		 * @example
		 * var lowerDiagonal = [1.0, 1.0, 1.0, 1.0];
		 * var diagonal = [2.0, 4.0, 4.0, 4.0, 2.0];
		 * var upperDiagonal = [1.0, 1.0, 1.0, 1.0];
		 * var rightHandSide = [
		 *     new Cesium.Cartesian3(410757.0, -1595711.0, 1375302.0),
		 *     new Cesium.Cartesian3(-5986705.0, -2190640.0, 1099600.0),
		 *     new Cesium.Cartesian3(-12593180.0, 288588.0, -1755549.0),
		 *     new Cesium.Cartesian3(-5349898.0, 2457005.0, -2685438.0),
		 *     new Cesium.Cartesian3(845820.0, 1573488.0, -1205591.0)
		 * ];
		 * var solution = Cesium.TridiagonalSystemSolver.solve(lowerDiagonal, diagonal, upperDiagonal, rightHandSide);
		 * @returns {Cartesian3[]} An array of Cartesians with length <code>n</code> that is the solution to the tridiagonal system of equations.
		 */
		function solve(diagonal: number[], lower: number[], upper: number[], right: (Cartesian3)[]): (Cartesian3)[];

	}

	/**
	 * A singleton that contains all of the servers that are trusted. Credentials will be sent with
	 * any requests to these servers.
	 * @exports TrustedServers
	 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
	 */
	namespace TrustedServers {
		/**
		 * Adds a trusted server to the registry
		 * @param {String} host The host to be added.
		 * @param {Number} port The port used to access the host.
		 * @example
		 * // Add a trusted server
		 * TrustedServers.add('my.server.com', 80);
		 */
		function add(host: string, port: number): void;

		/**
		 * Removes a trusted server from the registry
		 * @param {String} host The host to be removed.
		 * @param {Number} port The port used to access the host.
		 * @example
		 * // Remove a trusted server
		 * TrustedServers.remove('my.server.com', 80);
		 */
		function remove(host: string, port: number): void;

		/**
		 * Tests whether a server is trusted or not. The server must have been added with the port if it is included in the url.
		 * @param {String} url The url to be tested against the trusted list
		 * @returns {boolean} Returns true if url is trusted, false otherwise.
		 * @example
		 * // Add server
		 * TrustedServers.add('my.server.com', 81);
		 * // Check if server is trusted
		 * if (TrustedServers.contains('https://my.server.com:81/path/to/file.png')) {
		 *     // my.server.com:81 is trusted
		 * }
		 * if (TrustedServers.contains('https://my.server.com/path/to/file.png')) {
		 *     // my.server.com isn't trusted
		 * }
		 */
		function contains(url: string): boolean;

		/**
		 * Clears the registry
		 * @example
		 * // Remove a trusted server
		 * TrustedServers.clear();
		 */
		function clear(): void;

	}

	/**
	 * A vertex format defines what attributes make up a vertex.  A VertexFormat can be provided
	 * to a {@link Geometry} to request that certain properties be computed, e.g., just position,
	 * position and normal, etc.
	 * @param {Object} [options] An object with boolean properties corresponding to VertexFormat properties as shown in the code example.
	 * @alias VertexFormat
	 * @constructor
	 * @example
	 * // Create a vertex format with position and 2D texture coordinate attributes.
	 * var format = new Cesium.VertexFormat({
	 *   position : true,
	 *   st : true
	 * });
	 * @see Geometry#attributes
	 * @see Packable
	 */
	class VertexFormat {
		constructor(options?: any);

		/**
		 * When <code>true</code>, the vertex has a 3D position attribute.
		 * <p>
		 * 64-bit floating-point (for precision).  3 components per attribute.
		 * </p>
		 * @type Boolean
		 * @default false
		 */
		position: boolean;

		/**
		 * When <code>true</code>, the vertex has a normal attribute (normalized), which is commonly used for lighting.
		 * <p>
		 * 32-bit floating-point.  3 components per attribute.
		 * </p>
		 * @type Boolean
		 * @default false
		 */
		normal: boolean;

		/**
		 * When <code>true</code>, the vertex has a 2D texture coordinate attribute.
		 * <p>
		 * 32-bit floating-point.  2 components per attribute
		 * </p>
		 * @type Boolean
		 * @default false
		 */
		st: boolean;

		/**
		 * When <code>true</code>, the vertex has a bitangent attribute (normalized), which is used for tangent-space effects like bump mapping.
		 * <p>
		 * 32-bit floating-point.  3 components per attribute.
		 * </p>
		 * @type Boolean
		 * @default false
		 */
		bitangent: boolean;

		/**
		 * When <code>true</code>, the vertex has a tangent attribute (normalized), which is used for tangent-space effects like bump mapping.
		 * <p>
		 * 32-bit floating-point.  3 components per attribute.
		 * </p>
		 * @type Boolean
		 * @default false
		 */
		tangent: boolean;

		/**
		 * When <code>true</code>, the vertex has an RGB color attribute.
		 * <p>
		 * 8-bit unsigned byte.  3 components per attribute.
		 * </p>
		 * @type Boolean
		 * @default false
		 */
		color: boolean;

		/**
		 * An immutable vertex format with only a position attribute.
		 * @type {VertexFormat}
		 * @constant
		 * @see VertexFormat#position
		 */
		static POSITION_ONLY: VertexFormat;

		/**
		 * An immutable vertex format with position and normal attributes.
		 * This is compatible with per-instance color appearances like {@link PerInstanceColorAppearance}.
		 * @type {VertexFormat}
		 * @constant
		 * @see VertexFormat#position
		 * @see VertexFormat#normal
		 */
		static POSITION_AND_NORMAL: VertexFormat;

		/**
		 * An immutable vertex format with position, normal, and st attributes.
		 * This is compatible with {@link MaterialAppearance} when {@link MaterialAppearance#materialSupport}
		 * is <code>TEXTURED/code>.
		 * @type {VertexFormat}
		 * @constant
		 * @see VertexFormat#position
		 * @see VertexFormat#normal
		 * @see VertexFormat#st
		 */
		static POSITION_NORMAL_AND_ST: VertexFormat;

		/**
		 * An immutable vertex format with position and st attributes.
		 * This is compatible with {@link EllipsoidSurfaceAppearance}.
		 * @type {VertexFormat}
		 * @constant
		 * @see VertexFormat#position
		 * @see VertexFormat#st
		 */
		static POSITION_AND_ST: VertexFormat;

		/**
		 * An immutable vertex format with position and color attributes.
		 * @type {VertexFormat}
		 * @constant
		 * @see VertexFormat#position
		 * @see VertexFormat#color
		 */
		static POSITION_AND_COLOR: VertexFormat;

		/**
		 * An immutable vertex format with well-known attributes: position, normal, st, tangent, and bitangent.
		 * @type {VertexFormat}
		 * @constant
		 * @see VertexFormat#position
		 * @see VertexFormat#normal
		 * @see VertexFormat#st
		 * @see VertexFormat#tangent
		 * @see VertexFormat#bitangent
		 */
		static ALL: VertexFormat;

		/**
		 * An immutable vertex format with position, normal, and st attributes.
		 * This is compatible with most appearances and materials; however
		 * normal and st attributes are not always required.  When this is
		 * known in advance, another <code>VertexFormat</code> should be used.
		 * @type {VertexFormat}
		 * @constant
		 * @see VertexFormat#position
		 * @see VertexFormat#normal
		 */
		static DEFAULT: VertexFormat;

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		static packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {VertexFormat} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: VertexFormat, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {VertexFormat} [result] The object into which to store the result.
		 * @returns {VertexFormat} The modified result parameter or a new VertexFormat instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: VertexFormat): VertexFormat;

		/**
		 * Duplicates a VertexFormat instance.
		 * @param {VertexFormat} vertexFormat The vertex format to duplicate.
		 * @param {VertexFormat} [result] The object onto which to store the result.
		 * @returns {VertexFormat} The modified result parameter or a new VertexFormat instance if one was not provided. (Returns undefined if vertexFormat is undefined)
		 */
		static clone(vertexFormat: VertexFormat, result?: VertexFormat): VertexFormat;

	}

	/**
	 * Synchronizes a video element with a simulation clock.
	 * @alias VideoSynchronizer
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Clock} [options.clock] The clock instance used to drive the video.
	 * @param {HTMLVideoElement} [options.element] The video element to be synchronized.
	 * @param {JulianDate} [options.epoch=Iso8601.MINIMUM_VALUE] The simulation time that marks the start of the video.
	 * @param {Number} [options.tolerance=1.0] The maximum amount of time, in seconds, that the clock and video can diverge.
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Video.html|Video Material Demo}
	 */
	class VideoSynchronizer {
		constructor(options?: {
			clock?: Clock;
			element?: HTMLVideoElement;
			epoch?: JulianDate;
			tolerance?: number;
		});

		/**
		 * Gets or sets the simulation time that marks the start of the video.
		 * @type {JulianDate}
		 * @default Iso8601.MINIMUM_VALUE
		 */
		epoch: JulianDate;

		/**
		 * Gets or sets the amount of time in seconds the video's currentTime
		 * and the clock's currentTime can diverge before a video seek is performed.
		 * Lower values make the synchronization more accurate but video
		 * performance might suffer.  Higher values provide better performance
		 * but at the cost of accuracy.
		 * @type {Number}
		 * @default 1.0
		 */
		tolerance: number;

		/**
		 * Gets or sets the clock used to drive the video element.
		 * @memberof VideoSynchronizer.prototype
		 * @type {Clock}
		 */
		clock: Clock;

		/**
		 * Gets or sets the video element to synchronize.
		 * @memberof VideoSynchronizer.prototype
		 * @type {HTMLVideoElement}
		 */
		element: HTMLVideoElement;

		/**
		 * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 */
		destroy(): void;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * @returns {Boolean} True if this object was destroyed; otherwise, false.
		 */
		isDestroyed(): boolean;

	}

	/**
	 * A {@link TerrainProvider} that produces terrain geometry by tessellating height maps
	 * retrieved from a {@link http://vr-theworld.com/|VT MÄK VR-TheWorld server}.
	 * @alias VRTheWorldTerrainProvider
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Resource|String} options.url The URL of the VR-TheWorld TileMap.
	 * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid.  If this parameter is not
	 *                    specified, the WGS84 ellipsoid is used.
	 * @param {Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.
	 * @example
	 * var terrainProvider = new Cesium.VRTheWorldTerrainProvider({
	 *   url : 'https://www.vr-theworld.com/vr-theworld/tiles1.0.0/73/'
	 * });
	 * viewer.terrainProvider = terrainProvider;
	 * @see TerrainProvider
	 */
	class VRTheWorldTerrainProvider {
		constructor(options: {
			url: Resource | string;
			ellipsoid?: Ellipsoid;
			credit?: Credit | string;
		});

		/**
		 * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing
		 * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
		 * are passed an instance of {@link TileProviderError}.
		 * @memberof VRTheWorldTerrainProvider.prototype
		 * @type {Event}
		 */
		errorEvent: Event;

		/**
		 * Gets the credit to display when this terrain provider is active.  Typically this is used to credit
		 * the source of the terrain.  This function should not be called before {@link VRTheWorldTerrainProvider#ready} returns true.
		 * @memberof VRTheWorldTerrainProvider.prototype
		 * @type {Credit}
		 */
		credit: Credit;

		/**
		 * Gets the tiling scheme used by this provider.  This function should
		 * not be called before {@link VRTheWorldTerrainProvider#ready} returns true.
		 * @memberof VRTheWorldTerrainProvider.prototype
		 * @type {GeographicTilingScheme}
		 */
		tilingScheme: GeographicTilingScheme;

		/**
		 * Gets a value indicating whether or not the provider is ready for use.
		 * @memberof VRTheWorldTerrainProvider.prototype
		 * @type {Boolean}
		 */
		ready: boolean;

		/**
		 * Gets a promise that resolves to true when the provider is ready for use.
		 * @memberof VRTheWorldTerrainProvider.prototype
		 * @type {Promise.<Boolean>}
		 * @readonly
		 */
		readonly readyPromise: any;

		/**
		 * Gets a value indicating whether or not the provider includes a water mask.  The water mask
		 * indicates which areas of the globe are water rather than land, so they can be rendered
		 * as a reflective surface with animated waves.  This function should not be
		 * called before {@link VRTheWorldTerrainProvider#ready} returns true.
		 * @memberof VRTheWorldTerrainProvider.prototype
		 * @type {Boolean}
		 */
		hasWaterMask: boolean;

		/**
		 * Gets a value indicating whether or not the requested tiles include vertex normals.
		 * This function should not be called before {@link VRTheWorldTerrainProvider#ready} returns true.
		 * @memberof VRTheWorldTerrainProvider.prototype
		 * @type {Boolean}
		 */
		hasVertexNormals: boolean;

		/**
		 * Requests the geometry for a given tile.  This function should not be called before
		 * {@link VRTheWorldTerrainProvider#ready} returns true.  The result includes terrain
		 * data and indicates that all child tiles are available.
		 * @param {Number} x The X coordinate of the tile for which to request geometry.
		 * @param {Number} y The Y coordinate of the tile for which to request geometry.
		 * @param {Number} level The level of the tile for which to request geometry.
		 * @param {Request} [request] The request object. Intended for internal use only.
		 * @returns {Promise.<TerrainData>|undefined} A promise for the requested geometry.  If this method
		 *          returns undefined instead of a promise, it is an indication that too many requests are already
		 *          pending and the request will be retried later.
		 */
		requestTileGeometry(x: number, y: number, level: number, request?: Request): any | undefined;

		/**
		 * Gets the maximum geometric error allowed in a tile at a given level.
		 * @param {Number} level The tile level for which to get the maximum geometric error.
		 * @returns {Number} The maximum geometric error.
		 */
		getLevelMaximumGeometricError(level: number): number;

		/**
		 * Determines whether data for a tile is available to be loaded.
		 * @param {Number} x The X coordinate of the tile for which to request geometry.
		 * @param {Number} y The Y coordinate of the tile for which to request geometry.
		 * @param {Number} level The level of the tile for which to request geometry.
		 * @returns {Boolean} Undefined if not supported, otherwise true or false.
		 */
		getTileDataAvailable(x: number, y: number, level: number): boolean;

	}

	/**
	 * A description of a wall, which is similar to a KML line string. A wall is defined by a series of points,
	 * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.
	 * @alias WallGeometry
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.
	 * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
	 * @param {Number[]} [options.maximumHeights] An array parallel to <code>positions</code> that give the maximum height of the
	 *        wall at <code>positions</code>. If undefined, the height of each position in used.
	 * @param {Number[]} [options.minimumHeights] An array parallel to <code>positions</code> that give the minimum height of the
	 *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.
	 * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid for coordinate manipulation
	 * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
	 * @exception {DeveloperError} positions length must be greater than or equal to 2.
	 * @exception {DeveloperError} positions and maximumHeights must have the same length.
	 * @exception {DeveloperError} positions and minimumHeights must have the same length.
	 * @see WallGeometry#createGeometry
	 * @see WallGeometry#fromConstantHeight
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Wall.html|Cesium Sandcastle Wall Demo}
	 * @example
	 * // create a wall that spans from ground level to 10000 meters
	 * var wall = new Cesium.WallGeometry({
	 *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([
	 *     19.0, 47.0, 10000.0,
	 *     19.0, 48.0, 10000.0,
	 *     20.0, 48.0, 10000.0,
	 *     20.0, 47.0, 10000.0,
	 *     19.0, 47.0, 10000.0
	 *   ])
	 * });
	 * var geometry = Cesium.WallGeometry.createGeometry(wall);
	 */
	class WallGeometry {
		constructor(options: {
			positions: (Cartesian3)[];
			granularity?: number;
			maximumHeights?: number[];
			minimumHeights?: number[];
			ellipsoid?: Ellipsoid;
			vertexFormat?: VertexFormat;
		});

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {WallGeometry} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: WallGeometry, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {WallGeometry} [result] The object into which to store the result.
		 * @returns {WallGeometry} The modified result parameter or a new WallGeometry instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: WallGeometry): WallGeometry;

		/**
		 * A description of a wall, which is similar to a KML line string. A wall is defined by a series of points,
		 * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.
		 * @param {Object} options Object with the following properties:
		 * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.
		 * @param {Number} [options.maximumHeight] A constant that defines the maximum height of the
		 *        wall at <code>positions</code>. If undefined, the height of each position in used.
		 * @param {Number} [options.minimumHeight] A constant that defines the minimum height of the
		 *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.
		 * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid for coordinate manipulation
		 * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.
		 * @returns {WallGeometry}
		 * @example
		 * // create a wall that spans from 10000 meters to 20000 meters
		 * var wall = Cesium.WallGeometry.fromConstantHeights({
		 *   positions : Cesium.Cartesian3.fromDegreesArray([
		 *     19.0, 47.0,
		 *     19.0, 48.0,
		 *     20.0, 48.0,
		 *     20.0, 47.0,
		 *     19.0, 47.0,
		 *   ]),
		 *   minimumHeight : 20000.0,
		 *   maximumHeight : 10000.0
		 * });
		 * var geometry = Cesium.WallGeometry.createGeometry(wall);
		 * @see WallGeometry#createGeometry
		 */
		static fromConstantHeights(options: {
			positions: (Cartesian3)[];
			maximumHeight?: number;
			minimumHeight?: number;
			ellipsoid?: Ellipsoid;
			vertexFormat?: VertexFormat;
		}): WallGeometry;

		/**
		 * Computes the geometric representation of a wall, including its vertices, indices, and a bounding sphere.
		 * @param {WallGeometry} wallGeometry A description of the wall.
		 * @returns {Geometry|undefined} The computed vertices and indices.
		 */
		static createGeometry(wallGeometry: WallGeometry): Geometry | undefined;

	}

	/**
	 * A description of a wall outline. A wall is defined by a series of points,
	 * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.
	 * @alias WallOutlineGeometry
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.
	 * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
	 * @param {Number[]} [options.maximumHeights] An array parallel to <code>positions</code> that give the maximum height of the
	 *        wall at <code>positions</code>. If undefined, the height of each position in used.
	 * @param {Number[]} [options.minimumHeights] An array parallel to <code>positions</code> that give the minimum height of the
	 *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.
	 * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid for coordinate manipulation
	 * @exception {DeveloperError} positions length must be greater than or equal to 2.
	 * @exception {DeveloperError} positions and maximumHeights must have the same length.
	 * @exception {DeveloperError} positions and minimumHeights must have the same length.
	 * @see WallGeometry#createGeometry
	 * @see WallGeometry#fromConstantHeight
	 * @example
	 * // create a wall outline that spans from ground level to 10000 meters
	 * var wall = new Cesium.WallOutlineGeometry({
	 *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([
	 *     19.0, 47.0, 10000.0,
	 *     19.0, 48.0, 10000.0,
	 *     20.0, 48.0, 10000.0,
	 *     20.0, 47.0, 10000.0,
	 *     19.0, 47.0, 10000.0
	 *   ])
	 * });
	 * var geometry = Cesium.WallOutlineGeometry.createGeometry(wall);
	 */
	class WallOutlineGeometry {
		constructor(options: {
			positions: (Cartesian3)[];
			granularity?: number;
			maximumHeights?: number[];
			minimumHeights?: number[];
			ellipsoid?: Ellipsoid;
		});

		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {WallOutlineGeometry} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		static pack(value: WallOutlineGeometry, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {WallOutlineGeometry} [result] The object into which to store the result.
		 * @returns {WallOutlineGeometry} The modified result parameter or a new WallOutlineGeometry instance if one was not provided.
		 */
		static unpack(array: number[], startingIndex?: number, result?: WallOutlineGeometry): WallOutlineGeometry;

		/**
		 * A description of a walloutline. A wall is defined by a series of points,
		 * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.
		 * @param {Object} options Object with the following properties:
		 * @param {Cartesian3[]} options.positions An array of Cartesian objects, which are the points of the wall.
		 * @param {Number} [options.maximumHeight] A constant that defines the maximum height of the
		 *        wall at <code>positions</code>. If undefined, the height of each position in used.
		 * @param {Number} [options.minimumHeight] A constant that defines the minimum height of the
		 *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.
		 * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid for coordinate manipulation
		 * @returns {WallOutlineGeometry}
		 * @example
		 * // create a wall that spans from 10000 meters to 20000 meters
		 * var wall = Cesium.WallOutlineGeometry.fromConstantHeights({
		 *   positions : Cesium.Cartesian3.fromDegreesArray([
		 *     19.0, 47.0,
		 *     19.0, 48.0,
		 *     20.0, 48.0,
		 *     20.0, 47.0,
		 *     19.0, 47.0,
		 *   ]),
		 *   minimumHeight : 20000.0,
		 *   maximumHeight : 10000.0
		 * });
		 * var geometry = Cesium.WallOutlineGeometry.createGeometry(wall);
		 * @see WallOutlineGeometry#createGeometry
		 */
		static fromConstantHeights(options: {
			positions: (Cartesian3)[];
			maximumHeight?: number;
			minimumHeight?: number;
			ellipsoid?: Ellipsoid;
		}): WallOutlineGeometry;

		/**
		 * Computes the geometric representation of a wall outline, including its vertices, indices, and a bounding sphere.
		 * @param {WallOutlineGeometry} wallGeometry A description of the wall outline.
		 * @returns {Geometry|undefined} The computed vertices and indices.
		 */
		static createGeometry(wallGeometry: WallOutlineGeometry): Geometry | undefined;

	}

	/**
	 * Enum containing WebGL Constant values by name.
	 * for use without an active WebGL context, or in cases where certain constants are unavailable using the WebGL context
	 * (For example, in [Safari 9]{@link https://github.com/AnalyticalGraphicsInc/cesium/issues/2989}).
	 * These match the constants from the [WebGL 1.0]{@link https://www.khronos.org/registry/webgl/specs/latest/1.0/}
	 * and [WebGL 2.0]{@link https://www.khronos.org/registry/webgl/specs/latest/2.0/}
	 * specifications.
	 * @exports WebGLConstants
	 */
	namespace WebGLConstants {
	}

	/**
	 * The map projection used by Google Maps, Bing Maps, and most of ArcGIS Online, EPSG:3857.  This
	 * projection use longitude and latitude expressed with the WGS84 and transforms them to Mercator using
	 * the spherical (rather than ellipsoidal) equations.
	 * @alias WebMercatorProjection
	 * @constructor
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid.
	 * @see GeographicProjection
	 */
	class WebMercatorProjection {
		constructor(ellipsoid?: Ellipsoid);

		/**
		 * Gets the {@link Ellipsoid}.
		 * @memberof WebMercatorProjection.prototype
		 * @type {Ellipsoid}
		 * @readonly
		 */
		readonly ellipsoid: Ellipsoid;

		/**
		 * Converts a Mercator angle, in the range -PI to PI, to a geodetic latitude
		 * in the range -PI/2 to PI/2.
		 * @param {Number} mercatorAngle The angle to convert.
		 * @returns {Number} The geodetic latitude in radians.
		 */
		static mercatorAngleToGeodeticLatitude(mercatorAngle: number): number;

		/**
		 * Converts a geodetic latitude in radians, in the range -PI/2 to PI/2, to a Mercator
		 * angle in the range -PI to PI.
		 * @param {Number} latitude The geodetic latitude in radians.
		 * @returns {Number} The Mercator angle.
		 */
		static geodeticLatitudeToMercatorAngle(latitude: number): number;

		/**
		 * The maximum latitude (both North and South) supported by a Web Mercator
		 * (EPSG:3857) projection.  Technically, the Mercator projection is defined
		 * for any latitude up to (but not including) 90 degrees, but it makes sense
		 * to cut it off sooner because it grows exponentially with increasing latitude.
		 * The logic behind this particular cutoff value, which is the one used by
		 * Google Maps, Bing Maps, and Esri, is that it makes the projection
		 * square.  That is, the rectangle is equal in the X and Y directions.
		 * The constant value is computed by calling:
		 *    WebMercatorProjection.mercatorAngleToGeodeticLatitude(Math.PI)
		 * @type {Number}
		 */
		static MaximumLatitude: number;

		/**
		 * Converts geodetic ellipsoid coordinates, in radians, to the equivalent Web Mercator
		 * X, Y, Z coordinates expressed in meters and returned in a {@link Cartesian3}.  The height
		 * is copied unmodified to the Z coordinate.
		 * @param {Cartographic} cartographic The cartographic coordinates in radians.
		 * @param {Cartesian3} [result] The instance to which to copy the result, or undefined if a
		 *        new instance should be created.
		 * @returns {Cartesian3} The equivalent web mercator X, Y, Z coordinates, in meters.
		 */
		project(cartographic: Cartographic, result?: Cartesian3): Cartesian3;

		/**
		 * Converts Web Mercator X, Y coordinates, expressed in meters, to a {@link Cartographic}
		 * containing geodetic ellipsoid coordinates.  The Z coordinate is copied unmodified to the
		 * height.
		 * @param {Cartesian3} cartesian The web mercator Cartesian position to unrproject with height (z) in meters.
		 * @param {Cartographic} [result] The instance to which to copy the result, or undefined if a
		 *        new instance should be created.
		 * @returns {Cartographic} The equivalent cartographic coordinates.
		 */
		unproject(cartesian: Cartesian3, result?: Cartographic): Cartographic;

	}

	/**
	 * A tiling scheme for geometry referenced to a {@link WebMercatorProjection}, EPSG:3857.  This is
	 * the tiling scheme used by Google Maps, Microsoft Bing Maps, and most of ESRI ArcGIS Online.
	 * @alias WebMercatorTilingScheme
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid whose surface is being tiled. Defaults to
	 * the WGS84 ellipsoid.
	 * @param {Number} [options.numberOfLevelZeroTilesX=1] The number of tiles in the X direction at level zero of
	 *        the tile tree.
	 * @param {Number} [options.numberOfLevelZeroTilesY=1] The number of tiles in the Y direction at level zero of
	 *        the tile tree.
	 * @param {Cartesian2} [options.rectangleSouthwestInMeters] The southwest corner of the rectangle covered by the
	 *        tiling scheme, in meters.  If this parameter or rectangleNortheastInMeters is not specified, the entire
	 *        globe is covered in the longitude direction and an equal distance is covered in the latitude
	 *        direction, resulting in a square projection.
	 * @param {Cartesian2} [options.rectangleNortheastInMeters] The northeast corner of the rectangle covered by the
	 *        tiling scheme, in meters.  If this parameter or rectangleSouthwestInMeters is not specified, the entire
	 *        globe is covered in the longitude direction and an equal distance is covered in the latitude
	 *        direction, resulting in a square projection.
	 */
	class WebMercatorTilingScheme {
		constructor(options?: {
			ellipsoid?: Ellipsoid;
			numberOfLevelZeroTilesX?: number;
			numberOfLevelZeroTilesY?: number;
			rectangleSouthwestInMeters?: Cartesian2;
			rectangleNortheastInMeters?: Cartesian2;
		});

		/**
		 * Gets the ellipsoid that is tiled by this tiling scheme.
		 * @memberof WebMercatorTilingScheme.prototype
		 * @type {Ellipsoid}
		 */
		ellipsoid: Ellipsoid;

		/**
		 * Gets the rectangle, in radians, covered by this tiling scheme.
		 * @memberof WebMercatorTilingScheme.prototype
		 * @type {Rectangle}
		 */
		rectangle: Rectangle;

		/**
		 * Gets the map projection used by this tiling scheme.
		 * @memberof WebMercatorTilingScheme.prototype
		 * @type {MapProjection}
		 */
		projection: MapProjection;

		/**
		 * Gets the total number of tiles in the X direction at a specified level-of-detail.
		 * @param {Number} level The level-of-detail.
		 * @returns {Number} The number of tiles in the X direction at the given level.
		 */
		getNumberOfXTilesAtLevel(level: number): number;

		/**
		 * Gets the total number of tiles in the Y direction at a specified level-of-detail.
		 * @param {Number} level The level-of-detail.
		 * @returns {Number} The number of tiles in the Y direction at the given level.
		 */
		getNumberOfYTilesAtLevel(level: number): number;

		/**
		 * Transforms a rectangle specified in geodetic radians to the native coordinate system
		 * of this tiling scheme.
		 * @param {Rectangle} rectangle The rectangle to transform.
		 * @param {Rectangle} [result] The instance to which to copy the result, or undefined if a new instance
		 *        should be created.
		 * @returns {Rectangle} The specified 'result', or a new object containing the native rectangle if 'result'
		 *          is undefined.
		 */
		rectangleToNativeRectangle(rectangle: Rectangle, result?: Rectangle): Rectangle;

		/**
		 * Converts tile x, y coordinates and level to a rectangle expressed in the native coordinates
		 * of the tiling scheme.
		 * @param {Number} x The integer x coordinate of the tile.
		 * @param {Number} y The integer y coordinate of the tile.
		 * @param {Number} level The tile level-of-detail.  Zero is the least detailed.
		 * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance
		 *        should be created.
		 * @returns {Rectangle} The specified 'result', or a new object containing the rectangle
		 *          if 'result' is undefined.
		 */
		tileXYToNativeRectangle(x: number, y: number, level: number, result?: any): Rectangle;

		/**
		 * Converts tile x, y coordinates and level to a cartographic rectangle in radians.
		 * @param {Number} x The integer x coordinate of the tile.
		 * @param {Number} y The integer y coordinate of the tile.
		 * @param {Number} level The tile level-of-detail.  Zero is the least detailed.
		 * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance
		 *        should be created.
		 * @returns {Rectangle} The specified 'result', or a new object containing the rectangle
		 *          if 'result' is undefined.
		 */
		tileXYToRectangle(x: number, y: number, level: number, result?: any): Rectangle;

		/**
		 * Calculates the tile x, y coordinates of the tile containing
		 * a given cartographic position.
		 * @param {Cartographic} position The position.
		 * @param {Number} level The tile level-of-detail.  Zero is the least detailed.
		 * @param {Cartesian2} [result] The instance to which to copy the result, or undefined if a new instance
		 *        should be created.
		 * @returns {Cartesian2} The specified 'result', or a new object containing the tile x, y coordinates
		 *          if 'result' is undefined.
		 */
		positionToTileXY(position: Cartographic, level: number, result?: Cartesian2): Cartesian2;

	}

	/**
	 * A spline that linearly interpolates over an array of weight values used by morph targets.
	 * @alias WeightSpline
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Number[]} options.times An array of strictly increasing, unit-less, floating-point times at each point.
	 *                The values are in no way connected to the clock time. They are the parameterization for the curve.
	 * @param {Number[]} options.weights The array of floating-point control weights given. The weights are ordered such
	 *                that all weights for the targets are given in chronological order and order in which they appear in
	 *                the glTF from which the morph targets come. This means for 2 targets, weights = [w(0,0), w(0,1), w(1,0), w(1,1) ...]
	 *                where i and j in w(i,j) are the time indices and target indices, respectively.
	 * @exception {DeveloperError} weights.length must be greater than or equal to 2.
	 * @exception {DeveloperError} times.length must be a factor of weights.length.
	 * @example
	 * var times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];
	 * var weights = [0.0, 1.0, 0.25, 0.75, 0.5, 0.5, 0.75, 0.25, 1.0, 0.0]; //Two targets
	 * var spline = new Cesium.WeightSpline({
	 *     times : times,
	 *     weights : weights
	 * });
	 * var p0 = spline.evaluate(times[0]);
	 * @see LinearSpline
	 * @see HermiteSpline
	 * @see CatmullRomSpline
	 * @see QuaternionSpline
	 */
	class WeightSpline {
		constructor(options: {
			times: number[];
			weights: number[];
		});

		/**
		 * An array of times for the control weights.
		 * @memberof WeightSpline.prototype
		 * @type {Number[]}
		 * @readonly
		 */
		readonly times: number[];

		/**
		 * An array of floating-point array control weights.
		 * @memberof WeightSpline.prototype
		 * @type {Number[]}
		 * @readonly
		 */
		readonly weights: number[];

		/**
		 * Finds an index <code>i</code> in <code>times</code> such that the parameter
		 * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.
		 * @function
		 * @param {Number} time The time.
		 * @returns {Number} The index for the element at the start of the interval.
		 * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>
		 *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element
		 *                             in the array <code>times</code>.
		 */
		findTimeInterval(time: number): number;

		/**
		 * Wraps the given time to the period covered by the spline.
		 * @function
		 * @param {Number} time The time.
		 * @return {Number} The time, wrapped around to the updated animation.
		 */
		wrapTime(time: number): number;

		/**
		 * Clamps the given time to the period covered by the spline.
		 * @function
		 * @param {Number} time The time.
		 * @return {Number} The time, clamped to the animation period.
		 */
		clampTime(time: number): number;

		/**
		 * Evaluates the curve at a given time.
		 * @param {Number} time The time at which to evaluate the curve.
		 * @param {Number[]} [result] The object onto which to store the result.
		 * @returns {Number[]} The modified result parameter or a new instance of the point on the curve at the given time.
		 * @exception {DeveloperError} time must be in the range <code>[t<sub>0</sub>, t<sub>n</sub>]</code>, where <code>t<sub>0</sub></code>
		 *                             is the first element in the array <code>times</code> and <code>t<sub>n</sub></code> is the last element
		 *                             in the array <code>times</code>.
		 */
		evaluate(time: number, result?: number[]): number[];

	}

	/**
	 * Describes a two dimensional icon located at the position of the containing {@link Entity}.
	 * <p>
	 * <div align='center'>
	 * <img src='Images/Billboard.png' width='400' height='300' /><br />
	 * Example billboards
	 * </div>
	 * </p>
	 * @alias BillboardGraphics
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Property} [options.image] A Property specifying the Image, URI, or Canvas to use for the billboard.
	 * @param {Property} [options.show=true] A boolean Property specifying the visibility of the billboard.
	 * @param {Property} [options.scale=1.0] A numeric Property specifying the scale to apply to the image size.
	 * @param {Property} [options.horizontalOrigin=HorizontalOrigin.CENTER] A Property specifying the {@link HorizontalOrigin}.
	 * @param {Property} [options.verticalOrigin=VerticalOrigin.CENTER] A Property specifying the {@link VerticalOrigin}.
	 * @param {Property} [options.eyeOffset=Cartesian3.ZERO] A {@link Cartesian3} Property specifying the eye offset.
	 * @param {Property} [options.pixelOffset=Cartesian2.ZERO] A {@link Cartesian2} Property specifying the pixel offset.
	 * @param {Property} [options.rotation=0] A numeric Property specifying the rotation about the alignedAxis.
	 * @param {Property} [options.alignedAxis=Cartesian3.ZERO] A {@link Cartesian3} Property specifying the unit vector axis of rotation.
	 * @param {Property} [options.width] A numeric Property specifying the width of the billboard in pixels, overriding the native size.
	 * @param {Property} [options.height] A numeric Property specifying the height of the billboard in pixels, overriding the native size.
	 * @param {Property} [options.color=Color.WHITE] A Property specifying the tint {@link Color} of the image.
	 * @param {Property} [options.scaleByDistance] A {@link NearFarScalar} Property used to scale the point based on distance from the camera.
	 * @param {Property} [options.translucencyByDistance] A {@link NearFarScalar} Property used to set translucency based on distance from the camera.
	 * @param {Property} [options.pixelOffsetScaleByDistance] A {@link NearFarScalar} Property used to set pixelOffset based on distance from the camera.
	 * @param {Property} [options.imageSubRegion] A Property specifying a {@link BoundingRectangle} that defines a sub-region of the image to use for the billboard, rather than the entire image, measured in pixels from the bottom-left.
	 * @param {Property} [options.sizeInMeters] A boolean Property specifying whether this billboard's size should be measured in meters.
	 * @param {Property} [options.heightReference=HeightReference.NONE] A Property specifying what the height is relative to.
	 * @param {Property} [options.distanceDisplayCondition] A Property specifying at what distance from the camera that this billboard will be displayed.
	 * @param {Property} [options.disableDepthTestDistance] A Property specifying the distance from the camera at which to disable the depth test to.
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Billboards.html|Cesium Sandcastle Billboard Demo}
	 */
	class BillboardGraphics {
		constructor(options?: {
			image?: Property;
			show?: Property;
			scale?: Property;
			horizontalOrigin?: Property;
			verticalOrigin?: Property;
			eyeOffset?: Property;
			pixelOffset?: Property;
			rotation?: Property;
			alignedAxis?: Property;
			width?: Property;
			height?: Property;
			color?: Property;
			scaleByDistance?: Property;
			translucencyByDistance?: Property;
			pixelOffsetScaleByDistance?: Property;
			imageSubRegion?: Property;
			sizeInMeters?: Property;
			heightReference?: Property;
			distanceDisplayCondition?: Property;
			disableDepthTestDistance?: Property;
		});

		/**
		 * Gets the event that is raised whenever a property or sub-property is changed or modified.
		 * @memberof BillboardGraphics.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets or sets the Property specifying the Image, URI, or Canvas to use for the billboard.
		 * @memberof BillboardGraphics.prototype
		 * @type {Property}
		 */
		image: Property;

		/**
		 * Gets or sets the Property specifying a {@link BoundingRectangle} that defines a
		 * sub-region of the <code>image</code> to use for the billboard, rather than the entire image,
		 * measured in pixels from the bottom-left.
		 * @memberof BillboardGraphics.prototype
		 * @type {Property}
		 */
		imageSubRegion: Property;

		/**
		 * Gets or sets the numeric Property specifying the uniform scale to apply to the image.
		 * A scale greater than <code>1.0</code> enlarges the billboard while a scale less than <code>1.0</code> shrinks it.
		 * <p>
		 * <div align='center'>
		 * <img src='Images/Billboard.setScale.png' width='400' height='300' /><br/>
		 * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>, and <code>2.0</code>.
		 * </div>
		 * </p>
		 * @memberof BillboardGraphics.prototype
		 * @type {Property}
		 * @default 1.0
		 */
		scale: Property;

		/**
		 * Gets or sets the numeric Property specifying the rotation of the image
		 * counter clockwise from the <code>alignedAxis</code>.
		 * @memberof BillboardGraphics.prototype
		 * @type {Property}
		 * @default 0
		 */
		rotation: Property;

		/**
		 * Gets or sets the {@link Cartesian3} Property specifying the unit vector axis of rotation
		 * in the fixed frame. When set to Cartesian3.ZERO the rotation is from the top of the screen.
		 * @memberof BillboardGraphics.prototype
		 * @type {Property}
		 * @default Cartesian3.ZERO
		 */
		alignedAxis: Property;

		/**
		 * Gets or sets the Property specifying the {@link HorizontalOrigin}.
		 * @memberof BillboardGraphics.prototype
		 * @type {Property}
		 * @default HorizontalOrigin.CENTER
		 */
		horizontalOrigin: Property;

		/**
		 * Gets or sets the Property specifying the {@link VerticalOrigin}.
		 * @memberof BillboardGraphics.prototype
		 * @type {Property}
		 * @default VerticalOrigin.CENTER
		 */
		verticalOrigin: Property;

		/**
		 * Gets or sets the Property specifying the {@link Color} that is multiplied with the <code>image</code>.
		 * This has two common use cases.  First, the same white texture may be used by many different billboards,
		 * each with a different color, to create colored billboards. Second, the color's alpha component can be
		 * used to make the billboard translucent as shown below. An alpha of <code>0.0</code> makes the billboard
		 * transparent, and <code>1.0</code> makes the billboard opaque.
		 * <p>
		 * <div align='center'>
		 * <table border='0' cellpadding='5'><tr>
		 * <td align='center'><code>default</code><br/><img src='Images/Billboard.setColor.Alpha255.png' width='250' height='188' /></td>
		 * <td align='center'><code>alpha : 0.5</code><br/><img src='Images/Billboard.setColor.Alpha127.png' width='250' height='188' /></td>
		 * </tr></table>
		 * </div>
		 * </p>
		 * @memberof BillboardGraphics.prototype
		 * @type {Property}
		 * @default Color.WHITE
		 */
		color: Property;

		/**
		 * Gets or sets the {@link Cartesian3} Property specifying the billboard's offset in eye coordinates.
		 * Eye coordinates is a left-handed coordinate system, where <code>x</code> points towards the viewer's
		 * right, <code>y</code> points up, and <code>z</code> points into the screen.
		 * <p>
		 * An eye offset is commonly used to arrange multiple billboards or objects at the same position, e.g., to
		 * arrange a billboard above its corresponding 3D model.
		 * </p>
		 * Below, the billboard is positioned at the center of the Earth but an eye offset makes it always
		 * appear on top of the Earth regardless of the viewer's or Earth's orientation.
		 * <p>
		 * <div align='center'>
		 * <table border='0' cellpadding='5'><tr>
		 * <td align='center'><img src='Images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>
		 * <td align='center'><img src='Images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>
		 * </tr></table>
		 * <code>b.eyeOffset = new Cartesian3(0.0, 8000000.0, 0.0);</code>
		 * </div>
		 * </p>
		 * @memberof BillboardGraphics.prototype
		 * @type {Property}
		 * @default Cartesian3.ZERO
		 */
		eyeOffset: Property;

		/**
		 * Gets or sets the Property specifying the {@link HeightReference}.
		 * @memberof BillboardGraphics.prototype
		 * @type {Property}
		 * @default HeightReference.NONE
		 */
		heightReference: Property;

		/**
		 * Gets or sets the {@link Cartesian2} Property specifying the billboard's pixel offset in screen space
		 * from the origin of this billboard.  This is commonly used to align multiple billboards and labels at
		 * the same position, e.g., an image and text.  The screen space origin is the top, left corner of the
		 * canvas; <code>x</code> increases from left to right, and <code>y</code> increases from top to bottom.
		 * <p>
		 * <div align='center'>
		 * <table border='0' cellpadding='5'><tr>
		 * <td align='center'><code>default</code><br/><img src='Images/Billboard.setPixelOffset.default.png' width='250' height='188' /></td>
		 * <td align='center'><code>b.pixeloffset = new Cartesian2(50, 25);</code><br/><img src='Images/Billboard.setPixelOffset.x50y-25.png' width='250' height='188' /></td>
		 * </tr></table>
		 * The billboard's origin is indicated by the yellow point.
		 * </div>
		 * </p>
		 * @memberof BillboardGraphics.prototype
		 * @type {Property}
		 * @default Cartesian2.ZERO
		 */
		pixelOffset: Property;

		/**
		 * Gets or sets the boolean Property specifying the visibility of the billboard.
		 * @memberof BillboardGraphics.prototype
		 * @type {Property}
		 * @default true
		 */
		show: Property;

		/**
		 * Gets or sets the numeric Property specifying the billboard's width in pixels.
		 * When undefined, the native width is used.
		 * @memberof BillboardGraphics.prototype
		 * @type {Property}
		 */
		width: Property;

		/**
		 * Gets or sets the numeric Property specifying the height of the billboard in pixels.
		 * When undefined, the native height is used.
		 * @memberof BillboardGraphics.prototype
		 * @type {Property}
		 */
		height: Property;

		/**
		 * Gets or sets {@link NearFarScalar} Property specifying the scale of the billboard based on the distance from the camera.
		 * A billboard's scale will interpolate between the {@link NearFarScalar#nearValue} and
		 * {@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
		 * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
		 * Outside of these ranges the billboard's scale remains clamped to the nearest bound.
		 * @memberof BillboardGraphics.prototype
		 * @type {Property}
		 */
		scaleByDistance: Property;

		/**
		 * Gets or sets {@link NearFarScalar} Property specifying the translucency of the billboard based on the distance from the camera.
		 * A billboard's translucency will interpolate between the {@link NearFarScalar#nearValue} and
		 * {@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
		 * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
		 * Outside of these ranges the billboard's translucency remains clamped to the nearest bound.
		 * @memberof BillboardGraphics.prototype
		 * @type {Property}
		 */
		translucencyByDistance: Property;

		/**
		 * Gets or sets {@link NearFarScalar} Property specifying the pixel offset of the billboard based on the distance from the camera.
		 * A billboard's pixel offset will interpolate between the {@link NearFarScalar#nearValue} and
		 * {@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
		 * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
		 * Outside of these ranges the billboard's pixel offset remains clamped to the nearest bound.
		 * @memberof BillboardGraphics.prototype
		 * @type {Property}
		 */
		pixelOffsetScaleByDistance: Property;

		/**
		 * Gets or sets the boolean Property specifying if this billboard's size will be measured in meters.
		 * @memberof BillboardGraphics.prototype
		 * @type {Property}
		 * @default false
		 */
		sizeInMeters: Property;

		/**
		 * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this billboard will be displayed.
		 * @memberof BillboardGraphics.prototype
		 * @type {Property}
		 */
		distanceDisplayCondition: Property;

		/**
		 * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.
		 * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.
		 * @memberof BillboardGraphics.prototype
		 * @type {Property}
		 */
		disableDepthTestDistance: Property;

		/**
		 * Duplicates this instance.
		 * @param {BillboardGraphics} [result] The object onto which to store the result.
		 * @returns {BillboardGraphics} The modified result parameter or a new instance if one was not provided.
		 */
		clone(result?: BillboardGraphics): BillboardGraphics;

		/**
		 * Assigns each unassigned property on this object to the value
		 * of the same property on the provided source object.
		 * @param {BillboardGraphics} source The object to be merged into this object.
		 */
		merge(source: BillboardGraphics): void;

	}

	/**
	 * A {@link Visualizer} which maps {@link Entity#billboard} to a {@link Billboard}.
	 * @alias BillboardVisualizer
	 * @constructor
	 * @param {EntityCluster} entityCluster The entity cluster to manage the collection of billboards and optionally cluster with other entities.
	 * @param {EntityCollection} entityCollection The entityCollection to visualize.
	 */
	class BillboardVisualizer {
		constructor(entityCluster: EntityCluster, entityCollection: EntityCollection);

		/**
		 * Updates the primitives created by this visualizer to match their
		 * Entity counterpart at the given time.
		 * @param {JulianDate} time The time to update to.
		 * @returns {Boolean} This function always returns true.
		 */
		update(time: JulianDate): boolean;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * @returns {Boolean} True if this object was destroyed; otherwise, false.
		 */
		isDestroyed(): boolean;

		/**
		 * Removes and destroys all primitives created by this instance.
		 */
		destroy(): void;

	}

	/**
	 * A {@link GeometryUpdater} for boxes.
	 * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
	 * @alias BoxGeometryUpdater
	 * @constructor
	 * @param {Entity} entity The entity containing the geometry to be visualized.
	 * @param {Scene} scene The scene where visualization is taking place.
	 */
	class BoxGeometryUpdater {
		constructor(entity: Entity, scene: Scene);

		/**
		 * Gets the terrain offset property
		 * @type {TerrainOffsetProperty}
		 * @memberof BoxGeometryUpdater.prototype
		 * @readonly
		 */
		readonly terrainOffsetProperty: any;

		/**
		 * Creates the geometry instance which represents the fill of the geometry.
		 * @param {JulianDate} time The time to use when retrieving initial attribute values.
		 * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.
		 * @exception {DeveloperError} This instance does not represent a filled geometry.
		 */
		createFillGeometryInstance(time: JulianDate): GeometryInstance;

		/**
		 * Creates the geometry instance which represents the outline of the geometry.
		 * @param {JulianDate} time The time to use when retrieving initial attribute values.
		 * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.
		 * @exception {DeveloperError} This instance does not represent an outlined geometry.
		 */
		createOutlineGeometryInstance(time: JulianDate): GeometryInstance;

	}

	/**
	 * Describes a box. The center position and orientation are determined by the containing {@link Entity}.
	 * @alias BoxGraphics
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Property} [options.heightReference] A Property specifying what the height from the entity position is relative to.
	 * @param {Property} [options.dimensions] A {@link Cartesian3} Property specifying the length, width, and height of the box.
	 * @param {Property} [options.show=true] A boolean Property specifying the visibility of the box.
	 * @param {Property} [options.fill=true] A boolean Property specifying whether the box is filled with the provided material.
	 * @param {MaterialProperty} [options.material=Color.WHITE] A Property specifying the material used to fill the box.
	 * @param {Property} [options.outline=false] A boolean Property specifying whether the box is outlined.
	 * @param {Property} [options.outlineColor=Color.BLACK] A Property specifying the {@link Color} of the outline.
	 * @param {Property} [options.outlineWidth=1.0] A numeric Property specifying the width of the outline.
	 * @param {Property} [options.shadows=ShadowMode.DISABLED] An enum Property specifying whether the box casts or receives shadows from each light source.
	 * @param {Property} [options.distanceDisplayCondition] A Property specifying at what distance from the camera that this box will be displayed.
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Box.html|Cesium Sandcastle Box Demo}
	 */
	class BoxGraphics {
		constructor(options?: {
			heightReference?: Property;
			dimensions?: Property;
			show?: Property;
			fill?: Property;
			material?: MaterialProperty;
			outline?: Property;
			outlineColor?: Property;
			outlineWidth?: Property;
			shadows?: Property;
			distanceDisplayCondition?: Property;
		});

		/**
		 * Gets the event that is raised whenever a property or sub-property is changed or modified.
		 * @memberof BoxGraphics.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets or sets the Property specifying the {@link HeightReference}.
		 * @memberof BoxGraphics.prototype
		 * @type {Property}
		 * @default HeightReference.NONE
		 */
		heightReference: Property;

		/**
		 * Gets or sets the boolean Property specifying the visibility of the box.
		 * @memberof BoxGraphics.prototype
		 * @type {Property}
		 * @default true
		 */
		show: Property;

		/**
		 * Gets or sets {@link Cartesian3} Property property specifying the length, width, and height of the box.
		 * @memberof BoxGraphics.prototype
		 * @type {Property}
		 */
		dimensions: Property;

		/**
		 * Gets or sets the material used to fill the box.
		 * @memberof BoxGraphics.prototype
		 * @type {MaterialProperty}
		 * @default Color.WHITE
		 */
		material: MaterialProperty;

		/**
		 * Gets or sets the boolean Property specifying whether the box is filled with the provided material.
		 * @memberof BoxGraphics.prototype
		 * @type {Property}
		 * @default true
		 */
		fill: Property;

		/**
		 * Gets or sets the Property specifying whether the box is outlined.
		 * @memberof BoxGraphics.prototype
		 * @type {Property}
		 * @default false
		 */
		outline: Property;

		/**
		 * Gets or sets the Property specifying the {@link Color} of the outline.
		 * @memberof BoxGraphics.prototype
		 * @type {Property}
		 * @default Color.BLACK
		 */
		outlineColor: Property;

		/**
		 * Gets or sets the numeric Property specifying the width of the outline.
		 * @memberof BoxGraphics.prototype
		 * @type {Property}
		 * @default 1.0
		 */
		outlineWidth: Property;

		/**
		 * Get or sets the enum Property specifying whether the box
		 * casts or receives shadows from each light source.
		 * @memberof BoxGraphics.prototype
		 * @type {Property}
		 * @default ShadowMode.DISABLED
		 */
		shadows: Property;

		/**
		 * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this box will be displayed.
		 * @memberof BoxGraphics.prototype
		 * @type {Property}
		 */
		distanceDisplayCondition: Property;

		/**
		 * Duplicates this instance.
		 * @param {BoxGraphics} [result] The object onto which to store the result.
		 * @returns {BoxGraphics} The modified result parameter or a new instance if one was not provided.
		 */
		clone(result?: BoxGraphics): BoxGraphics;

		/**
		 * Assigns each unassigned property on this object to the value
		 * of the same property on the provided source object.
		 * @param {BoxGraphics} source The object to be merged into this object.
		 */
		merge(source: BoxGraphics): void;

	}

	/**
	 * A {@link Property} whose value is lazily evaluated by a callback function.
	 * @alias FunctionProperty
	 * @constructor
	 * @param {Function} callback The function to be called when the property is evaluated.
	 * @param {Boolean} isConstant <code>true</code> when the callback function returns the same value every time, <code>false</code> if the value will change.
	 */
	class FunctionProperty {
		constructor(callback: Function, isConstant: boolean);

		/**
		 * Gets a value indicating if this property is constant.
		 * @memberof FunctionProperty.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isConstant: boolean;

		/**
		 * Gets the event that is raised whenever the definition of this property changes.
		 * The definition is changed whenever setFunction is called.
		 * @memberof FunctionProperty.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets the value of the property.
		 * @param {JulianDate} [time] The time for which to retrieve the value.  This parameter is unused since the value does not change with respect to time.
		 * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied or is unsupported.
		 */
		getValue(time?: JulianDate, result?: any): any;

		/**
		 * Sets the callback to be used.
		 * @param {Function} callback The function to be called when the property is evaluated.
		 * @param {Boolean} isConstant <code>true</code> when the callback function returns the same value every time, <code>false</code> if the value will change.
		 */
		setFunction(callback: Function, isConstant: boolean): void;

		/**
		 * Compares this property to the provided property and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Property} [other] The other property.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		equals(other?: Property): boolean;

	}

	/**
	 * A {@link MaterialProperty} that maps to checkerboard {@link Material} uniforms.
	 * @alias CheckerboardMaterialProperty
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Property} [options.evenColor=Color.WHITE] A Property specifying the first {@link Color}.
	 * @param {Property} [options.oddColor=Color.BLACK] A Property specifying the second {@link Color}.
	 * @param {Property} [options.repeat=new Cartesian2(2.0, 2.0)] A {@link Cartesian2} Property specifying how many times the tiles repeat in each direction.
	 */
	class CheckerboardMaterialProperty {
		constructor(options?: {
			evenColor?: Property;
			oddColor?: Property;
			repeat?: Property;
		});

		/**
		 * Gets a value indicating if this property is constant.  A property is considered
		 * constant if getValue always returns the same result for the current definition.
		 * @memberof CheckerboardMaterialProperty.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isConstant: boolean;

		/**
		 * Gets the event that is raised whenever the definition of this property changes.
		 * The definition is considered to have changed if a call to getValue would return
		 * a different result for the same time.
		 * @memberof CheckerboardMaterialProperty.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets or sets the Property specifying the first {@link Color}.
		 * @memberof CheckerboardMaterialProperty.prototype
		 * @type {Property}
		 * @default Color.WHITE
		 */
		evenColor: Property;

		/**
		 * Gets or sets the Property specifying the second {@link Color}.
		 * @memberof CheckerboardMaterialProperty.prototype
		 * @type {Property}
		 * @default Color.BLACK
		 */
		oddColor: Property;

		/**
		 * Gets or sets the {@link Cartesian2} Property specifying how many times the tiles repeat in each direction.
		 * @memberof CheckerboardMaterialProperty.prototype
		 * @type {Property}
		 * @default new Cartesian2(2.0, 2.0)
		 */
		repeat: Property;

		/**
		 * Gets the {@link Material} type at the provided time.
		 * @param {JulianDate} time The time for which to retrieve the type.
		 * @returns {String} The type of material.
		 */
		getType(time: JulianDate): string;

		/**
		 * Gets the value of the property at the provided time.
		 * @param {JulianDate} time The time for which to retrieve the value.
		 * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValue(time: JulianDate, result?: any): any;

		/**
		 * Compares this property to the provided property and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Property} [other] The other property.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		equals(other?: Property): boolean;

	}

	/**
	 * A {@link MaterialProperty} that maps to solid color {@link Material} uniforms.
	 * @param {Property} [color=Color.WHITE] The {@link Color} Property to be used.
	 * @alias ColorMaterialProperty
	 * @constructor
	 */
	class ColorMaterialProperty {
		constructor(color?: Property);

		/**
		 * Gets a value indicating if this property is constant.  A property is considered
		 * constant if getValue always returns the same result for the current definition.
		 * @memberof ColorMaterialProperty.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isConstant: boolean;

		/**
		 * Gets the event that is raised whenever the definition of this property changes.
		 * The definition is considered to have changed if a call to getValue would return
		 * a different result for the same time.
		 * @memberof ColorMaterialProperty.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets or sets the {@link Color} {@link Property}.
		 * @memberof ColorMaterialProperty.prototype
		 * @type {Property}
		 * @default Color.WHITE
		 */
		color: Property;

		/**
		 * Gets the {@link Material} type at the provided time.
		 * @param {JulianDate} time The time for which to retrieve the type.
		 * @returns {String} The type of material.
		 */
		getType(time: JulianDate): string;

		/**
		 * Gets the value of the property at the provided time.
		 * @param {JulianDate} time The time for which to retrieve the value.
		 * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValue(time: JulianDate, result?: any): any;

		/**
		 * Compares this property to the provided property and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Property} [other] The other property.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		equals(other?: Property): boolean;

	}

	/**
	 * Non-destructively composites multiple {@link EntityCollection} instances into a single collection.
	 * If a Entity with the same ID exists in multiple collections, it is non-destructively
	 * merged into a single new entity instance.  If an entity has the same property in multiple
	 * collections, the property of the Entity in the last collection of the list it
	 * belongs to is used.  CompositeEntityCollection can be used almost anywhere that a
	 * EntityCollection is used.
	 * @alias CompositeEntityCollection
	 * @constructor
	 * @param {EntityCollection[]} [collections] The initial list of EntityCollection instances to merge.
	 * @param {DataSource|CompositeEntityCollection} [owner] The data source (or composite entity collection) which created this collection.
	 */
	class CompositeEntityCollection {
		constructor(collections?: (EntityCollection)[], owner?: DataSource | CompositeEntityCollection);

		/**
		 * Gets the event that is fired when entities are added or removed from the collection.
		 * The generated event is a {@link EntityCollection.collectionChangedEventFunction}.
		 * @memberof CompositeEntityCollection.prototype
		 * @readonly
		 * @type {Event}
		 */
		readonly collectionChanged: Event;

		/**
		 * Gets a globally unique identifier for this collection.
		 * @memberof CompositeEntityCollection.prototype
		 * @readonly
		 * @type {String}
		 */
		readonly id: string;

		/**
		 * Gets the array of Entity instances in the collection.
		 * This array should not be modified directly.
		 * @memberof CompositeEntityCollection.prototype
		 * @readonly
		 * @type {Entity[]}
		 */
		readonly values: Entity[];

		/**
		 * Gets the owner of this composite entity collection, ie. the data source or composite entity collection which created it.
		 * @memberof CompositeEntityCollection.prototype
		 * @readonly
		 * @type {DataSource|CompositeEntityCollection}
		 */
		readonly owner: DataSource | CompositeEntityCollection;

		/**
		 * Adds a collection to the composite.
		 * @param {EntityCollection} collection the collection to add.
		 * @param {Number} [index] the index to add the collection at.  If omitted, the collection will
		 *                         added on top of all existing collections.
		 * @exception {DeveloperError} index, if supplied, must be greater than or equal to zero and less than or equal to the number of collections.
		 */
		addCollection(collection: EntityCollection, index?: number): void;

		/**
		 * Removes a collection from this composite, if present.
		 * @param {EntityCollection} collection The collection to remove.
		 * @returns {Boolean} true if the collection was in the composite and was removed,
		 *                    false if the collection was not in the composite.
		 */
		removeCollection(collection: EntityCollection): boolean;

		/**
		 * Removes all collections from this composite.
		 */
		removeAllCollections(): void;

		/**
		 * Checks to see if the composite contains a given collection.
		 * @param {EntityCollection} collection the collection to check for.
		 * @returns {Boolean} true if the composite contains the collection, false otherwise.
		 */
		containsCollection(collection: EntityCollection): boolean;

		/**
		 * Returns true if the provided entity is in this collection, false otherwise.
		 * @param {Entity} entity The entity.
		 * @returns {Boolean} true if the provided entity is in this collection, false otherwise.
		 */
		contains(entity: Entity): boolean;

		/**
		 * Determines the index of a given collection in the composite.
		 * @param {EntityCollection} collection The collection to find the index of.
		 * @returns {Number} The index of the collection in the composite, or -1 if the collection does not exist in the composite.
		 */
		indexOfCollection(collection: EntityCollection): number;

		/**
		 * Gets a collection by index from the composite.
		 * @param {Number} index the index to retrieve.
		 */
		getCollection(index: number): void;

		/**
		 * Gets the number of collections in this composite.
		 */
		getCollectionsLength(): void;

		/**
		 * Raises a collection up one position in the composite.
		 * @param {EntityCollection} collection the collection to move.
		 * @exception {DeveloperError} collection is not in this composite.
		 */
		raiseCollection(collection: EntityCollection): void;

		/**
		 * Lowers a collection down one position in the composite.
		 * @param {EntityCollection} collection the collection to move.
		 * @exception {DeveloperError} collection is not in this composite.
		 */
		lowerCollection(collection: EntityCollection): void;

		/**
		 * Raises a collection to the top of the composite.
		 * @param {EntityCollection} collection the collection to move.
		 * @exception {DeveloperError} collection is not in this composite.
		 */
		raiseCollectionToTop(collection: EntityCollection): void;

		/**
		 * Lowers a collection to the bottom of the composite.
		 * @param {EntityCollection} collection the collection to move.
		 * @exception {DeveloperError} collection is not in this composite.
		 */
		lowerCollectionToBottom(collection: EntityCollection): void;

		/**
		 * Prevents {@link EntityCollection#collectionChanged} events from being raised
		 * until a corresponding call is made to {@link EntityCollection#resumeEvents}, at which
		 * point a single event will be raised that covers all suspended operations.
		 * This allows for many items to be added and removed efficiently.
		 * While events are suspended, recompositing of the collections will
		 * also be suspended, as this can be a costly operation.
		 * This function can be safely called multiple times as long as there
		 * are corresponding calls to {@link EntityCollection#resumeEvents}.
		 */
		suspendEvents(): void;

		/**
		 * Resumes raising {@link EntityCollection#collectionChanged} events immediately
		 * when an item is added or removed.  Any modifications made while while events were suspended
		 * will be triggered as a single event when this function is called.  This function also ensures
		 * the collection is recomposited if events are also resumed.
		 * This function is reference counted and can safely be called multiple times as long as there
		 * are corresponding calls to {@link EntityCollection#resumeEvents}.
		 * @exception {DeveloperError} resumeEvents can not be called before suspendEvents.
		 */
		resumeEvents(): void;

		/**
		 * Computes the maximum availability of the entities in the collection.
		 * If the collection contains a mix of infinitely available data and non-infinite data,
		 * It will return the interval pertaining to the non-infinite data only.  If all
		 * data is infinite, an infinite interval will be returned.
		 * @returns {TimeInterval} The availability of entities in the collection.
		 */
		computeAvailability(): TimeInterval;

		/**
		 * Gets an entity with the specified id.
		 * @param {String} id The id of the entity to retrieve.
		 * @returns {Entity} The entity with the provided id or undefined if the id did not exist in the collection.
		 */
		getById(id: string): Entity;

	}

	/**
	 * A {@link CompositeProperty} which is also a {@link MaterialProperty}.
	 * @alias CompositeMaterialProperty
	 * @constructor
	 */
	class CompositeMaterialProperty {
		constructor();

		/**
		 * Gets a value indicating if this property is constant.  A property is considered
		 * constant if getValue always returns the same result for the current definition.
		 * @memberof CompositeMaterialProperty.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isConstant: boolean;

		/**
		 * Gets the event that is raised whenever the definition of this property changes.
		 * The definition is changed whenever setValue is called with data different
		 * than the current value.
		 * @memberof CompositeMaterialProperty.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets the interval collection.
		 * @memberof CompositeMaterialProperty.prototype
		 * @type {TimeIntervalCollection}
		 */
		intervals: TimeIntervalCollection;

		/**
		 * Gets the {@link Material} type at the provided time.
		 * @param {JulianDate} time The time for which to retrieve the type.
		 * @returns {String} The type of material.
		 */
		getType(time: JulianDate): string;

		/**
		 * Gets the value of the property at the provided time.
		 * @param {JulianDate} time The time for which to retrieve the value.
		 * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValue(time: JulianDate, result?: any): any;

		/**
		 * Compares this property to the provided property and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Property} [other] The other property.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		equals(other?: Property): boolean;

	}

	/**
	 * A {@link CompositeProperty} which is also a {@link PositionProperty}.
	 * @alias CompositePositionProperty
	 * @constructor
	 * @param {ReferenceFrame} [referenceFrame=ReferenceFrame.FIXED] The reference frame in which the position is defined.
	 */
	class CompositePositionProperty {
		constructor(referenceFrame?: any);

		/**
		 * Gets a value indicating if this property is constant.  A property is considered
		 * constant if getValue always returns the same result for the current definition.
		 * @memberof CompositePositionProperty.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isConstant: boolean;

		/**
		 * Gets the event that is raised whenever the definition of this property changes.
		 * The definition is changed whenever setValue is called with data different
		 * than the current value.
		 * @memberof CompositePositionProperty.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets the interval collection.
		 * @memberof CompositePositionProperty.prototype
		 * @type {TimeIntervalCollection}
		 */
		intervals: TimeIntervalCollection;

		/**
		 * Gets or sets the reference frame which this position presents itself as.
		 * Each PositionProperty making up this object has it's own reference frame,
		 * so this property merely exposes a "preferred" reference frame for clients
		 * to use.
		 * @memberof CompositePositionProperty.prototype
		 * @type {ReferenceFrame}
		 */
		referenceFrame: any;

		/**
		 * Gets the value of the property at the provided time in the fixed frame.
		 * @param {JulianDate} time The time for which to retrieve the value.
		 * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValue(time: JulianDate, result?: any): any;

		/**
		 * Gets the value of the property at the provided time and in the provided reference frame.
		 * @param {JulianDate} time The time for which to retrieve the value.
		 * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.
		 * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValueInReferenceFrame(time: JulianDate, referenceFrame: any, result?: Cartesian3): Cartesian3;

		/**
		 * Compares this property to the provided property and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Property} [other] The other property.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		equals(other?: Property): boolean;

	}

	/**
	 * A {@link Property} which is defined by a {@link TimeIntervalCollection}, where the
	 * data property of each {@link TimeInterval} is another Property instance which is
	 * evaluated at the provided time.
	 * @alias CompositeProperty
	 * @constructor
	 * @example
	 * var constantProperty = ...;
	 * var sampledProperty = ...;
	 * //Create a composite property from two previously defined properties
	 * //where the property is valid on August 1st, 2012 and uses a constant
	 * //property for the first half of the day and a sampled property for the
	 * //remaining half.
	 * var composite = new Cesium.CompositeProperty();
	 * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({
	 *     iso8601 : '2012-08-01T00:00:00.00Z/2012-08-01T12:00:00.00Z',
	 *     data : constantProperty
	 * }));
	 * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({
	 *     iso8601 : '2012-08-01T12:00:00.00Z/2012-08-02T00:00:00.00Z',
	 *     isStartIncluded : false,
	 *     isStopIncluded : false,
	 *     data : sampledProperty
	 * }));
	 * @see CompositeMaterialProperty
	 * @see CompositePositionProperty
	 */
	class CompositeProperty {
		constructor();

		/**
		 * Gets a value indicating if this property is constant.  A property is considered
		 * constant if getValue always returns the same result for the current definition.
		 * @memberof CompositeProperty.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isConstant: boolean;

		/**
		 * Gets the event that is raised whenever the definition of this property changes.
		 * The definition is changed whenever setValue is called with data different
		 * than the current value.
		 * @memberof CompositeProperty.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets the interval collection.
		 * @memberof CompositeProperty.prototype
		 * @type {TimeIntervalCollection}
		 */
		intervals: TimeIntervalCollection;

		/**
		 * Gets the value of the property at the provided time.
		 * @param {JulianDate} time The time for which to retrieve the value.
		 * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValue(time: JulianDate, result?: any): any;

		/**
		 * Compares this property to the provided property and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Property} [other] The other property.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		equals(other?: Property): boolean;

	}

	/**
	 * A {@link PositionProperty} whose value does not change in respect to the
	 * {@link ReferenceFrame} in which is it defined.
	 * @alias ConstantPositionProperty
	 * @constructor
	 * @param {Cartesian3} [value] The property value.
	 * @param {ReferenceFrame} [referenceFrame=ReferenceFrame.FIXED] The reference frame in which the position is defined.
	 */
	class ConstantPositionProperty {
		constructor(value?: Cartesian3, referenceFrame?: any);

		/**
		 * Gets a value indicating if this property is constant.  A property is considered
		 * constant if getValue always returns the same result for the current definition.
		 * @memberof ConstantPositionProperty.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isConstant: boolean;

		/**
		 * Gets the event that is raised whenever the definition of this property changes.
		 * The definition is considered to have changed if a call to getValue would return
		 * a different result for the same time.
		 * @memberof ConstantPositionProperty.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets the reference frame in which the position is defined.
		 * @memberof ConstantPositionProperty.prototype
		 * @type {ReferenceFrame}
		 * @default ReferenceFrame.FIXED;
		 */
		referenceFrame: any;

		/**
		 * Gets the value of the property at the provided time in the fixed frame.
		 * @param {JulianDate} time The time for which to retrieve the value.
		 * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValue(time: JulianDate, result?: any): any;

		/**
		 * Sets the value of the property.
		 * @param {Cartesian3} value The property value.
		 * @param {ReferenceFrame} [referenceFrame=this.referenceFrame] The reference frame in which the position is defined.
		 */
		setValue(value: Cartesian3, referenceFrame?: any): void;

		/**
		 * Gets the value of the property at the provided time and in the provided reference frame.
		 * @param {JulianDate} time The time for which to retrieve the value.
		 * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.
		 * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValueInReferenceFrame(time: JulianDate, referenceFrame: any, result?: Cartesian3): Cartesian3;

		/**
		 * Compares this property to the provided property and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Property} [other] The other property.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		equals(other?: Property): boolean;

	}

	/**
	 * A {@link Property} whose value does not change with respect to simulation time.
	 * @alias ConstantProperty
	 * @constructor
	 * @param {*} [value] The property value.
	 * @see ConstantPositionProperty
	 */
	class ConstantProperty {
		constructor(value?: any);

		/**
		 * Gets a value indicating if this property is constant.
		 * This property always returns <code>true</code>.
		 * @memberof ConstantProperty.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isConstant: boolean;

		/**
		 * Gets the event that is raised whenever the definition of this property changes.
		 * The definition is changed whenever setValue is called with data different
		 * than the current value.
		 * @memberof ConstantProperty.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets the value of the property.
		 * @param {JulianDate} [time] The time for which to retrieve the value.  This parameter is unused since the value does not change with respect to time.
		 * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValue(time?: JulianDate, result?: any): any;

		/**
		 * Sets the value of the property.
		 * @param {*} value The property value.
		 */
		setValue(value: any): void;

		/**
		 * Compares this property to the provided property and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Property} [other] The other property.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		equals(other?: Property): boolean;

		/**
		 * Gets this property's value.
		 * @returns {*} This property's value.
		 */
		valueOf(): any;

		/**
		 * Creates a string representing this property's value.
		 * @returns {String} A string representing the property's value.
		 */
		toString(): string;

	}

	/**
	 * A {@link GeometryUpdater} for corridors.
	 * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
	 * @alias CorridorGeometryUpdater
	 * @constructor
	 * @param {Entity} entity The entity containing the geometry to be visualized.
	 * @param {Scene} scene The scene where visualization is taking place.
	 */
	class CorridorGeometryUpdater {
		constructor(entity: Entity, scene: Scene);

		/**
		 * Creates the geometry instance which represents the fill of the geometry.
		 * @param {JulianDate} time The time to use when retrieving initial attribute values.
		 * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.
		 * @exception {DeveloperError} This instance does not represent a filled geometry.
		 */
		createFillGeometryInstance(time: JulianDate): GeometryInstance;

		/**
		 * Creates the geometry instance which represents the outline of the geometry.
		 * @param {JulianDate} time The time to use when retrieving initial attribute values.
		 * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.
		 * @exception {DeveloperError} This instance does not represent an outlined geometry.
		 */
		createOutlineGeometryInstance(time: JulianDate): GeometryInstance;

	}

	/**
	 * Describes a corridor, which is a shape defined by a centerline and width that
	 * conforms to the curvature of the globe. It can be placed on the surface or at altitude
	 * and can optionally be extruded into a volume.
	 * @alias CorridorGraphics
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Property} [options.positions] A Property specifying the array of {@link Cartesian3} positions that define the centerline of the corridor.
	 * @param {Property} [options.width] A numeric Property specifying the distance between the edges of the corridor.
	 * @param {Property} [options.cornerType=CornerType.ROUNDED] A {@link CornerType} Property specifying the style of the corners.
	 * @param {Property} [options.height=0] A numeric Property specifying the altitude of the corridor relative to the ellipsoid surface.
	 * @param {Property} [options.heightReference] A Property specifying what the height is relative to.
	 * @param {Property} [options.extrudedHeight] A numeric Property specifying the altitude of the corridor's extruded face relative to the ellipsoid surface.
	 * @param {Property} [options.extrudedHeightReference] A Property specifying what the extrudedHeight is relative to.
	 * @param {Property} [options.show=true] A boolean Property specifying the visibility of the corridor.
	 * @param {Property} [options.fill=true] A boolean Property specifying whether the corridor is filled with the provided material.
	 * @param {MaterialProperty} [options.material=Color.WHITE] A Property specifying the material used to fill the corridor.
	 * @param {Property} [options.outline=false] A boolean Property specifying whether the corridor is outlined.
	 * @param {Property} [options.outlineColor=Color.BLACK] A Property specifying the {@link Color} of the outline.
	 * @param {Property} [options.outlineWidth=1.0] A numeric Property specifying the width of the outline.
	 * @param {Property} [options.granularity=Cesium.Math.RADIANS_PER_DEGREE] A numeric Property specifying the distance between each latitude and longitude.
	 * @param {Property} [options.shadows=ShadowMode.DISABLED] An enum Property specifying whether the corridor casts or receives shadows from each light source.
	 * @param {Property} [options.distanceDisplayCondition] A Property specifying at what distance from the camera that this corridor will be displayed.
	 * @param {ConstantProperty} [options.zIndex] A Property specifying the zIndex of the corridor, used for ordering.  Only has an effect if height and extrudedHeight are undefined, and if the corridor is static.
	 * @see Entity
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Corridor.html|Cesium Sandcastle Corridor Demo}
	 */
	class CorridorGraphics {
		constructor(options?: {
			positions?: Property;
			width?: Property;
			cornerType?: Property;
			height?: Property;
			heightReference?: Property;
			extrudedHeight?: Property;
			extrudedHeightReference?: Property;
			show?: Property;
			fill?: Property;
			material?: MaterialProperty;
			outline?: Property;
			outlineColor?: Property;
			outlineWidth?: Property;
			granularity?: Property;
			shadows?: Property;
			distanceDisplayCondition?: Property;
			zIndex?: ConstantProperty;
		});

		/**
		 * Gets the event that is raised whenever a property or sub-property is changed or modified.
		 * @memberof CorridorGraphics.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets or sets the boolean Property specifying the visibility of the corridor.
		 * @memberof CorridorGraphics.prototype
		 * @type {Property}
		 * @default true
		 */
		show: Property;

		/**
		 * Gets or sets the Property specifying the material used to fill the corridor.
		 * @memberof CorridorGraphics.prototype
		 * @type {MaterialProperty}
		 * @default Color.WHITE
		 */
		material: MaterialProperty;

		/**
		 * Gets or sets a Property specifying the array of {@link Cartesian3} positions that define the centerline of the corridor.
		 * @memberof CorridorGraphics.prototype
		 * @type {Property}
		 */
		positions: Property;

		/**
		 * Gets or sets the numeric Property specifying the altitude of the corridor.
		 * @memberof CorridorGraphics.prototype
		 * @type {Property}
		 * @default 0.0
		 */
		height: Property;

		/**
		 * Gets or sets the Property specifying the {@link HeightReference}.
		 * @memberof CorridorGraphics.prototype
		 * @type {Property}
		 * @default HeightReference.NONE
		 */
		heightReference: Property;

		/**
		 * Gets or sets the numeric Property specifying the altitude of the corridor extrusion.
		 * Setting this property creates a corridor shaped volume starting at height and ending
		 * at this altitude.
		 * @memberof CorridorGraphics.prototype
		 * @type {Property}
		 */
		extrudedHeight: Property;

		/**
		 * Gets or sets the Property specifying the extruded {@link HeightReference}.
		 * @memberof CorridorGraphics.prototype
		 * @type {Property}
		 * @default HeightReference.NONE
		 */
		extrudedHeightReference: Property;

		/**
		 * Gets or sets the numeric Property specifying the sampling distance between each latitude and longitude point.
		 * @memberof CorridorGraphics.prototype
		 * @type {Property}
		 * @default {CesiumMath.RADIANS_PER_DEGREE}
		 */
		granularity: Property;

		/**
		 * Gets or sets the numeric Property specifying the width of the corridor.
		 * @memberof CorridorGraphics.prototype
		 * @type {Property}
		 */
		width: Property;

		/**
		 * Gets or sets the boolean Property specifying whether the corridor is filled with the provided material.
		 * @memberof CorridorGraphics.prototype
		 * @type {Property}
		 * @default true
		 */
		fill: Property;

		/**
		 * Gets or sets the Property specifying whether the corridor is outlined.
		 * @memberof CorridorGraphics.prototype
		 * @type {Property}
		 * @default false
		 */
		outline: Property;

		/**
		 * Gets or sets the Property specifying the {@link Color} of the outline.
		 * @memberof CorridorGraphics.prototype
		 * @type {Property}
		 * @default Color.BLACK
		 */
		outlineColor: Property;

		/**
		 * Gets or sets the numeric Property specifying the width of the outline.
		 * @memberof CorridorGraphics.prototype
		 * @type {Property}
		 * @default 1.0
		 */
		outlineWidth: Property;

		/**
		 * Gets or sets the {@link CornerType} Property specifying how corners are styled.
		 * @memberof CorridorGraphics.prototype
		 * @type {Property}
		 * @default CornerType.ROUNDED
		 */
		cornerType: Property;

		/**
		 * Get or sets the enum Property specifying whether the corridor
		 * casts or receives shadows from each light source.
		 * @memberof CorridorGraphics.prototype
		 * @type {Property}
		 * @default ShadowMode.DISABLED
		 */
		shadows: Property;

		/**
		 * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this corridor will be displayed.
		 * @memberof CorridorGraphics.prototype
		 * @type {Property}
		 */
		distanceDisplayCondition: Property;

		/**
		 * Gets or sets the {@link ClassificationType} Property specifying whether this corridor will classify terrain, 3D Tiles, or both when on the ground.
		 * @memberof CorridorGraphics.prototype
		 * @type {Property}
		 * @default ClassificationType.TERRAIN
		 */
		classificationType: Property;

		/**
		 * Gets or sets the zIndex Property specifying the ordering of the corridor.  Only has an effect if the coridor is static and neither height or exturdedHeight are specified.
		 * @memberof CorridorGraphics.prototype
		 * @type {ConstantProperty}
		 * @default 0
		 */
		zIndex: ConstantProperty;

		/**
		 * Duplicates this instance.
		 * @param {CorridorGraphics} [result] The object onto which to store the result.
		 * @returns {CorridorGraphics} The modified result parameter or a new instance if one was not provided.
		 */
		clone(result?: CorridorGraphics): CorridorGraphics;

		/**
		 * Assigns each unassigned property on this object to the value
		 * of the same property on the provided source object.
		 * @param {CorridorGraphics} source The object to be merged into this object.
		 */
		merge(source: CorridorGraphics): void;

	}

	/**
	 * A {@link DataSource} implementation which can be used to manually manage a group of entities.
	 * @alias CustomDataSource
	 * @constructor
	 * @param {String} [name] A human-readable name for this instance.
	 * @example
	 * var dataSource = new Cesium.CustomDataSource('myData');
	 * var entity = dataSource.entities.add({
	 *    position : Cesium.Cartesian3.fromDegrees(1, 2, 0),
	 *    billboard : {
	 *        image : 'image.png'
	 *    }
	 * });
	 * viewer.dataSources.add(dataSource);
	 */
	class CustomDataSource {
		constructor(name?: string);

		/**
		 * Gets or sets a human-readable name for this instance.
		 * @memberof CustomDataSource.prototype
		 * @type {String}
		 */
		name: string;

		/**
		 * Gets or sets the clock for this instance.
		 * @memberof CustomDataSource.prototype
		 * @type {DataSourceClock}
		 */
		clock: DataSourceClock;

		/**
		 * Gets the collection of {@link Entity} instances.
		 * @memberof CustomDataSource.prototype
		 * @type {EntityCollection}
		 */
		entities: EntityCollection;

		/**
		 * Gets or sets whether the data source is currently loading data.
		 * @memberof CustomDataSource.prototype
		 * @type {Boolean}
		 */
		isLoading: boolean;

		/**
		 * Gets an event that will be raised when the underlying data changes.
		 * @memberof CustomDataSource.prototype
		 * @type {Event}
		 */
		changedEvent: Event;

		/**
		 * Gets an event that will be raised if an error is encountered during processing.
		 * @memberof CustomDataSource.prototype
		 * @type {Event}
		 */
		errorEvent: Event;

		/**
		 * Gets an event that will be raised when the data source either starts or stops loading.
		 * @memberof CustomDataSource.prototype
		 * @type {Event}
		 */
		loadingEvent: Event;

		/**
		 * Gets whether or not this data source should be displayed.
		 * @memberof CustomDataSource.prototype
		 * @type {Boolean}
		 */
		show: boolean;

		/**
		 * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.
		 * @memberof CustomDataSource.prototype
		 * @type {EntityCluster}
		 */
		clustering: EntityCluster;

	}

	/**
	 * A {@link GeometryUpdater} for cylinders.
	 * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
	 * @alias CylinderGeometryUpdater
	 * @constructor
	 * @param {Entity} entity The entity containing the geometry to be visualized.
	 * @param {Scene} scene The scene where visualization is taking place.
	 */
	class CylinderGeometryUpdater {
		constructor(entity: Entity, scene: Scene);

		/**
		 * Gets the terrain offset property
		 * @type {TerrainOffsetProperty}
		 * @memberof CylinderGeometryUpdater.prototype
		 * @readonly
		 */
		readonly terrainOffsetProperty: any;

		/**
		 * Creates the geometry instance which represents the fill of the geometry.
		 * @param {JulianDate} time The time to use when retrieving initial attribute values.
		 * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.
		 * @exception {DeveloperError} This instance does not represent a filled geometry.
		 */
		createFillGeometryInstance(time: JulianDate): GeometryInstance;

		/**
		 * Creates the geometry instance which represents the outline of the geometry.
		 * @param {JulianDate} time The time to use when retrieving initial attribute values.
		 * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.
		 * @exception {DeveloperError} This instance does not represent an outlined geometry.
		 */
		createOutlineGeometryInstance(time: JulianDate): GeometryInstance;

	}

	/**
	 * Describes a cylinder, truncated cone, or cone defined by a length, top radius, and bottom radius.
	 * The center position and orientation are determined by the containing {@link Entity}.
	 * @alias CylinderGraphics
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Property} [options.heightReference] A Property specifying what the height from the entity position is relative to.
	 * @param {Property} [options.length] A numeric Property specifying the length of the cylinder.
	 * @param {Property} [options.topRadius] A numeric Property specifying the radius of the top of the cylinder.
	 * @param {Property} [options.bottomRadius] A numeric Property specifying the radius of the bottom of the cylinder.
	 * @param {Property} [options.show=true] A boolean Property specifying the visibility of the cylinder.
	 * @param {Property} [options.fill=true] A boolean Property specifying whether the cylinder is filled with the provided material.
	 * @param {MaterialProperty} [options.material=Color.WHITE] A Property specifying the material used to fill the cylinder.
	 * @param {Property} [options.outline=false] A boolean Property specifying whether the cylinder is outlined.
	 * @param {Property} [options.outlineColor=Color.BLACK] A Property specifying the {@link Color} of the outline.
	 * @param {Property} [options.outlineWidth=1.0] A numeric Property specifying the width of the outline.
	 * @param {Property} [options.numberOfVerticalLines=16] A numeric Property specifying the number of vertical lines to draw along the perimeter for the outline.
	 * @param {Property} [options.slices=128] The number of edges around the perimeter of the cylinder.
	 * @param {Property} [options.shadows=ShadowMode.DISABLED] An enum Property specifying whether the cylinder casts or receives shadows from each light source.
	 * @param {Property} [options.distanceDisplayCondition] A Property specifying at what distance from the camera that this cylinder will be displayed.
	 */
	class CylinderGraphics {
		constructor(options?: {
			heightReference?: Property;
			length?: Property;
			topRadius?: Property;
			bottomRadius?: Property;
			show?: Property;
			fill?: Property;
			material?: MaterialProperty;
			outline?: Property;
			outlineColor?: Property;
			outlineWidth?: Property;
			numberOfVerticalLines?: Property;
			slices?: Property;
			shadows?: Property;
			distanceDisplayCondition?: Property;
		});

		/**
		 * Gets the event that is raised whenever a property or sub-property is changed or modified.
		 * @memberof CylinderGraphics.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets or sets the Property specifying the {@link HeightReference}.
		 * @memberof CylinderGraphics.prototype
		 * @type {Property}
		 * @default HeightReference.NONE
		 */
		heightReference: Property;

		/**
		 * Gets or sets the numeric Property specifying the length of the cylinder.
		 * @memberof CylinderGraphics.prototype
		 * @type {Property}
		 */
		length: Property;

		/**
		 * Gets or sets the numeric Property specifying the radius of the top of the cylinder.
		 * @memberof CylinderGraphics.prototype
		 * @type {Property}
		 */
		topRadius: Property;

		/**
		 * Gets or sets the numeric Property specifying the radius of the bottom of the cylinder.
		 * @memberof CylinderGraphics.prototype
		 * @type {Property}
		 */
		bottomRadius: Property;

		/**
		 * Gets or sets the Property specifying the number of vertical lines to draw along the perimeter for the outline.
		 * @memberof CylinderGraphics.prototype
		 * @type {Property}
		 * @default 16
		 */
		numberOfVerticalLines: Property;

		/**
		 * Gets or sets the Property specifying the number of edges around the perimeter of the cylinder.
		 * @memberof CylinderGraphics.prototype
		 * @type {Property}
		 * @default 128
		 */
		slices: Property;

		/**
		 * Gets or sets the boolean Property specifying the visibility of the cylinder.
		 * @memberof CylinderGraphics.prototype
		 * @type {Property}
		 * @default true
		 */
		show: Property;

		/**
		 * Gets or sets the Property specifying the material used to fill the cylinder.
		 * @memberof CylinderGraphics.prototype
		 * @type {MaterialProperty}
		 * @default Color.WHITE
		 */
		material: MaterialProperty;

		/**
		 * Gets or sets the boolean Property specifying whether the cylinder is filled with the provided material.
		 * @memberof CylinderGraphics.prototype
		 * @type {Property}
		 * @default true
		 */
		fill: Property;

		/**
		 * Gets or sets the boolean Property specifying whether the cylinder is outlined.
		 * @memberof CylinderGraphics.prototype
		 * @type {Property}
		 * @default false
		 */
		outline: Property;

		/**
		 * Gets or sets the Property specifying the {@link Color} of the outline.
		 * @memberof CylinderGraphics.prototype
		 * @type {Property}
		 * @default Color.BLACK
		 */
		outlineColor: Property;

		/**
		 * Gets or sets the numeric Property specifying the width of the outline.
		 * @memberof CylinderGraphics.prototype
		 * @type {Property}
		 * @default 1.0
		 */
		outlineWidth: Property;

		/**
		 * Get or sets the enum Property specifying whether the cylinder
		 * casts or receives shadows from each light source.
		 * @memberof CylinderGraphics.prototype
		 * @type {Property}
		 * @default ShadowMode.DISABLED
		 */
		shadows: Property;

		/**
		 * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this cylinder will be displayed.
		 * @memberof CylinderGraphics.prototype
		 * @type {Property}
		 */
		distanceDisplayCondition: Property;

		/**
		 * Duplicates this instance.
		 * @param {CylinderGraphics} [result] The object onto which to store the result.
		 * @returns {CylinderGraphics} The modified result parameter or a new instance if one was not provided.
		 */
		clone(result?: CylinderGraphics): CylinderGraphics;

		/**
		 * Assigns each unassigned property on this object to the value
		 * of the same property on the provided source object.
		 * @param {CylinderGraphics} source The object to be merged into this object.
		 */
		merge(source: CylinderGraphics): void;

	}

	/**
	 * A {@link DataSource} which processes {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/CZML-Guide|CZML}.
	 * @alias CzmlDataSource
	 * @constructor
	 * @param {String} [name] An optional name for the data source.  This value will be overwritten if a loaded document contains a name.
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=CZML.html|Cesium Sandcastle CZML Demo}
	 */
	class CzmlDataSource {
		constructor(name?: string);

		/**
		 * Creates a Promise to a new instance loaded with the provided CZML data.
		 * @param {Resource|String|Object} czml A url or CZML object to be processed.
		 * @param {Object} [options] An object with the following properties:
		 * @param {Resource|String} [options.sourceUri] Overrides the url to use for resolving relative links.
		 * @returns {Promise.<CzmlDataSource>} A promise that resolves to the new instance once the data is processed.
		 */
		static load(czml: Resource | string | any, options?: {
			sourceUri?: Resource | string;
		}): any;

		/**
		 * Gets a human-readable name for this instance.
		 * @memberof CzmlDataSource.prototype
		 * @type {String}
		 */
		name: string;

		/**
		 * Gets the clock settings defined by the loaded CZML.  If no clock is explicitly
		 * defined in the CZML, the combined availability of all objects is returned.  If
		 * only static data exists, this value is undefined.
		 * @memberof CzmlDataSource.prototype
		 * @type {DataSourceClock}
		 */
		clock: DataSourceClock;

		/**
		 * Gets the collection of {@link Entity} instances.
		 * @memberof CzmlDataSource.prototype
		 * @type {EntityCollection}
		 */
		entities: EntityCollection;

		/**
		 * Gets a value indicating if the data source is currently loading data.
		 * @memberof CzmlDataSource.prototype
		 * @type {Boolean}
		 */
		isLoading: boolean;

		/**
		 * Gets an event that will be raised when the underlying data changes.
		 * @memberof CzmlDataSource.prototype
		 * @type {Event}
		 */
		changedEvent: Event;

		/**
		 * Gets an event that will be raised if an error is encountered during processing.
		 * @memberof CzmlDataSource.prototype
		 * @type {Event}
		 */
		errorEvent: Event;

		/**
		 * Gets an event that will be raised when the data source either starts or stops loading.
		 * @memberof CzmlDataSource.prototype
		 * @type {Event}
		 */
		loadingEvent: Event;

		/**
		 * Gets whether or not this data source should be displayed.
		 * @memberof CzmlDataSource.prototype
		 * @type {Boolean}
		 */
		show: boolean;

		/**
		 * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.
		 * @memberof CzmlDataSource.prototype
		 * @type {EntityCluster}
		 */
		clustering: EntityCluster;

		/**
		 * Gets the array of CZML processing functions.
		 * @memberof CzmlDataSource
		 * @type Array
		 */
		static updaters: any[];

		/**
		 * Processes the provided url or CZML object without clearing any existing data.
		 * @param {Resource|String|Object} czml A url or CZML object to be processed.
		 * @param {Object} [options] An object with the following properties:
		 * @param {String} [options.sourceUri] Overrides the url to use for resolving relative links.
		 * @returns {Promise.<CzmlDataSource>} A promise that resolves to this instances once the data is processed.
		 */
		process(czml: Resource | string | any, options?: {
			sourceUri?: string;
		}): any;

		/**
		 * Loads the provided url or CZML object, replacing any existing data.
		 * @param {Resource|String|Object} czml A url or CZML object to be processed.
		 * @param {Object} [options] An object with the following properties:
		 * @param {String} [options.sourceUri] Overrides the url to use for resolving relative links.
		 * @returns {Promise.<CzmlDataSource>} A promise that resolves to this instances once the data is processed.
		 */
		load(czml: Resource | string | any, options?: {
			sourceUri?: string;
		}): any;

		/**
		 * A helper function used by custom CZML updater functions
		 * which creates or updates a {@link Property} from a CZML packet.
		 * @function
		 * @param {Function} type The constructor function for the property being processed.
		 * @param {Object} object The object on which the property will be added or updated.
		 * @param {String} propertyName The name of the property on the object.
		 * @param {Object} packetData The CZML packet being processed.
		 * @param {TimeInterval} interval A constraining interval for which the data is valid.
		 * @param {String} sourceUri The originating uri of the data being processed.
		 * @param {EntityCollection} entityCollection The collection being processsed.
		 */
		static processPacketData(type: Function, object: any, propertyName: string, packetData: any, interval: TimeInterval, sourceUri: string, entityCollection: EntityCollection): void;

		/**
		 * A helper function used by custom CZML updater functions
		 * which creates or updates a {@link PositionProperty} from a CZML packet.
		 * @function
		 * @param {Object} object The object on which the property will be added or updated.
		 * @param {String} propertyName The name of the property on the object.
		 * @param {Object} packetData The CZML packet being processed.
		 * @param {TimeInterval} interval A constraining interval for which the data is valid.
		 * @param {String} sourceUri The originating uri of the data being processed.
		 * @param {EntityCollection} entityCollection The collection being processsed.
		 */
		static processPositionPacketData(object: any, propertyName: string, packetData: any, interval: TimeInterval, sourceUri: string, entityCollection: EntityCollection): void;

		/**
		 * A helper function used by custom CZML updater functions
		 * which creates or updates a {@link MaterialProperty} from a CZML packet.
		 * @function
		 * @param {Object} object The object on which the property will be added or updated.
		 * @param {String} propertyName The name of the property on the object.
		 * @param {Object} packetData The CZML packet being processed.
		 * @param {TimeInterval} interval A constraining interval for which the data is valid.
		 * @param {String} sourceUri The originating uri of the data being processed.
		 * @param {EntityCollection} entityCollection The collection being processsed.
		 */
		static processMaterialPacketData(object: any, propertyName: string, packetData: any, interval: TimeInterval, sourceUri: string, entityCollection: EntityCollection): void;

	}

	/**
	 * Defines the interface for data sources, which turn arbitrary data into a
	 * {@link EntityCollection} for generic consumption. This object is an interface
	 * for documentation purposes and is not intended to be instantiated directly.
	 * @alias DataSource
	 * @constructor
	 * @see Entity
	 * @see DataSourceDisplay
	 */
	class DataSource {
		constructor();

		/**
		 * Gets a human-readable name for this instance.
		 * @memberof DataSource.prototype
		 * @type {String}
		 */
		name: string;

		/**
		 * Gets the preferred clock settings for this data source.
		 * @memberof DataSource.prototype
		 * @type {DataSourceClock}
		 */
		clock: DataSourceClock;

		/**
		 * Gets the collection of {@link Entity} instances.
		 * @memberof DataSource.prototype
		 * @type {EntityCollection}
		 */
		entities: EntityCollection;

		/**
		 * Gets a value indicating if the data source is currently loading data.
		 * @memberof DataSource.prototype
		 * @type {Boolean}
		 */
		isLoading: boolean;

		/**
		 * Gets an event that will be raised when the underlying data changes.
		 * @memberof DataSource.prototype
		 * @type {Event}
		 */
		changedEvent: Event;

		/**
		 * Gets an event that will be raised if an error is encountered during processing.
		 * @memberof DataSource.prototype
		 * @type {Event}
		 */
		errorEvent: Event;

		/**
		 * Gets an event that will be raised when the value of isLoading changes.
		 * @memberof DataSource.prototype
		 * @type {Event}
		 */
		loadingEvent: Event;

		/**
		 * Gets whether or not this data source should be displayed.
		 * @memberof DataSource.prototype
		 * @type {Boolean}
		 */
		show: boolean;

		/**
		 * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.
		 * @memberof DataSource.prototype
		 * @type {EntityCluster}
		 */
		clustering: EntityCluster;

		/**
		 * Updates the data source to the provided time.  This function is optional and
		 * is not required to be implemented.  It is provided for data sources which
		 * retrieve data based on the current animation time or scene state.
		 * If implemented, update will be called by {@link DataSourceDisplay} once a frame.
		 * @function
		 * @param {JulianDate} time The simulation time.
		 * @returns {Boolean} True if this data source is ready to be displayed at the provided time, false otherwise.
		 */
		update(time: JulianDate): boolean;

	}

	/**
	 * Represents desired clock settings for a particular {@link DataSource}.  These settings may be applied
	 * to the {@link Clock} when the DataSource is loaded.
	 * @alias DataSourceClock
	 * @constructor
	 */
	class DataSourceClock {
		constructor();

		/**
		 * Gets the event that is raised whenever a new property is assigned.
		 * @memberof DataSourceClock.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets or sets the desired start time of the clock.
		 * See {@link Clock#startTime}.
		 * @memberof DataSourceClock.prototype
		 * @type {JulianDate}
		 */
		startTime: JulianDate;

		/**
		 * Gets or sets the desired stop time of the clock.
		 * See {@link Clock#stopTime}.
		 * @memberof DataSourceClock.prototype
		 * @type {JulianDate}
		 */
		stopTime: JulianDate;

		/**
		 * Gets or sets the desired current time when this data source is loaded.
		 * See {@link Clock#currentTime}.
		 * @memberof DataSourceClock.prototype
		 * @type {JulianDate}
		 */
		currentTime: JulianDate;

		/**
		 * Gets or sets the desired clock range setting.
		 * See {@link Clock#clockRange}.
		 * @memberof DataSourceClock.prototype
		 * @type {ClockRange}
		 */
		clockRange: any;

		/**
		 * Gets or sets the desired clock step setting.
		 * See {@link Clock#clockStep}.
		 * @memberof DataSourceClock.prototype
		 * @type {ClockStep}
		 */
		clockStep: any;

		/**
		 * Gets or sets the desired clock multiplier.
		 * See {@link Clock#multiplier}.
		 * @memberof DataSourceClock.prototype
		 * @type {Number}
		 */
		multiplier: number;

		/**
		 * Duplicates a DataSourceClock instance.
		 * @param {DataSourceClock} [result] The object onto which to store the result.
		 * @returns {DataSourceClock} The modified result parameter or a new instance if one was not provided.
		 */
		clone(result?: DataSourceClock): DataSourceClock;

		/**
		 * Returns true if this DataSourceClock is equivalent to the other
		 * @param {DataSourceClock} other The other DataSourceClock to compare to.
		 * @returns {Boolean} <code>true</code> if the DataSourceClocks are equal; otherwise, <code>false</code>.
		 */
		equals(other: DataSourceClock): boolean;

		/**
		 * Assigns each unassigned property on this object to the value
		 * of the same property on the provided source object.
		 * @param {DataSourceClock} source The object to be merged into this object.
		 */
		merge(source: DataSourceClock): void;

		/**
		 * Gets the value of this clock instance as a {@link Clock} object.
		 * @returns {Clock} The modified result parameter or a new instance if one was not provided.
		 */
		getValue(): Clock;

	}

	/**
	 * A collection of {@link DataSource} instances.
	 * @alias DataSourceCollection
	 * @constructor
	 */
	class DataSourceCollection {
		constructor();

		/**
		 * Gets the number of data sources in this collection.
		 * @memberof DataSourceCollection.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly length: number;

		/**
		 * An event that is raised when a data source is added to the collection.
		 * Event handlers are passed the data source that was added.
		 * @memberof DataSourceCollection.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly dataSourceAdded: Event;

		/**
		 * An event that is raised when a data source is removed from the collection.
		 * Event handlers are passed the data source that was removed.
		 * @memberof DataSourceCollection.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly dataSourceRemoved: Event;

		/**
		 * An event that is raised when a data source changes position in the collection.  Event handlers are passed the data source
		 * that was moved, its new index after the move, and its old index prior to the move.
		 * @memberof DataSourceCollection.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly dataSourceMoved: Event;

		/**
		 * Adds a data source to the collection.
		 * @param {DataSource|Promise.<DataSource>} dataSource A data source or a promise to a data source to add to the collection.
		 *                                        When passing a promise, the data source will not actually be added
		 *                                        to the collection until the promise resolves successfully.
		 * @returns {Promise.<DataSource>} A Promise that resolves once the data source has been added to the collection.
		 */
		add(dataSource: DataSource | any): any;

		/**
		 * Removes a data source from this collection, if present.
		 * @param {DataSource} dataSource The data source to remove.
		 * @param {Boolean} [destroy=false] Whether to destroy the data source in addition to removing it.
		 * @returns {Boolean} true if the data source was in the collection and was removed,
		 *                    false if the data source was not in the collection.
		 */
		remove(dataSource: DataSource, destroy?: boolean): boolean;

		/**
		 * Removes all data sources from this collection.
		 * @param {Boolean} [destroy=false] whether to destroy the data sources in addition to removing them.
		 */
		removeAll(destroy?: boolean): void;

		/**
		 * Checks to see if the collection contains a given data source.
		 * @param {DataSource} dataSource The data source to check for.
		 * @returns {Boolean} true if the collection contains the data source, false otherwise.
		 */
		contains(dataSource: DataSource): boolean;

		/**
		 * Determines the index of a given data source in the collection.
		 * @param {DataSource} dataSource The data source to find the index of.
		 * @returns {Number} The index of the data source in the collection, or -1 if the data source does not exist in the collection.
		 */
		indexOf(dataSource: DataSource): number;

		/**
		 * Gets a data source by index from the collection.
		 * @param {Number} index the index to retrieve.
		 * @returns {DataSource} The data source at the specified index.
		 */
		get(index: number): DataSource;

		/**
		 * Raises a data source up one position in the collection.
		 * @param {DataSource} dataSource The data source to move.
		 * @exception {DeveloperError} dataSource is not in this collection.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 */
		raise(dataSource: DataSource): void;

		/**
		 * Lowers a data source down one position in the collection.
		 * @param {DataSource} dataSource The data source to move.
		 * @exception {DeveloperError} dataSource is not in this collection.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 */
		lower(dataSource: DataSource): void;

		/**
		 * Raises a data source to the top of the collection.
		 * @param {DataSource} dataSource The data source to move.
		 * @exception {DeveloperError} dataSource is not in this collection.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 */
		raiseToTop(dataSource: DataSource): void;

		/**
		 * Lowers a data source to the bottom of the collection.
		 * @param {DataSource} dataSource The data source to move.
		 * @exception {DeveloperError} dataSource is not in this collection.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 */
		lowerToBottom(dataSource: DataSource): void;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * @returns {Boolean} true if this object was destroyed; otherwise, false.
		 * @see DataSourceCollection#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys the resources held by all data sources in this collection.  Explicitly destroying this
		 * object allows for deterministic release of WebGL resources, instead of relying on the garbage
		 * collector. Once this object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * dataSourceCollection = dataSourceCollection && dataSourceCollection.destroy();
		 * @see DataSourceCollection#isDestroyed
		 */
		destroy(): void;

	}

	/**
	 * Visualizes a collection of {@link DataSource} instances.
	 * @alias DataSourceDisplay
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Scene} options.scene The scene in which to display the data.
	 * @param {DataSourceCollection} options.dataSourceCollection The data sources to display.
	 * @param {DataSourceDisplay~Function} [options.visualizersFunction=DataSourceDisplay.defaultFunction]
	 *        A function which creates an array of visualizers used for visualization.
	 *        If undefined, all standard visualizers are used.
	 */
	class DataSourceDisplay {
		constructor(options: {
			scene: Scene;
			dataSourceCollection: DataSourceCollection;
			visualizersFunction?: Function;
		});

		/**
		 * Gets or sets the default function which creates an array of visualizers used for visualization.
		 * By default, this function uses all standard visualizers.
		 * @type {DataSourceDisplay~Function}
		 */
		static defaultFunction(): void;

		/**
		 * Gets the scene associated with this display.
		 * @memberof DataSourceDisplay.prototype
		 * @type {Scene}
		 */
		scene: Scene;

		/**
		 * Gets the collection of data sources to display.
		 * @memberof DataSourceDisplay.prototype
		 * @type {DataSourceCollection}
		 */
		dataSources: DataSourceCollection;

		/**
		 * Gets the default data source instance which can be used to
		 * manually create and visualize entities not tied to
		 * a specific data source. This instance is always available
		 * and does not appear in the list dataSources collection.
		 * @memberof DataSourceDisplay.prototype
		 * @type {CustomDataSource}
		 */
		defaultDataSource: CustomDataSource;

		/**
		 * Gets a value indicating whether or not all entities in the data source are ready
		 * @memberof DataSourceDisplay.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly ready: boolean;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <br /><br />
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * @returns {Boolean} True if this object was destroyed; otherwise, false.
		 * @see DataSourceDisplay#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
		 * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
		 * <br /><br />
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * dataSourceDisplay = dataSourceDisplay.destroy();
		 * @see DataSourceDisplay#isDestroyed
		 */
		destroy(): void;

		/**
		 * Updates the display to the provided time.
		 * @param {JulianDate} time The simulation time.
		 * @returns {Boolean} True if all data sources are ready to be displayed, false otherwise.
		 */
		update(time: JulianDate): boolean;

		/**
		 * Computes a bounding sphere which encloses the visualization produced for the specified entity.
		 * The bounding sphere is in the fixed frame of the scene's globe.
		 * @param {Entity} entity The entity whose bounding sphere to compute.
		 * @param {Boolean} allowPartial If true, pending bounding spheres are ignored and an answer will be returned from the currently available data.
		 *                               If false, the the function will halt and return pending if any of the bounding spheres are pending.
		 * @param {BoundingSphere} result The bounding sphere onto which to store the result.
		 * @returns {BoundingSphereState} BoundingSphereState.DONE if the result contains the bounding sphere,
		 *                       BoundingSphereState.PENDING if the result is still being computed, or
		 *                       BoundingSphereState.FAILED if the entity has no visualization in the current scene.
		 */
		getBoundingSphere(entity: Entity, allowPartial: boolean, result: BoundingSphere): any;

	}

	/**
	 * A {@link GeometryUpdater} for ellipses.
	 * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
	 * @alias EllipseGeometryUpdater
	 * @constructor
	 * @param {Entity} entity The entity containing the geometry to be visualized.
	 * @param {Scene} scene The scene where visualization is taking place.
	 */
	class EllipseGeometryUpdater {
		constructor(entity: Entity, scene: Scene);

		/**
		 * Creates the geometry instance which represents the fill of the geometry.
		 * @param {JulianDate} time The time to use when retrieving initial attribute values.
		 * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.
		 * @exception {DeveloperError} This instance does not represent a filled geometry.
		 */
		createFillGeometryInstance(time: JulianDate): GeometryInstance;

		/**
		 * Creates the geometry instance which represents the outline of the geometry.
		 * @param {JulianDate} time The time to use when retrieving initial attribute values.
		 * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.
		 * @exception {DeveloperError} This instance does not represent an outlined geometry.
		 */
		createOutlineGeometryInstance(time: JulianDate): GeometryInstance;

		/**
		 * Gets a value indicating if the geometry should be drawn on terrain.
		 * @memberof EllipseGeometryUpdater.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly onTerrain: boolean;

	}

	/**
	 * Describes an ellipse defined by a center point and semi-major and semi-minor axes.
	 * The ellipse conforms to the curvature of the globe and can be placed on the surface or
	 * at altitude and can optionally be extruded into a volume.
	 * The center point is determined by the containing {@link Entity}.
	 * @alias EllipseGraphics
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Property} [options.semiMajorAxis] The numeric Property specifying the semi-major axis.
	 * @param {Property} [options.semiMinorAxis] The numeric Property specifying the semi-minor axis.
	 * @param {Property} [options.height=0] A numeric Property specifying the altitude of the ellipse relative to the ellipsoid surface.
	 * @param {Property} [options.heightReference] A Property specifying what the height is relative to.
	 * @param {Property} [options.extrudedHeight] A numeric Property specifying the altitude of the ellipse's extruded face relative to the ellipsoid surface.
	 * @param {Property} [options.extrudedHeightReference] A Property specifying what the extrudedHeight is relative to.
	 * @param {Property} [options.show=true] A boolean Property specifying the visibility of the ellipse.
	 * @param {Property} [options.fill=true] A boolean Property specifying whether the ellipse is filled with the provided material.
	 * @param {MaterialProperty} [options.material=Color.WHITE] A Property specifying the material used to fill the ellipse.
	 * @param {Property} [options.outline=false] A boolean Property specifying whether the ellipse is outlined.
	 * @param {Property} [options.outlineColor=Color.BLACK] A Property specifying the {@link Color} of the outline.
	 * @param {Property} [options.outlineWidth=1.0] A numeric Property specifying the width of the outline.
	 * @param {Property} [options.numberOfVerticalLines=16] A numeric Property specifying the number of vertical lines to draw along the perimeter for the outline.
	 * @param {Property} [options.rotation=0.0] A numeric property specifying the rotation of the ellipse counter-clockwise from north.
	 * @param {Property} [options.stRotation=0.0] A numeric property specifying the rotation of the ellipse texture counter-clockwise from north.
	 * @param {Property} [options.granularity=Cesium.Math.RADIANS_PER_DEGREE] A numeric Property specifying the angular distance between points on the ellipse.
	 * @param {Property} [options.shadows=ShadowMode.DISABLED] An enum Property specifying whether the ellipse casts or receives shadows from each light source.
	 * @param {Property} [options.distanceDisplayCondition] A Property specifying at what distance from the camera that this ellipse will be displayed.
	 * @param {ConstantProperty} [options.zIndex=0] A property specifying the zIndex of the Ellipse.  Used for ordering ground geometry.  Only has an effect if the ellipse is constant and neither height or exturdedHeight are specified.
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Circles and Ellipses.html|Cesium Sandcastle Circles and Ellipses Demo}
	 */
	class EllipseGraphics {
		constructor(options?: {
			semiMajorAxis?: Property;
			semiMinorAxis?: Property;
			height?: Property;
			heightReference?: Property;
			extrudedHeight?: Property;
			extrudedHeightReference?: Property;
			show?: Property;
			fill?: Property;
			material?: MaterialProperty;
			outline?: Property;
			outlineColor?: Property;
			outlineWidth?: Property;
			numberOfVerticalLines?: Property;
			rotation?: Property;
			stRotation?: Property;
			granularity?: Property;
			shadows?: Property;
			distanceDisplayCondition?: Property;
			zIndex?: ConstantProperty;
		});

		/**
		 * Gets the event that is raised whenever a property or sub-property is changed or modified.
		 * @memberof EllipseGraphics.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets or sets the numeric Property specifying the semi-major axis.
		 * @memberof EllipseGraphics.prototype
		 * @type {Property}
		 */
		semiMajorAxis: Property;

		/**
		 * Gets or sets the numeric Property specifying the semi-minor axis.
		 * @memberof EllipseGraphics.prototype
		 * @type {Property}
		 */
		semiMinorAxis: Property;

		/**
		 * Gets or sets the numeric property specifying the rotation of the ellipse clockwise from north.
		 * @memberof EllipseGraphics.prototype
		 * @type {Property}
		 * @default 0
		 */
		rotation: Property;

		/**
		 * Gets or sets the boolean Property specifying the visibility of the ellipse.
		 * @memberof EllipseGraphics.prototype
		 * @type {Property}
		 * @default true
		 */
		show: Property;

		/**
		 * Gets or sets the Property specifying the material used to fill the ellipse.
		 * @memberof EllipseGraphics.prototype
		 * @type {MaterialProperty}
		 * @default Color.WHITE
		 */
		material: MaterialProperty;

		/**
		 * Gets or sets the numeric Property specifying the altitude of the ellipse.
		 * @memberof EllipseGraphics.prototype
		 * @type {Property}
		 * @default 0.0
		 */
		height: Property;

		/**
		 * Gets or sets the Property specifying the {@link HeightReference}.
		 * @memberof EllipseGraphics.prototype
		 * @type {Property}
		 * @default HeightReference.NONE
		 */
		heightReference: Property;

		/**
		 * Gets or sets the numeric Property specifying the altitude of the ellipse extrusion.
		 * Setting this property creates volume starting at height and ending at this altitude.
		 * @memberof EllipseGraphics.prototype
		 * @type {Property}
		 */
		extrudedHeight: Property;

		/**
		 * Gets or sets the Property specifying the extruded {@link HeightReference}.
		 * @memberof EllipseGraphics.prototype
		 * @type {Property}
		 * @default HeightReference.NONE
		 */
		extrudedHeightReference: Property;

		/**
		 * Gets or sets the numeric Property specifying the angular distance between points on the ellipse.
		 * @memberof EllipseGraphics.prototype
		 * @type {Property}
		 * @default {CesiumMath.RADIANS_PER_DEGREE}
		 */
		granularity: Property;

		/**
		 * Gets or sets the numeric property specifying the rotation of the ellipse texture counter-clockwise from north.
		 * @memberof EllipseGraphics.prototype
		 * @type {Property}
		 * @default 0
		 */
		stRotation: Property;

		/**
		 * Gets or sets the boolean Property specifying whether the ellipse is filled with the provided material.
		 * @memberof EllipseGraphics.prototype
		 * @type {Property}
		 * @default true
		 */
		fill: Property;

		/**
		 * Gets or sets the Property specifying whether the ellipse is outlined.
		 * @memberof EllipseGraphics.prototype
		 * @type {Property}
		 * @default false
		 */
		outline: Property;

		/**
		 * Gets or sets the Property specifying the {@link Color} of the outline.
		 * @memberof EllipseGraphics.prototype
		 * @type {Property}
		 * @default Color.BLACK
		 */
		outlineColor: Property;

		/**
		 * Gets or sets the numeric Property specifying the width of the outline.
		 * @memberof EllipseGraphics.prototype
		 * @type {Property}
		 * @default 1.0
		 */
		outlineWidth: Property;

		/**
		 * Gets or sets the numeric Property specifying the number of vertical lines to draw along the perimeter for the outline.
		 * @memberof EllipseGraphics.prototype
		 * @type {Property}
		 * @default 16
		 */
		numberOfVerticalLines: Property;

		/**
		 * Get or sets the enum Property specifying whether the ellipse
		 * casts or receives shadows from each light source.
		 * @memberof EllipseGraphics.prototype
		 * @type {Property}
		 * @default ShadowMode.DISABLED
		 */
		shadows: Property;

		/**
		 * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this ellipse will be displayed.
		 * @memberof EllipseGraphics.prototype
		 * @type {Property}
		 */
		distanceDisplayCondition: Property;

		/**
		 * Gets or sets the {@link ClassificationType} Property specifying whether this ellipse will classify terrain, 3D Tiles, or both when on the ground.
		 * @memberof EllipseGraphics.prototype
		 * @type {Property}
		 * @default ClassificationType.TERRAIN
		 */
		classificationType: Property;

		/**
		 * Gets or sets the zIndex Property specifying the ellipse ordering.  Only has an effect if the ellipse is constant and neither height or extrudedHeight are specified
		 * @memberof EllipseGraphics.prototype
		 * @type {ConstantProperty}
		 * @default 0
		 */
		zIndex: ConstantProperty;

		/**
		 * Duplicates this instance.
		 * @param {EllipseGraphics} [result] The object onto which to store the result.
		 * @returns {EllipseGraphics} The modified result parameter or a new instance if one was not provided.
		 */
		clone(result?: EllipseGraphics): EllipseGraphics;

		/**
		 * Assigns each unassigned property on this object to the value
		 * of the same property on the provided source object.
		 * @param {EllipseGraphics} source The object to be merged into this object.
		 */
		merge(source: EllipseGraphics): void;

	}

	/**
	 * A {@link GeometryUpdater} for ellipsoids.
	 * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
	 * @alias EllipsoidGeometryUpdater
	 * @constructor
	 * @param {Entity} entity The entity containing the geometry to be visualized.
	 * @param {Scene} scene The scene where visualization is taking place.
	 */
	class EllipsoidGeometryUpdater {
		constructor(entity: Entity, scene: Scene);

		/**
		 * Gets the terrain offset property
		 * @type {TerrainOffsetProperty}
		 * @memberof EllipsoidGeometryUpdater.prototype
		 * @readonly
		 */
		readonly terrainOffsetProperty: any;

		/**
		 * Creates the geometry instance which represents the fill of the geometry.
		 * @param {JulianDate} time The time to use when retrieving initial attribute values.
		 * @param {Boolean} [skipModelMatrix=false] Whether to compute a model matrix for the geometry instance
		 * @param {Matrix4} [modelMatrixResult] Used to store the result of the model matrix calculation
		 * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.
		 * @exception {DeveloperError} This instance does not represent a filled geometry.
		 */
		createFillGeometryInstance(time: JulianDate, skipModelMatrix?: boolean, modelMatrixResult?: Matrix4): GeometryInstance;

		/**
		 * Creates the geometry instance which represents the outline of the geometry.
		 * @param {JulianDate} time The time to use when retrieving initial attribute values.
		 * @param {Boolean} [skipModelMatrix=false] Whether to compute a model matrix for the geometry instance
		 * @param {Matrix4} [modelMatrixResult] Used to store the result of the model matrix calculation
		 * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.
		 * @exception {DeveloperError} This instance does not represent an outlined geometry.
		 */
		createOutlineGeometryInstance(time: JulianDate, skipModelMatrix?: boolean, modelMatrixResult?: Matrix4): GeometryInstance;

	}

	/**
	 * Describe an ellipsoid or sphere.  The center position and orientation are determined by the containing {@link Entity}.
	 * @alias EllipsoidGraphics
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Property} [options.heightReference] A Property specifying what the height from the entity position is relative to.
	 * @param {Property} [options.radii] A {@link Cartesian3} Property specifying the radii of the ellipsoid.
	 * @param {Property} [options.show=true] A boolean Property specifying the visibility of the ellipsoid.
	 * @param {Property} [options.fill=true] A boolean Property specifying whether the ellipsoid is filled with the provided material.
	 * @param {MaterialProperty} [options.material=Color.WHITE] A Property specifying the material used to fill the ellipsoid.
	 * @param {Property} [options.outline=false] A boolean Property specifying whether the ellipsoid is outlined.
	 * @param {Property} [options.outlineColor=Color.BLACK] A Property specifying the {@link Color} of the outline.
	 * @param {Property} [options.outlineWidth=1.0] A numeric Property specifying the width of the outline.
	 * @param {Property} [options.subdivisions=128] A Property specifying the number of samples per outline ring, determining the granularity of the curvature.
	 * @param {Property} [options.stackPartitions=64] A Property specifying the number of stacks.
	 * @param {Property} [options.slicePartitions=64] A Property specifying the number of radial slices.
	 * @param {Property} [options.shadows=ShadowMode.DISABLED] An enum Property specifying whether the ellipsoid casts or receives shadows from each light source.
	 * @param {Property} [options.distanceDisplayCondition] A Property specifying at what distance from the camera that this ellipsoid will be displayed.
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Spheres%20and%20Ellipsoids.html|Cesium Sandcastle Spheres and Ellipsoids Demo}
	 */
	class EllipsoidGraphics {
		constructor(options?: {
			heightReference?: Property;
			radii?: Property;
			show?: Property;
			fill?: Property;
			material?: MaterialProperty;
			outline?: Property;
			outlineColor?: Property;
			outlineWidth?: Property;
			subdivisions?: Property;
			stackPartitions?: Property;
			slicePartitions?: Property;
			shadows?: Property;
			distanceDisplayCondition?: Property;
		});

		/**
		 * Gets the event that is raised whenever a property or sub-property is changed or modified.
		 * @memberof EllipsoidGraphics.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets or sets the Property specifying the {@link HeightReference}.
		 * @memberof EllipsoidGraphics.prototype
		 * @type {Property}
		 * @default HeightReference.NONE
		 */
		heightReference: Property;

		/**
		 * Gets or sets the boolean Property specifying the visibility of the ellipsoid.
		 * @memberof EllipsoidGraphics.prototype
		 * @type {Property}
		 * @default true
		 */
		show: Property;

		/**
		 * Gets or sets the {@link Cartesian3} {@link Property} specifying the radii of the ellipsoid.
		 * @memberof EllipsoidGraphics.prototype
		 * @type {Property}
		 */
		radii: Property;

		/**
		 * Gets or sets the Property specifying the material used to fill the ellipsoid.
		 * @memberof EllipsoidGraphics.prototype
		 * @type {MaterialProperty}
		 * @default Color.WHITE
		 */
		material: MaterialProperty;

		/**
		 * Gets or sets the boolean Property specifying whether the ellipsoid is filled with the provided material.
		 * @memberof EllipsoidGraphics.prototype
		 * @type {Property}
		 * @default true
		 */
		fill: Property;

		/**
		 * Gets or sets the Property specifying whether the ellipsoid is outlined.
		 * @memberof EllipsoidGraphics.prototype
		 * @type {Property}
		 * @default false
		 */
		outline: Property;

		/**
		 * Gets or sets the Property specifying the {@link Color} of the outline.
		 * @memberof EllipsoidGraphics.prototype
		 * @type {Property}
		 * @default Color.BLACK
		 */
		outlineColor: Property;

		/**
		 * Gets or sets the numeric Property specifying the width of the outline.
		 * @memberof EllipsoidGraphics.prototype
		 * @type {Property}
		 * @default 1.0
		 */
		outlineWidth: Property;

		/**
		 * Gets or sets the Property specifying the number of stacks.
		 * @memberof EllipsoidGraphics.prototype
		 * @type {Property}
		 * @default 64
		 */
		stackPartitions: Property;

		/**
		 * Gets or sets the Property specifying the number of radial slices.
		 * @memberof EllipsoidGraphics.prototype
		 * @type {Property}
		 * @default 64
		 */
		slicePartitions: Property;

		/**
		 * Gets or sets the Property specifying the number of samples per outline ring, determining the granularity of the curvature.
		 * @memberof EllipsoidGraphics.prototype
		 * @type {Property}
		 * @default 128
		 */
		subdivisions: Property;

		/**
		 * Get or sets the enum Property specifying whether the ellipsoid
		 * casts or receives shadows from each light source.
		 * @memberof EllipsoidGraphics.prototype
		 * @type {Property}
		 * @default ShadowMode.DISABLED
		 */
		shadows: Property;

		/**
		 * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this ellipsoid will be displayed.
		 * @memberof EllipsoidGraphics.prototype
		 * @type {Property}
		 */
		distanceDisplayCondition: Property;

		/**
		 * Duplicates this instance.
		 * @param {EllipsoidGraphics} [result] The object onto which to store the result.
		 * @returns {EllipsoidGraphics} The modified result parameter or a new instance if one was not provided.
		 */
		clone(result?: EllipsoidGraphics): EllipsoidGraphics;

		/**
		 * Assigns each unassigned property on this object to the value
		 * of the same property on the provided source object.
		 * @param {EllipsoidGraphics} source The object to be merged into this object.
		 */
		merge(source: EllipsoidGraphics): void;

	}

	/**
	 * Defines how screen space objects (billboards, points, labels) are clustered.
	 * @param {Object} [options] An object with the following properties:
	 * @param {Boolean} [options.enabled=false] Whether or not to enable clustering.
	 * @param {Number} [options.pixelRange=80] The pixel range to extend the screen space bounding box.
	 * @param {Number} [options.minimumClusterSize=2] The minimum number of screen space objects that can be clustered.
	 * @param {Boolean} [options.clusterBillboards=true] Whether or not to cluster the billboards of an entity.
	 * @param {Boolean} [options.clusterLabels=true] Whether or not to cluster the labels of an entity.
	 * @param {Boolean} [options.clusterPoints=true] Whether or not to cluster the points of an entity.
	 * @alias EntityCluster
	 * @constructor
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Clustering.html|Cesium Sandcastle Clustering Demo}
	 */
	class EntityCluster {
		constructor(options?: {
			enabled?: boolean;
			pixelRange?: number;
			minimumClusterSize?: number;
			clusterBillboards?: boolean;
			clusterLabels?: boolean;
			clusterPoints?: boolean;
		});

		/**
		 * Gets or sets whether clustering is enabled.
		 * @memberof EntityCluster.prototype
		 * @type {Boolean}
		 */
		enabled: boolean;

		/**
		 * Gets or sets the pixel range to extend the screen space bounding box.
		 * @memberof EntityCluster.prototype
		 * @type {Number}
		 */
		pixelRange: number;

		/**
		 * Gets or sets the minimum number of screen space objects that can be clustered.
		 * @memberof EntityCluster.prototype
		 * @type {Number}
		 */
		minimumClusterSize: number;

		/**
		 * Gets the event that will be raised when a new cluster will be displayed. The signature of the event listener is {@link EntityCluster~newClusterFunction}.
		 * @memberof EntityCluster.prototype
		 * @type {Event}
		 */
		clusterEvent: Event;

		/**
		 * Gets or sets whether clustering billboard entities is enabled.
		 * @memberof EntityCluster.prototype
		 * @type {Boolean}
		 */
		clusterBillboards: boolean;

		/**
		 * Gets or sets whether clustering labels entities is enabled.
		 * @memberof EntityCluster.prototype
		 * @type {Boolean}
		 */
		clusterLabels: boolean;

		/**
		 * Gets or sets whether clustering point entities is enabled.
		 * @memberof EntityCluster.prototype
		 * @type {Boolean}
		 */
		clusterPoints: boolean;

		/**
		 * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
		 * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
		 * <p>
		 * Unlike other objects that use WebGL resources, this object can be reused. For example, if a data source is removed
		 * from a data source collection and added to another.
		 * </p>
		 */
		destroy(): void;

	}

	/**
	 * An observable collection of {@link Entity} instances where each entity has a unique id.
	 * @alias EntityCollection
	 * @constructor
	 * @param {DataSource|CompositeEntityCollection} [owner] The data source (or composite entity collection) which created this collection.
	 */
	class EntityCollection {
		constructor(owner?: DataSource | CompositeEntityCollection);

		/**
		 * Prevents {@link EntityCollection#collectionChanged} events from being raised
		 * until a corresponding call is made to {@link EntityCollection#resumeEvents}, at which
		 * point a single event will be raised that covers all suspended operations.
		 * This allows for many items to be added and removed efficiently.
		 * This function can be safely called multiple times as long as there
		 * are corresponding calls to {@link EntityCollection#resumeEvents}.
		 */
		suspendEvents(): void;

		/**
		 * Resumes raising {@link EntityCollection#collectionChanged} events immediately
		 * when an item is added or removed.  Any modifications made while while events were suspended
		 * will be triggered as a single event when this function is called.
		 * This function is reference counted and can safely be called multiple times as long as there
		 * are corresponding calls to {@link EntityCollection#resumeEvents}.
		 * @exception {DeveloperError} resumeEvents can not be called before suspendEvents.
		 */
		resumeEvents(): void;

		/**
		 * The signature of the event generated by {@link EntityCollection#collectionChanged}.
		 * @function
		 * @param {EntityCollection} collection The collection that triggered the event.
		 * @param {Entity[]} added The array of {@link Entity} instances that have been added to the collection.
		 * @param {Entity[]} removed The array of {@link Entity} instances that have been removed from the collection.
		 * @param {Entity[]} changed The array of {@link Entity} instances that have been modified.
		 */
		static collectionChangedEventFunction(collection: EntityCollection, added: Entity[], removed: Entity[], changed: Entity[]): void;

		/**
		 * Gets the event that is fired when entities are added or removed from the collection.
		 * The generated event is a {@link EntityCollection.collectionChangedEventFunction}.
		 * @memberof EntityCollection.prototype
		 * @readonly
		 * @type {Event}
		 */
		readonly collectionChanged: Event;

		/**
		 * Gets a globally unique identifier for this collection.
		 * @memberof EntityCollection.prototype
		 * @readonly
		 * @type {String}
		 */
		readonly id: string;

		/**
		 * Gets the array of Entity instances in the collection.
		 * This array should not be modified directly.
		 * @memberof EntityCollection.prototype
		 * @readonly
		 * @type {Entity[]}
		 */
		readonly values: Entity[];

		/**
		 * Gets whether or not this entity collection should be
		 * displayed.  When true, each entity is only displayed if
		 * its own show property is also true.
		 * @memberof EntityCollection.prototype
		 * @type {Boolean}
		 */
		show: boolean;

		/**
		 * Gets the owner of this entity collection, ie. the data source or composite entity collection which created it.
		 * @memberof EntityCollection.prototype
		 * @readonly
		 * @type {DataSource|CompositeEntityCollection}
		 */
		readonly owner: DataSource | CompositeEntityCollection;

		/**
		 * Computes the maximum availability of the entities in the collection.
		 * If the collection contains a mix of infinitely available data and non-infinite data,
		 * it will return the interval pertaining to the non-infinite data only.  If all
		 * data is infinite, an infinite interval will be returned.
		 * @returns {TimeInterval} The availability of entities in the collection.
		 */
		computeAvailability(): TimeInterval;

		/**
		 * Add an entity to the collection.
		 * @param {Entity} entity The entity to be added.
		 * @returns {Entity} The entity that was added.
		 * @exception {DeveloperError} An entity with <entity.id> already exists in this collection.
		 */
		add(entity: Entity): Entity;

		/**
		 * Removes an entity from the collection.
		 * @param {Entity} entity The entity to be removed.
		 * @returns {Boolean} true if the item was removed, false if it did not exist in the collection.
		 */
		remove(entity: Entity): boolean;

		/**
		 * Returns true if the provided entity is in this collection, false otherwise.
		 * @param {Entity} entity The entity.
		 * @returns {Boolean} true if the provided entity is in this collection, false otherwise.
		 */
		contains(entity: Entity): boolean;

		/**
		 * Removes an entity with the provided id from the collection.
		 * @param {String} id The id of the entity to remove.
		 * @returns {Boolean} true if the item was removed, false if no item with the provided id existed in the collection.
		 */
		removeById(id: string): boolean;

		/**
		 * Removes all Entities from the collection.
		 */
		removeAll(): void;

		/**
		 * Gets an entity with the specified id.
		 * @param {String} id The id of the entity to retrieve.
		 * @returns {Entity} The entity with the provided id or undefined if the id did not exist in the collection.
		 */
		getById(id: string): Entity;

		/**
		 * Gets an entity with the specified id or creates it and adds it to the collection if it does not exist.
		 * @param {String} id The id of the entity to retrieve or create.
		 * @returns {Entity} The new or existing object.
		 */
		getOrCreateEntity(id: string): Entity;

	}

	/**
	 * A utility object for tracking an entity with the camera.
	 * @alias EntityView
	 * @constructor
	 * @param {Entity} entity The entity to track with the camera.
	 * @param {Scene} scene The scene to use.
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to use for orienting the camera.
	 */
	class EntityView {
		constructor(entity: Entity, scene: Scene, ellipsoid?: Ellipsoid);

		/**
		 * The entity to track with the camera.
		 * @type {Entity}
		 */
		entity: Entity;

		/**
		 * The scene in which to track the object.
		 * @type {Scene}
		 */
		scene: Scene;

		/**
		 * The ellipsoid to use for orienting the camera.
		 * @type {Ellipsoid}
		 */
		ellipsoid: Ellipsoid;

		/**
		 * The bounding sphere of the object.
		 * @type {BoundingSphere}
		 */
		boundingSphere: BoundingSphere;

		/**
		 * Gets or sets a camera offset that will be used to
		 * initialize subsequent EntityViews.
		 * @memberof EntityView
		 * @type {Cartesian3}
		 */
		static defaultOffset3D: Cartesian3;

		/**
		 * Should be called each animation frame to update the camera
		 * to the latest settings.
		 * @param {JulianDate} time The current animation time.
		 * @param {BoundingSphere} [boundingSphere] bounding sphere of the object.
		 */
		update(time: JulianDate, boundingSphere?: BoundingSphere): void;

	}

	/**
	 * A {@link DataSource} which processes both
	 * {@link http://www.geojson.org/|GeoJSON} and {@link https://github.com/mbostock/topojson|TopoJSON} data.
	 * {@link https://github.com/mapbox/simplestyle-spec|simplestyle-spec} properties will also be used if they
	 * are present.
	 * @alias GeoJsonDataSource
	 * @constructor
	 * @param {String} [name] The name of this data source.  If undefined, a name will be taken from
	 *                        the name of the GeoJSON file.
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=GeoJSON%20and%20TopoJSON.html|Cesium Sandcastle GeoJSON and TopoJSON Demo}
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=GeoJSON%20simplestyle.html|Cesium Sandcastle GeoJSON simplestyle Demo}
	 * @example
	 * var viewer = new Cesium.Viewer('cesiumContainer');
	 * viewer.dataSources.add(Cesium.GeoJsonDataSource.load('../../SampleData/ne_10m_us_states.topojson', {
	 *   stroke: Cesium.Color.HOTPINK,
	 *   fill: Cesium.Color.PINK,
	 *   strokeWidth: 3,
	 *   markerSymbol: '?'
	 * }));
	 */
	class GeoJsonDataSource {
		constructor(name?: string);

		/**
		 * Creates a Promise to a new instance loaded with the provided GeoJSON or TopoJSON data.
		 * @param {Resource|String|Object} data A url, GeoJSON object, or TopoJSON object to be loaded.
		 * @param {Object} [options] An object with the following properties:
		 * @param {String} [options.sourceUri] Overrides the url to use for resolving relative links.
		 * @param {Number} [options.markerSize=GeoJsonDataSource.markerSize] The default size of the map pin created for each point, in pixels.
		 * @param {String} [options.markerSymbol=GeoJsonDataSource.markerSymbol] The default symbol of the map pin created for each point.
		 * @param {Color} [options.markerColor=GeoJsonDataSource.markerColor] The default color of the map pin created for each point.
		 * @param {Color} [options.stroke=GeoJsonDataSource.stroke] The default color of polylines and polygon outlines.
		 * @param {Number} [options.strokeWidth=GeoJsonDataSource.strokeWidth] The default width of polylines and polygon outlines.
		 * @param {Color} [options.fill=GeoJsonDataSource.fill] The default color for polygon interiors.
		 * @param {Boolean} [options.clampToGround=GeoJsonDataSource.clampToGround] true if we want the geometry features (polygons or linestrings) clamped to the ground.
		 * @returns {Promise.<GeoJsonDataSource>} A promise that will resolve when the data is loaded.
		 */
		static load(data: Resource | string | any, options?: {
			sourceUri?: string;
			markerSize?: number;
			markerSymbol?: string;
			markerColor?: Color;
			stroke?: Color;
			strokeWidth?: number;
			fill?: Color;
			clampToGround?: boolean;
		}): any;

		/**
		 * Gets or sets the default size of the map pin created for each point, in pixels.
		 * @memberof GeoJsonDataSource
		 * @type {Number}
		 * @default 48
		 */
		static markerSize: number;

		/**
		 * Gets or sets the default symbol of the map pin created for each point.
		 * This can be any valid {@link http://mapbox.com/maki/|Maki} identifier, any single character,
		 * or blank if no symbol is to be used.
		 * @memberof GeoJsonDataSource
		 * @type {String}
		 */
		static markerSymbol: string;

		/**
		 * Gets or sets the default color of the map pin created for each point.
		 * @memberof GeoJsonDataSource
		 * @type {Color}
		 * @default Color.ROYALBLUE
		 */
		static markerColor: Color;

		/**
		 * Gets or sets the default color of polylines and polygon outlines.
		 * @memberof GeoJsonDataSource
		 * @type {Color}
		 * @default Color.BLACK
		 */
		static stroke: Color;

		/**
		 * Gets or sets the default width of polylines and polygon outlines.
		 * @memberof GeoJsonDataSource
		 * @type {Number}
		 * @default 2.0
		 */
		static strokeWidth: number;

		/**
		 * Gets or sets default color for polygon interiors.
		 * @memberof GeoJsonDataSource
		 * @type {Color}
		 * @default Color.YELLOW
		 */
		static fill: Color;

		/**
		 * Gets or sets default of whether to clamp to the ground.
		 * @memberof GeoJsonDataSource
		 * @type {Boolean}
		 * @default false
		 */
		static clampToGround: boolean;

		/**
		 * Gets an object that maps the name of a crs to a callback function which takes a GeoJSON coordinate
		 * and transforms it into a WGS84 Earth-fixed Cartesian.  Older versions of GeoJSON which
		 * supported the EPSG type can be added to this list as well, by specifying the complete EPSG name,
		 * for example 'EPSG:4326'.
		 * @memberof GeoJsonDataSource
		 * @type {Object}
		 */
		static crsNames: any;

		/**
		 * Gets an object that maps the href property of a crs link to a callback function
		 * which takes the crs properties object and returns a Promise that resolves
		 * to a function that takes a GeoJSON coordinate and transforms it into a WGS84 Earth-fixed Cartesian.
		 * Items in this object take precedence over those defined in <code>crsLinkHrefs</code>, assuming
		 * the link has a type specified.
		 * @memberof GeoJsonDataSource
		 * @type {Object}
		 */
		static crsLinkHrefs: any;

		/**
		 * Gets an object that maps the type property of a crs link to a callback function
		 * which takes the crs properties object and returns a Promise that resolves
		 * to a function that takes a GeoJSON coordinate and transforms it into a WGS84 Earth-fixed Cartesian.
		 * Items in <code>crsLinkHrefs</code> take precedence over this object.
		 * @memberof GeoJsonDataSource
		 * @type {Object}
		 */
		static crsLinkTypes: any;

		/**
		 * Gets or sets a human-readable name for this instance.
		 * @memberof GeoJsonDataSource.prototype
		 * @type {String}
		 */
		name: string;

		/**
		 * This DataSource only defines static data, therefore this property is always undefined.
		 * @memberof GeoJsonDataSource.prototype
		 * @type {DataSourceClock}
		 */
		clock: DataSourceClock;

		/**
		 * Gets the collection of {@link Entity} instances.
		 * @memberof GeoJsonDataSource.prototype
		 * @type {EntityCollection}
		 */
		entities: EntityCollection;

		/**
		 * Gets a value indicating if the data source is currently loading data.
		 * @memberof GeoJsonDataSource.prototype
		 * @type {Boolean}
		 */
		isLoading: boolean;

		/**
		 * Gets an event that will be raised when the underlying data changes.
		 * @memberof GeoJsonDataSource.prototype
		 * @type {Event}
		 */
		changedEvent: Event;

		/**
		 * Gets an event that will be raised if an error is encountered during processing.
		 * @memberof GeoJsonDataSource.prototype
		 * @type {Event}
		 */
		errorEvent: Event;

		/**
		 * Gets an event that will be raised when the data source either starts or stops loading.
		 * @memberof GeoJsonDataSource.prototype
		 * @type {Event}
		 */
		loadingEvent: Event;

		/**
		 * Gets whether or not this data source should be displayed.
		 * @memberof GeoJsonDataSource.prototype
		 * @type {Boolean}
		 */
		show: boolean;

		/**
		 * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.
		 * @memberof GeoJsonDataSource.prototype
		 * @type {EntityCluster}
		 */
		clustering: EntityCluster;

		/**
		 * Asynchronously loads the provided GeoJSON or TopoJSON data, replacing any existing data.
		 * @param {Resource|String|Object} data A url, GeoJSON object, or TopoJSON object to be loaded.
		 * @param {Object} [options] An object with the following properties:
		 * @param {String} [options.sourceUri] Overrides the url to use for resolving relative links.
		 * @param {GeoJsonDataSource~describe} [options.describe=GeoJsonDataSource.defaultDescribeProperty] A function which returns a Property object (or just a string),
		 *                                                                                which converts the properties into an html description.
		 * @param {Number} [options.markerSize=GeoJsonDataSource.markerSize] The default size of the map pin created for each point, in pixels.
		 * @param {String} [options.markerSymbol=GeoJsonDataSource.markerSymbol] The default symbol of the map pin created for each point.
		 * @param {Color} [options.markerColor=GeoJsonDataSource.markerColor] The default color of the map pin created for each point.
		 * @param {Color} [options.stroke=GeoJsonDataSource.stroke] The default color of polylines and polygon outlines.
		 * @param {Number} [options.strokeWidth=GeoJsonDataSource.strokeWidth] The default width of polylines and polygon outlines.
		 * @param {Color} [options.fill=GeoJsonDataSource.fill] The default color for polygon interiors.
		 * @param {Boolean} [options.clampToGround=GeoJsonDataSource.clampToGround] true if we want the features clamped to the ground.
		 * @returns {Promise.<GeoJsonDataSource>} a promise that will resolve when the GeoJSON is loaded.
		 */
		load(data: Resource | string | any, options?: {
			sourceUri?: string;
			describe?: object;
			markerSize?: number;
			markerSymbol?: string;
			markerColor?: Color;
			stroke?: Color;
			strokeWidth?: number;
			fill?: Color;
			clampToGround?: boolean;
		}): any;

	}

	/**
	 * An abstract class for updating geometry entites.
	 * @alias GeometryUpdater
	 * @constructor
	 * @param {Object} options An object with the following properties:
	 * @param {Entity} options.entity The entity containing the geometry to be visualized.
	 * @param {Scene} options.scene The scene where visualization is taking place.
	 * @param {Object} options.geometryOptions Options for the geometry
	 * @param {String} options.geometryPropertyName The geometry property name
	 * @param {String[]} options.observedPropertyNames The entity properties this geometry cares about
	 */
	class GeometryUpdater {
		constructor(options: {
			entity: Entity;
			scene: Scene;
			geometryOptions: any;
			geometryPropertyName: string;
			observedPropertyNames: string[];
		});

		/**
		 * Gets the unique ID associated with this updater
		 * @memberof GeometryUpdater.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly id: string;

		/**
		 * Gets the entity associated with this geometry.
		 * @memberof GeometryUpdater.prototype
		 * @type {Entity}
		 * @readonly
		 */
		readonly entity: Entity;

		/**
		 * Gets a value indicating if the geometry has a fill component.
		 * @memberof GeometryUpdater.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly fillEnabled: boolean;

		/**
		 * Gets a value indicating if fill visibility varies with simulation time.
		 * @memberof GeometryUpdater.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly hasConstantFill: boolean;

		/**
		 * Gets the material property used to fill the geometry.
		 * @memberof GeometryUpdater.prototype
		 * @type {MaterialProperty}
		 * @readonly
		 */
		readonly fillMaterialProperty: MaterialProperty;

		/**
		 * Gets a value indicating if the geometry has an outline component.
		 * @memberof GeometryUpdater.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly outlineEnabled: boolean;

		/**
		 * Gets a value indicating if the geometry has an outline component.
		 * @memberof GeometryUpdater.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly hasConstantOutline: boolean;

		/**
		 * Gets the {@link Color} property for the geometry outline.
		 * @memberof GeometryUpdater.prototype
		 * @type {Property}
		 * @readonly
		 */
		readonly outlineColorProperty: Property;

		/**
		 * Gets the constant with of the geometry outline, in pixels.
		 * This value is only valid if isDynamic is false.
		 * @memberof GeometryUpdater.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly outlineWidth: number;

		/**
		 * Gets the property specifying whether the geometry
		 * casts or receives shadows from each light source.
		 * @memberof GeometryUpdater.prototype
		 * @type {Property}
		 * @readonly
		 */
		readonly shadowsProperty: Property;

		/**
		 * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this geometry will be displayed.
		 * @memberof GeometryUpdater.prototype
		 * @type {Property}
		 * @readonly
		 */
		readonly distanceDisplayConditionProperty: Property;

		/**
		 * Gets or sets the {@link ClassificationType} Property specifying if this geometry will classify terrain, 3D Tiles, or both when on the ground.
		 * @memberof GeometryUpdater.prototype
		 * @type {Property}
		 * @readonly
		 */
		readonly classificationTypeProperty: Property;

		/**
		 * Gets a value indicating if the geometry is time-varying.
		 * If true, all visualization is delegated to the {@link DynamicGeometryUpdater}
		 * returned by GeometryUpdater#createDynamicUpdater.
		 * @memberof GeometryUpdater.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isDynamic: boolean;

		/**
		 * Gets a value indicating if the geometry is closed.
		 * This property is only valid for static geometry.
		 * @memberof GeometryUpdater.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isClosed: boolean;

		/**
		 * Gets an event that is raised whenever the public properties
		 * of this updater change.
		 * @memberof GeometryUpdater.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly geometryChanged: boolean;

		/**
		 * Checks if the geometry is outlined at the provided time.
		 * @param {JulianDate} time The time for which to retrieve visibility.
		 * @returns {Boolean} true if geometry is outlined at the provided time, false otherwise.
		 */
		isOutlineVisible(time: JulianDate): boolean;

		/**
		 * Checks if the geometry is filled at the provided time.
		 * @param {JulianDate} time The time for which to retrieve visibility.
		 * @returns {Boolean} true if geometry is filled at the provided time, false otherwise.
		 */
		isFilled(time: JulianDate): boolean;

		/**
		 * Creates the geometry instance which represents the fill of the geometry.
		 * @function
		 * @param {JulianDate} time The time to use when retrieving initial attribute values.
		 * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.
		 * @exception {DeveloperError} This instance does not represent a filled geometry.
		 */
		createFillGeometryInstance(time: JulianDate): GeometryInstance;

		/**
		 * Creates the geometry instance which represents the outline of the geometry.
		 * @function
		 * @param {JulianDate} time The time to use when retrieving initial attribute values.
		 * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.
		 * @exception {DeveloperError} This instance does not represent an outlined geometry.
		 */
		createOutlineGeometryInstance(time: JulianDate): GeometryInstance;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * @returns {Boolean} True if this object was destroyed; otherwise, false.
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 */
		destroy(): void;

		/**
		 * Creates the dynamic updater to be used when GeometryUpdater#isDynamic is true.
		 * @param {PrimitiveCollection} primitives The primitive collection to use.
		 * @param {PrimitiveCollection} [groundPrimitives] The primitive collection to use for ground primitives.
		 * @returns {DynamicGeometryUpdater} The dynamic updater used to update the geometry each frame.
		 * @exception {DeveloperError} This instance does not represent dynamic geometry.
		 */
		createDynamicUpdater(primitives: PrimitiveCollection, groundPrimitives?: PrimitiveCollection): any;

	}

	/**
	 * A general purpose visualizer for geometry represented by {@link Primitive} instances.
	 * @alias GeometryVisualizer
	 * @constructor
	 * @param {Scene} scene The scene the primitives will be rendered in.
	 * @param {EntityCollection} entityCollection The entityCollection to visualize.
	 * @param {PrimitiveCollection} [primitives=scene.primitives] A collection to add primitives related to the entities
	 * @param {PrimitiveCollection} [groundPrimitives=scene.groundPrimitives] A collection to add ground primitives related to the entities
	 */
	class GeometryVisualizer {
		constructor(scene: Scene, entityCollection: EntityCollection, primitives?: PrimitiveCollection, groundPrimitives?: PrimitiveCollection);

		/**
		 * Updates all of the primitives created by this visualizer to match their
		 * Entity counterpart at the given time.
		 * @param {JulianDate} time The time to update to.
		 * @returns {Boolean} True if the visualizer successfully updated to the provided time,
		 * false if the visualizer is waiting for asynchronous primitives to be created.
		 */
		update(time: JulianDate): boolean;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * @returns {Boolean} True if this object was destroyed; otherwise, false.
		 */
		isDestroyed(): boolean;

		/**
		 * Removes and destroys all primitives created by this instance.
		 */
		destroy(): void;

	}

	/**
	 * A {@link MaterialProperty} that maps to grid {@link Material} uniforms.
	 * @alias GridMaterialProperty
	 * @param {Object} [options] Object with the following properties:
	 * @param {Property} [options.color=Color.WHITE] A Property specifying the grid {@link Color}.
	 * @param {Property} [options.cellAlpha=0.1] A numeric Property specifying cell alpha values.
	 * @param {Property} [options.lineCount=new Cartesian2(8, 8)] A {@link Cartesian2} Property specifying the number of grid lines along each axis.
	 * @param {Property} [options.lineThickness=new Cartesian2(1.0, 1.0)] A {@link Cartesian2} Property specifying the thickness of grid lines along each axis.
	 * @param {Property} [options.lineOffset=new Cartesian2(0.0, 0.0)] A {@link Cartesian2} Property specifying starting offset of grid lines along each axis.
	 * @constructor
	 */
	class GridMaterialProperty {
		constructor(options?: {
			color?: Property;
			cellAlpha?: Property;
			lineCount?: Property;
			lineThickness?: Property;
			lineOffset?: Property;
		});

		/**
		 * Gets a value indicating if this property is constant.  A property is considered
		 * constant if getValue always returns the same result for the current definition.
		 * @memberof GridMaterialProperty.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isConstant: boolean;

		/**
		 * Gets the event that is raised whenever the definition of this property changes.
		 * The definition is considered to have changed if a call to getValue would return
		 * a different result for the same time.
		 * @memberof GridMaterialProperty.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets or sets the Property specifying the grid {@link Color}.
		 * @memberof GridMaterialProperty.prototype
		 * @type {Property}
		 * @default Color.WHITE
		 */
		color: Property;

		/**
		 * Gets or sets the numeric Property specifying cell alpha values.
		 * @memberof GridMaterialProperty.prototype
		 * @type {Property}
		 * @default 0.1
		 */
		cellAlpha: Property;

		/**
		 * Gets or sets the {@link Cartesian2} Property specifying the number of grid lines along each axis.
		 * @memberof GridMaterialProperty.prototype
		 * @type {Property}
		 * @default new Cartesian2(8.0, 8.0)
		 */
		lineCount: Property;

		/**
		 * Gets or sets the {@link Cartesian2} Property specifying the thickness of grid lines along each axis.
		 * @memberof GridMaterialProperty.prototype
		 * @type {Property}
		 * @default new Cartesian2(1.0, 1.0)
		 */
		lineThickness: Property;

		/**
		 * Gets or sets the {@link Cartesian2} Property specifying the starting offset of grid lines along each axis.
		 * @memberof GridMaterialProperty.prototype
		 * @type {Property}
		 * @default new Cartesian2(0.0, 0.0)
		 */
		lineOffset: Property;

		/**
		 * Gets the {@link Material} type at the provided time.
		 * @param {JulianDate} time The time for which to retrieve the type.
		 * @returns {String} The type of material.
		 */
		getType(time: JulianDate): string;

		/**
		 * Gets the value of the property at the provided time.
		 * @param {JulianDate} time The time for which to retrieve the value.
		 * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValue(time: JulianDate, result?: any): any;

		/**
		 * Compares this property to the provided property and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Property} [other] The other property.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		equals(other?: Property): boolean;

	}

	/**
	 * A {@link MaterialProperty} that maps to image {@link Material} uniforms.
	 * @alias ImageMaterialProperty
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Property} [options.image] A Property specifying the Image, URL, Canvas, or Video.
	 * @param {Property} [options.repeat=new Cartesian2(1.0, 1.0)] A {@link Cartesian2} Property specifying the number of times the image repeats in each direction.
	 * @param {Property} [options.color=Color.WHITE] The color applied to the image
	 * @param {Property} [options.transparent=false] Set to true when the image has transparency (for example, when a png has transparent sections)
	 */
	class ImageMaterialProperty {
		constructor(options?: {
			image?: Property;
			repeat?: Property;
			color?: Property;
			transparent?: Property;
		});

		/**
		 * Gets a value indicating if this property is constant.  A property is considered
		 * constant if getValue always returns the same result for the current definition.
		 * @memberof ImageMaterialProperty.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isConstant: boolean;

		/**
		 * Gets the event that is raised whenever the definition of this property changes.
		 * The definition is considered to have changed if a call to getValue would return
		 * a different result for the same time.
		 * @memberof ImageMaterialProperty.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets or sets the Property specifying Image, URL, Canvas, or Video to use.
		 * @memberof ImageMaterialProperty.prototype
		 * @type {Property}
		 */
		image: Property;

		/**
		 * Gets or sets the {@link Cartesian2} Property specifying the number of times the image repeats in each direction.
		 * @memberof ImageMaterialProperty.prototype
		 * @type {Property}
		 * @default new Cartesian2(1, 1)
		 */
		repeat: Property;

		/**
		 * Gets or sets the Color Property specifying the desired color applied to the image.
		 * @memberof ImageMaterialProperty.prototype
		 * @type {Property}
		 * @default 1.0
		 */
		color: Property;

		/**
		 * Gets or sets the Boolean Property specifying whether the image has transparency
		 * @memberof ImageMaterialProperty.prototype
		 * @type {Property}
		 * @default 1.0
		 */
		transparent: Property;

		/**
		 * Gets the {@link Material} type at the provided time.
		 * @param {JulianDate} time The time for which to retrieve the type.
		 * @returns {String} The type of material.
		 */
		getType(time: JulianDate): string;

		/**
		 * Gets the value of the property at the provided time.
		 * @param {JulianDate} time The time for which to retrieve the value.
		 * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValue(time: JulianDate, result?: any): any;

		/**
		 * Compares this property to the provided property and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Property} [other] The other property.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		equals(other?: Property): boolean;

	}

	/**
	 * Representation of <Camera> from KML
	 * @alias KmlCamera
	 * @constructor
	 * @param {Cartesian3} position camera position
	 * @param {HeadingPitchRoll} headingPitchRoll camera orientation
	 */
	class KmlCamera {
		constructor(position: Cartesian3, headingPitchRoll: HeadingPitchRoll);

	}

	/**
	 * A {@link DataSource} which processes Keyhole Markup Language 2.2 (KML).
	 * <p>
	 * KML support in Cesium is incomplete, but a large amount of the standard,
	 * as well as Google's <code>gx</code> extension namespace, is supported. See Github issue
	 * {@link https://github.com/AnalyticalGraphicsInc/cesium/issues/873|#873} for a
	 * detailed list of what is and isn't support. Cesium will also write information to the
	 * console when it encounters most unsupported features.
	 * </p>
	 * <p>
	 * Non visual feature data, such as <code>atom:author</code> and <code>ExtendedData</code>
	 * is exposed via an instance of {@link KmlFeatureData}, which is added to each {@link Entity}
	 * under the <code>kml</code> property.
	 * </p>
	 * @alias KmlDataSource
	 * @constructor
	 * @param {Object} options An object with the following properties:
	 * @param {Camera} options.camera The camera that is used for viewRefreshModes and sending camera properties to network links.
	 * @param {Canvas} options.canvas The canvas that is used for sending viewer properties to network links.
	 * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The global ellipsoid used for geographical calculations.
	 * @see {@link http://www.opengeospatial.org/standards/kml/|Open Geospatial Consortium KML Standard}
	 * @see {@link https://developers.google.com/kml/|Google KML Documentation}
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=KML.html|Cesium Sandcastle KML Demo}
	 * @example
	 * var viewer = new Cesium.Viewer('cesiumContainer');
	 * viewer.dataSources.add(Cesium.KmlDataSource.load('../../SampleData/facilities.kmz',
	 *      {
	 *           camera: viewer.scene.camera,
	 *           canvas: viewer.scene.canvas
	 *      })
	 * );
	 */
	class KmlDataSource {
		constructor(options: {
			camera: Camera;
			canvas: any;
			ellipsoid?: Ellipsoid;
		});

		/**
		 * Creates a Promise to a new instance loaded with the provided KML data.
		 * @param {Resource|String|Document|Blob} data A url, parsed KML document, or Blob containing binary KMZ data or a parsed KML document.
		 * @param {Object} options An object with the following properties:
		 * @param {Camera} options.camera The camera that is used for viewRefreshModes and sending camera properties to network links.
		 * @param {Canvas} options.canvas The canvas that is used for sending viewer properties to network links.
		 * @param {String} [options.sourceUri] Overrides the url to use for resolving relative links and other KML network features.
		 * @param {Boolean} [options.clampToGround=false] true if we want the geometry features (Polygons, LineStrings and LinearRings) clamped to the ground.
		 * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The global ellipsoid used for geographical calculations.
		 * @returns {Promise.<KmlDataSource>} A promise that will resolve to a new KmlDataSource instance once the KML is loaded.
		 */
		static load(data: Resource | string | Document | Blob, options: {
			camera: Camera;
			canvas: any;
			sourceUri?: string;
			clampToGround?: boolean;
			ellipsoid?: Ellipsoid;
		}): any;

		/**
		 * Gets or sets a human-readable name for this instance.
		 * This will be automatically be set to the KML document name on load.
		 * @memberof KmlDataSource.prototype
		 * @type {String}
		 */
		name: string;

		/**
		 * Gets the clock settings defined by the loaded KML. This represents the total
		 * availability interval for all time-dynamic data. If the KML does not contain
		 * time-dynamic data, this value is undefined.
		 * @memberof KmlDataSource.prototype
		 * @type {DataSourceClock}
		 */
		clock: DataSourceClock;

		/**
		 * Gets the collection of {@link Entity} instances.
		 * @memberof KmlDataSource.prototype
		 * @type {EntityCollection}
		 */
		entities: EntityCollection;

		/**
		 * Gets a value indicating if the data source is currently loading data.
		 * @memberof KmlDataSource.prototype
		 * @type {Boolean}
		 */
		isLoading: boolean;

		/**
		 * Gets an event that will be raised when the underlying data changes.
		 * @memberof KmlDataSource.prototype
		 * @type {Event}
		 */
		changedEvent: Event;

		/**
		 * Gets an event that will be raised if an error is encountered during processing.
		 * @memberof KmlDataSource.prototype
		 * @type {Event}
		 */
		errorEvent: Event;

		/**
		 * Gets an event that will be raised when the data source either starts or stops loading.
		 * @memberof KmlDataSource.prototype
		 * @type {Event}
		 */
		loadingEvent: Event;

		/**
		 * Gets an event that will be raised when the data source refreshes a network link.
		 * @memberof KmlDataSource.prototype
		 * @type {Event}
		 */
		refreshEvent: Event;

		/**
		 * Gets an event that will be raised when the data source finds an unsupported node type.
		 * @memberof KmlDataSource.prototype
		 * @type {Event}
		 */
		unsupportedNodeEvent: Event;

		/**
		 * Gets whether or not this data source should be displayed.
		 * @memberof KmlDataSource.prototype
		 * @type {Boolean}
		 */
		show: boolean;

		/**
		 * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.
		 * @memberof KmlDataSource.prototype
		 * @type {EntityCluster}
		 */
		clustering: EntityCluster;

		/**
		 * Asynchronously loads the provided KML data, replacing any existing data.
		 * @param {Resource|String|Document|Blob} data A url, parsed KML document, or Blob containing binary KMZ data or a parsed KML document.
		 * @param {Object} [options] An object with the following properties:
		 * @param {Resource|String} [options.sourceUri] Overrides the url to use for resolving relative links and other KML network features.
		 * @param {Boolean} [options.clampToGround=false] true if we want the geometry features (Polygons, LineStrings and LinearRings) clamped to the ground. If true, lines will use corridors so use Entity.corridor instead of Entity.polyline.
		 * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The global ellipsoid used for geographical calculations.
		 * @returns {Promise.<KmlDataSource>} A promise that will resolve to this instances once the KML is loaded.
		 */
		load(data: Resource | string | Document | Blob, options?: {
			sourceUri?: Resource | string;
			clampToGround?: boolean;
			ellipsoid?: Ellipsoid;
		}): any;

		/**
		 * Updates any NetworkLink that require updating
		 * @function
		 * @param {JulianDate} time The simulation time.
		 * @returns {Boolean} True if this data source is ready to be displayed at the provided time, false otherwise.
		 */
		update(time: JulianDate): boolean;

	}

	/**
	 * Contains KML Feature data loaded into the <code>Entity.kml</code> property by {@link KmlDataSource}.
	 * @alias KmlFeatureData
	 * @constructor
	 */
	class KmlFeatureData {
		constructor();

		/**
		 * Gets the atom syndication format author field.
		 * @type Object
		 */
		author: any;

		/**
		 * Gets the link.
		 * @type Object
		 */
		link: any;

		/**
		 * Gets the unstructured address field.
		 * @type String
		 */
		address: string;

		/**
		 * Gets the phone number.
		 * @type String
		 */
		phoneNumber: string;

		/**
		 * Gets the snippet.
		 * @type String
		 */
		snippet: string;

		/**
		 * Gets the extended data, parsed into a JSON object.
		 * Currently only the <code>Data</code> property is supported.
		 * <code>SchemaData</code> and custom data are ignored.
		 * @type String
		 */
		extendedData: string;

	}

	/**
	 * @alias KmlLookAt
	 * @constructor
	 * @param {Cartesian3} position camera position
	 * @param {HeadingPitchRange} headingPitchRange camera orientation
	 */
	class KmlLookAt {
		constructor(position: Cartesian3, headingPitchRange: HeadingPitchRange);

	}

	/**
	 * @alias KmlTour
	 * @constructor
	 * @param {String} name name parsed from KML
	 * @param {String} id id parsed from KML
	 * @param {Array} playlist array with KMLTourFlyTos, KMLTourWaits and KMLTourSoundCues
	 */
	class KmlTour {
		constructor(name: string, id: string, playlist: any[]);

		/**
		 * Id of kml gx:Tour entry
		 * @type String
		 */
		id: string;

		/**
		 * Tour name
		 * @type String
		 */
		name: string;

		/**
		 * Index of current entry from playlist
		 * @type Number
		 */
		playlistIndex: number;

		/**
		 * Array of playlist entries
		 * @type Array
		 */
		playlist: any[];

		/**
		 * Event will be called when tour starts to play,
		 * before any playlist entry starts to play.
		 * @type Event
		 */
		tourStart: Event;

		/**
		 * Event will be called when all playlist entries are
		 * played, or tour playback being canceled.
		 * If tour playback was terminated, event callback will
		 * be called with terminated=true parameter.
		 * @type Event
		 */
		tourEnd: Event;

		/**
		 * Event will be called when entry from playlist starts to play.
		 * Event callback will be called with curent entry as first parameter.
		 * @type Event
		 */
		entryStart: Event;

		/**
		 * Event will be called when entry from playlist ends to play.
		 * Event callback will be called with following parameters:
		 * 1. entry - entry
		 * 2. terminated - true if playback was terminated by calling {@link KmlTour#stop}
		 * @type Event
		 */
		entryEnd: Event;

		/**
		 * Add entry to this tour playlist.
		 * @param {KmlTourFlyTo|KmlTourWait} entry an entry to add to the playlist.
		 */
		addPlaylistEntry(entry: KmlTourFlyTo | KmlTourWait): void;

		/**
		 * Play this tour.
		 * @param {Viewer} viewer viewer widget.
		 * @param {Object} [cameraOptions] these options will be merged with {@link Camera#flyTo}
		 * options for FlyTo playlist entries.
		 */
		play(viewer: any, cameraOptions?: any): void;

		/**
		 * Stop curently playing tour.
		 */
		stop(): void;

	}

	/**
	 * @alias KmlTourFlyTo
	 * @constructor
	 * @param {Number} duration entry duration
	 * @param {String} flyToMode KML fly to mode: bounce, smooth, etc
	 * @param {KmlCamera|KmlLookAt} view KmlCamera or KmlLookAt
	 */
	class KmlTourFlyTo {
		constructor(duration: number, flyToMode: string, view: KmlCamera | KmlLookAt);

		/**
		 * Play this playlist entry
		 * @param {KmlTourFlyTo~Function} done function which will be called when playback ends
		 * @param {Camera} camera Cesium camera
		 * @param {Object} [cameraOptions] which will be merged with camera flyTo options. See {@link Camera#flyTo}
		 */
		play(done: Function, camera: Camera, cameraOptions?: any): void;

		/**
		 * Stop execution of curent entry. Cancel camera flyTo
		 */
		stop(): void;

		/**
		 * Returns options for {@link Camera#flyTo} or {@link Camera#flyToBoundingSphere}
		 * depends on this.view type.
		 * @param {Object} cameraOptions options to merge with generated. See {@link Camera#flyTo}
		 * @returns {Object} {@link Camera#flyTo} or {@link Camera#flyToBoundingSphere} options
		 */
		getCameraOptions(cameraOptions: any): any;

	}

	/**
	 * @alias KmlTourWait
	 * @constructor
	 * @param {Number} duration entry duration
	 */
	class KmlTourWait {
		constructor(duration: number);

		/**
		 * Play this playlist entry
		 * @param {KmlTourWait~Function} done function which will be called when playback ends
		 */
		play(done: Function): void;

		/**
		 * Stop execution of curent entry, cancel curent timeout
		 */
		stop(): void;

	}

	/**
	 * Describes a two dimensional label located at the position of the containing {@link Entity}.
	 * <p>
	 * <div align='center'>
	 * <img src='Images/Label.png' width='400' height='300' /><br />
	 * Example labels
	 * </div>
	 * </p>
	 * @alias LabelGraphics
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Property} [options.text] A Property specifying the text. Explicit newlines '\n' are supported.
	 * @param {Property} [options.font='30px sans-serif'] A Property specifying the CSS font.
	 * @param {Property} [options.style=LabelStyle.FILL] A Property specifying the {@link LabelStyle}.
	 * @param {Property} [options.fillColor=Color.WHITE] A Property specifying the fill {@link Color}.
	 * @param {Property} [options.outlineColor=Color.BLACK] A Property specifying the outline {@link Color}.
	 * @param {Property} [options.outlineWidth=1.0] A numeric Property specifying the outline width.
	 * @param {Property} [options.show=true] A boolean Property specifying the visibility of the label.
	 * @param {Property} [options.showBackground=false] A boolean Property specifying the visibility of the background behind the label.
	 * @param {Property} [options.backgroundColor=new Color(0.165, 0.165, 0.165, 0.8)] A Property specifying the background {@link Color}.
	 * @param {Property} [options.backgroundPadding=new Cartesian2(7, 5)] A {@link Cartesian2} Property specifying the horizontal and vertical background padding in pixels.
	 * @param {Property} [options.scale=1.0] A numeric Property specifying the scale to apply to the text.
	 * @param {Property} [options.horizontalOrigin=HorizontalOrigin.CENTER] A Property specifying the {@link HorizontalOrigin}.
	 * @param {Property} [options.verticalOrigin=VerticalOrigin.CENTER] A Property specifying the {@link VerticalOrigin}.
	 * @param {Property} [options.eyeOffset=Cartesian3.ZERO] A {@link Cartesian3} Property specifying the eye offset.
	 * @param {Property} [options.pixelOffset=Cartesian2.ZERO] A {@link Cartesian2} Property specifying the pixel offset.
	 * @param {Property} [options.translucencyByDistance] A {@link NearFarScalar} Property used to set translucency based on distance from the camera.
	 * @param {Property} [options.pixelOffsetScaleByDistance] A {@link NearFarScalar} Property used to set pixelOffset based on distance from the camera.
	 * @param {Property} [options.scaleByDistance] A {@link NearFarScalar} Property used to set scale based on distance from the camera.
	 * @param {Property} [options.heightReference=HeightReference.NONE] A Property specifying what the height is relative to.
	 * @param {Property} [options.distanceDisplayCondition] A Property specifying at what distance from the camera that this label will be displayed.
	 * @param {Property} [options.disableDepthTestDistance] A Property specifying the distance from the camera at which to disable the depth test to.
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Labels.html|Cesium Sandcastle Labels Demo}
	 */
	class LabelGraphics {
		constructor(options?: {
			text?: Property;
			font?: Property;
			style?: Property;
			fillColor?: Property;
			outlineColor?: Property;
			outlineWidth?: Property;
			show?: Property;
			showBackground?: Property;
			backgroundColor?: Property;
			backgroundPadding?: Property;
			scale?: Property;
			horizontalOrigin?: Property;
			verticalOrigin?: Property;
			eyeOffset?: Property;
			pixelOffset?: Property;
			translucencyByDistance?: Property;
			pixelOffsetScaleByDistance?: Property;
			scaleByDistance?: Property;
			heightReference?: Property;
			distanceDisplayCondition?: Property;
			disableDepthTestDistance?: Property;
		});

		/**
		 * Gets the event that is raised whenever a property or sub-property is changed or modified.
		 * @memberof LabelGraphics.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets or sets the string Property specifying the text of the label.
		 * Explicit newlines '\n' are supported.
		 * @memberof LabelGraphics.prototype
		 * @type {Property}
		 */
		text: Property;

		/**
		 * Gets or sets the string Property specifying the font in CSS syntax.
		 * @memberof LabelGraphics.prototype
		 * @type {Property}
		 * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/font|CSS font on MDN}
		 */
		font: Property;

		/**
		 * Gets or sets the Property specifying the {@link LabelStyle}.
		 * @memberof LabelGraphics.prototype
		 * @type {Property}
		 */
		style: Property;

		/**
		 * Gets or sets the Property specifying the fill {@link Color}.
		 * @memberof LabelGraphics.prototype
		 * @type {Property}
		 */
		fillColor: Property;

		/**
		 * Gets or sets the Property specifying the outline {@link Color}.
		 * @memberof LabelGraphics.prototype
		 * @type {Property}
		 */
		outlineColor: Property;

		/**
		 * Gets or sets the numeric Property specifying the outline width.
		 * @memberof LabelGraphics.prototype
		 * @type {Property}
		 */
		outlineWidth: Property;

		/**
		 * Gets or sets the Property specifying the {@link HorizontalOrigin}.
		 * @memberof LabelGraphics.prototype
		 * @type {Property}
		 */
		horizontalOrigin: Property;

		/**
		 * Gets or sets the Property specifying the {@link VerticalOrigin}.
		 * @memberof LabelGraphics.prototype
		 * @type {Property}
		 */
		verticalOrigin: Property;

		/**
		 * Gets or sets the {@link Cartesian3} Property specifying the label's offset in eye coordinates.
		 * Eye coordinates is a left-handed coordinate system, where <code>x</code> points towards the viewer's
		 * right, <code>y</code> points up, and <code>z</code> points into the screen.
		 * <p>
		 * An eye offset is commonly used to arrange multiple labels or objects at the same position, e.g., to
		 * arrange a label above its corresponding 3D model.
		 * </p>
		 * Below, the label is positioned at the center of the Earth but an eye offset makes it always
		 * appear on top of the Earth regardless of the viewer's or Earth's orientation.
		 * <p>
		 * <div align='center'>
		 * <table border='0' cellpadding='5'><tr>
		 * <td align='center'><img src='Images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>
		 * <td align='center'><img src='Images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>
		 * </tr></table>
		 * <code>l.eyeOffset = new Cartesian3(0.0, 8000000.0, 0.0);</code><br /><br />
		 * </div>
		 * </p>
		 * @memberof LabelGraphics.prototype
		 * @type {Property}
		 * @default Cartesian3.ZERO
		 */
		eyeOffset: Property;

		/**
		 * Gets or sets the Property specifying the {@link HeightReference}.
		 * @memberof LabelGraphics.prototype
		 * @type {Property}
		 * @default HeightReference.NONE
		 */
		heightReference: Property;

		/**
		 * Gets or sets the {@link Cartesian2} Property specifying the label's pixel offset in screen space
		 * from the origin of this label.  This is commonly used to align multiple labels and labels at
		 * the same position, e.g., an image and text.  The screen space origin is the top, left corner of the
		 * canvas; <code>x</code> increases from left to right, and <code>y</code> increases from top to bottom.
		 * <p>
		 * <div align='center'>
		 * <table border='0' cellpadding='5'><tr>
		 * <td align='center'><code>default</code><br/><img src='Images/Label.setPixelOffset.default.png' width='250' height='188' /></td>
		 * <td align='center'><code>l.pixeloffset = new Cartesian2(25, 75);</code><br/><img src='Images/Label.setPixelOffset.x50y-25.png' width='250' height='188' /></td>
		 * </tr></table>
		 * The label's origin is indicated by the yellow point.
		 * </div>
		 * </p>
		 * @memberof LabelGraphics.prototype
		 * @type {Property}
		 * @default Cartesian2.ZERO
		 */
		pixelOffset: Property;

		/**
		 * Gets or sets the numeric Property specifying the uniform scale to apply to the image.
		 * A scale greater than <code>1.0</code> enlarges the label while a scale less than <code>1.0</code> shrinks it.
		 * <p>
		 * <div align='center'>
		 * <img src='Images/Label.setScale.png' width='400' height='300' /><br/>
		 * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>,
		 * and <code>2.0</code>.
		 * </div>
		 * </p>
		 * @memberof LabelGraphics.prototype
		 * @type {Property}
		 * @default 1.0
		 */
		scale: Property;

		/**
		 * Gets or sets the boolean Property specifying the visibility of the label.
		 * @memberof LabelGraphics.prototype
		 * @type {Property}
		 */
		show: Property;

		/**
		 * Gets or sets the boolean Property specifying the visibility of the background behind the label.
		 * @memberof LabelGraphics.prototype
		 * @type {Property}
		 * @default false
		 */
		showBackground: Property;

		/**
		 * Gets or sets the Property specifying the background {@link Color}.
		 * @memberof LabelGraphics.prototype
		 * @type {Property}
		 * @default new Color(0.165, 0.165, 0.165, 0.8)
		 */
		backgroundColor: Property;

		/**
		 * Gets or sets the {@link Cartesian2} Property specifying the label's horizontal and vertical
		 * background padding in pixels.
		 * @memberof LabelGraphics.prototype
		 * @type {Property}
		 * @default new Cartesian2(7, 5)
		 */
		backgroundPadding: Property;

		/**
		 * Gets or sets {@link NearFarScalar} Property specifying the translucency of the label based on the distance from the camera.
		 * A label's translucency will interpolate between the {@link NearFarScalar#nearValue} and
		 * {@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
		 * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
		 * Outside of these ranges the label's translucency remains clamped to the nearest bound.
		 * @memberof LabelGraphics.prototype
		 * @type {Property}
		 */
		translucencyByDistance: Property;

		/**
		 * Gets or sets {@link NearFarScalar} Property specifying the pixel offset of the label based on the distance from the camera.
		 * A label's pixel offset will interpolate between the {@link NearFarScalar#nearValue} and
		 * {@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
		 * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
		 * Outside of these ranges the label's pixel offset remains clamped to the nearest bound.
		 * @memberof LabelGraphics.prototype
		 * @type {Property}
		 */
		pixelOffsetScaleByDistance: Property;

		/**
		 * Gets or sets near and far scaling properties of a Label based on the label's distance from the camera.
		 * A label's scale will interpolate between the {@link NearFarScalar#nearValue} and
		 * {@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
		 * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
		 * Outside of these ranges the label's scale remains clamped to the nearest bound.  If undefined,
		 * scaleByDistance will be disabled.
		 * @memberof LabelGraphics.prototype
		 * @type {Property}
		 */
		scaleByDistance: Property;

		/**
		 * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this label will be displayed.
		 * @memberof LabelGraphics.prototype
		 * @type {Property}
		 */
		distanceDisplayCondition: Property;

		/**
		 * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.
		 * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.
		 * @memberof LabelGraphics.prototype
		 * @type {Property}
		 */
		disableDepthTestDistance: Property;

		/**
		 * Duplicates this instance.
		 * @param {LabelGraphics} [result] The object onto which to store the result.
		 * @returns {LabelGraphics} The modified result parameter or a new instance if one was not provided.
		 */
		clone(result?: LabelGraphics): LabelGraphics;

		/**
		 * Assigns each unassigned property on this object to the value
		 * of the same property on the provided source object.
		 * @param {LabelGraphics} source The object to be merged into this object.
		 */
		merge(source: LabelGraphics): void;

	}

	/**
	 * A {@link Visualizer} which maps the {@link LabelGraphics} instance
	 * in {@link Entity#label} to a {@link Label}.
	 * @alias LabelVisualizer
	 * @constructor
	 * @param {EntityCluster} entityCluster The entity cluster to manage the collection of billboards and optionally cluster with other entities.
	 * @param {EntityCollection} entityCollection The entityCollection to visualize.
	 */
	class LabelVisualizer {
		constructor(entityCluster: EntityCluster, entityCollection: EntityCollection);

		/**
		 * Updates the primitives created by this visualizer to match their
		 * Entity counterpart at the given time.
		 * @param {JulianDate} time The time to update to.
		 * @returns {Boolean} This function always returns true.
		 */
		update(time: JulianDate): boolean;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * @returns {Boolean} True if this object was destroyed; otherwise, false.
		 */
		isDestroyed(): boolean;

		/**
		 * Removes and destroys all primitives created by this instance.
		 */
		destroy(): void;

	}

	/**
	 * The interface for all {@link Property} objects that represent {@link Material} uniforms.
	 * This type defines an interface and cannot be instantiated directly.
	 * @alias MaterialProperty
	 * @constructor
	 * @see ColorMaterialProperty
	 * @see CompositeMaterialProperty
	 * @see GridMaterialProperty
	 * @see ImageMaterialProperty
	 * @see PolylineGlowMaterialProperty
	 * @see PolylineOutlineMaterialProperty
	 * @see StripeMaterialProperty
	 */
	class MaterialProperty {
		constructor();

		/**
		 * Gets a value indicating if this property is constant.  A property is considered
		 * constant if getValue always returns the same result for the current definition.
		 * @memberof MaterialProperty.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isConstant: boolean;

		/**
		 * Gets the event that is raised whenever the definition of this property changes.
		 * The definition is considered to have changed if a call to getValue would return
		 * a different result for the same time.
		 * @memberof MaterialProperty.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets the {@link Material} type at the provided time.
		 * @function
		 * @param {JulianDate} time The time for which to retrieve the type.
		 * @returns {String} The type of material.
		 */
		getType(time: JulianDate): string;

		/**
		 * Gets the value of the property at the provided time.
		 * @function
		 * @param {JulianDate} time The time for which to retrieve the value.
		 * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValue(time: JulianDate, result?: any): any;

		/**
		 * Compares this property to the provided property and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @function
		 * @param {Property} [other] The other property.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		equals(other?: Property): boolean;

	}

	/**
	 * A 3D model based on {@link https://github.com/KhronosGroup/glTF|glTF}, the runtime asset format for WebGL, OpenGL ES, and OpenGL.
	 * The position and orientation of the model is determined by the containing {@link Entity}.
	 * <p>
	 * Cesium includes support for glTF geometry, materials, animations, and skinning.
	 * Cameras and lights are not currently supported.
	 * </p>
	 * @alias ModelGraphics
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Property} [options.uri] A string or Resource Property specifying the URI of the glTF asset.
	 * @param {Property} [options.show=true] A boolean Property specifying the visibility of the model.
	 * @param {Property} [options.scale=1.0] A numeric Property specifying a uniform linear scale.
	 * @param {Property} [options.minimumPixelSize=0.0] A numeric Property specifying the approximate minimum pixel size of the model regardless of zoom.
	 * @param {Property} [options.maximumScale] The maximum scale size of a model. An upper limit for minimumPixelSize.
	 * @param {Property} [options.incrementallyLoadTextures=true] Determine if textures may continue to stream in after the model is loaded.
	 * @param {Property} [options.runAnimations=true] A boolean Property specifying if glTF animations specified in the model should be started.
	 * @param {Property} [options.clampAnimations=true] A boolean Property specifying if glTF animations should hold the last pose for time durations with no keyframes.
	 * @param {Property} [options.nodeTransformations] An object, where keys are names of nodes, and values are {@link TranslationRotationScale} Properties describing the transformation to apply to that node.
	 * @param {Property} [options.shadows=ShadowMode.ENABLED] An enum Property specifying whether the model casts or receives shadows from each light source.
	 * @param {Property} [options.heightReference=HeightReference.NONE] A Property specifying what the height is relative to.
	 * @param {Property} [options.distanceDisplayCondition] A Property specifying at what distance from the camera that this model will be displayed.
	 * @param {Property} [options.silhouetteColor=Color.RED] A Property specifying the {@link Color} of the silhouette.
	 * @param {Property} [options.silhouetteSize=0.0] A numeric Property specifying the size of the silhouette in pixels.
	 * @param {Property} [options.color=Color.WHITE] A Property specifying the {@link Color} that blends with the model's rendered color.
	 * @param {Property} [options.colorBlendMode=ColorBlendMode.HIGHLIGHT] An enum Property specifying how the color blends with the model.
	 * @param {Property} [options.colorBlendAmount=0.5] A numeric Property specifying the color strength when the <code>colorBlendMode</code> is <code>MIX</code>. A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with any value in-between resulting in a mix of the two.
	 * @param {Property} [options.clippingPlanes] A property specifying the {@link ClippingPlaneCollection} used to selectively disable rendering the model.
	 * @see {@link https://cesiumjs.org/tutorials/3D-Models-Tutorial/|3D Models Tutorial}
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=3D%20Models.html|Cesium Sandcastle 3D Models Demo}
	 */
	class ModelGraphics {
		constructor(options?: {
			uri?: Property;
			show?: Property;
			scale?: Property;
			minimumPixelSize?: Property;
			maximumScale?: Property;
			incrementallyLoadTextures?: Property;
			runAnimations?: Property;
			clampAnimations?: Property;
			nodeTransformations?: Property;
			shadows?: Property;
			heightReference?: Property;
			distanceDisplayCondition?: Property;
			silhouetteColor?: Property;
			silhouetteSize?: Property;
			color?: Property;
			colorBlendMode?: Property;
			colorBlendAmount?: Property;
			clippingPlanes?: Property;
		});

		/**
		 * Gets the event that is raised whenever a property or sub-property is changed or modified.
		 * @memberof ModelGraphics.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets or sets the boolean Property specifying the visibility of the model.
		 * @memberof ModelGraphics.prototype
		 * @type {Property}
		 * @default true
		 */
		show: Property;

		/**
		 * Gets or sets the numeric Property specifying a uniform linear scale
		 * for this model. Values greater than 1.0 increase the size of the model while
		 * values less than 1.0 decrease it.
		 * @memberof ModelGraphics.prototype
		 * @type {Property}
		 * @default 1.0
		 */
		scale: Property;

		/**
		 * Gets or sets the numeric Property specifying the approximate minimum
		 * pixel size of the model regardless of zoom. This can be used to ensure that
		 * a model is visible even when the viewer zooms out.  When <code>0.0</code>,
		 * no minimum size is enforced.
		 * @memberof ModelGraphics.prototype
		 * @type {Property}
		 * @default 0.0
		 */
		minimumPixelSize: Property;

		/**
		 * Gets or sets the numeric Property specifying the maximum scale
		 * size of a model. This property is used as an upper limit for
		 * {@link ModelGraphics#minimumPixelSize}.
		 * @memberof ModelGraphics.prototype
		 * @type {Property}
		 */
		maximumScale: Property;

		/**
		 * Get or sets the boolean Property specifying whether textures
		 * may continue to stream in after the model is loaded.
		 * @memberof ModelGraphics.prototype
		 * @type {Property}
		 */
		incrementallyLoadTextures: Property;

		/**
		 * Get or sets the enum Property specifying whether the model
		 * casts or receives shadows from each light source.
		 * @memberof ModelGraphics.prototype
		 * @type {Property}
		 * @default ShadowMode.ENABLED
		 */
		shadows: Property;

		/**
		 * Gets or sets the string Property specifying the URI of the glTF asset.
		 * @memberof ModelGraphics.prototype
		 * @type {Property}
		 */
		uri: Property;

		/**
		 * Gets or sets the boolean Property specifying if glTF animations should be run.
		 * @memberof ModelGraphics.prototype
		 * @type {Property}
		 * @default true
		 */
		runAnimations: Property;

		/**
		 * Gets or sets the boolean Property specifying if glTF animations should hold the last pose for time durations with no keyframes.
		 * @memberof ModelGraphics.prototype
		 * @type {Property}
		 * @default true
		 */
		clampAnimations: Property;

		/**
		 * Gets or sets the set of node transformations to apply to this model.  This is represented as an {@link PropertyBag}, where keys are
		 * names of nodes, and values are {@link TranslationRotationScale} Properties describing the transformation to apply to that node.
		 * @memberof ModelGraphics.prototype
		 * @type {PropertyBag}
		 */
		nodeTransformations: PropertyBag;

		/**
		 * Gets or sets the Property specifying the {@link HeightReference}.
		 * @memberof ModelGraphics.prototype
		 * @type {Property}
		 * @default HeightReference.NONE
		 */
		heightReference: Property;

		/**
		 * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this model will be displayed.
		 * @memberof ModelGraphics.prototype
		 * @type {Property}
		 */
		distanceDisplayCondition: Property;

		/**
		 * Gets or sets the Property specifying the {@link Color} of the silhouette.
		 * @memberof ModelGraphics.prototype
		 * @type {Property}
		 * @default Color.RED
		 */
		silhouetteColor: Property;

		/**
		 * Gets or sets the numeric Property specifying the size of the silhouette in pixels.
		 * @memberof ModelGraphics.prototype
		 * @type {Property}
		 * @default 0.0
		 */
		silhouetteSize: Property;

		/**
		 * Gets or sets the Property specifying the {@link Color} that blends with the model's rendered color.
		 * @memberof ModelGraphics.prototype
		 * @type {Property}
		 * @default Color.WHITE
		 */
		color: Property;

		/**
		 * Gets or sets the enum Property specifying how the color blends with the model.
		 * @memberof ModelGraphics.prototype
		 * @type {Property}
		 * @default ColorBlendMode.HIGHLIGHT
		 */
		colorBlendMode: Property;

		/**
		 * A numeric Property specifying the color strength when the <code>colorBlendMode</code> is MIX.
		 * A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with
		 * any value in-between resulting in a mix of the two.
		 * @memberof ModelGraphics.prototype
		 * @type {Property}
		 * @default 0.5
		 */
		colorBlendAmount: Property;

		/**
		 * A property specifying the {@link ClippingPlaneCollection} used to selectively disable rendering the model.
		 * @memberof ModelGraphics.prototype
		 * @type {Property}
		 */
		clippingPlanes: Property;

		/**
		 * Duplicates this instance.
		 * @param {ModelGraphics} [result] The object onto which to store the result.
		 * @returns {ModelGraphics} The modified result parameter or a new instance if one was not provided.
		 */
		clone(result?: ModelGraphics): ModelGraphics;

		/**
		 * Assigns each unassigned property on this object to the value
		 * of the same property on the provided source object.
		 * @param {ModelGraphics} source The object to be merged into this object.
		 */
		merge(source: ModelGraphics): void;

	}

	/**
	 * A {@link Visualizer} which maps {@link Entity#model} to a {@link Model}.
	 * @alias ModelVisualizer
	 * @constructor
	 * @param {Scene} scene The scene the primitives will be rendered in.
	 * @param {EntityCollection} entityCollection The entityCollection to visualize.
	 */
	class ModelVisualizer {
		constructor(scene: Scene, entityCollection: EntityCollection);

		/**
		 * Updates models created this visualizer to match their
		 * Entity counterpart at the given time.
		 * @param {JulianDate} time The time to update to.
		 * @returns {Boolean} This function always returns true.
		 */
		update(time: JulianDate): boolean;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * @returns {Boolean} True if this object was destroyed; otherwise, false.
		 */
		isDestroyed(): boolean;

		/**
		 * Removes and destroys all primitives created by this instance.
		 */
		destroy(): void;

	}

	/**
	 * A {@link Property} that produces {@link TranslationRotationScale} data.
	 * @alias NodeTransformationProperty
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Property} [options.translation=Cartesian3.ZERO] A {@link Cartesian3} Property specifying the (x, y, z) translation to apply to the node.
	 * @param {Property} [options.rotation=Quaternion.IDENTITY] A {@link Quaternion} Property specifying the (x, y, z, w) rotation to apply to the node.
	 * @param {Property} [options.scale=new Cartesian3(1.0, 1.0, 1.0)] A {@link Cartesian3} Property specifying the (x, y, z) scaling to apply to the node.
	 */
	class NodeTransformationProperty {
		constructor(options?: {
			translation?: Property;
			rotation?: Property;
			scale?: Property;
		});

		/**
		 * Gets a value indicating if this property is constant.  A property is considered
		 * constant if getValue always returns the same result for the current definition.
		 * @memberof NodeTransformationProperty.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isConstant: boolean;

		/**
		 * Gets the event that is raised whenever the definition of this property changes.
		 * The definition is considered to have changed if a call to getValue would return
		 * a different result for the same time.
		 * @memberof NodeTransformationProperty.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets or sets the {@link Cartesian3} Property specifying the (x, y, z) translation to apply to the node.
		 * @memberof NodeTransformationProperty.prototype
		 * @type {Property}
		 * @default Cartesian3.ZERO
		 */
		translation: Property;

		/**
		 * Gets or sets the {@link Quaternion} Property specifying the (x, y, z, w) rotation to apply to the node.
		 * @memberof NodeTransformationProperty.prototype
		 * @type {Property}
		 * @default Quaternion.IDENTITY
		 */
		rotation: Property;

		/**
		 * Gets or sets the {@link Cartesian3} Property specifying the (x, y, z) scaling to apply to the node.
		 * @memberof NodeTransformationProperty.prototype
		 * @type {Property}
		 * @default new Cartesian3(1.0, 1.0, 1.0)
		 */
		scale: Property;

		/**
		 * Gets the value of the property at the provided time.
		 * @param {JulianDate} time The time for which to retrieve the value.
		 * @param {TranslationRotationScale} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {TranslationRotationScale} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValue(time: JulianDate, result?: TranslationRotationScale): TranslationRotationScale;

		/**
		 * Compares this property to the provided property and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Property} [other] The other property.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		equals(other?: Property): boolean;

	}

	/**
	 * Describes a polyline defined as the path made by an {@link Entity} as it moves over time.
	 * @alias PathGraphics
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Property} [options.leadTime] A Property specifying the number of seconds behind the object to show.
	 * @param {Property} [options.trailTime] A Property specifying the number of seconds in front of the object to show.
	 * @param {Property} [options.show=true] A boolean Property specifying the visibility of the path.
	 * @param {Property} [options.width=1.0] A numeric Property specifying the width in pixels.
	 * @param {MaterialProperty} [options.material=Color.WHITE] A Property specifying the material used to draw the path.
	 * @param {Property} [options.resolution=60] A numeric Property specifying the maximum number of seconds to step when sampling the position.
	 * @param {Property} [options.distanceDisplayCondition] A Property specifying at what distance from the camera that this path will be displayed.
	 */
	class PathGraphics {
		constructor(options?: {
			leadTime?: Property;
			trailTime?: Property;
			show?: Property;
			width?: Property;
			material?: MaterialProperty;
			resolution?: Property;
			distanceDisplayCondition?: Property;
		});

		/**
		 * Gets the event that is raised whenever a property or sub-property is changed or modified.
		 * @memberof PathGraphics.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets or sets the boolean Property specifying the visibility of the path.
		 * @memberof PathGraphics.prototype
		 * @type {Property}
		 * @default true
		 */
		show: Property;

		/**
		 * Gets or sets the Property specifying the material used to draw the path.
		 * @memberof PathGraphics.prototype
		 * @type {MaterialProperty}
		 * @default Color.WHITE
		 */
		material: MaterialProperty;

		/**
		 * Gets or sets the numeric Property specifying the width in pixels.
		 * @memberof PathGraphics.prototype
		 * @type {Property}
		 * @default 1.0
		 */
		width: Property;

		/**
		 * Gets or sets the Property specifying the maximum number of seconds to step when sampling the position.
		 * @memberof PathGraphics.prototype
		 * @type {Property}
		 * @default 60
		 */
		resolution: Property;

		/**
		 * Gets or sets the Property specifying the number of seconds in front of the object to show.
		 * @memberof PathGraphics.prototype
		 * @type {Property}
		 */
		leadTime: Property;

		/**
		 * Gets or sets the Property specifying the number of seconds behind the object to show.
		 * @memberof PathGraphics.prototype
		 * @type {Property}
		 */
		trailTime: Property;

		/**
		 * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this path will be displayed.
		 * @memberof PathGraphics.prototype
		 * @type {Property}
		 */
		distanceDisplayCondition: Property;

		/**
		 * Duplicates this instance.
		 * @param {PathGraphics} [result] The object onto which to store the result.
		 * @returns {PathGraphics} The modified result parameter or a new instance if one was not provided.
		 */
		clone(result?: PathGraphics): PathGraphics;

		/**
		 * Assigns each unassigned property on this object to the value
		 * of the same property on the provided source object.
		 * @param {PathGraphics} source The object to be merged into this object.
		 */
		merge(source: PathGraphics): void;

	}

	/**
	 * A {@link Visualizer} which maps {@link Entity#path} to a {@link Polyline}.
	 * @alias PathVisualizer
	 * @constructor
	 * @param {Scene} scene The scene the primitives will be rendered in.
	 * @param {EntityCollection} entityCollection The entityCollection to visualize.
	 */
	class PathVisualizer {
		constructor(scene: Scene, entityCollection: EntityCollection);

		/**
		 * Updates all of the primitives created by this visualizer to match their
		 * Entity counterpart at the given time.
		 * @param {JulianDate} time The time to update to.
		 * @returns {Boolean} This function always returns true.
		 */
		update(time: JulianDate): boolean;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * @returns {Boolean} True if this object was destroyed; otherwise, false.
		 */
		isDestroyed(): boolean;

		/**
		 * Removes and destroys all primitives created by this instance.
		 */
		destroy(): void;

	}

	/**
	 * A {@link GeometryUpdater} for planes.
	 * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
	 * @alias PlaneGeometryUpdater
	 * @constructor
	 * @param {Entity} entity The entity containing the geometry to be visualized.
	 * @param {Scene} scene The scene where visualization is taking place.
	 */
	class PlaneGeometryUpdater {
		constructor(entity: Entity, scene: Scene);

		/**
		 * Creates the geometry instance which represents the fill of the geometry.
		 * @param {JulianDate} time The time to use when retrieving initial attribute values.
		 * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.
		 * @exception {DeveloperError} This instance does not represent a filled geometry.
		 */
		createFillGeometryInstance(time: JulianDate): GeometryInstance;

		/**
		 * Creates the geometry instance which represents the outline of the geometry.
		 * @param {JulianDate} time The time to use when retrieving initial attribute values.
		 * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.
		 * @exception {DeveloperError} This instance does not represent an outlined geometry.
		 */
		createOutlineGeometryInstance(time: JulianDate): GeometryInstance;

	}

	/**
	 * Describes a plane. The center position and orientation are determined by the containing {@link Entity}.
	 * @alias PlaneGraphics
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Property} [options.plane] A {@link Plane} Property specifying the normal and distance for the plane.
	 * @param {Property} [options.dimensions] A {@link Cartesian2} Property specifying the width and height of the plane.
	 * @param {Property} [options.show=true] A boolean Property specifying the visibility of the plane.
	 * @param {Property} [options.fill=true] A boolean Property specifying whether the plane is filled with the provided material.
	 * @param {MaterialProperty} [options.material=Color.WHITE] A Property specifying the material used to fill the plane.
	 * @param {Property} [options.outline=false] A boolean Property specifying whether the plane is outlined.
	 * @param {Property} [options.outlineColor=Color.BLACK] A Property specifying the {@link Color} of the outline.
	 * @param {Property} [options.outlineWidth=1.0] A numeric Property specifying the width of the outline.
	 * @param {Property} [options.shadows=ShadowMode.DISABLED] An enum Property specifying whether the plane casts or receives shadows from each light source.
	 * @param {Property} [options.distanceDisplayCondition] A Property specifying at what distance from the camera that this plane will be displayed.
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Plane.html|Cesium Sandcastle Plane Demo}
	 */
	class PlaneGraphics {
		constructor(options?: {
			plane?: Property;
			dimensions?: Property;
			show?: Property;
			fill?: Property;
			material?: MaterialProperty;
			outline?: Property;
			outlineColor?: Property;
			outlineWidth?: Property;
			shadows?: Property;
			distanceDisplayCondition?: Property;
		});

		/**
		 * Gets the event that is raised whenever a property or sub-property is changed or modified.
		 * @memberof PlaneGraphics.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets or sets the boolean Property specifying the visibility of the plane.
		 * @memberof PlaneGraphics.prototype
		 * @type {Property}
		 * @default true
		 */
		show: Property;

		/**
		 * Gets or sets the {@link Plane} Property specifying the normal and distance of the plane.
		 * @memberof PlaneGraphics.prototype
		 * @type {Property}
		 */
		plane: Property;

		/**
		 * Gets or sets the {@link Cartesian2} Property specifying the width and height of the plane.
		 * @memberof PlaneGraphics.prototype
		 * @type {Property}
		 */
		dimensions: Property;

		/**
		 * Gets or sets the material used to fill the plane.
		 * @memberof PlaneGraphics.prototype
		 * @type {MaterialProperty}
		 * @default Color.WHITE
		 */
		material: MaterialProperty;

		/**
		 * Gets or sets the boolean Property specifying whether the plane is filled with the provided material.
		 * @memberof PlaneGraphics.prototype
		 * @type {Property}
		 * @default true
		 */
		fill: Property;

		/**
		 * Gets or sets the Property specifying whether the plane is outlined.
		 * @memberof PlaneGraphics.prototype
		 * @type {Property}
		 * @default false
		 */
		outline: Property;

		/**
		 * Gets or sets the Property specifying the {@link Color} of the outline.
		 * @memberof PlaneGraphics.prototype
		 * @type {Property}
		 * @default Color.BLACK
		 */
		outlineColor: Property;

		/**
		 * Gets or sets the numeric Property specifying the width of the outline.
		 * @memberof PlaneGraphics.prototype
		 * @type {Property}
		 * @default 1.0
		 */
		outlineWidth: Property;

		/**
		 * Get or sets the enum Property specifying whether the plane
		 * casts or receives shadows from each light source.
		 * @memberof PlaneGraphics.prototype
		 * @type {Property}
		 * @default ShadowMode.DISABLED
		 */
		shadows: Property;

		/**
		 * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this plane will be displayed.
		 * @memberof PlaneGraphics.prototype
		 * @type {Property}
		 */
		distanceDisplayCondition: Property;

		/**
		 * Duplicates this instance.
		 * @param {PlaneGraphics} [result] The object onto which to store the result.
		 * @returns {PlaneGraphics} The modified result parameter or a new instance if one was not provided.
		 */
		clone(result?: PlaneGraphics): PlaneGraphics;

		/**
		 * Assigns each unassigned property on this object to the value
		 * of the same property on the provided source object.
		 * @param {PlaneGraphics} source The object to be merged into this object.
		 */
		merge(source: PlaneGraphics): void;

	}

	/**
	 * Describes a graphical point located at the position of the containing {@link Entity}.
	 * @alias PointGraphics
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Property} [options.color=Color.WHITE] A Property specifying the {@link Color} of the point.
	 * @param {Property} [options.pixelSize=1] A numeric Property specifying the size in pixels.
	 * @param {Property} [options.outlineColor=Color.BLACK] A Property specifying the {@link Color} of the outline.
	 * @param {Property} [options.outlineWidth=0] A numeric Property specifying the the outline width in pixels.
	 * @param {Property} [options.show=true] A boolean Property specifying the visibility of the point.
	 * @param {Property} [options.scaleByDistance] A {@link NearFarScalar} Property used to scale the point based on distance.
	 * @param {Property} [options.translucencyByDistance] A {@link NearFarScalar} Property used to set translucency based on distance from the camera.
	 * @param {Property} [options.heightReference=HeightReference.NONE] A Property specifying what the height is relative to.
	 * @param {Property} [options.distanceDisplayCondition] A Property specifying at what distance from the camera that this point will be displayed.
	 * @param {Property} [options.disableDepthTestDistance] A Property specifying the distance from the camera at which to disable the depth test to.
	 */
	class PointGraphics {
		constructor(options?: {
			color?: Property;
			pixelSize?: Property;
			outlineColor?: Property;
			outlineWidth?: Property;
			show?: Property;
			scaleByDistance?: Property;
			translucencyByDistance?: Property;
			heightReference?: Property;
			distanceDisplayCondition?: Property;
			disableDepthTestDistance?: Property;
		});

		/**
		 * Gets the event that is raised whenever a property or sub-property is changed or modified.
		 * @memberof PointGraphics.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets or sets the Property specifying the {@link Color} of the point.
		 * @memberof PointGraphics.prototype
		 * @type {Property}
		 * @default Color.WHITE
		 */
		color: Property;

		/**
		 * Gets or sets the numeric Property specifying the size in pixels.
		 * @memberof PointGraphics.prototype
		 * @type {Property}
		 * @default 1
		 */
		pixelSize: Property;

		/**
		 * Gets or sets the Property specifying the {@link Color} of the outline.
		 * @memberof PointGraphics.prototype
		 * @type {Property}
		 * @default Color.BLACK
		 */
		outlineColor: Property;

		/**
		 * Gets or sets the numeric Property specifying the the outline width in pixels.
		 * @memberof PointGraphics.prototype
		 * @type {Property}
		 * @default 0
		 */
		outlineWidth: Property;

		/**
		 * Gets or sets the boolean Property specifying the visibility of the point.
		 * @memberof PointGraphics.prototype
		 * @type {Property}
		 * @default true
		 */
		show: Property;

		/**
		 * Gets or sets the {@link NearFarScalar} Property used to scale the point based on distance.
		 * If undefined, a constant size is used.
		 * @memberof PointGraphics.prototype
		 * @type {Property}
		 */
		scaleByDistance: Property;

		/**
		 * Gets or sets {@link NearFarScalar} Property specifying the translucency of the point based on the distance from the camera.
		 * A point's translucency will interpolate between the {@link NearFarScalar#nearValue} and
		 * {@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
		 * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
		 * Outside of these ranges the points's translucency remains clamped to the nearest bound.
		 * @memberof PointGraphics.prototype
		 * @type {Property}
		 */
		translucencyByDistance: Property;

		/**
		 * Gets or sets the Property specifying the {@link HeightReference}.
		 * @memberof PointGraphics.prototype
		 * @type {Property}
		 * @default HeightReference.NONE
		 */
		heightReference: Property;

		/**
		 * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this point will be displayed.
		 * @memberof PointGraphics.prototype
		 * @type {Property}
		 */
		distanceDisplayCondition: Property;

		/**
		 * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.
		 * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.
		 * @memberof PointGraphics.prototype
		 * @type {Property}
		 */
		disableDepthTestDistance: Property;

		/**
		 * Duplicates this instance.
		 * @param {PointGraphics} [result] The object onto which to store the result.
		 * @returns {PointGraphics} The modified result parameter or a new instance if one was not provided.
		 */
		clone(result?: PointGraphics): PointGraphics;

		/**
		 * Assigns each unassigned property on this object to the value
		 * of the same property on the provided source object.
		 * @param {PointGraphics} source The object to be merged into this object.
		 */
		merge(source: PointGraphics): void;

	}

	/**
	 * A {@link Visualizer} which maps {@link Entity#point} to a {@link PointPrimitive}.
	 * @alias PointVisualizer
	 * @constructor
	 * @param {EntityCluster} entityCluster The entity cluster to manage the collection of billboards and optionally cluster with other entities.
	 * @param {EntityCollection} entityCollection The entityCollection to visualize.
	 */
	class PointVisualizer {
		constructor(entityCluster: EntityCluster, entityCollection: EntityCollection);

		/**
		 * Updates the primitives created by this visualizer to match their
		 * Entity counterpart at the given time.
		 * @param {JulianDate} time The time to update to.
		 * @returns {Boolean} This function always returns true.
		 */
		update(time: JulianDate): boolean;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * @returns {Boolean} True if this object was destroyed; otherwise, false.
		 */
		isDestroyed(): boolean;

		/**
		 * Removes and destroys all primitives created by this instance.
		 */
		destroy(): void;

	}

	/**
	 * A {@link GeometryUpdater} for polygons.
	 * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
	 * @alias PolygonGeometryUpdater
	 * @constructor
	 * @param {Entity} entity The entity containing the geometry to be visualized.
	 * @param {Scene} scene The scene where visualization is taking place.
	 */
	class PolygonGeometryUpdater {
		constructor(entity: Entity, scene: Scene);

		/**
		 * Creates the geometry instance which represents the fill of the geometry.
		 * @param {JulianDate} time The time to use when retrieving initial attribute values.
		 * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.
		 * @exception {DeveloperError} This instance does not represent a filled geometry.
		 */
		createFillGeometryInstance(time: JulianDate): GeometryInstance;

		/**
		 * Creates the geometry instance which represents the outline of the geometry.
		 * @param {JulianDate} time The time to use when retrieving initial attribute values.
		 * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.
		 * @exception {DeveloperError} This instance does not represent an outlined geometry.
		 */
		createOutlineGeometryInstance(time: JulianDate): GeometryInstance;

	}

	/**
	 * Describes a polygon defined by an hierarchy of linear rings which make up the outer shape and any nested holes.
	 * The polygon conforms to the curvature of the globe and can be placed on the surface or
	 * at altitude and can optionally be extruded into a volume.
	 * @alias PolygonGraphics
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Property} [options.hierarchy] A Property specifying the {@link PolygonHierarchy}.
	 * @param {Property} [options.height=0] A numeric Property specifying the altitude of the polygon relative to the ellipsoid surface.
	 * @param {Property} [options.heightReference] A Property specifying what the height is relative to.
	 * @param {Property} [options.extrudedHeight] A numeric Property specifying the altitude of the polygon's extruded face relative to the ellipsoid surface.
	 * @param {Property} [options.extrudedHeightReference] A Property specifying what the extrudedHeight is relative to.
	 * @param {Property} [options.show=true] A boolean Property specifying the visibility of the polygon.
	 * @param {Property} [options.fill=true] A boolean Property specifying whether the polygon is filled with the provided material.
	 * @param {MaterialProperty} [options.material=Color.WHITE] A Property specifying the material used to fill the polygon.
	 * @param {Property} [options.outline=false] A boolean Property specifying whether the polygon is outlined.
	 * @param {Property} [options.outlineColor=Color.BLACK] A Property specifying the {@link Color} of the outline.
	 * @param {Property} [options.outlineWidth=1.0] A numeric Property specifying the width of the outline.
	 * @param {Property} [options.stRotation=0.0] A numeric property specifying the rotation of the polygon texture counter-clockwise from north.
	 * @param {Property} [options.granularity=Cesium.Math.RADIANS_PER_DEGREE] A numeric Property specifying the angular distance between each latitude and longitude point.
	 * @param {Property} [options.perPositionHeight=false] A boolean specifying whether or not the the height of each position is used.
	 * @param {Boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.
	 * @param {Boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.
	 * @param {Property} [options.shadows=ShadowMode.DISABLED] An enum Property specifying whether the polygon casts or receives shadows from each light source.
	 * @param {Property} [options.distanceDisplayCondition] A Property specifying at what distance from the camera that this polygon will be displayed.
	 * @param {ConstantProperty} [options.zIndex=0] A property specifying the zIndex used for ordering ground geometry.  Only has an effect if the polygon is constant and neither height or extrudedHeight are specified.
	 * @see Entity
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Polygon.html|Cesium Sandcastle Polygon Demo}
	 */
	class PolygonGraphics {
		constructor(options?: {
			hierarchy?: Property;
			height?: Property;
			heightReference?: Property;
			extrudedHeight?: Property;
			extrudedHeightReference?: Property;
			show?: Property;
			fill?: Property;
			material?: MaterialProperty;
			outline?: Property;
			outlineColor?: Property;
			outlineWidth?: Property;
			stRotation?: Property;
			granularity?: Property;
			perPositionHeight?: Property;
			closeTop?: boolean;
			closeBottom?: boolean;
			shadows?: Property;
			distanceDisplayCondition?: Property;
			zIndex?: ConstantProperty;
		});

		/**
		 * Gets the event that is raised whenever a property or sub-property is changed or modified.
		 * @memberof PolygonGraphics.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets or sets the boolean Property specifying the visibility of the polygon.
		 * @memberof PolygonGraphics.prototype
		 * @type {Property}
		 * @default true
		 */
		show: Property;

		/**
		 * Gets or sets the Property specifying the material used to fill the polygon.
		 * @memberof PolygonGraphics.prototype
		 * @type {MaterialProperty}
		 * @default Color.WHITE
		 */
		material: MaterialProperty;

		/**
		 * Gets or sets the Property specifying the {@link PolygonHierarchy}.
		 * @memberof PolygonGraphics.prototype
		 * @type {Property}
		 */
		hierarchy: Property;

		/**
		 * Gets or sets the numeric Property specifying the constant altitude of the polygon.
		 * @memberof PolygonGraphics.prototype
		 * @type {Property}
		 * @default 0.0
		 */
		height: Property;

		/**
		 * Gets or sets the Property specifying the {@link HeightReference}.
		 * @memberof PolygonGraphics.prototype
		 * @type {Property}
		 * @default HeightReference.NONE
		 */
		heightReference: Property;

		/**
		 * Gets or sets the numeric Property specifying the altitude of the polygon extrusion.
		 * If {@link PolygonGraphics#perPositionHeight} is false, the volume starts at {@link PolygonGraphics#height} and ends at this altitude.
		 * If {@link PolygonGraphics#perPositionHeight} is true, the volume starts at the height of each {@link PolygonGraphics#hierarchy} position and ends at this altitude.
		 * @memberof PolygonGraphics.prototype
		 * @type {Property}
		 */
		extrudedHeight: Property;

		/**
		 * Gets or sets the Property specifying the extruded {@link HeightReference}.
		 * @memberof PolygonGraphics.prototype
		 * @type {Property}
		 * @default HeightReference.NONE
		 */
		extrudedHeightReference: Property;

		/**
		 * Gets or sets the numeric Property specifying the angular distance between points on the polygon.
		 * @memberof PolygonGraphics.prototype
		 * @type {Property}
		 * @default {CesiumMath.RADIANS_PER_DEGREE}
		 */
		granularity: Property;

		/**
		 * Gets or sets the numeric property specifying the rotation of the polygon texture counter-clockwise from north.
		 * @memberof PolygonGraphics.prototype
		 * @type {Property}
		 * @default 0
		 */
		stRotation: Property;

		/**
		 * Gets or sets the boolean Property specifying whether the polygon is filled with the provided material.
		 * @memberof PolygonGraphics.prototype
		 * @type {Property}
		 * @default true
		 */
		fill: Property;

		/**
		 * Gets or sets the Property specifying whether the polygon is outlined.
		 * @memberof PolygonGraphics.prototype
		 * @type {Property}
		 * @default false
		 */
		outline: Property;

		/**
		 * Gets or sets the Property specifying the {@link Color} of the outline.
		 * @memberof PolygonGraphics.prototype
		 * @type {Property}
		 * @default Color.BLACK
		 */
		outlineColor: Property;

		/**
		 * Gets or sets the numeric Property specifying the width of the outline.
		 * @memberof PolygonGraphics.prototype
		 * @type {Property}
		 * @default 1.0
		 */
		outlineWidth: Property;

		/**
		 * Gets or sets the boolean specifying whether or not the the height of each position is used.
		 * If true, the shape will have non-uniform altitude defined by the height of each {@link PolygonGraphics#hierarchy} position.
		 * If false, the shape will have a constant altitude as specified by {@link PolygonGraphics#height}.
		 * @memberof PolygonGraphics.prototype
		 * @type {Property}
		 */
		perPositionHeight: Property;

		/**
		 * Gets or sets a boolean specifying whether or not the top of an extruded polygon is included.
		 * @memberof PolygonGraphics.prototype
		 * @type {Property}
		 */
		closeTop: Property;

		/**
		 * Gets or sets a boolean specifying whether or not the bottom of an extruded polygon is included.
		 * @memberof PolygonGraphics.prototype
		 * @type {Property}
		 */
		closeBottom: Property;

		/**
		 * Get or sets the enum Property specifying whether the polygon
		 * casts or receives shadows from each light source.
		 * @memberof PolygonGraphics.prototype
		 * @type {Property}
		 * @default ShadowMode.DISABLED
		 */
		shadows: Property;

		/**
		 * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this polygon will be displayed.
		 * @memberof PolygonGraphics.prototype
		 * @type {Property}
		 */
		distanceDisplayCondition: Property;

		/**
		 * Gets or sets the {@link ClassificationType} Property specifying whether this polygon will classify terrain, 3D Tiles, or both when on the ground.
		 * @memberof PolygonGraphics.prototype
		 * @type {Property}
		 * @default ClassificationType.TERRAIN
		 */
		classificationType: Property;

		/**
		 * Gets or sets the zIndex Prperty specifying the ordering of ground geometry.  Only has an effect if the polygon is constant and neither height or extrudedHeight are specified.
		 * @memberof PolygonGraphics.prototype
		 * @type {ConstantProperty}
		 * @default 0
		 */
		zIndex: ConstantProperty;

		/**
		 * Duplicates this instance.
		 * @param {PolygonGraphics} [result] The object onto which to store the result.
		 * @returns {PolygonGraphics} The modified result parameter or a new instance if one was not provided.
		 */
		clone(result?: PolygonGraphics): PolygonGraphics;

		/**
		 * Assigns each unassigned property on this object to the value
		 * of the same property on the provided source object.
		 * @param {PolygonGraphics} source The object to be merged into this object.
		 */
		merge(source: PolygonGraphics): void;

	}

	/**
	 * A {@link MaterialProperty} that maps to PolylineArrow {@link Material} uniforms.
	 * @param {Property} [color=Color.WHITE] The {@link Color} Property to be used.
	 * @alias PolylineArrowMaterialProperty
	 * @constructor
	 */
	class PolylineArrowMaterialProperty {
		constructor(color?: Property);

		/**
		 * Gets a value indicating if this property is constant.  A property is considered
		 * constant if getValue always returns the same result for the current definition.
		 * @memberof PolylineArrowMaterialProperty.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isConstant: boolean;

		/**
		 * Gets the event that is raised whenever the definition of this property changes.
		 * The definition is considered to have changed if a call to getValue would return
		 * a different result for the same time.
		 * @memberof PolylineArrowMaterialProperty.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets or sets the {@link Color} {@link Property}.
		 * @memberof PolylineArrowMaterialProperty.prototype
		 * @type {Property}
		 * @default Color.WHITE
		 */
		color: Property;

		/**
		 * Gets the {@link Material} type at the provided time.
		 * @param {JulianDate} time The time for which to retrieve the type.
		 * @returns {String} The type of material.
		 */
		getType(time: JulianDate): string;

		/**
		 * Gets the value of the property at the provided time.
		 * @param {JulianDate} time The time for which to retrieve the value.
		 * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValue(time: JulianDate, result?: any): any;

		/**
		 * Compares this property to the provided property and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Property} [other] The other property.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		equals(other?: Property): boolean;

	}

	/**
	 * A {@link MaterialProperty} that maps to polyline dash {@link Material} uniforms.
	 * @alias PolylineDashMaterialProperty
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Property} [options.color=Color.WHITE] A Property specifying the {@link Color} of the line.
	 * @param {Property} [options.gapColor=Color.TRANSPARENT] A Property specifying the {@link Color} of the gaps in the line.
	 * @param {Property} [options.dashLength=16.0] A numeric Property specifying the length of the dash pattern in pixel.s
	 * @param {Property} [options.dashPattern=255.0] A numeric Property specifying a 16 bit pattern for the dash
	 */
	class PolylineDashMaterialProperty {
		constructor(options?: {
			color?: Property;
			gapColor?: Property;
			dashLength?: Property;
			dashPattern?: Property;
		});

		/**
		 * Gets a value indicating if this property is constant.  A property is considered
		 * constant if getValue always returns the same result for the current definition.
		 * @memberof PolylineDashMaterialProperty.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isConstant: boolean;

		/**
		 * Gets the event that is raised whenever the definition of this property changes.
		 * The definition is considered to have changed if a call to getValue would return
		 * a different result for the same time.
		 * @memberof PolylineDashMaterialProperty.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets or sets the Property specifying the {@link Color} of the line.
		 * @memberof PolylineDashMaterialProperty.prototype
		 * @type {Property}
		 */
		color: Property;

		/**
		 * Gets or sets the Property specifying the {@link Color} of the gaps in the line.
		 * @memberof PolylineDashMaterialProperty.prototype
		 * @type {Property}
		 */
		gapColor: Property;

		/**
		 * Gets or sets the numeric Property specifying the length of a dash cycle
		 * @memberof PolylineDashMaterialProperty.prototype
		 * @type {Property}
		 */
		dashLength: Property;

		/**
		 * Gets or sets the numeric Property specifying a dash pattern
		 * @memberof PolylineDashMaterialProperty.prototype
		 * @type {Property}
		 */
		dashPattern: Property;

		/**
		 * Gets the {@link Material} type at the provided time.
		 * @param {JulianDate} time The time for which to retrieve the type.
		 * @returns {String} The type of material.
		 */
		getType(time: JulianDate): string;

		/**
		 * Gets the value of the property at the provided time.
		 * @param {JulianDate} time The time for which to retrieve the value.
		 * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValue(time: JulianDate, result?: any): any;

		/**
		 * Compares this property to the provided property and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Property} [other] The other property.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		equals(other?: Property): boolean;

	}

	/**
	 * A {@link GeometryUpdater} for polylines.
	 * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
	 * @alias PolylineGeometryUpdater
	 * @constructor
	 * @param {Entity} entity The entity containing the geometry to be visualized.
	 * @param {Scene} scene The scene where visualization is taking place.
	 */
	class PolylineGeometryUpdater {
		constructor(entity: Entity, scene: Scene);

		/**
		 * Gets the unique ID associated with this updater
		 * @memberof PolylineGeometryUpdater.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly id: string;

		/**
		 * Gets the entity associated with this geometry.
		 * @memberof PolylineGeometryUpdater.prototype
		 * @type {Entity}
		 * @readonly
		 */
		readonly entity: Entity;

		/**
		 * Gets a value indicating if the geometry has a fill component.
		 * @memberof PolylineGeometryUpdater.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly fillEnabled: boolean;

		/**
		 * Gets a value indicating if fill visibility varies with simulation time.
		 * @memberof PolylineGeometryUpdater.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly hasConstantFill: boolean;

		/**
		 * Gets the material property used to fill the geometry.
		 * @memberof PolylineGeometryUpdater.prototype
		 * @type {MaterialProperty}
		 * @readonly
		 */
		readonly fillMaterialProperty: MaterialProperty;

		/**
		 * Gets the material property used to fill the geometry when it fails the depth test.
		 * @memberof PolylineGeometryUpdater.prototype
		 * @type {MaterialProperty}
		 * @readonly
		 */
		readonly depthFailMaterialProperty: MaterialProperty;

		/**
		 * Gets a value indicating if the geometry has an outline component.
		 * @memberof PolylineGeometryUpdater.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly outlineEnabled: boolean;

		/**
		 * Gets a value indicating if outline visibility varies with simulation time.
		 * @memberof PolylineGeometryUpdater.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly hasConstantOutline: boolean;

		/**
		 * Gets the {@link Color} property for the geometry outline.
		 * @memberof PolylineGeometryUpdater.prototype
		 * @type {Property}
		 * @readonly
		 */
		readonly outlineColorProperty: Property;

		/**
		 * Gets the property specifying whether the geometry
		 * casts or receives shadows from each light source.
		 * @memberof PolylineGeometryUpdater.prototype
		 * @type {Property}
		 * @readonly
		 */
		readonly shadowsProperty: Property;

		/**
		 * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this geometry will be displayed.
		 * @memberof PolylineGeometryUpdater.prototype
		 * @type {Property}
		 * @readonly
		 */
		readonly distanceDisplayConditionProperty: Property;

		/**
		 * Gets a value indicating if the geometry is time-varying.
		 * If true, all visualization is delegated to the {@link DynamicGeometryUpdater}
		 * returned by GeometryUpdater#createDynamicUpdater.
		 * @memberof PolylineGeometryUpdater.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isDynamic: boolean;

		/**
		 * Gets a value indicating if the geometry is closed.
		 * This property is only valid for static geometry.
		 * @memberof PolylineGeometryUpdater.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isClosed: boolean;

		/**
		 * Gets an event that is raised whenever the public properties
		 * of this updater change.
		 * @memberof PolylineGeometryUpdater.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly geometryChanged: boolean;

		/**
		 * Gets a value indicating if the geometry is clamped to the ground.
		 * Returns false if polylines on terrain is not supported.
		 * @memberof PolylineGeometryUpdater.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly clampToGround: boolean;

		/**
		 * Checks if the geometry is outlined at the provided time.
		 * @param {JulianDate} time The time for which to retrieve visibility.
		 * @returns {Boolean} true if geometry is outlined at the provided time, false otherwise.
		 */
		isOutlineVisible(time: JulianDate): boolean;

		/**
		 * Checks if the geometry is filled at the provided time.
		 * @param {JulianDate} time The time for which to retrieve visibility.
		 * @returns {Boolean} true if geometry is filled at the provided time, false otherwise.
		 */
		isFilled(time: JulianDate): boolean;

		/**
		 * Creates the geometry instance which represents the fill of the geometry.
		 * @param {JulianDate} time The time to use when retrieving initial attribute values.
		 * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.
		 * @exception {DeveloperError} This instance does not represent a filled geometry.
		 */
		createFillGeometryInstance(time: JulianDate): GeometryInstance;

		/**
		 * Creates the geometry instance which represents the outline of the geometry.
		 * @param {JulianDate} time The time to use when retrieving initial attribute values.
		 * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.
		 * @exception {DeveloperError} This instance does not represent an outlined geometry.
		 */
		createOutlineGeometryInstance(time: JulianDate): GeometryInstance;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * @returns {Boolean} True if this object was destroyed; otherwise, false.
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 */
		destroy(): void;

		/**
		 * Creates the dynamic updater to be used when GeometryUpdater#isDynamic is true.
		 * @param {PrimitiveCollection} primitives The primitive collection to use.
		 * @param {PrimitiveCollection|OrderedGroundPrimitiveCollection} groundPrimitives The primitive collection to use for ordered ground primitives.
		 * @returns {DynamicGeometryUpdater} The dynamic updater used to update the geometry each frame.
		 * @exception {DeveloperError} This instance does not represent dynamic geometry.
		 */
		createDynamicUpdater(primitives: PrimitiveCollection, groundPrimitives: PrimitiveCollection | any): any;

	}

	/**
	 * A {@link MaterialProperty} that maps to polyline glow {@link Material} uniforms.
	 * @alias PolylineGlowMaterialProperty
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Property} [options.color=Color.WHITE] A Property specifying the {@link Color} of the line.
	 * @param {Property} [options.glowPower=0.25] A numeric Property specifying the strength of the glow, as a percentage of the total line width.
	 */
	class PolylineGlowMaterialProperty {
		constructor(options?: {
			color?: Property;
			glowPower?: Property;
		});

		/**
		 * Gets a value indicating if this property is constant.  A property is considered
		 * constant if getValue always returns the same result for the current definition.
		 * @memberof PolylineGlowMaterialProperty.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isConstant: boolean;

		/**
		 * Gets the event that is raised whenever the definition of this property changes.
		 * The definition is considered to have changed if a call to getValue would return
		 * a different result for the same time.
		 * @memberof PolylineGlowMaterialProperty.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets or sets the Property specifying the {@link Color} of the line.
		 * @memberof PolylineGlowMaterialProperty.prototype
		 * @type {Property}
		 */
		color: Property;

		/**
		 * Gets or sets the numeric Property specifying the strength of the glow, as a percentage of the total line width (less than 1.0).
		 * @memberof PolylineGlowMaterialProperty.prototype
		 * @type {Property}
		 */
		glowPower: Property;

		/**
		 * Gets the {@link Material} type at the provided time.
		 * @param {JulianDate} time The time for which to retrieve the type.
		 * @returns {String} The type of material.
		 */
		getType(time: JulianDate): string;

		/**
		 * Gets the value of the property at the provided time.
		 * @param {JulianDate} time The time for which to retrieve the value.
		 * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValue(time: JulianDate, result?: any): any;

		/**
		 * Compares this property to the provided property and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Property} [other] The other property.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		equals(other?: Property): boolean;

	}

	/**
	 * Describes a polyline. The first two positions define a line segment,
	 * and each additional position defines a line segment from the previous position. The segments
	 * can be linear connected points, great arcs, or clamped to terrain.
	 * @alias PolylineGraphics
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Property} [options.positions] A Property specifying the array of {@link Cartesian3} positions that define the line strip.
	 * @param {Property} [options.followSurface=true] A boolean Property specifying whether the line segments should be great arcs or linearly connected.
	 * @param {Property} [options.clampToGround=false] A boolean Property specifying whether the Polyline should be clamped to the ground.
	 * @param {Property} [options.width=1.0] A numeric Property specifying the width in pixels.
	 * @param {Property} [options.show=true] A boolean Property specifying the visibility of the polyline.
	 * @param {MaterialProperty} [options.material=Color.WHITE] A Property specifying the material used to draw the polyline.
	 * @param {MaterialProperty} [options.depthFailMaterial] A property specifiying the material used to draw the polyline when it is below the terrain.
	 * @param {Property} [options.granularity=Cesium.Math.RADIANS_PER_DEGREE] A numeric Property specifying the angular distance between each latitude and longitude if followSurface is true.
	 * @param {Property} [options.shadows=ShadowMode.DISABLED] An enum Property specifying whether the polyline casts or receives shadows from each light source.
	 * @param {Property} [options.distanceDisplayCondition] A Property specifying at what distance from the camera that this polyline will be displayed.
	 * @param {Property} [options.zIndex=0] A Property specifying the zIndex used for ordering ground geometry. Only has an effect if `clampToGround` is true and polylines on terrain is supported.
	 * @see Entity
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Polyline.html|Cesium Sandcastle Polyline Demo}
	 */
	class PolylineGraphics {
		constructor(options?: {
			positions?: Property;
			followSurface?: Property;
			clampToGround?: Property;
			width?: Property;
			show?: Property;
			material?: MaterialProperty;
			depthFailMaterial?: MaterialProperty;
			granularity?: Property;
			shadows?: Property;
			distanceDisplayCondition?: Property;
			zIndex?: Property;
		});

		/**
		 * Gets the event that is raised whenever a property or sub-property is changed or modified.
		 * @memberof PolylineGraphics.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets or sets the boolean Property specifying the visibility of the polyline.
		 * @memberof PolylineGraphics.prototype
		 * @type {Property}
		 * @default true
		 */
		show: Property;

		/**
		 * Gets or sets the Property specifying the material used to draw the polyline.
		 * @memberof PolylineGraphics.prototype
		 * @type {MaterialProperty}
		 * @default Color.WHITE
		 */
		material: MaterialProperty;

		/**
		 * Gets or sets the Property specifying the material used to draw the polyline when it fails the depth test.
		 * <p>
		 * Requires the EXT_frag_depth WebGL extension to render properly. If the extension is not supported,
		 * there may be artifacts.
		 * </p>
		 * @memberof PolylineGraphics.prototype
		 * @type {MaterialProperty}
		 * @default undefined
		 */
		depthFailMaterial: MaterialProperty;

		/**
		 * Gets or sets the Property specifying the array of {@link Cartesian3}
		 * positions that define the line strip.
		 * @memberof PolylineGraphics.prototype
		 * @type {Property}
		 */
		positions: Property;

		/**
		 * Gets or sets the numeric Property specifying the width in pixels.
		 * @memberof PolylineGraphics.prototype
		 * @type {Property}
		 * @default 1.0
		 */
		width: Property;

		/**
		 * Gets or sets the boolean Property specifying whether the line segments
		 * should be great arcs or linearly connected.
		 * @memberof PolylineGraphics.prototype
		 * @type {Property}
		 * @default true
		 */
		followSurface: Property;

		/**
		 * Gets or sets the boolean Property specifying whether the polyline
		 * should be clamped to the ground.
		 * @memberof PolylineGraphics.prototype
		 * @type {Property}
		 * @default false
		 */
		clampToGround: Property;

		/**
		 * Gets or sets the numeric Property specifying the angular distance between each latitude and longitude if followSurface is true and clampToGround is false.
		 * @memberof PolylineGraphics.prototype
		 * @type {Property}
		 * @default Cesium.Math.RADIANS_PER_DEGREE
		 */
		granularity: Property;

		/**
		 * Get or sets the enum Property specifying whether the polyline
		 * casts or receives shadows from each light source.
		 * @memberof PolylineGraphics.prototype
		 * @type {Property}
		 * @default ShadowMode.DISABLED
		 */
		shadows: Property;

		/**
		 * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this polyline will be displayed.
		 * @memberof PolylineGraphics.prototype
		 * @type {Property}
		 */
		distanceDisplayCondition: Property;

		/**
		 * Duplicates this instance.
		 * @param {PolylineGraphics} [result] The object onto which to store the result.
		 * @returns {PolylineGraphics} The modified result parameter or a new instance if one was not provided.
		 */
		clone(result?: PolylineGraphics): PolylineGraphics;

		/**
		 * Assigns each unassigned property on this object to the value
		 * of the same property on the provided source object.
		 * @param {PolylineGraphics} source The object to be merged into this object.
		 */
		merge(source: PolylineGraphics): void;

	}

	/**
	 * A {@link MaterialProperty} that maps to polyline outline {@link Material} uniforms.
	 * @alias PolylineOutlineMaterialProperty
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Property} [options.color=Color.WHITE] A Property specifying the {@link Color} of the line.
	 * @param {Property} [options.outlineColor=Color.BLACK] A Property specifying the {@link Color} of the outline.
	 * @param {Property} [options.outlineWidth=1.0] A numeric Property specifying the width of the outline, in pixels.
	 */
	class PolylineOutlineMaterialProperty {
		constructor(options?: {
			color?: Property;
			outlineColor?: Property;
			outlineWidth?: Property;
		});

		/**
		 * Gets a value indicating if this property is constant.  A property is considered
		 * constant if getValue always returns the same result for the current definition.
		 * @memberof PolylineOutlineMaterialProperty.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isConstant: boolean;

		/**
		 * Gets the event that is raised whenever the definition of this property changes.
		 * The definition is considered to have changed if a call to getValue would return
		 * a different result for the same time.
		 * @memberof PolylineOutlineMaterialProperty.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets or sets the Property specifying the {@link Color} of the line.
		 * @memberof PolylineOutlineMaterialProperty.prototype
		 * @type {Property}
		 * @default Color.WHITE
		 */
		color: Property;

		/**
		 * Gets or sets the Property specifying the {@link Color} of the outline.
		 * @memberof PolylineOutlineMaterialProperty.prototype
		 * @type {Property}
		 * @default Color.BLACK
		 */
		outlineColor: Property;

		/**
		 * Gets or sets the numeric Property specifying the width of the outline.
		 * @memberof PolylineOutlineMaterialProperty.prototype
		 * @type {Property}
		 * @default 1.0
		 */
		outlineWidth: Property;

		/**
		 * Gets the {@link Material} type at the provided time.
		 * @param {JulianDate} time The time for which to retrieve the type.
		 * @returns {String} The type of material.
		 */
		getType(time: JulianDate): string;

		/**
		 * Gets the value of the property at the provided time.
		 * @param {JulianDate} time The time for which to retrieve the value.
		 * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValue(time: JulianDate, result?: any): any;

		/**
		 * Compares this property to the provided property and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Property} [other] The other property.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		equals(other?: Property): boolean;

	}

	/**
	 * A visualizer for polylines represented by {@link Primitive} instances.
	 * @alias PolylineVisualizer
	 * @constructor
	 * @param {Scene} scene The scene the primitives will be rendered in.
	 * @param {EntityCollection} entityCollection The entityCollection to visualize.
	 * @param {PrimitiveCollection} [primitives=scene.primitives] A collection to add primitives related to the entities
	 * @param {PrimitiveCollection} [groundPrimitives=scene.groundPrimitives] A collection to add ground primitives related to the entities
	 */
	class PolylineVisualizer {
		constructor(scene: Scene, entityCollection: EntityCollection, primitives?: PrimitiveCollection, groundPrimitives?: PrimitiveCollection);

		/**
		 * Updates all of the primitives created by this visualizer to match their
		 * Entity counterpart at the given time.
		 * @param {JulianDate} time The time to update to.
		 * @returns {Boolean} True if the visualizer successfully updated to the provided time,
		 * false if the visualizer is waiting for asynchronous primitives to be created.
		 */
		update(time: JulianDate): boolean;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * @returns {Boolean} True if this object was destroyed; otherwise, false.
		 */
		isDestroyed(): boolean;

		/**
		 * Removes and destroys all primitives created by this instance.
		 */
		destroy(): void;

	}

	/**
	 * A {@link GeometryUpdater} for polyline volumes.
	 * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
	 * @alias PolylineVolumeGeometryUpdater
	 * @constructor
	 * @param {Entity} entity The entity containing the geometry to be visualized.
	 * @param {Scene} scene The scene where visualization is taking place.
	 */
	class PolylineVolumeGeometryUpdater {
		constructor(entity: Entity, scene: Scene);

		/**
		 * Creates the geometry instance which represents the fill of the geometry.
		 * @param {JulianDate} time The time to use when retrieving initial attribute values.
		 * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.
		 * @exception {DeveloperError} This instance does not represent a filled geometry.
		 */
		createFillGeometryInstance(time: JulianDate): GeometryInstance;

		/**
		 * Creates the geometry instance which represents the outline of the geometry.
		 * @param {JulianDate} time The time to use when retrieving initial attribute values.
		 * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.
		 * @exception {DeveloperError} This instance does not represent an outlined geometry.
		 */
		createOutlineGeometryInstance(time: JulianDate): GeometryInstance;

	}

	/**
	 * Describes a polyline volume defined as a line strip and corresponding two dimensional shape which is extruded along it.
	 * The resulting volume conforms to the curvature of the globe.
	 * @alias PolylineVolumeGraphics
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Property} [options.positions] A Property specifying the array of {@link Cartesian3} positions which define the line strip.
	 * @param {Property} [options.shape] A Property specifying the array of {@link Cartesian2} positions which define the shape to be extruded.
	 * @param {Property} [options.cornerType=CornerType.ROUNDED] A {@link CornerType} Property specifying the style of the corners.
	 * @param {Property} [options.show=true] A boolean Property specifying the visibility of the volume.
	 * @param {Property} [options.fill=true] A boolean Property specifying whether the volume is filled with the provided material.
	 * @param {MaterialProperty} [options.material=Color.WHITE] A Property specifying the material used to fill the volume.
	 * @param {Property} [options.outline=false] A boolean Property specifying whether the volume is outlined.
	 * @param {Property} [options.outlineColor=Color.BLACK] A Property specifying the {@link Color} of the outline.
	 * @param {Property} [options.outlineWidth=1.0] A numeric Property specifying the width of the outline.
	 * @param {Property} [options.granularity=Cesium.Math.RADIANS_PER_DEGREE] A numeric Property specifying the angular distance between each latitude and longitude point.
	 * @param {Property} [options.shadows=ShadowMode.DISABLED] An enum Property specifying whether the volume casts or receives shadows from each light source.
	 * @param {Property} [options.distanceDisplayCondition] A Property specifying at what distance from the camera that this volume will be displayed.
	 * @see Entity
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Polyline%20Volume.html|Cesium Sandcastle Polyline Volume Demo}
	 */
	class PolylineVolumeGraphics {
		constructor(options?: {
			positions?: Property;
			shape?: Property;
			cornerType?: Property;
			show?: Property;
			fill?: Property;
			material?: MaterialProperty;
			outline?: Property;
			outlineColor?: Property;
			outlineWidth?: Property;
			granularity?: Property;
			shadows?: Property;
			distanceDisplayCondition?: Property;
		});

		/**
		 * Gets the event that is raised whenever a property or sub-property is changed or modified.
		 * @memberof PolylineVolumeGraphics.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets or sets the boolean Property specifying the visibility of the volume.
		 * @memberof PolylineVolumeGraphics.prototype
		 * @type {Property}
		 * @default true
		 */
		show: Property;

		/**
		 * Gets or sets the Property specifying the material used to fill the volume.
		 * @memberof PolylineVolumeGraphics.prototype
		 * @type {MaterialProperty}
		 * @default Color.WHITE
		 */
		material: MaterialProperty;

		/**
		 * Gets or sets the Property specifying the array of {@link Cartesian3} positions which define the line strip.
		 * @memberof PolylineVolumeGraphics.prototype
		 * @type {Property}
		 */
		positions: Property;

		/**
		 * Gets or sets the Property specifying the array of {@link Cartesian2} positions which define the shape to be extruded.
		 * @memberof PolylineVolumeGraphics.prototype
		 * @type {Property}
		 */
		shape: Property;

		/**
		 * Gets or sets the numeric Property specifying the angular distance between points on the volume.
		 * @memberof PolylineVolumeGraphics.prototype
		 * @type {Property}
		 * @default {CesiumMath.RADIANS_PER_DEGREE}
		 */
		granularity: Property;

		/**
		 * Gets or sets the boolean Property specifying whether the volume is filled with the provided material.
		 * @memberof PolylineVolumeGraphics.prototype
		 * @type {Property}
		 * @default true
		 */
		fill: Property;

		/**
		 * Gets or sets the Property specifying whether the volume is outlined.
		 * @memberof PolylineVolumeGraphics.prototype
		 * @type {Property}
		 * @default false
		 */
		outline: Property;

		/**
		 * Gets or sets the Property specifying the {@link Color} of the outline.
		 * @memberof PolylineVolumeGraphics.prototype
		 * @type {Property}
		 * @default Color.BLACK
		 */
		outlineColor: Property;

		/**
		 * Gets or sets the numeric Property specifying the width of the outline.
		 * @memberof PolylineVolumeGraphics.prototype
		 * @type {Property}
		 * @default 1.0
		 */
		outlineWidth: Property;

		/**
		 * Gets or sets the {@link CornerType} Property specifying the style of the corners.
		 * @memberof PolylineVolumeGraphics.prototype
		 * @type {Property}
		 * @default CornerType.ROUNDED
		 */
		cornerType: Property;

		/**
		 * Get or sets the enum Property specifying whether the volume
		 * casts or receives shadows from each light source.
		 * @memberof PolylineVolumeGraphics.prototype
		 * @type {Property}
		 * @default ShadowMode.DISABLED
		 */
		shadows: Property;

		/**
		 * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this volume will be displayed.
		 * @memberof PolylineVolumeGraphics.prototype
		 * @type {Property}
		 */
		distanceDisplayCondition: Property;

		/**
		 * Duplicates this instance.
		 * @param {PolylineVolumeGraphics} [result] The object onto which to store the result.
		 * @returns {PolylineVolumeGraphics} The modified result parameter or a new instance if one was not provided.
		 */
		clone(result?: PolylineVolumeGraphics): PolylineVolumeGraphics;

		/**
		 * Assigns each unassigned property on this object to the value
		 * of the same property on the provided source object.
		 * @param {PolylineVolumeGraphics} source The object to be merged into this object.
		 */
		merge(source: PolylineVolumeGraphics): void;

	}

	/**
	 * The interface for all {@link Property} objects that define a world
	 * location as a {@link Cartesian3} with an associated {@link ReferenceFrame}.
	 * This type defines an interface and cannot be instantiated directly.
	 * @alias PositionProperty
	 * @constructor
	 * @see CompositePositionProperty
	 * @see ConstantPositionProperty
	 * @see SampledPositionProperty
	 * @see TimeIntervalCollectionPositionProperty
	 */
	class PositionProperty {
		constructor();

		/**
		 * Gets a value indicating if this property is constant.  A property is considered
		 * constant if getValue always returns the same result for the current definition.
		 * @memberof PositionProperty.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isConstant: boolean;

		/**
		 * Gets the event that is raised whenever the definition of this property changes.
		 * The definition is considered to have changed if a call to getValue would return
		 * a different result for the same time.
		 * @memberof PositionProperty.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets the reference frame that the position is defined in.
		 * @memberof PositionProperty.prototype
		 * @type {ReferenceFrame}
		 */
		referenceFrame: any;

		/**
		 * Gets the value of the property at the provided time in the fixed frame.
		 * @function
		 * @param {JulianDate} time The time for which to retrieve the value.
		 * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValue(time: JulianDate, result?: Cartesian3): Cartesian3;

		/**
		 * Gets the value of the property at the provided time and in the provided reference frame.
		 * @function
		 * @param {JulianDate} time The time for which to retrieve the value.
		 * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.
		 * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValueInReferenceFrame(time: JulianDate, referenceFrame: any, result?: Cartesian3): Cartesian3;

		/**
		 * Compares this property to the provided property and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @function
		 * @param {Property} [other] The other property.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		equals(other?: Property): boolean;

	}

	/**
	 * A {@link PositionProperty} whose value is an array whose items are the computed value
	 * of other PositionProperty instances.
	 * @alias PositionPropertyArray
	 * @constructor
	 * @param {Property[]} [value] An array of Property instances.
	 * @param {ReferenceFrame} [referenceFrame=ReferenceFrame.FIXED] The reference frame in which the position is defined.
	 */
	class PositionPropertyArray {
		constructor(value?: (Property)[], referenceFrame?: any);

		/**
		 * Gets a value indicating if this property is constant.  This property
		 * is considered constant if all property items in the array are constant.
		 * @memberof PositionPropertyArray.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isConstant: boolean;

		/**
		 * Gets the event that is raised whenever the definition of this property changes.
		 * The definition is changed whenever setValue is called with data different
		 * than the current value or one of the properties in the array also changes.
		 * @memberof PositionPropertyArray.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets the reference frame in which the position is defined.
		 * @memberof PositionPropertyArray.prototype
		 * @type {ReferenceFrame}
		 * @default ReferenceFrame.FIXED;
		 */
		referenceFrame: any;

		/**
		 * Gets the value of the property.
		 * @param {JulianDate} [time] The time for which to retrieve the value.  This parameter is unused since the value does not change with respect to time.
		 * @param {Cartesian3[]} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Cartesian3[]} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValue(time?: JulianDate, result?: (Cartesian3)[]): (Cartesian3)[];

		/**
		 * Gets the value of the property at the provided time and in the provided reference frame.
		 * @param {JulianDate} time The time for which to retrieve the value.
		 * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.
		 * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValueInReferenceFrame(time: JulianDate, referenceFrame: any, result?: Cartesian3): Cartesian3;

		/**
		 * Sets the value of the property.
		 * @param {Property[]} value An array of Property instances.
		 */
		setValue(value: (Property)[]): void;

		/**
		 * Compares this property to the provided property and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Property} [other] The other property.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		equals(other?: Property): boolean;

	}

	/**
	 * The interface for all properties, which represent a value that can optionally vary over time.
	 * This type defines an interface and cannot be instantiated directly.
	 * @alias Property
	 * @constructor
	 * @see CompositeProperty
	 * @see ConstantProperty
	 * @see SampledProperty
	 * @see TimeIntervalCollectionProperty
	 * @see MaterialProperty
	 * @see PositionProperty
	 * @see ReferenceProperty
	 */
	class Property {
		constructor();

		/**
		 * Gets a value indicating if this property is constant.  A property is considered
		 * constant if getValue always returns the same result for the current definition.
		 * @memberof Property.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isConstant: boolean;

		/**
		 * Gets the event that is raised whenever the definition of this property changes.
		 * The definition is considered to have changed if a call to getValue would return
		 * a different result for the same time.
		 * @memberof Property.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets the value of the property at the provided time.
		 * @function
		 * @param {JulianDate} time The time for which to retrieve the value.
		 * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValue(time: JulianDate, result?: any): any;

		/**
		 * Compares this property to the provided property and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @function
		 * @param {Property} [other] The other property.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		equals(other?: Property): boolean;

		/**
		 * @param {Property} left
		 * @param {Property} right
		 * @return {Boolean}
		 */
		static equals(left: Property, right: Property): boolean;

		/**
		 * @param {Array} left
		 * @param {Array} right
		 * @return {Boolean}
		 */
		static arrayEquals(left: any[], right: any[]): boolean;

		/**
		 * @param {*} property
		 * @return {Boolean}
		 */
		static isConstant(property: any): boolean;

		/**
		 * @param {Property} property
		 * @param {JulianDate} time
		 * @param {*} [result]
		 */
		static getValueOrUndefined(property: Property, time: JulianDate, result?: any): void;

	}

	/**
	 * A {@link Property} whose value is an array whose items are the computed value
	 * of other property instances.
	 * @alias PropertyArray
	 * @constructor
	 * @param {Property[]} [value] An array of Property instances.
	 */
	class PropertyArray {
		constructor(value?: (Property)[]);

		/**
		 * Gets a value indicating if this property is constant.  This property
		 * is considered constant if all property items in the array are constant.
		 * @memberof PropertyArray.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isConstant: boolean;

		/**
		 * Gets the event that is raised whenever the definition of this property changes.
		 * The definition is changed whenever setValue is called with data different
		 * than the current value or one of the properties in the array also changes.
		 * @memberof PropertyArray.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets the value of the property.
		 * @param {JulianDate} time The time for which to retrieve the value.
		 * @param {Object[]} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Object[]} The modified result parameter, which is an array of values produced by evaluating each of the contained properties at the given time or a new instance if the result parameter was not supplied.
		 */
		getValue(time: JulianDate, result?: any[]): any[];

		/**
		 * Sets the value of the property.
		 * @param {Property[]} value An array of Property instances.
		 */
		setValue(value: (Property)[]): void;

		/**
		 * Compares this property to the provided property and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Property} [other] The other property.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		equals(other?: Property): boolean;

	}

	/**
	 * A {@link Property} whose value is a key-value mapping of property names to the computed value of other properties.
	 * @alias PropertyBag
	 * @constructor
	 * @param {Object} [value] An object, containing key-value mapping of property names to properties.
	 * @param {Function} [createPropertyFunction] A function that will be called when the value of any of the properties in value are not a Property.
	 */
	class PropertyBag {
		constructor(value?: any, createPropertyFunction?: Function);

		/**
		 * Gets the names of all properties registered on this instance.
		 * @memberof PropertyBag.prototype
		 * @type {Array}
		 */
		propertyNames: any[];

		/**
		 * Gets a value indicating if this property is constant.  This property
		 * is considered constant if all property items in this object are constant.
		 * @memberof PropertyBag.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isConstant: boolean;

		/**
		 * Gets the event that is raised whenever the set of properties contained in this
		 * object changes, or one of the properties itself changes.
		 * @memberof PropertyBag.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Determines if this object has defined a property with the given name.
		 * @param {String} propertyName The name of the property to check for.
		 * @returns {Boolean} True if this object has defined a property with the given name, false otherwise.
		 */
		hasProperty(propertyName: string): boolean;

		/**
		 * Adds a property to this object.
		 * @param {String} propertyName The name of the property to add.
		 * @param {*} [value] The value of the new property, if provided.
		 * @param {Function} [createPropertyFunction] A function that will be called when the value of this new property is set to a value that is not a Property.
		 * @exception {DeveloperError} "propertyName" is already a registered property.
		 */
		addProperty(propertyName: string, value?: any, createPropertyFunction?: Function): void;

		/**
		 * Removed a property previously added with addProperty.
		 * @param {String} propertyName The name of the property to remove.
		 * @exception {DeveloperError} "propertyName" is not a registered property.
		 */
		removeProperty(propertyName: string): void;

		/**
		 * Gets the value of this property.  Each contained property will be evaluated at the given time, and the overall
		 * result will be an object, mapping property names to those values.
		 * @param {JulianDate} time The time for which to retrieve the value.
		 * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * Note that any properties in result which are not part of this PropertyBag will be left as-is.
		 * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValue(time: JulianDate, result?: any): any;

		/**
		 * Assigns each unassigned property on this object to the value
		 * of the same property on the provided source object.
		 * @param {Object} source The object to be merged into this object.
		 * @param {Function} [createPropertyFunction] A function that will be called when the value of any of the properties in value are not a Property.
		 */
		merge(source: any, createPropertyFunction?: Function): void;

		/**
		 * Compares this property to the provided property and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Property} [other] The other property.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		equals(other?: Property): boolean;

	}

	/**
	 * A {@link GeometryUpdater} for rectangles.
	 * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
	 * @alias RectangleGeometryUpdater
	 * @constructor
	 * @param {Entity} entity The entity containing the geometry to be visualized.
	 * @param {Scene} scene The scene where visualization is taking place.
	 */
	class RectangleGeometryUpdater {
		constructor(entity: Entity, scene: Scene);

		/**
		 * Creates the geometry instance which represents the fill of the geometry.
		 * @param {JulianDate} time The time to use when retrieving initial attribute values.
		 * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.
		 * @exception {DeveloperError} This instance does not represent a filled geometry.
		 */
		createFillGeometryInstance(time: JulianDate): GeometryInstance;

		/**
		 * Creates the geometry instance which represents the outline of the geometry.
		 * @param {JulianDate} time The time to use when retrieving initial attribute values.
		 * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.
		 * @exception {DeveloperError} This instance does not represent an outlined geometry.
		 */
		createOutlineGeometryInstance(time: JulianDate): GeometryInstance;

	}

	/**
	 * Describes graphics for a {@link Rectangle}.
	 * The rectangle conforms to the curvature of the globe and can be placed on the surface or
	 * at altitude and can optionally be extruded into a volume.
	 * @alias RectangleGraphics
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Property} [options.coordinates] The Property specifying the {@link Rectangle}.
	 * @param {Property} [options.height=0] A numeric Property specifying the altitude of the rectangle relative to the ellipsoid surface.
	 * @param {Property} [options.heightReference] A Property specifying what the height is relative to.
	 * @param {Property} [options.extrudedHeight] A numeric Property specifying the altitude of the rectangle's extruded face relative to the ellipsoid surface.
	 * @param {Property} [options.extrudedHeightReference] A Property specifying what the extrudedHeight is relative to.
	 * @param {Property} [options.show=true] A boolean Property specifying the visibility of the rectangle.
	 * @param {Property} [options.fill=true] A boolean Property specifying whether the rectangle is filled with the provided material.
	 * @param {MaterialProperty} [options.material=Color.WHITE] A Property specifying the material used to fill the rectangle.
	 * @param {Property} [options.outline=false] A boolean Property specifying whether the rectangle is outlined.
	 * @param {Property} [options.outlineColor=Color.BLACK] A Property specifying the {@link Color} of the outline.
	 * @param {Property} [options.outlineWidth=1.0] A numeric Property specifying the width of the outline.
	 * @param {Property} [options.rotation=0.0] A numeric property specifying the rotation of the rectangle clockwise from north.
	 * @param {Property} [options.stRotation=0.0] A numeric property specifying the rotation of the rectangle texture counter-clockwise from north.
	 * @param {Property} [options.granularity=Cesium.Math.RADIANS_PER_DEGREE] A numeric Property specifying the angular distance between points on the rectangle.
	 * @param {Property} [options.shadows=ShadowMode.DISABLED] An enum Property specifying whether the rectangle casts or receives shadows from each light source.
	 * @param {Property} [options.distanceDisplayCondition] A Property specifying at what distance from the camera that this rectangle will be displayed.
	 * @param {Property} [options.zIndex=0] A Property specifying the zIndex used for ordering ground geometry.  Only has an effect if the rectangle is constant and neither height or extrudedHeight are specified.
	 * @see Entity
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Rectangle.html|Cesium Sandcastle Rectangle Demo}
	 */
	class RectangleGraphics {
		constructor(options?: {
			coordinates?: Property;
			height?: Property;
			heightReference?: Property;
			extrudedHeight?: Property;
			extrudedHeightReference?: Property;
			show?: Property;
			fill?: Property;
			material?: MaterialProperty;
			outline?: Property;
			outlineColor?: Property;
			outlineWidth?: Property;
			rotation?: Property;
			stRotation?: Property;
			granularity?: Property;
			shadows?: Property;
			distanceDisplayCondition?: Property;
			zIndex?: Property;
		});

		/**
		 * Gets or sets the zIndex Property specifying the ordering of the polyline. Only has an effect if `clampToGround` is true and polylines on terrain is supported.
		 * @memberof RectangleGraphics.prototype
		 * @type {ConstantProperty}
		 * @default 0
		 */
		zIndex: ConstantProperty;

		/**
		 * Gets the event that is raised whenever a property or sub-property is changed or modified.
		 * @memberof RectangleGraphics.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets or sets the boolean Property specifying the visibility of the rectangle.
		 * @memberof RectangleGraphics.prototype
		 * @type {Property}
		 * @default true
		 */
		show: Property;

		/**
		 * Gets or sets the Property specifying the {@link Rectangle}.
		 * @memberof RectangleGraphics.prototype
		 * @type {Property}
		 */
		coordinates: Property;

		/**
		 * Gets or sets the Property specifying the material used to fill the rectangle.
		 * @memberof RectangleGraphics.prototype
		 * @type {MaterialProperty}
		 * @default Color.WHITE
		 */
		material: MaterialProperty;

		/**
		 * Gets or sets the numeric Property specifying the altitude of the rectangle.
		 * @memberof RectangleGraphics.prototype
		 * @type {Property}
		 * @default 0.0
		 */
		height: Property;

		/**
		 * Gets or sets the Property specifying the {@link HeightReference}.
		 * @memberof RectangleGraphics.prototype
		 * @type {Property}
		 * @default HeightReference.NONE
		 */
		heightReference: Property;

		/**
		 * Gets or sets the numeric Property specifying the altitude of the rectangle extrusion.
		 * Setting this property creates volume starting at height and ending at this altitude.
		 * @memberof RectangleGraphics.prototype
		 * @type {Property}
		 */
		extrudedHeight: Property;

		/**
		 * Gets or sets the Property specifying the extruded {@link HeightReference}.
		 * @memberof RectangleGraphics.prototype
		 * @type {Property}
		 * @default HeightReference.NONE
		 */
		extrudedHeightReference: Property;

		/**
		 * Gets or sets the numeric Property specifying the angular distance between points on the rectangle.
		 * @memberof RectangleGraphics.prototype
		 * @type {Property}
		 * @default {CesiumMath.RADIANS_PER_DEGREE}
		 */
		granularity: Property;

		/**
		 * Gets or sets the numeric property specifying the rotation of the rectangle texture counter-clockwise from north.
		 * @memberof RectangleGraphics.prototype
		 * @type {Property}
		 * @default 0
		 */
		stRotation: Property;

		/**
		 * Gets or sets the numeric property specifying the rotation of the rectangle clockwise from north.
		 * @memberof RectangleGraphics.prototype
		 * @type {Property}
		 * @default 0
		 */
		rotation: Property;

		/**
		 * Gets or sets the boolean Property specifying whether the rectangle is filled with the provided material.
		 * @memberof RectangleGraphics.prototype
		 * @type {Property}
		 * @default true
		 */
		fill: Property;

		/**
		 * Gets or sets the Property specifying whether the rectangle is outlined.
		 * @memberof RectangleGraphics.prototype
		 * @type {Property}
		 * @default false
		 */
		outline: Property;

		/**
		 * Gets or sets the Property specifying the {@link Color} of the outline.
		 * @memberof RectangleGraphics.prototype
		 * @type {Property}
		 * @default Color.BLACK
		 */
		outlineColor: Property;

		/**
		 * Gets or sets the numeric Property specifying the width of the outline.
		 * @memberof RectangleGraphics.prototype
		 * @type {Property}
		 * @default 1.0
		 */
		outlineWidth: Property;

		/**
		 * Get or sets the enum Property specifying whether the rectangle
		 * casts or receives shadows from each light source.
		 * @memberof RectangleGraphics.prototype
		 * @type {Property}
		 * @default ShadowMode.DISABLED
		 */
		shadows: Property;

		/**
		 * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this rectangle will be displayed.
		 * @memberof RectangleGraphics.prototype
		 * @type {Property}
		 */
		distanceDisplayCondition: Property;

		/**
		 * Gets or sets the {@link ClassificationType} Property specifying whether this rectangle will classify terrain, 3D Tiles, or both when on the ground.
		 * @memberof RectangleGraphics.prototype
		 * @type {Property}
		 * @default ClassificationType.TERRAIN
		 */
		classificationType: Property;

		/**
		 * Duplicates this instance.
		 * @param {RectangleGraphics} [result] The object onto which to store the result.
		 * @returns {RectangleGraphics} The modified result parameter or a new instance if one was not provided.
		 */
		clone(result?: RectangleGraphics): RectangleGraphics;

		/**
		 * Assigns each unassigned property on this object to the value
		 * of the same property on the provided source object.
		 * @param {RectangleGraphics} source The object to be merged into this object.
		 */
		merge(source: RectangleGraphics): void;

	}

	/**
	 * A {@link Property} which transparently links to another property on a provided object.
	 * @alias ReferenceProperty
	 * @constructor
	 * @param {EntityCollection} targetCollection The entity collection which will be used to resolve the reference.
	 * @param {String} targetId The id of the entity which is being referenced.
	 * @param {String[]} targetPropertyNames The names of the property on the target entity which we will use.
	 * @example
	 * var collection = new Cesium.EntityCollection();
	 * //Create a new entity and assign a billboard scale.
	 * var object1 = new Cesium.Entity({id:'object1'});
	 * object1.billboard = new Cesium.BillboardGraphics();
	 * object1.billboard.scale = new Cesium.ConstantProperty(2.0);
	 * collection.add(object1);
	 * //Create a second entity and reference the scale from the first one.
	 * var object2 = new Cesium.Entity({id:'object2'});
	 * object2.model = new Cesium.ModelGraphics();
	 * object2.model.scale = new Cesium.ReferenceProperty(collection, 'object1', ['billboard', 'scale']);
	 * collection.add(object2);
	 * //Create a third object, but use the fromString helper function.
	 * var object3 = new Cesium.Entity({id:'object3'});
	 * object3.billboard = new Cesium.BillboardGraphics();
	 * object3.billboard.scale = Cesium.ReferenceProperty.fromString(collection, 'object1#billboard.scale');
	 * collection.add(object3);
	 * //You can refer to an entity with a # or . in id and property names by escaping them.
	 * var object4 = new Cesium.Entity({id:'#object.4'});
	 * object4.billboard = new Cesium.BillboardGraphics();
	 * object4.billboard.scale = new Cesium.ConstantProperty(2.0);
	 * collection.add(object4);
	 * var object5 = new Cesium.Entity({id:'object5'});
	 * object5.billboard = new Cesium.BillboardGraphics();
	 * object5.billboard.scale = Cesium.ReferenceProperty.fromString(collection, '\\#object\\.4#billboard.scale');
	 * collection.add(object5);
	 */
	class ReferenceProperty {
		constructor(targetCollection: EntityCollection, targetId: string, targetPropertyNames: string[]);

		/**
		 * Gets a value indicating if this property is constant.
		 * @memberof ReferenceProperty.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isConstant: boolean;

		/**
		 * Gets the event that is raised whenever the definition of this property changes.
		 * The definition is changed whenever the referenced property's definition is changed.
		 * @memberof ReferenceProperty.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets the reference frame that the position is defined in.
		 * This property is only valid if the referenced property is a {@link PositionProperty}.
		 * @memberof ReferenceProperty.prototype
		 * @type {ReferenceFrame}
		 * @readonly
		 */
		readonly referenceFrame: any;

		/**
		 * Gets the id of the entity being referenced.
		 * @memberof ReferenceProperty.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly targetId: string;

		/**
		 * Gets the collection containing the entity being referenced.
		 * @memberof ReferenceProperty.prototype
		 * @type {EntityCollection}
		 * @readonly
		 */
		readonly targetCollection: EntityCollection;

		/**
		 * Gets the array of property names used to retrieve the referenced property.
		 * @memberof ReferenceProperty.prototype
		 * @type {String[]}
		 * @readonly
		 */
		readonly targetPropertyNames: string[];

		/**
		 * Gets the resolved instance of the underlying referenced property.
		 * @memberof ReferenceProperty.prototype
		 * @type {Property}
		 * @readonly
		 */
		readonly resolvedProperty: Property;

		/**
		 * Creates a new instance given the entity collection that will
		 * be used to resolve it and a string indicating the target entity id and property.
		 * The format of the string is "objectId#foo.bar", where # separates the id from
		 * property path and . separates sub-properties.  If the reference identifier or
		 * or any sub-properties contains a # . or \ they must be escaped.
		 * @param {EntityCollection} targetCollection
		 * @param {String} referenceString
		 * @returns {ReferenceProperty} A new instance of ReferenceProperty.
		 * @exception {DeveloperError} invalid referenceString.
		 */
		static fromString(targetCollection: EntityCollection, referenceString: string): ReferenceProperty;

		/**
		 * Gets the value of the property at the provided time.
		 * @param {JulianDate} time The time for which to retrieve the value.
		 * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValue(time: JulianDate, result?: any): any;

		/**
		 * Gets the value of the property at the provided time and in the provided reference frame.
		 * This method is only valid if the property being referenced is a {@link PositionProperty}.
		 * @param {JulianDate} time The time for which to retrieve the value.
		 * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.
		 * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValueInReferenceFrame(time: JulianDate, referenceFrame: any, result?: Cartesian3): Cartesian3;

		/**
		 * Gets the {@link Material} type at the provided time.
		 * This method is only valid if the property being referenced is a {@link MaterialProperty}.
		 * @param {JulianDate} time The time for which to retrieve the type.
		 * @returns {String} The type of material.
		 */
		getType(time: JulianDate): string;

		/**
		 * Compares this property to the provided property and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Property} [other] The other property.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		equals(other?: Property): boolean;

	}

	/**
	 * Represents a {@link Packable} number that always interpolates values
	 * towards the shortest angle of rotation. This object is never used directly
	 * but is instead passed to the constructor of {@link SampledProperty}
	 * in order to represent a two-dimensional angle of rotation.
	 * @exports Rotation
	 * @example
	 * var time1 = Cesium.JulianDate.fromIso8601('2010-05-07T00:00:00');
	 * var time2 = Cesium.JulianDate.fromIso8601('2010-05-07T00:01:00');
	 * var time3 = Cesium.JulianDate.fromIso8601('2010-05-07T00:02:00');
	 * var property = new Cesium.SampledProperty(Cesium.Rotation);
	 * property.addSample(time1, 0);
	 * property.addSample(time3, Cesium.Math.toRadians(350));
	 * //Getting the value at time2 will equal 355 degrees instead
	 * //of 175 degrees (which is what you get if you construct
	 * //a SampledProperty(Number) instead.  Note, the actual
	 * //return value is in radians, not degrees.
	 * property.getValue(time2);
	 * @see PackableForInterpolation
	 */
	namespace Rotation {
		/**
		 * The number of elements used to pack the object into an array.
		 * @type {Number}
		 */
		const packedLength: number;

		/**
		 * Stores the provided instance into the provided array.
		 * @param {Rotation} value The value to pack.
		 * @param {Number[]} array The array to pack into.
		 * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.
		 * @returns {Number[]} The array that was packed into
		 */
		function pack(value: any, array: number[], startingIndex?: number): number[];

		/**
		 * Retrieves an instance from a packed array.
		 * @param {Number[]} array The packed array.
		 * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.
		 * @param {Rotation} [result] The object into which to store the result.
		 * @returns {Rotation} The modified result parameter or a new Rotation instance if one was not provided.
		 */
		function unpack(array: number[], startingIndex?: number, result?: any): any;

		/**
		 * Converts a packed array into a form suitable for interpolation.
		 * @param {Number[]} packedArray The packed array.
		 * @param {Number} [startingIndex=0] The index of the first element to be converted.
		 * @param {Number} [lastIndex=packedArray.length] The index of the last element to be converted.
		 * @param {Number[]} [result] The object into which to store the result.
		 */
		function convertPackedArrayForInterpolation(packedArray: number[], startingIndex?: number, lastIndex?: number, result?: number[]): void;

		/**
		 * Retrieves an instance from a packed array converted with {@link Rotation.convertPackedArrayForInterpolation}.
		 * @param {Number[]} array The array previously packed for interpolation.
		 * @param {Number[]} sourceArray The original packed array.
		 * @param {Number} [firstIndex=0] The firstIndex used to convert the array.
		 * @param {Number} [lastIndex=packedArray.length] The lastIndex used to convert the array.
		 * @param {Rotation} [result] The object into which to store the result.
		 * @returns {Rotation} The modified result parameter or a new Rotation instance if one was not provided.
		 */
		function unpackInterpolationResult(array: number[], sourceArray: number[], firstIndex?: number, lastIndex?: number, result?: any): any;

	}

	/**
	 * A {@link SampledProperty} which is also a {@link PositionProperty}.
	 * @alias SampledPositionProperty
	 * @constructor
	 * @param {ReferenceFrame} [referenceFrame=ReferenceFrame.FIXED] The reference frame in which the position is defined.
	 * @param {Number} [numberOfDerivatives=0] The number of derivatives that accompany each position; i.e. velocity, acceleration, etc...
	 */
	class SampledPositionProperty {
		constructor(referenceFrame?: any, numberOfDerivatives?: number);

		/**
		 * Gets a value indicating if this property is constant.  A property is considered
		 * constant if getValue always returns the same result for the current definition.
		 * @memberof SampledPositionProperty.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isConstant: boolean;

		/**
		 * Gets the event that is raised whenever the definition of this property changes.
		 * The definition is considered to have changed if a call to getValue would return
		 * a different result for the same time.
		 * @memberof SampledPositionProperty.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets the reference frame in which the position is defined.
		 * @memberof SampledPositionProperty.prototype
		 * @type {ReferenceFrame}
		 * @default ReferenceFrame.FIXED;
		 */
		referenceFrame: any;

		/**
		 * Gets the degree of interpolation to perform when retrieving a value.
		 * @memberof SampledPositionProperty.prototype
		 * @type {Number}
		 * @default 1
		 */
		interpolationDegree: number;

		/**
		 * Gets the interpolation algorithm to use when retrieving a value.
		 * @memberof SampledPositionProperty.prototype
		 * @type {InterpolationAlgorithm}
		 * @default LinearApproximation
		 */
		interpolationAlgorithm: any;

		/**
		 * The number of derivatives contained by this property; i.e. 0 for just position, 1 for velocity, etc.
		 * @memberof SampledPositionProperty.prototype
		 * @type {Boolean}
		 * @default false
		 */
		numberOfDerivatives: boolean;

		/**
		 * Gets or sets the type of extrapolation to perform when a value
		 * is requested at a time after any available samples.
		 * @memberof SampledPositionProperty.prototype
		 * @type {ExtrapolationType}
		 * @default ExtrapolationType.NONE
		 */
		forwardExtrapolationType: any;

		/**
		 * Gets or sets the amount of time to extrapolate forward before
		 * the property becomes undefined.  A value of 0 will extrapolate forever.
		 * @memberof SampledPositionProperty.prototype
		 * @type {Number}
		 * @default 0
		 */
		forwardExtrapolationDuration: number;

		/**
		 * Gets or sets the type of extrapolation to perform when a value
		 * is requested at a time before any available samples.
		 * @memberof SampledPositionProperty.prototype
		 * @type {ExtrapolationType}
		 * @default ExtrapolationType.NONE
		 */
		backwardExtrapolationType: any;

		/**
		 * Gets or sets the amount of time to extrapolate backward
		 * before the property becomes undefined.  A value of 0 will extrapolate forever.
		 * @memberof SampledPositionProperty.prototype
		 * @type {Number}
		 * @default 0
		 */
		backwardExtrapolationDuration: number;

		/**
		 * Gets the position at the provided time.
		 * @param {JulianDate} time The time for which to retrieve the value.
		 * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValue(time: JulianDate, result?: Cartesian3): Cartesian3;

		/**
		 * Gets the position at the provided time and in the provided reference frame.
		 * @param {JulianDate} time The time for which to retrieve the value.
		 * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.
		 * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValueInReferenceFrame(time: JulianDate, referenceFrame: any, result?: Cartesian3): Cartesian3;

		/**
		 * Sets the algorithm and degree to use when interpolating a position.
		 * @param {Object} [options] Object with the following properties:
		 * @param {InterpolationAlgorithm} [options.interpolationAlgorithm] The new interpolation algorithm.  If undefined, the existing property will be unchanged.
		 * @param {Number} [options.interpolationDegree] The new interpolation degree.  If undefined, the existing property will be unchanged.
		 */
		setInterpolationOptions(options?: {
			interpolationAlgorithm?: any;
			interpolationDegree?: number;
		}): void;

		/**
		 * Adds a new sample.
		 * @param {JulianDate} time The sample time.
		 * @param {Cartesian3} position The position at the provided time.
		 * @param {Cartesian3[]} [derivatives] The array of derivative values at the provided time.
		 */
		addSample(time: JulianDate, position: Cartesian3, derivatives?: (Cartesian3)[]): void;

		/**
		 * Adds multiple samples via parallel arrays.
		 * @param {JulianDate[]} times An array of JulianDate instances where each index is a sample time.
		 * @param {Cartesian3[]} positions An array of Cartesian3 position instances, where each value corresponds to the provided time index.
		 * @param {Array[]} [derivatives] An array where each value is another array containing derivatives for the corresponding time index.
		 * @exception {DeveloperError} All arrays must be the same length.
		 */
		addSamples(times: (JulianDate)[], positions: (Cartesian3)[], derivatives?: (any[])[]): void;

		/**
		 * Adds samples as a single packed array where each new sample is represented as a date,
		 * followed by the packed representation of the corresponding value and derivatives.
		 * @param {Number[]} packedSamples The array of packed samples.
		 * @param {JulianDate} [epoch] If any of the dates in packedSamples are numbers, they are considered an offset from this epoch, in seconds.
		 */
		addSamplesPackedArray(packedSamples: number[], epoch?: JulianDate): void;

		/**
		 * Compares this property to the provided property and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Property} [other] The other property.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		equals(other?: Property): boolean;

	}

	/**
	 * A {@link Property} whose value is interpolated for a given time from the
	 * provided set of samples and specified interpolation algorithm and degree.
	 * @alias SampledProperty
	 * @constructor
	 * @param {Number|Packable} type The type of property.
	 * @param {Packable[]} [derivativeTypes] When supplied, indicates that samples will contain derivative information of the specified types.
	 * @example
	 * //Create a linearly interpolated Cartesian2
	 * var property = new Cesium.SampledProperty(Cesium.Cartesian2);
	 * //Populate it with data
	 * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:00:00.00Z'), new Cesium.Cartesian2(0, 0));
	 * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-02T00:00:00.00Z'), new Cesium.Cartesian2(4, 7));
	 * //Retrieve an interpolated value
	 * var result = property.getValue(Cesium.JulianDate.fromIso8601('2012-08-01T12:00:00.00Z'));
	 * @example
	 * //Create a simple numeric SampledProperty that uses third degree Hermite Polynomial Approximation
	 * var property = new Cesium.SampledProperty(Number);
	 * property.setInterpolationOptions({
	 *     interpolationDegree : 3,
	 *     interpolationAlgorithm : Cesium.HermitePolynomialApproximation
	 * });
	 * //Populate it with data
	 * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:00:00.00Z'), 1.0);
	 * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:01:00.00Z'), 6.0);
	 * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:02:00.00Z'), 12.0);
	 * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:03:30.00Z'), 5.0);
	 * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:06:30.00Z'), 2.0);
	 * //Samples can be added in any order.
	 * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:00:30.00Z'), 6.2);
	 * //Retrieve an interpolated value
	 * var result = property.getValue(Cesium.JulianDate.fromIso8601('2012-08-01T00:02:34.00Z'));
	 * @see SampledPositionProperty
	 */
	class SampledProperty {
		constructor(type: number | any, derivativeTypes?: any[]);

		/**
		 * Gets a value indicating if this property is constant.  A property is considered
		 * constant if getValue always returns the same result for the current definition.
		 * @memberof SampledProperty.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isConstant: boolean;

		/**
		 * Gets the event that is raised whenever the definition of this property changes.
		 * The definition is considered to have changed if a call to getValue would return
		 * a different result for the same time.
		 * @memberof SampledProperty.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets the type of property.
		 * @memberof SampledProperty.prototype
		 * @type {*}
		 */
		type: any;

		/**
		 * Gets the derivative types used by this property.
		 * @memberof SampledProperty.prototype
		 * @type {Packable[]}
		 */
		derivativeTypes: any[];

		/**
		 * Gets the degree of interpolation to perform when retrieving a value.
		 * @memberof SampledProperty.prototype
		 * @type {Number}
		 * @default 1
		 */
		interpolationDegree: number;

		/**
		 * Gets the interpolation algorithm to use when retrieving a value.
		 * @memberof SampledProperty.prototype
		 * @type {InterpolationAlgorithm}
		 * @default LinearApproximation
		 */
		interpolationAlgorithm: any;

		/**
		 * Gets or sets the type of extrapolation to perform when a value
		 * is requested at a time after any available samples.
		 * @memberof SampledProperty.prototype
		 * @type {ExtrapolationType}
		 * @default ExtrapolationType.NONE
		 */
		forwardExtrapolationType: any;

		/**
		 * Gets or sets the amount of time to extrapolate forward before
		 * the property becomes undefined.  A value of 0 will extrapolate forever.
		 * @memberof SampledProperty.prototype
		 * @type {Number}
		 * @default 0
		 */
		forwardExtrapolationDuration: number;

		/**
		 * Gets or sets the type of extrapolation to perform when a value
		 * is requested at a time before any available samples.
		 * @memberof SampledProperty.prototype
		 * @type {ExtrapolationType}
		 * @default ExtrapolationType.NONE
		 */
		backwardExtrapolationType: any;

		/**
		 * Gets or sets the amount of time to extrapolate backward
		 * before the property becomes undefined.  A value of 0 will extrapolate forever.
		 * @memberof SampledProperty.prototype
		 * @type {Number}
		 * @default 0
		 */
		backwardExtrapolationDuration: number;

		/**
		 * Gets the value of the property at the provided time.
		 * @param {JulianDate} time The time for which to retrieve the value.
		 * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValue(time: JulianDate, result?: any): any;

		/**
		 * Sets the algorithm and degree to use when interpolating a value.
		 * @param {Object} [options] Object with the following properties:
		 * @param {InterpolationAlgorithm} [options.interpolationAlgorithm] The new interpolation algorithm.  If undefined, the existing property will be unchanged.
		 * @param {Number} [options.interpolationDegree] The new interpolation degree.  If undefined, the existing property will be unchanged.
		 */
		setInterpolationOptions(options?: {
			interpolationAlgorithm?: any;
			interpolationDegree?: number;
		}): void;

		/**
		 * Adds a new sample
		 * @param {JulianDate} time The sample time.
		 * @param {Packable} value The value at the provided time.
		 * @param {Packable[]} [derivatives] The array of derivatives at the provided time.
		 */
		addSample(time: JulianDate, value: any, derivatives?: any[]): void;

		/**
		 * Adds an array of samples
		 * @param {JulianDate[]} times An array of JulianDate instances where each index is a sample time.
		 * @param {Packable[]} values The array of values, where each value corresponds to the provided times index.
		 * @param {Array[]} [derivativeValues] An array where each item is the array of derivatives at the equivalent time index.
		 * @exception {DeveloperError} times and values must be the same length.
		 * @exception {DeveloperError} times and derivativeValues must be the same length.
		 */
		addSamples(times: (JulianDate)[], values: any[], derivativeValues?: (any[])[]): void;

		/**
		 * Adds samples as a single packed array where each new sample is represented as a date,
		 * followed by the packed representation of the corresponding value and derivatives.
		 * @param {Number[]} packedSamples The array of packed samples.
		 * @param {JulianDate} [epoch] If any of the dates in packedSamples are numbers, they are considered an offset from this epoch, in seconds.
		 */
		addSamplesPackedArray(packedSamples: number[], epoch?: JulianDate): void;

		/**
		 * Compares this property to the provided property and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Property} [other] The other property.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		equals(other?: Property): boolean;

	}

	/**
	 * A {@link MaterialProperty} that maps to stripe {@link Material} uniforms.
	 * @alias StripeMaterialProperty
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Property} [options.evenColor=Color.WHITE] A Property specifying the first {@link Color}.
	 * @param {Property} [options.oddColor=Color.BLACK] A Property specifying the second {@link Color}.
	 * @param {Property} [options.repeat=1] A numeric Property specifying how many times the stripes repeat.
	 * @param {Property} [options.offset=0] A numeric Property specifying how far into the pattern to start the material.
	 * @param {Property} [options.orientation=StripeOrientation.HORIZONTAL] A Property specifying the {@link StripeOrientation}.
	 */
	class StripeMaterialProperty {
		constructor(options?: {
			evenColor?: Property;
			oddColor?: Property;
			repeat?: Property;
			offset?: Property;
			orientation?: Property;
		});

		/**
		 * Gets a value indicating if this property is constant.  A property is considered
		 * constant if getValue always returns the same result for the current definition.
		 * @memberof StripeMaterialProperty.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isConstant: boolean;

		/**
		 * Gets the event that is raised whenever the definition of this property changes.
		 * The definition is considered to have changed if a call to getValue would return
		 * a different result for the same time.
		 * @memberof StripeMaterialProperty.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets or sets the Property specifying the {@link StripeOrientation}/
		 * @memberof StripeMaterialProperty.prototype
		 * @type {Property}
		 * @default StripeOrientation.HORIZONTAL
		 */
		orientation: Property;

		/**
		 * Gets or sets the Property specifying the first {@link Color}.
		 * @memberof StripeMaterialProperty.prototype
		 * @type {Property}
		 * @default Color.WHITE
		 */
		evenColor: Property;

		/**
		 * Gets or sets the Property specifying the second {@link Color}.
		 * @memberof StripeMaterialProperty.prototype
		 * @type {Property}
		 * @default Color.BLACK
		 */
		oddColor: Property;

		/**
		 * Gets or sets the numeric Property specifying the point into the pattern
		 * to begin drawing; with 0.0 being the beginning of the even color, 1.0 the beginning
		 * of the odd color, 2.0 being the even color again, and any multiple or fractional values
		 * being in between.
		 * @memberof StripeMaterialProperty.prototype
		 * @type {Property}
		 * @default 0.0
		 */
		offset: Property;

		/**
		 * Gets or sets the numeric Property specifying how many times the stripes repeat.
		 * @memberof StripeMaterialProperty.prototype
		 * @type {Property}
		 * @default 1.0
		 */
		repeat: Property;

		/**
		 * Gets the {@link Material} type at the provided time.
		 * @param {JulianDate} time The time for which to retrieve the type.
		 * @returns {String} The type of material.
		 */
		getType(time: JulianDate): string;

		/**
		 * Gets the value of the property at the provided time.
		 * @param {JulianDate} time The time for which to retrieve the value.
		 * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValue(time: JulianDate, result?: any): any;

		/**
		 * Compares this property to the provided property and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Property} [other] The other property.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		equals(other?: Property): boolean;

	}

	/**
	 * A {@link TimeIntervalCollectionProperty} which is also a {@link PositionProperty}.
	 * @alias TimeIntervalCollectionPositionProperty
	 * @constructor
	 * @param {ReferenceFrame} [referenceFrame=ReferenceFrame.FIXED] The reference frame in which the position is defined.
	 */
	class TimeIntervalCollectionPositionProperty {
		constructor(referenceFrame?: any);

		/**
		 * Gets a value indicating if this property is constant.  A property is considered
		 * constant if getValue always returns the same result for the current definition.
		 * @memberof TimeIntervalCollectionPositionProperty.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isConstant: boolean;

		/**
		 * Gets the event that is raised whenever the definition of this property changes.
		 * The definition is considered to have changed if a call to getValue would return
		 * a different result for the same time.
		 * @memberof TimeIntervalCollectionPositionProperty.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets the interval collection.
		 * @memberof TimeIntervalCollectionPositionProperty.prototype
		 * @type {TimeIntervalCollection}
		 */
		intervals: TimeIntervalCollection;

		/**
		 * Gets the reference frame in which the position is defined.
		 * @memberof TimeIntervalCollectionPositionProperty.prototype
		 * @type {ReferenceFrame}
		 * @default ReferenceFrame.FIXED;
		 */
		referenceFrame: any;

		/**
		 * Gets the value of the property at the provided time in the fixed frame.
		 * @param {JulianDate} time The time for which to retrieve the value.
		 * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValue(time: JulianDate, result?: any): any;

		/**
		 * Gets the value of the property at the provided time and in the provided reference frame.
		 * @param {JulianDate} time The time for which to retrieve the value.
		 * @param {ReferenceFrame} referenceFrame The desired referenceFrame of the result.
		 * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValueInReferenceFrame(time: JulianDate, referenceFrame: any, result?: Cartesian3): Cartesian3;

		/**
		 * Compares this property to the provided property and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Property} [other] The other property.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		equals(other?: Property): boolean;

	}

	/**
	 * A {@link Property} which is defined by a {@link TimeIntervalCollection}, where the
	 * data property of each {@link TimeInterval} represents the value at time.
	 * @alias TimeIntervalCollectionProperty
	 * @constructor
	 * @example
	 * //Create a Cartesian2 interval property which contains data on August 1st, 2012
	 * //and uses a different value every 6 hours.
	 * var composite = new Cesium.TimeIntervalCollectionProperty();
	 * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({
	 *     iso8601 : '2012-08-01T00:00:00.00Z/2012-08-01T06:00:00.00Z',
	 *     isStartIncluded : true,
	 *     isStopIncluded : false,
	 *     data : new Cesium.Cartesian2(2.0, 3.4)
	 * }));
	 * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({
	 *     iso8601 : '2012-08-01T06:00:00.00Z/2012-08-01T12:00:00.00Z',
	 *     isStartIncluded : true,
	 *     isStopIncluded : false,
	 *     data : new Cesium.Cartesian2(12.0, 2.7)
	 * }));
	 * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({
	 *     iso8601 : '2012-08-01T12:00:00.00Z/2012-08-01T18:00:00.00Z',
	 *     isStartIncluded : true,
	 *     isStopIncluded : false,
	 *     data : new Cesium.Cartesian2(5.0, 12.4)
	 * }));
	 * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({
	 *     iso8601 : '2012-08-01T18:00:00.00Z/2012-08-02T00:00:00.00Z',
	 *     isStartIncluded : true,
	 *     isStopIncluded : true,
	 *     data : new Cesium.Cartesian2(85.0, 4.1)
	 * }));
	 */
	class TimeIntervalCollectionProperty {
		constructor();

		/**
		 * Gets a value indicating if this property is constant.  A property is considered
		 * constant if getValue always returns the same result for the current definition.
		 * @memberof TimeIntervalCollectionProperty.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isConstant: boolean;

		/**
		 * Gets the event that is raised whenever the definition of this property changes.
		 * The definition is changed whenever setValue is called with data different
		 * than the current value.
		 * @memberof TimeIntervalCollectionProperty.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets the interval collection.
		 * @memberof TimeIntervalCollectionProperty.prototype
		 * @type {TimeIntervalCollection}
		 */
		intervals: TimeIntervalCollection;

		/**
		 * Gets the value of the property at the provided time.
		 * @param {JulianDate} time The time for which to retrieve the value.
		 * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValue(time: JulianDate, result?: any): any;

		/**
		 * Compares this property to the provided property and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Property} [other] The other property.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		equals(other?: Property): boolean;

	}

	/**
	 * A {@link Property} which evaluates to a {@link Quaternion} rotation
	 * based on the velocity of the provided {@link PositionProperty}.
	 * @alias VelocityOrientationProperty
	 * @constructor
	 * @param {Property} [position] The position property used to compute the orientation.
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid used to determine which way is up.
	 * @example
	 * //Create an entity with position and orientation.
	 * var position = new Cesium.SampledProperty();
	 * position.addSamples(...);
	 * var entity = viewer.entities.add({
	 *   position : position,
	 *   orientation : new Cesium.VelocityOrientationProperty(position)
	 * }));
	 */
	class VelocityOrientationProperty {
		constructor(position?: Property, ellipsoid?: Ellipsoid);

		/**
		 * Gets a value indicating if this property is constant.
		 * @memberof VelocityOrientationProperty.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isConstant: boolean;

		/**
		 * Gets the event that is raised whenever the definition of this property changes.
		 * @memberof VelocityOrientationProperty.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets or sets the position property used to compute orientation.
		 * @memberof VelocityOrientationProperty.prototype
		 * @type {Property}
		 */
		position: Property;

		/**
		 * Gets or sets the ellipsoid used to determine which way is up.
		 * @memberof VelocityOrientationProperty.prototype
		 * @type {Property}
		 */
		ellipsoid: Property;

		/**
		 * Gets the value of the property at the provided time.
		 * @param {JulianDate} [time] The time for which to retrieve the value.
		 * @param {Quaternion} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Quaternion} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValue(time?: JulianDate, result?: Quaternion): Quaternion;

		/**
		 * Compares this property to the provided property and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Property} [other] The other property.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		equals(other?: Property): boolean;

	}

	/**
	 * A {@link Property} which evaluates to a {@link Cartesian3} vector
	 * based on the velocity of the provided {@link PositionProperty}.
	 * @alias VelocityVectorProperty
	 * @constructor
	 * @param {Property} [position] The position property used to compute the velocity.
	 * @param {Boolean} [normalize=true] Whether to normalize the computed velocity vector.
	 * @example
	 * //Create an entity with a billboard rotated to match its velocity.
	 * var position = new Cesium.SampledProperty();
	 * position.addSamples(...);
	 * var entity = viewer.entities.add({
	 *   position : position,
	 *   billboard : {
	 *     image : 'image.png',
	 *     alignedAxis : new Cesium.VelocityVectorProperty(position, true) // alignedAxis must be a unit vector
	 *   }
	 * }));
	 */
	class VelocityVectorProperty {
		constructor(position?: Property, normalize?: boolean);

		/**
		 * Gets a value indicating if this property is constant.
		 * @memberof VelocityVectorProperty.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly isConstant: boolean;

		/**
		 * Gets the event that is raised whenever the definition of this property changes.
		 * @memberof VelocityVectorProperty.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets or sets the position property used to compute the velocity vector.
		 * @memberof VelocityVectorProperty.prototype
		 * @type {Property}
		 */
		position: Property;

		/**
		 * Gets or sets whether the vector produced by this property
		 * will be normalized or not.
		 * @memberof VelocityVectorProperty.prototype
		 * @type {Boolean}
		 */
		normalize: boolean;

		/**
		 * Gets the value of the property at the provided time.
		 * @param {JulianDate} [time] The time for which to retrieve the value.
		 * @param {Cartesian3} [result] The object to store the value into, if omitted, a new instance is created and returned.
		 * @returns {Cartesian3} The modified result parameter or a new instance if the result parameter was not supplied.
		 */
		getValue(time?: JulianDate, result?: Cartesian3): Cartesian3;

		/**
		 * Compares this property to the provided property and returns
		 * <code>true</code> if they are equal, <code>false</code> otherwise.
		 * @param {Property} [other] The other property.
		 * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
		 */
		equals(other?: Property): boolean;

	}

	/**
	 * Defines the interface for visualizers. Visualizers are plug-ins to
	 * {@link DataSourceDisplay} that render data associated with
	 * {@link DataSource} instances.
	 * This object is an interface for documentation purposes and is not intended
	 * to be instantiated directly.
	 * @alias Visualizer
	 * @constructor
	 * @see BillboardVisualizer
	 * @see LabelVisualizer
	 * @see ModelVisualizer
	 * @see PathVisualizer
	 * @see PointVisualizer
	 * @see GeometryVisualizer
	 */
	class Visualizer {
		constructor();

		/**
		 * Updates the visualization to the provided time.
		 * @function
		 * @param {JulianDate} time The time.
		 * @returns {Boolean} True if the display was updated to the provided time,
		 * false if the visualizer is waiting for an asynchronous operation to
		 * complete before data can be updated.
		 */
		update(time: JulianDate): boolean;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * @function
		 * @returns {Boolean} True if this object was destroyed; otherwise, false.
		 */
		isDestroyed(): boolean;

		/**
		 * Removes all visualization and cleans up any resources associated with this instance.
		 * @function
		 */
		destroy(): void;

	}

	/**
	 * A {@link GeometryUpdater} for walls.
	 * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
	 * @alias WallGeometryUpdater
	 * @constructor
	 * @param {Entity} entity The entity containing the geometry to be visualized.
	 * @param {Scene} scene The scene where visualization is taking place.
	 */
	class WallGeometryUpdater {
		constructor(entity: Entity, scene: Scene);

		/**
		 * Creates the geometry instance which represents the fill of the geometry.
		 * @param {JulianDate} time The time to use when retrieving initial attribute values.
		 * @returns {GeometryInstance} The geometry instance representing the filled portion of the geometry.
		 * @exception {DeveloperError} This instance does not represent a filled geometry.
		 */
		createFillGeometryInstance(time: JulianDate): GeometryInstance;

		/**
		 * Creates the geometry instance which represents the outline of the geometry.
		 * @param {JulianDate} time The time to use when retrieving initial attribute values.
		 * @returns {GeometryInstance} The geometry instance representing the outline portion of the geometry.
		 * @exception {DeveloperError} This instance does not represent an outlined geometry.
		 */
		createOutlineGeometryInstance(time: JulianDate): GeometryInstance;

	}

	/**
	 * Describes a two dimensional wall defined as a line strip and optional maximum and minimum heights.
	 * The wall conforms to the curvature of the globe and can be placed along the surface or at altitude.
	 * @alias WallGraphics
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Property} [options.positions] A Property specifying the array of {@link Cartesian3} positions which define the top of the wall.
	 * @param {Property} [options.maximumHeights] A Property specifying an array of heights to be used for the top of the wall instead of the height of each position.
	 * @param {Property} [options.minimumHeights] A Property specifying an array of heights to be used for the bottom of the wall instead of the globe surface.
	 * @param {Property} [options.show=true] A boolean Property specifying the visibility of the wall.
	 * @param {Property} [options.fill=true] A boolean Property specifying whether the wall is filled with the provided material.
	 * @param {MaterialProperty} [options.material=Color.WHITE] A Property specifying the material used to fill the wall.
	 * @param {Property} [options.outline=false] A boolean Property specifying whether the wall is outlined.
	 * @param {Property} [options.outlineColor=Color.BLACK] A Property specifying the {@link Color} of the outline.
	 * @param {Property} [options.outlineWidth=1.0] A numeric Property specifying the width of the outline.
	 * @param {Property} [options.granularity=Cesium.Math.RADIANS_PER_DEGREE] A numeric Property specifying the angular distance between each latitude and longitude point.
	 * @param {Property} [options.shadows=ShadowMode.DISABLED] An enum Property specifying whether the wall casts or receives shadows from each light source.
	 * @param {Property} [options.distanceDisplayCondition] A Property specifying at what distance from the camera that this wall will be displayed.
	 * @see Entity
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Wall.html|Cesium Sandcastle Wall Demo}
	 */
	class WallGraphics {
		constructor(options?: {
			positions?: Property;
			maximumHeights?: Property;
			minimumHeights?: Property;
			show?: Property;
			fill?: Property;
			material?: MaterialProperty;
			outline?: Property;
			outlineColor?: Property;
			outlineWidth?: Property;
			granularity?: Property;
			shadows?: Property;
			distanceDisplayCondition?: Property;
		});

		/**
		 * Gets the event that is raised whenever a property or sub-property is changed or modified.
		 * @memberof WallGraphics.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly definitionChanged: Event;

		/**
		 * Gets or sets the boolean Property specifying the visibility of the wall.
		 * @memberof WallGraphics.prototype
		 * @type {Property}
		 * @default true
		 */
		show: Property;

		/**
		 * Gets or sets the Property specifying the material used to fill the wall.
		 * @memberof WallGraphics.prototype
		 * @type {MaterialProperty}
		 * @default Color.WHITE
		 */
		material: MaterialProperty;

		/**
		 * Gets or sets the Property specifying the array of {@link Cartesian3} positions which define the top of the wall.
		 * @memberof WallGraphics.prototype
		 * @type {Property}
		 */
		positions: Property;

		/**
		 * Gets or sets the Property specifying an array of heights to be used for the bottom of the wall instead of the surface of the globe.
		 * If defined, the array must be the same length as {@link Wall#positions}.
		 * @memberof WallGraphics.prototype
		 * @type {Property}
		 */
		minimumHeights: Property;

		/**
		 * Gets or sets the Property specifying an array of heights to be used for the top of the wall instead of the height of each position.
		 * If defined, the array must be the same length as {@link Wall#positions}.
		 * @memberof WallGraphics.prototype
		 * @type {Property}
		 */
		maximumHeights: Property;

		/**
		 * Gets or sets the numeric Property specifying the angular distance between points on the wall.
		 * @memberof WallGraphics.prototype
		 * @type {Property}
		 * @default {CesiumMath.RADIANS_PER_DEGREE}
		 */
		granularity: Property;

		/**
		 * Gets or sets the boolean Property specifying whether the wall is filled with the provided material.
		 * @memberof WallGraphics.prototype
		 * @type {Property}
		 * @default true
		 */
		fill: Property;

		/**
		 * Gets or sets the Property specifying whether the wall is outlined.
		 * @memberof WallGraphics.prototype
		 * @type {Property}
		 * @default false
		 */
		outline: Property;

		/**
		 * Gets or sets the Property specifying the {@link Color} of the outline.
		 * @memberof WallGraphics.prototype
		 * @type {Property}
		 * @default Color.BLACK
		 */
		outlineColor: Property;

		/**
		 * Gets or sets the numeric Property specifying the width of the outline.
		 * @memberof WallGraphics.prototype
		 * @type {Property}
		 * @default 1.0
		 */
		outlineWidth: Property;

		/**
		 * Get or sets the enum Property specifying whether the wall
		 * casts or receives shadows from each light source.
		 * @memberof WallGraphics.prototype
		 * @type {Property}
		 * @default ShadowMode.DISABLED
		 */
		shadows: Property;

		/**
		 * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this wall will be displayed.
		 * @memberof WallGraphics.prototype
		 * @type {Property}
		 */
		distanceDisplayCondition: Property;

		/**
		 * Duplicates this instance.
		 * @param {WallGraphics} [result] The object onto which to store the result.
		 * @returns {WallGraphics} The modified result parameter or a new instance if one was not provided.
		 */
		clone(result?: WallGraphics): WallGraphics;

		/**
		 * Assigns each unassigned property on this object to the value
		 * of the same property on the provided source object.
		 * @param {WallGraphics} source The object to be merged into this object.
		 */
		merge(source: WallGraphics): void;

	}

	/**
	 * An automatic GLSL uniform containing the viewport's <code>x</code>, <code>y</code>, <code>width</code>,
	 * and <code>height</code> properties in an <code>vec4</code>'s <code>x</code>, <code>y</code>, <code>z</code>,
	 * and <code>w</code> components, respectively.
	 * @alias czm_viewport
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform vec4 czm_viewport;
	 * // Scale the window coordinate components to [0, 1] by dividing
	 * // by the viewport's width and height.
	 * vec2 v = gl_FragCoord.xy / czm_viewport.zw;
	 * @see Context#getViewport
	 */
	namespace czm_viewport {
	}

	/**
	 * An automatic GLSL uniform representing a 4x4 orthographic projection matrix that
	 * transforms window coordinates to clip coordinates.  Clip coordinates is the
	 * coordinate system for a vertex shader's <code>gl_Position</code> output.
	 * <br /><br />
	 * This transform is useful when a vertex shader inputs or manipulates window coordinates
	 * as done by {@link BillboardCollection}.
	 * <br /><br />
	 * Do not confuse {@link czm_viewportTransformation} with <code>czm_viewportOrthographic</code>.
	 * The former transforms from normalized device coordinates to window coordinates; the later transforms
	 * from window coordinates to clip coordinates, and is often used to assign to <code>gl_Position</code>.
	 * @alias czm_viewportOrthographic
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform mat4 czm_viewportOrthographic;
	 * // Example
	 * gl_Position = czm_viewportOrthographic * vec4(windowPosition, 0.0, 1.0);
	 * @see UniformState#viewportOrthographic
	 * @see czm_viewport
	 * @see czm_viewportTransformation
	 * @see BillboardCollection
	 */
	namespace czm_viewportOrthographic {
	}

	/**
	 * An automatic GLSL uniform representing a 4x4 transformation matrix that
	 * transforms normalized device coordinates to window coordinates.  The context's
	 * full viewport is used, and the depth range is assumed to be <code>near = 0</code>
	 * and <code>far = 1</code>.
	 * <br /><br />
	 * This transform is useful when there is a need to manipulate window coordinates
	 * in a vertex shader as done by {@link BillboardCollection}.  In many cases,
	 * this matrix will not be used directly; instead, {@link czm_modelToWindowCoordinates}
	 * will be used to transform directly from model to window coordinates.
	 * <br /><br />
	 * Do not confuse <code>czm_viewportTransformation</code> with {@link czm_viewportOrthographic}.
	 * The former transforms from normalized device coordinates to window coordinates; the later transforms
	 * from window coordinates to clip coordinates, and is often used to assign to <code>gl_Position</code>.
	 * @alias czm_viewportTransformation
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform mat4 czm_viewportTransformation;
	 * // Use czm_viewportTransformation as part of the
	 * // transform from model to window coordinates.
	 * vec4 q = czm_modelViewProjection * positionMC;               // model to clip coordinates
	 * q.xyz /= q.w;                                                // clip to normalized device coordinates (ndc)
	 * q.xyz = (czm_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // ndc to window coordinates
	 * @see UniformState#viewportTransformation
	 * @see czm_viewport
	 * @see czm_viewportOrthographic
	 * @see czm_modelToWindowCoordinates
	 * @see BillboardCollection
	 */
	namespace czm_viewportTransformation {
	}

	/**
	 * An automatic GLSL uniform representing a 4x4 model transformation matrix that
	 * transforms model coordinates to world coordinates.
	 * @alias czm_model
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform mat4 czm_model;
	 * // Example
	 * vec4 worldPosition = czm_model * modelPosition;
	 * @see UniformState#model
	 * @see czm_inverseModel
	 * @see czm_modelView
	 * @see czm_modelViewProjection
	 */
	namespace czm_model {
	}

	/**
	 * An automatic GLSL uniform representing a 4x4 model transformation matrix that
	 * transforms world coordinates to model coordinates.
	 * @alias czm_inverseModel
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform mat4 czm_inverseModel;
	 * // Example
	 * vec4 modelPosition = czm_inverseModel * worldPosition;
	 * @see UniformState#inverseModel
	 * @see czm_model
	 * @see czm_inverseModelView
	 */
	namespace czm_inverseModel {
	}

	/**
	 * An automatic GLSL uniform representing a 4x4 view transformation matrix that
	 * transforms world coordinates to eye coordinates.
	 * @alias czm_view
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform mat4 czm_view;
	 * // Example
	 * vec4 eyePosition = czm_view * worldPosition;
	 * @see UniformState#view
	 * @see czm_viewRotation
	 * @see czm_modelView
	 * @see czm_viewProjection
	 * @see czm_modelViewProjection
	 * @see czm_inverseView
	 */
	namespace czm_view {
	}

	/**
	 * An automatic GLSL uniform representing a 4x4 view transformation matrix that
	 * transforms 3D world coordinates to eye coordinates.  In 3D mode, this is identical to
	 * {@link czm_view}, but in 2D and Columbus View it represents the view matrix
	 * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting
	 * 2D and Columbus View in the same way that 3D is lit.
	 * @alias czm_view3D
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform mat4 czm_view3D;
	 * // Example
	 * vec4 eyePosition3D = czm_view3D * worldPosition3D;
	 * @see UniformState#view3D
	 * @see czm_view
	 */
	namespace czm_view3D {
	}

	/**
	 * An automatic GLSL uniform representing a 3x3 view rotation matrix that
	 * transforms vectors in world coordinates to eye coordinates.
	 * @alias czm_viewRotation
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform mat3 czm_viewRotation;
	 * // Example
	 * vec3 eyeVector = czm_viewRotation * worldVector;
	 * @see UniformState#viewRotation
	 * @see czm_view
	 * @see czm_inverseView
	 * @see czm_inverseViewRotation
	 */
	namespace czm_viewRotation {
	}

	/**
	 * An automatic GLSL uniform representing a 3x3 view rotation matrix that
	 * transforms vectors in 3D world coordinates to eye coordinates.  In 3D mode, this is identical to
	 * {@link czm_viewRotation}, but in 2D and Columbus View it represents the view matrix
	 * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting
	 * 2D and Columbus View in the same way that 3D is lit.
	 * @alias czm_viewRotation3D
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform mat3 czm_viewRotation3D;
	 * // Example
	 * vec3 eyeVector = czm_viewRotation3D * worldVector;
	 * @see UniformState#viewRotation3D
	 * @see czm_viewRotation
	 */
	namespace czm_viewRotation3D {
	}

	/**
	 * An automatic GLSL uniform representing a 4x4 transformation matrix that
	 * transforms from eye coordinates to world coordinates.
	 * @alias czm_inverseView
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform mat4 czm_inverseView;
	 * // Example
	 * vec4 worldPosition = czm_inverseView * eyePosition;
	 * @see UniformState#inverseView
	 * @see czm_view
	 * @see czm_inverseNormal
	 */
	namespace czm_inverseView {
	}

	/**
	 * An automatic GLSL uniform representing a 4x4 transformation matrix that
	 * transforms from 3D eye coordinates to world coordinates.  In 3D mode, this is identical to
	 * {@link czm_inverseView}, but in 2D and Columbus View it represents the inverse view matrix
	 * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting
	 * 2D and Columbus View in the same way that 3D is lit.
	 * @alias czm_inverseView3D
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform mat4 czm_inverseView3D;
	 * // Example
	 * vec4 worldPosition = czm_inverseView3D * eyePosition;
	 * @see UniformState#inverseView3D
	 * @see czm_inverseView
	 */
	namespace czm_inverseView3D {
	}

	/**
	 * An automatic GLSL uniform representing a 3x3 rotation matrix that
	 * transforms vectors from eye coordinates to world coordinates.
	 * @alias czm_inverseViewRotation
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform mat3 czm_inverseViewRotation;
	 * // Example
	 * vec4 worldVector = czm_inverseViewRotation * eyeVector;
	 * @see UniformState#inverseView
	 * @see czm_view
	 * @see czm_viewRotation
	 * @see czm_inverseViewRotation
	 */
	namespace czm_inverseViewRotation {
	}

	/**
	 * An automatic GLSL uniform representing a 3x3 rotation matrix that
	 * transforms vectors from 3D eye coordinates to world coordinates.  In 3D mode, this is identical to
	 * {@link czm_inverseViewRotation}, but in 2D and Columbus View it represents the inverse view matrix
	 * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting
	 * 2D and Columbus View in the same way that 3D is lit.
	 * @alias czm_inverseViewRotation3D
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform mat3 czm_inverseViewRotation3D;
	 * // Example
	 * vec4 worldVector = czm_inverseViewRotation3D * eyeVector;
	 * @see UniformState#inverseView3D
	 * @see czm_inverseViewRotation
	 */
	namespace czm_inverseViewRotation3D {
	}

	/**
	 * An automatic GLSL uniform representing a 4x4 projection transformation matrix that
	 * transforms eye coordinates to clip coordinates.  Clip coordinates is the
	 * coordinate system for a vertex shader's <code>gl_Position</code> output.
	 * @alias czm_projection
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform mat4 czm_projection;
	 * // Example
	 * gl_Position = czm_projection * eyePosition;
	 * @see UniformState#projection
	 * @see czm_viewProjection
	 * @see czm_modelViewProjection
	 * @see czm_infiniteProjection
	 */
	namespace czm_projection {
	}

	/**
	 * An automatic GLSL uniform representing a 4x4 inverse projection transformation matrix that
	 * transforms from clip coordinates to eye coordinates. Clip coordinates is the
	 * coordinate system for a vertex shader's <code>gl_Position</code> output.
	 * @alias czm_inverseProjection
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform mat4 czm_inverseProjection;
	 * // Example
	 * vec4 eyePosition = czm_inverseProjection * clipPosition;
	 * @see UniformState#inverseProjection
	 * @see czm_projection
	 */
	namespace czm_inverseProjection {
	}

	/**
	 * An automatic GLSL uniform representing a 4x4 projection transformation matrix with the far plane at infinity,
	 * that transforms eye coordinates to clip coordinates.  Clip coordinates is the
	 * coordinate system for a vertex shader's <code>gl_Position</code> output.  An infinite far plane is used
	 * in algorithms like shadow volumes and GPU ray casting with proxy geometry to ensure that triangles
	 * are not clipped by the far plane.
	 * @alias czm_infiniteProjection
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform mat4 czm_infiniteProjection;
	 * // Example
	 * gl_Position = czm_infiniteProjection * eyePosition;
	 * @see UniformState#infiniteProjection
	 * @see czm_projection
	 * @see czm_modelViewInfiniteProjection
	 */
	namespace czm_infiniteProjection {
	}

	/**
	 * An automatic GLSL uniform representing a 4x4 model-view transformation matrix that
	 * transforms model coordinates to eye coordinates.
	 * <br /><br />
	 * Positions should be transformed to eye coordinates using <code>czm_modelView</code> and
	 * normals should be transformed using {@link czm_normal}.
	 * @alias czm_modelView
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform mat4 czm_modelView;
	 * // Example
	 * vec4 eyePosition = czm_modelView * modelPosition;
	 * // The above is equivalent to, but more efficient than:
	 * vec4 eyePosition = czm_view * czm_model * modelPosition;
	 * @see UniformState#modelView
	 * @see czm_model
	 * @see czm_view
	 * @see czm_modelViewProjection
	 * @see czm_normal
	 */
	namespace czm_modelView {
	}

	/**
	 * An automatic GLSL uniform representing a 4x4 model-view transformation matrix that
	 * transforms 3D model coordinates to eye coordinates.  In 3D mode, this is identical to
	 * {@link czm_modelView}, but in 2D and Columbus View it represents the model-view matrix
	 * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting
	 * 2D and Columbus View in the same way that 3D is lit.
	 * <br /><br />
	 * Positions should be transformed to eye coordinates using <code>czm_modelView3D</code> and
	 * normals should be transformed using {@link czm_normal3D}.
	 * @alias czm_modelView3D
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform mat4 czm_modelView3D;
	 * // Example
	 * vec4 eyePosition = czm_modelView3D * modelPosition;
	 * // The above is equivalent to, but more efficient than:
	 * vec4 eyePosition = czm_view3D * czm_model * modelPosition;
	 * @see UniformState#modelView3D
	 * @see czm_modelView
	 */
	namespace czm_modelView3D {
	}

	/**
	 * An automatic GLSL uniform representing a 4x4 model-view transformation matrix that
	 * transforms model coordinates, relative to the eye, to eye coordinates.  This is used
	 * in conjunction with {@link czm_translateRelativeToEye}.
	 * @alias czm_modelViewRelativeToEye
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform mat4 czm_modelViewRelativeToEye;
	 * // Example
	 * attribute vec3 positionHigh;
	 * attribute vec3 positionLow;
	 * void main()
	 * {
	 *   vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);
	 *   gl_Position = czm_projection * (czm_modelViewRelativeToEye * p);
	 * }
	 * @see czm_modelViewProjectionRelativeToEye
	 * @see czm_translateRelativeToEye
	 * @see EncodedCartesian3
	 */
	namespace czm_modelViewRelativeToEye {
	}

	/**
	 * An automatic GLSL uniform representing a 4x4 transformation matrix that
	 * transforms from eye coordinates to model coordinates.
	 * @alias czm_inverseModelView
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform mat4 czm_inverseModelView;
	 * // Example
	 * vec4 modelPosition = czm_inverseModelView * eyePosition;
	 * @see UniformState#inverseModelView
	 * @see czm_modelView
	 */
	namespace czm_inverseModelView {
	}

	/**
	 * An automatic GLSL uniform representing a 4x4 transformation matrix that
	 * transforms from eye coordinates to 3D model coordinates.  In 3D mode, this is identical to
	 * {@link czm_inverseModelView}, but in 2D and Columbus View it represents the inverse model-view matrix
	 * as if the camera were at an equivalent location in 3D mode.  This is useful for lighting
	 * 2D and Columbus View in the same way that 3D is lit.
	 * @alias czm_inverseModelView3D
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform mat4 czm_inverseModelView3D;
	 * // Example
	 * vec4 modelPosition = czm_inverseModelView3D * eyePosition;
	 * @see UniformState#inverseModelView
	 * @see czm_inverseModelView
	 * @see czm_modelView3D
	 */
	namespace czm_inverseModelView3D {
	}

	/**
	 * An automatic GLSL uniform representing a 4x4 view-projection transformation matrix that
	 * transforms world coordinates to clip coordinates.  Clip coordinates is the
	 * coordinate system for a vertex shader's <code>gl_Position</code> output.
	 * @alias czm_viewProjection
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform mat4 czm_viewProjection;
	 * // Example
	 * vec4 gl_Position = czm_viewProjection * czm_model * modelPosition;
	 * // The above is equivalent to, but more efficient than:
	 * gl_Position = czm_projection * czm_view * czm_model * modelPosition;
	 * @see UniformState#viewProjection
	 * @see czm_view
	 * @see czm_projection
	 * @see czm_modelViewProjection
	 * @see czm_inverseViewProjection
	 */
	namespace czm_viewProjection {
	}

	/**
	 * An automatic GLSL uniform representing a 4x4 view-projection transformation matrix that
	 * transforms clip coordinates to world coordinates.  Clip coordinates is the
	 * coordinate system for a vertex shader's <code>gl_Position</code> output.
	 * @alias czm_inverseViewProjection
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform mat4 czm_inverseViewProjection;
	 * // Example
	 * vec4 worldPosition = czm_inverseViewProjection * clipPosition;
	 * @see UniformState#inverseViewProjection
	 * @see czm_viewProjection
	 */
	namespace czm_inverseViewProjection {
	}

	/**
	 * An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that
	 * transforms model coordinates to clip coordinates.  Clip coordinates is the
	 * coordinate system for a vertex shader's <code>gl_Position</code> output.
	 * @alias czm_modelViewProjection
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform mat4 czm_modelViewProjection;
	 * // Example
	 * vec4 gl_Position = czm_modelViewProjection * modelPosition;
	 * // The above is equivalent to, but more efficient than:
	 * gl_Position = czm_projection * czm_view * czm_model * modelPosition;
	 * @see UniformState#modelViewProjection
	 * @see czm_model
	 * @see czm_view
	 * @see czm_projection
	 * @see czm_modelView
	 * @see czm_viewProjection
	 * @see czm_modelViewInfiniteProjection
	 * @see czm_inverseModelViewProjection
	 */
	namespace czm_modelViewProjection {
	}

	/**
	 * An automatic GLSL uniform representing a 4x4 inverse model-view-projection transformation matrix that
	 * transforms clip coordinates to model coordinates.  Clip coordinates is the
	 * coordinate system for a vertex shader's <code>gl_Position</code> output.
	 * @alias czm_inverseModelViewProjection
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform mat4 czm_inverseModelViewProjection;
	 * // Example
	 * vec4 modelPosition = czm_inverseModelViewProjection * clipPosition;
	 * @see UniformState#modelViewProjection
	 * @see czm_modelViewProjection
	 */
	namespace czm_inverseModelViewProjection {
	}

	/**
	 * An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that
	 * transforms model coordinates, relative to the eye, to clip coordinates.  Clip coordinates is the
	 * coordinate system for a vertex shader's <code>gl_Position</code> output.  This is used in
	 * conjunction with {@link czm_translateRelativeToEye}.
	 * @alias czm_modelViewProjectionRelativeToEye
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform mat4 czm_modelViewProjectionRelativeToEye;
	 * // Example
	 * attribute vec3 positionHigh;
	 * attribute vec3 positionLow;
	 * void main()
	 * {
	 *   vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);
	 *   gl_Position = czm_modelViewProjectionRelativeToEye * p;
	 * }
	 * @see czm_modelViewRelativeToEye
	 * @see czm_translateRelativeToEye
	 * @see EncodedCartesian3
	 */
	namespace czm_modelViewProjectionRelativeToEye {
	}

	/**
	 * An automatic GLSL uniform representing a 4x4 model-view-projection transformation matrix that
	 * transforms model coordinates to clip coordinates.  Clip coordinates is the
	 * coordinate system for a vertex shader's <code>gl_Position</code> output.  The projection matrix places
	 * the far plane at infinity.  This is useful in algorithms like shadow volumes and GPU ray casting with
	 * proxy geometry to ensure that triangles are not clipped by the far plane.
	 * @alias czm_modelViewInfiniteProjection
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform mat4 czm_modelViewInfiniteProjection;
	 * // Example
	 * vec4 gl_Position = czm_modelViewInfiniteProjection * modelPosition;
	 * // The above is equivalent to, but more efficient than:
	 * gl_Position = czm_infiniteProjection * czm_view * czm_model * modelPosition;
	 * @see UniformState#modelViewInfiniteProjection
	 * @see czm_model
	 * @see czm_view
	 * @see czm_infiniteProjection
	 * @see czm_modelViewProjection
	 */
	namespace czm_modelViewInfiniteProjection {
	}

	/**
	 * An automatic GLSL uniform that indicates if the current camera is orthographic in 3D.
	 * @alias czm_orthographicIn3D
	 * @namespace
	 * @glslUniform
	 * @see UniformState#orthographicIn3D
	 */
	namespace czm_orthographicIn3D {
	}

	/**
	 * An automatic GLSL uniform representing a 3x3 normal transformation matrix that
	 * transforms normal vectors in model coordinates to eye coordinates.
	 * <br /><br />
	 * Positions should be transformed to eye coordinates using {@link czm_modelView} and
	 * normals should be transformed using <code>czm_normal</code>.
	 * @alias czm_normal
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform mat3 czm_normal;
	 * // Example
	 * vec3 eyeNormal = czm_normal * normal;
	 * @see UniformState#normal
	 * @see czm_inverseNormal
	 * @see czm_modelView
	 */
	namespace czm_normal {
	}

	/**
	 * An automatic GLSL uniform representing a 3x3 normal transformation matrix that
	 * transforms normal vectors in 3D model coordinates to eye coordinates.
	 * In 3D mode, this is identical to
	 * {@link czm_normal}, but in 2D and Columbus View it represents the normal transformation
	 * matrix as if the camera were at an equivalent location in 3D mode.  This is useful for lighting
	 * 2D and Columbus View in the same way that 3D is lit.
	 * <br /><br />
	 * Positions should be transformed to eye coordinates using {@link czm_modelView3D} and
	 * normals should be transformed using <code>czm_normal3D</code>.
	 * @alias czm_normal3D
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform mat3 czm_normal3D;
	 * // Example
	 * vec3 eyeNormal = czm_normal3D * normal;
	 * @see UniformState#normal3D
	 * @see czm_normal
	 */
	namespace czm_normal3D {
	}

	/**
	 * An automatic GLSL uniform representing a 3x3 normal transformation matrix that
	 * transforms normal vectors in eye coordinates to model coordinates.  This is
	 * the opposite of the transform provided by {@link czm_normal}.
	 * @alias czm_inverseNormal
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform mat3 czm_inverseNormal;
	 * // Example
	 * vec3 normalMC = czm_inverseNormal * normalEC;
	 * @see UniformState#inverseNormal
	 * @see czm_normal
	 * @see czm_modelView
	 * @see czm_inverseView
	 */
	namespace czm_inverseNormal {
	}

	/**
	 * An automatic GLSL uniform representing a 3x3 normal transformation matrix that
	 * transforms normal vectors in eye coordinates to 3D model coordinates.  This is
	 * the opposite of the transform provided by {@link czm_normal}.
	 * In 3D mode, this is identical to
	 * {@link czm_inverseNormal}, but in 2D and Columbus View it represents the inverse normal transformation
	 * matrix as if the camera were at an equivalent location in 3D mode.  This is useful for lighting
	 * 2D and Columbus View in the same way that 3D is lit.
	 * @alias czm_inverseNormal3D
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform mat3 czm_inverseNormal3D;
	 * // Example
	 * vec3 normalMC = czm_inverseNormal3D * normalEC;
	 * @see UniformState#inverseNormal3D
	 * @see czm_inverseNormal
	 */
	namespace czm_inverseNormal3D {
	}

	/**
	 * An automatic GLSL uniform containing height (<code>x</code>) and height squared (<code>y</code>)
	 *  of the eye (camera) in the 2D scene in meters.
	 * @alias czm_eyeHeight2D
	 * @namespace
	 * @glslUniform
	 * @see UniformState#eyeHeight2D
	 */
	namespace czm_eyeHeight2D {
	}

	/**
	 * An automatic GLSL uniform containing the near distance (<code>x</code>) and the far distance (<code>y</code>)
	 * of the frustum defined by the camera.  This is the largest possible frustum, not an individual
	 * frustum used for multi-frustum rendering.
	 * @alias czm_entireFrustum
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform vec2 czm_entireFrustum;
	 * // Example
	 * float frustumLength = czm_entireFrustum.y - czm_entireFrustum.x;
	 * @see UniformState#entireFrustum
	 * @see czm_currentFrustum
	 */
	namespace czm_entireFrustum {
	}

	/**
	 * An automatic GLSL uniform containing the near distance (<code>x</code>) and the far distance (<code>y</code>)
	 * of the frustum defined by the camera.  This is the individual
	 * frustum used for multi-frustum rendering.
	 * @alias czm_currentFrustum
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform vec2 czm_currentFrustum;
	 * // Example
	 * float frustumLength = czm_currentFrustum.y - czm_currentFrustum.x;
	 * @see UniformState#currentFrustum
	 * @see czm_entireFrustum
	 */
	namespace czm_currentFrustum {
	}

	/**
	 * The distances to the frustum planes. The top, bottom, left and right distances are
	 * the x, y, z, and w components, respectively.
	 * @alias czm_frustumPlanes
	 * @namespace
	 * @glslUniform
	 */
	namespace czm_frustumPlanes {
	}

	/**
	 * An automatic GLSL uniform containing log2 of the far distance + 1.0.
	 * This is used when reversing log depth computations.
	 * @alias czm_log2FarPlusOne
	 * @namespace
	 * @glslUniform
	 */
	namespace czm_log2FarPlusOne {
	}

	/**
	 * An automatic GLSL uniform containing log2 of the near distance.
	 * This is used when writing log depth in the fragment shader.
	 * @alias czm_log2NearDistance
	 * @namespace
	 * @glslUniform
	 */
	namespace czm_log2NearDistance {
	}

	/**
	 * An automatic GLSL uniform representing the sun position in world coordinates.
	 * @alias czm_sunPositionWC
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform vec3 czm_sunPositionWC;
	 * @see UniformState#sunPositionWC
	 * @see czm_sunPositionColumbusView
	 * @see czm_sunDirectionWC
	 */
	namespace czm_sunPositionWC {
	}

	/**
	 * An automatic GLSL uniform representing the sun position in Columbus view world coordinates.
	 * @alias czm_sunPositionColumbusView
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform vec3 czm_sunPositionColumbusView;
	 * @see UniformState#sunPositionColumbusView
	 * @see czm_sunPositionWC
	 */
	namespace czm_sunPositionColumbusView {
	}

	/**
	 * An automatic GLSL uniform representing the normalized direction to the sun in eye coordinates.
	 * This is commonly used for directional lighting computations.
	 * @alias czm_sunDirectionEC
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform vec3 czm_sunDirectionEC;
	 * // Example
	 * float diffuse = max(dot(czm_sunDirectionEC, normalEC), 0.0);
	 * @see UniformState#sunDirectionEC
	 * @see czm_moonDirectionEC
	 * @see czm_sunDirectionWC
	 */
	namespace czm_sunDirectionEC {
	}

	/**
	 * An automatic GLSL uniform representing the normalized direction to the sun in world coordinates.
	 * This is commonly used for directional lighting computations.
	 * @alias czm_sunDirectionWC
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform vec3 czm_sunDirectionWC;
	 * @see UniformState#sunDirectionWC
	 * @see czm_sunPositionWC
	 * @see czm_sunDirectionEC
	 */
	namespace czm_sunDirectionWC {
	}

	/**
	 * An automatic GLSL uniform representing the normalized direction to the moon in eye coordinates.
	 * This is commonly used for directional lighting computations.
	 * @alias czm_moonDirectionEC
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform vec3 czm_moonDirectionEC;
	 * // Example
	 * float diffuse = max(dot(czm_moonDirectionEC, normalEC), 0.0);
	 * @see UniformState#moonDirectionEC
	 * @see czm_sunDirectionEC
	 */
	namespace czm_moonDirectionEC {
	}

	/**
	 * An automatic GLSL uniform representing the high bits of the camera position in model
	 * coordinates.  This is used for GPU RTE to eliminate jittering artifacts when rendering
	 * as described in {@link http://blogs.agi.com/insight3d/index.php/2008/09/03/precisions-precisions/|Precisions, Precisions}.
	 * @alias czm_encodedCameraPositionMCHigh
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform vec3 czm_encodedCameraPositionMCHigh;
	 * @see czm_encodedCameraPositionMCLow
	 * @see czm_modelViewRelativeToEye
	 * @see czm_modelViewProjectionRelativeToEye
	 */
	namespace czm_encodedCameraPositionMCHigh {
	}

	/**
	 * An automatic GLSL uniform representing the low bits of the camera position in model
	 * coordinates.  This is used for GPU RTE to eliminate jittering artifacts when rendering
	 * as described in {@link http://blogs.agi.com/insight3d/index.php/2008/09/03/precisions-precisions/|Precisions, Precisions}.
	 * @alias czm_encodedCameraPositionMCLow
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform vec3 czm_encodedCameraPositionMCLow;
	 * @see czm_encodedCameraPositionMCHigh
	 * @see czm_modelViewRelativeToEye
	 * @see czm_modelViewProjectionRelativeToEye
	 */
	namespace czm_encodedCameraPositionMCLow {
	}

	/**
	 * An automatic GLSL uniform representing the position of the viewer (camera) in world coordinates.
	 * @alias czm_viewerPositionWC
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform vec3 czm_viewerPositionWC;
	 */
	namespace czm_viewerPositionWC {
	}

	/**
	 * An automatic GLSL uniform representing the frame number. This uniform is automatically incremented
	 * every frame.
	 * @alias czm_frameNumber
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform float czm_frameNumber;
	 */
	namespace czm_frameNumber {
	}

	/**
	 * An automatic GLSL uniform representing the current morph transition time between
	 * 2D/Columbus View and 3D, with 0.0 being 2D or Columbus View and 1.0 being 3D.
	 * @alias czm_morphTime
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform float czm_morphTime;
	 * // Example
	 * vec4 p = czm_columbusViewMorph(position2D, position3D, czm_morphTime);
	 */
	namespace czm_morphTime {
	}

	/**
	 * An automatic GLSL uniform representing the current {@link SceneMode}, expressed
	 * as a float.
	 * @alias czm_sceneMode
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform float czm_sceneMode;
	 * // Example
	 * if (czm_sceneMode == czm_sceneMode2D)
	 * {
	 *     eyeHeightSq = czm_eyeHeight2D.y;
	 * }
	 * @see czm_sceneMode2D
	 * @see czm_sceneModeColumbusView
	 * @see czm_sceneMode3D
	 * @see czm_sceneModeMorphing
	 */
	namespace czm_sceneMode {
	}

	/**
	 * An automatic GLSL uniform representing the current rendering pass.
	 * @alias czm_pass
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform float czm_pass;
	 * // Example
	 * if ((czm_pass == czm_passTranslucent) && isOpaque())
	 * {
	 *     gl_Position *= 0.0; // Cull opaque geometry in the translucent pass
	 * }
	 */
	namespace czm_pass {
	}

	/**
	 * An automatic GLSL uniform representing the current scene background color.
	 * @alias czm_backgroundColor
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform vec4 czm_backgroundColor;
	 * // Example: If the given color's RGB matches the background color, invert it.
	 * vec4 adjustColorForContrast(vec4 color)
	 * {
	 *     if (czm_backgroundColor.rgb == color.rgb)
	 *     {
	 *         color.rgb = vec3(1.0) - color.rgb;
	 *     }
	 *     return color;
	 * }
	 */
	namespace czm_backgroundColor {
	}

	/**
	 * An automatic GLSL uniform containing the BRDF look up texture used for image-based lighting computations.
	 * @alias czm_brdfLut
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform sampler2D czm_brdfLut;
	 * // Example: For a given roughness and NdotV value, find the material's BRDF information in the red and green channels
	 * float roughness = 0.5;
	 * float NdotV = dot(normal, view);
	 * vec2 brdfLut = texture2D(czm_brdfLut, vec2(NdotV, 1.0 - roughness)).rg;
	 */
	namespace czm_brdfLut {
	}

	/**
	 * An automatic GLSL uniform containing the environment map used within the scene.
	 * @alias czm_environmentMap
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform samplerCube czm_environmentMap;
	 * // Example: Create a perfect reflection of the environment map on a  model
	 * float reflected = reflect(view, normal);
	 * vec4 reflectedColor = textureCube(czm_environmentMap, reflected);
	 */
	namespace czm_environmentMap {
	}

	/**
	 * An automatic GLSL uniform representing a 3x3 rotation matrix that transforms
	 * from True Equator Mean Equinox (TEME) axes to the pseudo-fixed axes at the current scene time.
	 * @alias czm_temeToPseudoFixed
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform mat3 czm_temeToPseudoFixed;
	 * // Example
	 * vec3 pseudoFixed = czm_temeToPseudoFixed * teme;
	 * @see UniformState#temeToPseudoFixedMatrix
	 * @see Transforms.computeTemeToPseudoFixedMatrix
	 */
	namespace czm_temeToPseudoFixed {
	}

	/**
	 * An automatic GLSL uniform representing the ratio of canvas coordinate space to canvas pixel space.
	 * @alias czm_resolutionScale
	 * @namespace
	 * @glslUniform
	 * @example
	 * uniform float czm_resolutionScale;
	 */
	namespace czm_resolutionScale {
	}

	/**
	 * An automatic GLSL uniform scalar used to mix a color with the fog color based on the distance to the camera.
	 * @alias czm_fogDensity
	 * @namespace
	 * @glslUniform
	 * @see czm_fog
	 */
	namespace czm_fogDensity {
	}

	/**
	 * An automatic GLSL uniform representing the splitter position to use when rendering imagery layers with a splitter.
	 * This will be in pixel coordinates relative to the canvas.
	 * @alias czm_imagerySplitPosition
	 * @namespace
	 * @glslUniform
	 * @example
	 * // GLSL declaration
	 * uniform float czm_imagerySplitPosition;
	 */
	namespace czm_imagerySplitPosition {
	}

	/**
	 * An automatic GLSL uniform scalar representing the geometric tolerance per meter
	 * @alias czm_geometricToleranceOverMeter
	 * @namespace
	 * @glslUniform
	 */
	namespace czm_geometricToleranceOverMeter {
	}

	/**
	 * An automatic GLSL uniform representing the distance from the camera at which to disable the depth test of billboards, labels and points
	 * to, for example, prevent clipping against terrain. When set to zero, the depth test should always be applied. When less than zero,
	 * the depth test should never be applied.
	 * @alias czm_minimumDisableDepthTestDistance
	 * @namespace
	 * @glslUniform
	 */
	namespace czm_minimumDisableDepthTestDistance {
	}

	/**
	 * An automatic GLSL uniform that will be the highlight color of unclassified 3D Tiles.
	 * @alias czm_invertClassificationColor
	 * @namespace
	 * @glslUniform
	 */
	namespace czm_invertClassificationColor {
	}

	/**
	 * Enumerates all possible filters used when magnifying WebGL textures.
	 * @exports TextureMagnificationFilter
	 * @see TextureMinificationFilter
	 */
	namespace TextureMagnificationFilter {
		/**
		 * Samples the texture by returning the closest pixel.
		 * @type {Number}
		 * @constant
		 */
		const NEAREST: number;

		/**
		 * Samples the texture through bi-linear interpolation of the four nearest pixels. This produces smoother results than <code>NEAREST</code> filtering.
		 * @type {Number}
		 * @constant
		 */
		const LINEAR: number;

	}

	/**
	 * Enumerates all possible filters used when minifying WebGL textures.
	 * @exports TextureMinificationFilter
	 * @see TextureMagnificationFilter
	 */
	namespace TextureMinificationFilter {
		/**
		 * Samples the texture by returning the closest pixel.
		 * @type {Number}
		 * @constant
		 */
		const NEAREST: number;

		/**
		 * Samples the texture through bi-linear interpolation of the four nearest pixels. This produces smoother results than <code>NEAREST</code> filtering.
		 * @type {Number}
		 * @constant
		 */
		const LINEAR: number;

		/**
		 * Selects the nearest mip level and applies nearest sampling within that level.
		 * <p>
		 * Requires that the texture has a mipmap. The mip level is chosen by the view angle and screen-space size of the texture.
		 * </p>
		 * @type {Number}
		 * @constant
		 */
		const NEAREST_MIPMAP_NEAREST: number;

		/**
		 * Selects the nearest mip level and applies linear sampling within that level.
		 * <p>
		 * Requires that the texture has a mipmap. The mip level is chosen by the view angle and screen-space size of the texture.
		 * </p>
		 * @type {Number}
		 * @constant
		 */
		const LINEAR_MIPMAP_NEAREST: number;

		/**
		 * Read texture values with nearest sampling from two adjacent mip levels and linearly interpolate the results.
		 * <p>
		 * This option provides a good balance of visual quality and speed when sampling from a mipmapped texture.
		 * </p>
		 * <p>
		 * Requires that the texture has a mipmap. The mip level is chosen by the view angle and screen-space size of the texture.
		 * </p>
		 * @type {Number}
		 * @constant
		 */
		const NEAREST_MIPMAP_LINEAR: number;

		/**
		 * Read texture values with linear sampling from two adjacent mip levels and linearly interpolate the results.
		 * <p>
		 * This option provides a good balance of visual quality and speed when sampling from a mipmapped texture.
		 * </p>
		 * <p>
		 * Requires that the texture has a mipmap. The mip level is chosen by the view angle and screen-space size of the texture.
		 * </p>
		 * @type {Number}
		 * @constant
		 */
		const LINEAR_MIPMAP_LINEAR: number;

	}

	/**
	 * An appearance defines the full GLSL vertex and fragment shaders and the
	 * render state used to draw a {@link Primitive}.  All appearances implement
	 * this base <code>Appearance</code> interface.
	 * @alias Appearance
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Boolean} [options.translucent=true] When <code>true</code>, the geometry is expected to appear translucent so {@link Appearance#renderState} has alpha blending enabled.
	 * @param {Boolean} [options.closed=false] When <code>true</code>, the geometry is expected to be closed so {@link Appearance#renderState} has backface culling enabled.
	 * @param {Material} [options.material=Material.ColorType] The material used to determine the fragment color.
	 * @param {String} [options.vertexShaderSource] Optional GLSL vertex shader source to override the default vertex shader.
	 * @param {String} [options.fragmentShaderSource] Optional GLSL fragment shader source to override the default fragment shader.
	 * @param {RenderState} [options.renderState] Optional render state to override the default render state.
	 * @see MaterialAppearance
	 * @see EllipsoidSurfaceAppearance
	 * @see PerInstanceColorAppearance
	 * @see DebugAppearance
	 * @see PolylineColorAppearance
	 * @see PolylineMaterialAppearance
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Geometry%20and%20Appearances.html|Geometry and Appearances Demo}
	 */
	class Appearance {
		constructor(options?: {
			translucent?: boolean;
			closed?: boolean;
			material?: Material;
			vertexShaderSource?: string;
			fragmentShaderSource?: string;
			renderState?: any;
		});

		/**
		 * The material used to determine the fragment color.  Unlike other {@link Appearance}
		 * properties, this is not read-only, so an appearance's material can change on the fly.
		 * @type Material
		 * @see {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric|Fabric}
		 */
		material: Material;

		/**
		 * When <code>true</code>, the geometry is expected to appear translucent.
		 * @type {Boolean}
		 * @default true
		 */
		translucent: boolean;

		/**
		 * The GLSL source code for the vertex shader.
		 * @memberof Appearance.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly vertexShaderSource: string;

		/**
		 * The GLSL source code for the fragment shader.  The full fragment shader
		 * source is built procedurally taking into account the {@link Appearance#material}.
		 * Use {@link Appearance#getFragmentShaderSource} to get the full source.
		 * @memberof Appearance.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly fragmentShaderSource: string;

		/**
		 * The WebGL fixed-function state to use when rendering the geometry.
		 * @memberof Appearance.prototype
		 * @type {Object}
		 * @readonly
		 */
		readonly renderState: any;

		/**
		 * When <code>true</code>, the geometry is expected to be closed.
		 * @memberof Appearance.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default false
		 */
		readonly closed: boolean;

		/**
		 * Procedurally creates the full GLSL fragment shader source for this appearance
		 * taking into account {@link Appearance#fragmentShaderSource} and {@link Appearance#material}.
		 * @returns {String} The full GLSL fragment shader source.
		 */
		getFragmentShaderSource(): string;

		/**
		 * Determines if the geometry is translucent based on {@link Appearance#translucent} and {@link Material#isTranslucent}.
		 * @returns {Boolean} <code>true</code> if the appearance is translucent.
		 */
		isTranslucent(): boolean;

		/**
		 * Creates a render state.  This is not the final render state instance; instead,
		 * it can contain a subset of render state properties identical to the render state
		 * created in the context.
		 * @returns {Object} The render state.
		 */
		getRenderState(): any;

	}

	/**
	 * Provides tiled imagery hosted by an ArcGIS MapServer.  By default, the server's pre-cached tiles are
	 * used, if available.
	 * @alias ArcGisMapServerImageryProvider
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Resource|String} options.url The URL of the ArcGIS MapServer service.
	 * @param {String} [options.token] The ArcGIS token used to authenticate with the ArcGIS MapServer service.
	 * @param {TileDiscardPolicy} [options.tileDiscardPolicy] The policy that determines if a tile
	 *        is invalid and should be discarded.  If this value is not specified, a default
	 *        {@link DiscardMissingTileImagePolicy} is used for tiled map servers, and a
	 *        {@link NeverTileDiscardPolicy} is used for non-tiled map servers.  In the former case,
	 *        we request tile 0,0 at the maximum tile level and check pixels (0,0), (200,20), (20,200),
	 *        (80,110), and (160, 130).  If all of these pixels are transparent, the discard check is
	 *        disabled and no tiles are discarded.  If any of them have a non-transparent color, any
	 *        tile that has the same values in these pixel locations is discarded.  The end result of
	 *        these defaults should be correct tile discarding for a standard ArcGIS Server.  To ensure
	 *        that no tiles are discarded, construct and pass a {@link NeverTileDiscardPolicy} for this
	 *        parameter.
	 * @param {Boolean} [options.usePreCachedTilesIfAvailable=true] If true, the server's pre-cached
	 *        tiles are used if they are available.  If false, any pre-cached tiles are ignored and the
	 *        'export' service is used.
	 * @param {String} [options.layers] A comma-separated list of the layers to show, or undefined if all layers should be shown.
	 * @param {Boolean} [options.enablePickFeatures=true] If true, {@link ArcGisMapServerImageryProvider#pickFeatures} will invoke
	 *        the Identify service on the MapServer and return the features included in the response.  If false,
	 *        {@link ArcGisMapServerImageryProvider#pickFeatures} will immediately return undefined (indicating no pickable features)
	 *        without communicating with the server.  Set this property to false if you don't want this provider's features to
	 *        be pickable. Can be overridden by setting the {@link ArcGisMapServerImageryProvider#enablePickFeatures} property on the object.
	 * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle of the layer.  This parameter is ignored when accessing
	 *                    a tiled layer.
	 * @param {TilingScheme} [options.tilingScheme=new GeographicTilingScheme()] The tiling scheme to use to divide the world into tiles.
	 *                       This parameter is ignored when accessing a tiled server.
	 * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If the tilingScheme is specified and used,
	 *                    this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither
	 *                    parameter is specified, the WGS84 ellipsoid is used.
	 * @param {Number} [options.tileWidth=256] The width of each tile in pixels.  This parameter is ignored when accessing a tiled server.
	 * @param {Number} [options.tileHeight=256] The height of each tile in pixels.  This parameter is ignored when accessing a tiled server.
	 * @param {Number} [options.maximumLevel] The maximum tile level to request, or undefined if there is no maximum.  This parameter is ignored when accessing
	 *                                        a tiled server.
	 * @see BingMapsImageryProvider
	 * @see GoogleEarthEnterpriseMapsProvider
	 * @see createOpenStreetMapImageryProvider
	 * @see SingleTileImageryProvider
	 * @see createTileMapServiceImageryProvider
	 * @see WebMapServiceImageryProvider
	 * @see WebMapTileServiceImageryProvider
	 * @see UrlTemplateImageryProvider
	 * @example
	 * var esri = new Cesium.ArcGisMapServerImageryProvider({
	 *     url : 'https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer'
	 * });
	 * @see {@link http://resources.esri.com/help/9.3/arcgisserver/apis/rest/|ArcGIS Server REST API}
	 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
	 */
	class ArcGisMapServerImageryProvider {
		constructor(options: {
			url: Resource | string;
			token?: string;
			tileDiscardPolicy?: TileDiscardPolicy;
			usePreCachedTilesIfAvailable?: boolean;
			layers?: string;
			enablePickFeatures?: boolean;
			rectangle?: Rectangle;
			tilingScheme?: TilingScheme;
			ellipsoid?: Ellipsoid;
			tileWidth?: number;
			tileHeight?: number;
			maximumLevel?: number;
		});

		/**
		 * Gets or sets a value indicating whether feature picking is enabled.  If true, {@link ArcGisMapServerImageryProvider#pickFeatures} will
		 * invoke the "identify" operation on the ArcGIS server and return the features included in the response.  If false,
		 * {@link ArcGisMapServerImageryProvider#pickFeatures} will immediately return undefined (indicating no pickable features)
		 * without communicating with the server.
		 * @type {Boolean}
		 * @default true
		 */
		enablePickFeatures: boolean;

		/**
		 * Gets the URL of the ArcGIS MapServer.
		 * @memberof ArcGisMapServerImageryProvider.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly url: string;

		/**
		 * Gets the ArcGIS token used to authenticate with the ArcGis MapServer service.
		 * @memberof ArcGisMapServerImageryProvider.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly token: string;

		/**
		 * Gets the proxy used by this provider.
		 * @memberof ArcGisMapServerImageryProvider.prototype
		 * @type {Proxy}
		 * @readonly
		 */
		readonly proxy: Proxy;

		/**
		 * Gets the width of each tile, in pixels. This function should
		 * not be called before {@link ArcGisMapServerImageryProvider#ready} returns true.
		 * @memberof ArcGisMapServerImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly tileWidth: number;

		/**
		 * Gets the height of each tile, in pixels.  This function should
		 * not be called before {@link ArcGisMapServerImageryProvider#ready} returns true.
		 * @memberof ArcGisMapServerImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly tileHeight: number;

		/**
		 * Gets the maximum level-of-detail that can be requested.  This function should
		 * not be called before {@link ArcGisMapServerImageryProvider#ready} returns true.
		 * @memberof ArcGisMapServerImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly maximumLevel: number;

		/**
		 * Gets the minimum level-of-detail that can be requested.  This function should
		 * not be called before {@link ArcGisMapServerImageryProvider#ready} returns true.
		 * @memberof ArcGisMapServerImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly minimumLevel: number;

		/**
		 * Gets the tiling scheme used by this provider.  This function should
		 * not be called before {@link ArcGisMapServerImageryProvider#ready} returns true.
		 * @memberof ArcGisMapServerImageryProvider.prototype
		 * @type {TilingScheme}
		 * @readonly
		 */
		readonly tilingScheme: TilingScheme;

		/**
		 * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should
		 * not be called before {@link ArcGisMapServerImageryProvider#ready} returns true.
		 * @memberof ArcGisMapServerImageryProvider.prototype
		 * @type {Rectangle}
		 * @readonly
		 */
		readonly rectangle: Rectangle;

		/**
		 * Gets the tile discard policy.  If not undefined, the discard policy is responsible
		 * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
		 * returns undefined, no tiles are filtered.  This function should
		 * not be called before {@link ArcGisMapServerImageryProvider#ready} returns true.
		 * @memberof ArcGisMapServerImageryProvider.prototype
		 * @type {TileDiscardPolicy}
		 * @readonly
		 */
		readonly tileDiscardPolicy: TileDiscardPolicy;

		/**
		 * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
		 * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
		 * are passed an instance of {@link TileProviderError}.
		 * @memberof ArcGisMapServerImageryProvider.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly errorEvent: Event;

		/**
		 * Gets a value indicating whether or not the provider is ready for use.
		 * @memberof ArcGisMapServerImageryProvider.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly ready: boolean;

		/**
		 * Gets a promise that resolves to true when the provider is ready for use.
		 * @memberof ArcGisMapServerImageryProvider.prototype
		 * @type {Promise.<Boolean>}
		 * @readonly
		 */
		readonly readyPromise: any;

		/**
		 * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
		 * the source of the imagery.  This function should not be called before {@link ArcGisMapServerImageryProvider#ready} returns true.
		 * @memberof ArcGisMapServerImageryProvider.prototype
		 * @type {Credit}
		 * @readonly
		 */
		readonly credit: Credit;

		/**
		 * Gets a value indicating whether this imagery provider is using pre-cached tiles from the
		 * ArcGIS MapServer.  If the imagery provider is not yet ready ({@link ArcGisMapServerImageryProvider#ready}), this function
		 * will return the value of `options.usePreCachedTilesIfAvailable`, even if the MapServer does
		 * not have pre-cached tiles.
		 * @memberof ArcGisMapServerImageryProvider.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		readonly usingPrecachedTiles: boolean;

		/**
		 * Gets a value indicating whether or not the images provided by this imagery provider
		 * include an alpha channel.  If this property is false, an alpha channel, if present, will
		 * be ignored.  If this property is true, any images without an alpha channel will be treated
		 * as if their alpha is 1.0 everywhere.  When this property is false, memory usage
		 * and texture upload time are reduced.
		 * @memberof ArcGisMapServerImageryProvider.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		readonly hasAlphaChannel: boolean;

		/**
		 * Gets the comma-separated list of layer IDs to show.
		 * @memberof ArcGisMapServerImageryProvider.prototype
		 * @type {String}
		 */
		layers: string;

		/**
		 * Gets the credits to be displayed when a given tile is displayed.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level;
		 * @returns {Credit[]} The credits to be displayed when the tile is displayed.
		 * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.
		 */
		getTileCredits(x: number, y: number, level: number): (Credit)[];

		/**
		 * Requests the image for a given tile.  This function should
		 * not be called before {@link ArcGisMapServerImageryProvider#ready} returns true.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level.
		 * @param {Request} [request] The request object. Intended for internal use only.
		 * @returns {Promise.<Image|Canvas>|undefined} A promise for the image that will resolve when the image is available, or
		 *          undefined if there are too many active requests to the server, and the request
		 *          should be retried later.  The resolved image may be either an
		 *          Image or a Canvas DOM object.
		 * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.
		 */
		requestImage(x: number, y: number, level: number, request?: Request): any | any | undefined;

		/**
		 * Asynchronously determines what features, if any, are located at a given longitude and latitude within
		 * a tile.  This function should not be called before {@link ImageryProvider#ready} returns true.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level.
		 * @param {Number} longitude The longitude at which to pick features.
		 * @param {Number} latitude  The latitude at which to pick features.
		 * @return {Promise.<ImageryLayerFeatureInfo[]>|undefined} A promise for the picked features that will resolve when the asynchronous
		 *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}
		 *                   instances.  The array may be empty if no features are found at the given location.
		 * @exception {DeveloperError} <code>pickFeatures</code> must not be called before the imagery provider is ready.
		 */
		pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): any | undefined;

	}

	/**
	 * A viewport-aligned image positioned in the 3D scene, that is created
	 * and rendered using a {@link BillboardCollection}.  A billboard is created and its initial
	 * properties are set by calling {@link BillboardCollection#add}.
	 * <br /><br />
	 * <div align='center'>
	 * <img src='Images/Billboard.png' width='400' height='300' /><br />
	 * Example billboards
	 * </div>
	 * @alias Billboard
	 * @param {object} options
	 * @performance Reading a property, e.g., {@link Billboard#show}, is constant time.
	 * Assigning to a property is constant time but results in
	 * CPU to GPU traffic when {@link BillboardCollection#update} is called.  The per-billboard traffic is
	 * the same regardless of how many properties were updated.  If most billboards in a collection need to be
	 * updated, it may be more efficient to clear the collection with {@link BillboardCollection#removeAll}
	 * and add new billboards instead of modifying each one.
	 * @exception {DeveloperError} scaleByDistance.far must be greater than scaleByDistance.near
	 * @exception {DeveloperError} translucencyByDistance.far must be greater than translucencyByDistance.near
	 * @exception {DeveloperError} pixelOffsetScaleByDistance.far must be greater than pixelOffsetScaleByDistance.near
	 * @exception {DeveloperError} distanceDisplayCondition.far must be greater than distanceDisplayCondition.near
	 * @see BillboardCollection
	 * @see BillboardCollection#add
	 * @see Label
	 * @internalConstructor
	 * @class
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Billboards.html|Cesium Sandcastle Billboard Demo}
	 */
	class EngineBillboard {
		constructor(options: object);

		/**
		 * Determines if this billboard will be shown.  Use this to hide or show a billboard, instead
		 * of removing it and re-adding it to the collection.
		 * @memberof Billboard.prototype
		 * @type {Boolean}
		 * @default true
		 */
		show: boolean;

		/**
		 * Gets or sets the Cartesian position of this billboard.
		 * @memberof Billboard.prototype
		 * @type {Cartesian3}
		 */
		position: Cartesian3;

		/**
		 * Gets or sets the height reference of this billboard.
		 * @memberof Billboard.prototype
		 * @type {HeightReference}
		 * @default HeightReference.NONE
		 */
		heightReference: any;

		/**
		 * Gets or sets the pixel offset in screen space from the origin of this billboard.  This is commonly used
		 * to align multiple billboards and labels at the same position, e.g., an image and text.  The
		 * screen space origin is the top, left corner of the canvas; <code>x</code> increases from
		 * left to right, and <code>y</code> increases from top to bottom.
		 * <br /><br />
		 * <div align='center'>
		 * <table border='0' cellpadding='5'><tr>
		 * <td align='center'><code>default</code><br/><img src='Images/Billboard.setPixelOffset.default.png' width='250' height='188' /></td>
		 * <td align='center'><code>b.pixeloffset = new Cartesian2(50, 25);</code><br/><img src='Images/Billboard.setPixelOffset.x50y-25.png' width='250' height='188' /></td>
		 * </tr></table>
		 * The billboard's origin is indicated by the yellow point.
		 * </div>
		 * @memberof Billboard.prototype
		 * @type {Cartesian2}
		 */
		pixelOffset: Cartesian2;

		/**
		 * Gets or sets near and far scaling properties of a Billboard based on the billboard's distance from the camera.
		 * A billboard's scale will interpolate between the {@link NearFarScalar#nearValue} and
		 * {@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
		 * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
		 * Outside of these ranges the billboard's scale remains clamped to the nearest bound.  If undefined,
		 * scaleByDistance will be disabled.
		 * @memberof Billboard.prototype
		 * @type {NearFarScalar}
		 * @example
		 * // Example 1.
		 * // Set a billboard's scaleByDistance to scale by 1.5 when the
		 * // camera is 1500 meters from the billboard and disappear as
		 * // the camera distance approaches 8.0e6 meters.
		 * b.scaleByDistance = new Cesium.NearFarScalar(1.5e2, 1.5, 8.0e6, 0.0);
		 * @example
		 * // Example 2.
		 * // disable scaling by distance
		 * b.scaleByDistance = undefined;
		 */
		scaleByDistance: NearFarScalar;

		/**
		 * Gets or sets near and far translucency properties of a Billboard based on the billboard's distance from the camera.
		 * A billboard's translucency will interpolate between the {@link NearFarScalar#nearValue} and
		 * {@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
		 * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
		 * Outside of these ranges the billboard's translucency remains clamped to the nearest bound.  If undefined,
		 * translucencyByDistance will be disabled.
		 * @memberof Billboard.prototype
		 * @type {NearFarScalar}
		 * @example
		 * // Example 1.
		 * // Set a billboard's translucency to 1.0 when the
		 * // camera is 1500 meters from the billboard and disappear as
		 * // the camera distance approaches 8.0e6 meters.
		 * b.translucencyByDistance = new Cesium.NearFarScalar(1.5e2, 1.0, 8.0e6, 0.0);
		 * @example
		 * // Example 2.
		 * // disable translucency by distance
		 * b.translucencyByDistance = undefined;
		 */
		translucencyByDistance: NearFarScalar;

		/**
		 * Gets or sets near and far pixel offset scaling properties of a Billboard based on the billboard's distance from the camera.
		 * A billboard's pixel offset will be scaled between the {@link NearFarScalar#nearValue} and
		 * {@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
		 * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
		 * Outside of these ranges the billboard's pixel offset scale remains clamped to the nearest bound.  If undefined,
		 * pixelOffsetScaleByDistance will be disabled.
		 * @memberof Billboard.prototype
		 * @type {NearFarScalar}
		 * @example
		 * // Example 1.
		 * // Set a billboard's pixel offset scale to 0.0 when the
		 * // camera is 1500 meters from the billboard and scale pixel offset to 10.0 pixels
		 * // in the y direction the camera distance approaches 8.0e6 meters.
		 * b.pixelOffset = new Cesium.Cartesian2(0.0, 1.0);
		 * b.pixelOffsetScaleByDistance = new Cesium.NearFarScalar(1.5e2, 0.0, 8.0e6, 10.0);
		 * @example
		 * // Example 2.
		 * // disable pixel offset by distance
		 * b.pixelOffsetScaleByDistance = undefined;
		 */
		pixelOffsetScaleByDistance: NearFarScalar;

		/**
		 * Gets or sets the 3D Cartesian offset applied to this billboard in eye coordinates.  Eye coordinates is a left-handed
		 * coordinate system, where <code>x</code> points towards the viewer's right, <code>y</code> points up, and
		 * <code>z</code> points into the screen.  Eye coordinates use the same scale as world and model coordinates,
		 * which is typically meters.
		 * <br /><br />
		 * An eye offset is commonly used to arrange multiple billboards or objects at the same position, e.g., to
		 * arrange a billboard above its corresponding 3D model.
		 * <br /><br />
		 * Below, the billboard is positioned at the center of the Earth but an eye offset makes it always
		 * appear on top of the Earth regardless of the viewer's or Earth's orientation.
		 * <br /><br />
		 * <div align='center'>
		 * <table border='0' cellpadding='5'><tr>
		 * <td align='center'><img src='Images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>
		 * <td align='center'><img src='Images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>
		 * </tr></table>
		 * <code>b.eyeOffset = new Cartesian3(0.0, 8000000.0, 0.0);</code><br /><br />
		 * </div>
		 * @memberof Billboard.prototype
		 * @type {Cartesian3}
		 */
		eyeOffset: Cartesian3;

		/**
		 * Gets or sets the horizontal origin of this billboard, which determines if the billboard is
		 * to the left, center, or right of its anchor position.
		 * <br /><br />
		 * <div align='center'>
		 * <img src='Images/Billboard.setHorizontalOrigin.png' width='648' height='196' /><br />
		 * </div>
		 * @memberof Billboard.prototype
		 * @type {HorizontalOrigin}
		 * @example
		 * // Use a bottom, left origin
		 * b.horizontalOrigin = Cesium.HorizontalOrigin.LEFT;
		 * b.verticalOrigin = Cesium.VerticalOrigin.BOTTOM;
		 */
		horizontalOrigin: any;

		/**
		 * Gets or sets the vertical origin of this billboard, which determines if the billboard is
		 * to the above, below, or at the center of its anchor position.
		 * <br /><br />
		 * <div align='center'>
		 * <img src='Images/Billboard.setVerticalOrigin.png' width='695' height='175' /><br />
		 * </div>
		 * @memberof Billboard.prototype
		 * @type {VerticalOrigin}
		 * @example
		 * // Use a bottom, left origin
		 * b.horizontalOrigin = Cesium.HorizontalOrigin.LEFT;
		 * b.verticalOrigin = Cesium.VerticalOrigin.BOTTOM;
		 */
		verticalOrigin: any;

		/**
		 * Gets or sets the uniform scale that is multiplied with the billboard's image size in pixels.
		 * A scale of <code>1.0</code> does not change the size of the billboard; a scale greater than
		 * <code>1.0</code> enlarges the billboard; a positive scale less than <code>1.0</code> shrinks
		 * the billboard.
		 * <br /><br />
		 * <div align='center'>
		 * <img src='Images/Billboard.setScale.png' width='400' height='300' /><br/>
		 * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>,
		 * and <code>2.0</code>.
		 * </div>
		 * @memberof Billboard.prototype
		 * @type {Number}
		 */
		scale: number;

		/**
		 * Gets or sets the color that is multiplied with the billboard's texture.  This has two common use cases.  First,
		 * the same white texture may be used by many different billboards, each with a different color, to create
		 * colored billboards.  Second, the color's alpha component can be used to make the billboard translucent as shown below.
		 * An alpha of <code>0.0</code> makes the billboard transparent, and <code>1.0</code> makes the billboard opaque.
		 * <br /><br />
		 * <div align='center'>
		 * <table border='0' cellpadding='5'><tr>
		 * <td align='center'><code>default</code><br/><img src='Images/Billboard.setColor.Alpha255.png' width='250' height='188' /></td>
		 * <td align='center'><code>alpha : 0.5</code><br/><img src='Images/Billboard.setColor.Alpha127.png' width='250' height='188' /></td>
		 * </tr></table>
		 * </div>
		 * <br />
		 * The red, green, blue, and alpha values are indicated by <code>value</code>'s <code>red</code>, <code>green</code>,
		 * <code>blue</code>, and <code>alpha</code> properties as shown in Example 1.  These components range from <code>0.0</code>
		 * (no intensity) to <code>1.0</code> (full intensity).
		 * @memberof Billboard.prototype
		 * @type {Color}
		 * @example
		 * // Example 1. Assign yellow.
		 * b.color = Cesium.Color.YELLOW;
		 * @example
		 * // Example 2. Make a billboard 50% translucent.
		 * b.color = new Cesium.Color(1.0, 1.0, 1.0, 0.5);
		 */
		color: Color;

		/**
		 * Gets or sets the rotation angle in radians.
		 * @memberof Billboard.prototype
		 * @type {Number}
		 */
		rotation: number;

		/**
		 * Gets or sets the aligned axis in world space. The aligned axis is the unit vector that the billboard up vector points towards.
		 * The default is the zero vector, which means the billboard is aligned to the screen up vector.
		 * @memberof Billboard.prototype
		 * @type {Cartesian3}
		 * @example
		 * // Example 1.
		 * // Have the billboard up vector point north
		 * billboard.alignedAxis = Cesium.Cartesian3.UNIT_Z;
		 * @example
		 * // Example 2.
		 * // Have the billboard point east.
		 * billboard.alignedAxis = Cesium.Cartesian3.UNIT_Z;
		 * billboard.rotation = -Cesium.Math.PI_OVER_TWO;
		 * @example
		 * // Example 3.
		 * // Reset the aligned axis
		 * billboard.alignedAxis = Cesium.Cartesian3.ZERO;
		 */
		alignedAxis: Cartesian3;

		/**
		 * Gets or sets a width for the billboard. If undefined, the image width will be used.
		 * @memberof Billboard.prototype
		 * @type {Number}
		 */
		width: number;

		/**
		 * Gets or sets a height for the billboard. If undefined, the image height will be used.
		 * @memberof Billboard.prototype
		 * @type {Number}
		 */
		height: number;

		/**
		 * Gets or sets if the billboard size is in meters or pixels. <code>true</code> to size the billboard in meters;
		 * otherwise, the size is in pixels.
		 * @memberof Billboard.prototype
		 * @type {Boolean}
		 * @default false
		 */
		sizeInMeters: boolean;

		/**
		 * Gets or sets the condition specifying at what distance from the camera that this billboard will be displayed.
		 * @memberof Billboard.prototype
		 * @type {DistanceDisplayCondition}
		 * @default undefined
		 */
		distanceDisplayCondition: DistanceDisplayCondition;

		/**
		 * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.
		 * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.
		 * @memberof Billboard.prototype
		 * @type {Number}
		 */
		disableDepthTestDistance: number;

		/**
		 * Gets or sets the user-defined object returned when the billboard is picked.
		 * @memberof Billboard.prototype
		 * @type {Object}
		 */
		id: any;

		/**
		 * <p>
		 * Gets or sets the image to be used for this billboard.  If a texture has already been created for the
		 * given image, the existing texture is used.
		 * </p>
		 * <p>
		 * This property can be set to a loaded Image, a URL which will be loaded as an Image automatically,
		 * a canvas, or another billboard's image property (from the same billboard collection).
		 * </p>
		 * @memberof Billboard.prototype
		 * @type {String}
		 * @example
		 * // load an image from a URL
		 * b.image = 'some/image/url.png';
		 * // assuming b1 and b2 are billboards in the same billboard collection,
		 * // use the same image for both billboards.
		 * b2.image = b1.image;
		 */
		image: string;

		/**
		 * When <code>true</code>, this billboard is ready to render, i.e., the image
		 * has been downloaded and the WebGL resources are created.
		 * @memberof Billboard.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default false
		 */
		readonly ready: boolean;

		/**
		 * <p>
		 * Sets the image to be used for this billboard.  If a texture has already been created for the
		 * given id, the existing texture is used.
		 * </p>
		 * <p>
		 * This function is useful for dynamically creating textures that are shared across many billboards.
		 * Only the first billboard will actually call the function and create the texture, while subsequent
		 * billboards created with the same id will simply re-use the existing texture.
		 * </p>
		 * <p>
		 * To load an image from a URL, setting the {@link Billboard#image} property is more convenient.
		 * </p>
		 * @param {String} id The id of the image.  This can be any string that uniquely identifies the image.
		 * @param {Image|Canvas|String|Resource|Billboard~Function} image The image to load.  This parameter
		 *        can either be a loaded Image or Canvas, a URL which will be loaded as an Image automatically,
		 *        or a function which will be called to create the image if it hasn't been loaded already.
		 * @example
		 * // create a billboard image dynamically
		 * function drawImage(id) {
		 *   // create and draw an image using a canvas
		 *   var canvas = document.createElement('canvas');
		 *   var context2D = canvas.getContext('2d');
		 *   // ... draw image
		 *   return canvas;
		 * }
		 * // drawImage will be called to create the texture
		 * b.setImage('myImage', drawImage);
		 * // subsequent billboards created in the same collection using the same id will use the existing
		 * // texture, without the need to create the canvas or draw the image
		 * b2.setImage('myImage', drawImage);
		 */
		setImage(id: string, image: any | any | string | Resource | Function): void;

		/**
		 * Uses a sub-region of the image with the given id as the image for this billboard,
		 * measured in pixels from the bottom-left.
		 * @param {String} id The id of the image to use.
		 * @param {BoundingRectangle} subRegion The sub-region of the image.
		 * @exception {RuntimeError} image with id must be in the atlas
		 */
		setImageSubRegion(id: string, subRegion: BoundingRectangle): void;

		/**
		 * Computes the screen-space position of the billboard's origin, taking into account eye and pixel offsets.
		 * The screen space origin is the top, left corner of the canvas; <code>x</code> increases from
		 * left to right, and <code>y</code> increases from top to bottom.
		 * @param {Scene} scene The scene.
		 * @param {Cartesian2} [result] The object onto which to store the result.
		 * @returns {Cartesian2} The screen-space position of the billboard.
		 * @exception {DeveloperError} Billboard must be in a collection.
		 * @example
		 * console.log(b.computeScreenSpacePosition(scene).toString());
		 * @see Billboard#eyeOffset
		 * @see Billboard#pixelOffset
		 */
		computeScreenSpacePosition(scene: Scene, result?: Cartesian2): Cartesian2;

		/**
		 * Determines if this billboard equals another billboard.  Billboards are equal if all their properties
		 * are equal.  Billboards in different collections can be equal.
		 * @param {Billboard} other The billboard to compare for equality.
		 * @returns {Boolean} <code>true</code> if the billboards are equal; otherwise, <code>false</code>.
		 */
		equals(other: Billboard): boolean;

	}

	/**
	 * A renderable collection of billboards.  Billboards are viewport-aligned
	 * images positioned in the 3D scene.
	 * <br /><br />
	 * <div align='center'>
	 * <img src='Images/Billboard.png' width='400' height='300' /><br />
	 * Example billboards
	 * </div>
	 * <br /><br />
	 * Billboards are added and removed from the collection using {@link BillboardCollection#add}
	 * and {@link BillboardCollection#remove}.  Billboards in a collection automatically share textures
	 * for images with the same identifier.
	 * @alias BillboardCollection
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms each billboard from model to world coordinates.
	 * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.
	 * @param {Scene} [options.scene] Must be passed in for billboards that use the height reference property or will be depth tested against the globe.
	 * @param {BlendOption} [options.blendOption=BlendOption.OPAQUE_AND_TRANSLUCENT] The billboard blending option. The default
	 * is used for rendering both opaque and translucent billboards. However, if either all of the billboards are completely opaque or all are completely translucent,
	 * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve performance by up to 2x.
	 * @performance For best performance, prefer a few collections, each with many billboards, to
	 * many collections with only a few billboards each.  Organize collections so that billboards
	 * with the same update frequency are in the same collection, i.e., billboards that do not
	 * change should be in one collection; billboards that change every frame should be in another
	 * collection; and so on.
	 * @see BillboardCollection#add
	 * @see BillboardCollection#remove
	 * @see Billboard
	 * @see LabelCollection
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Billboards.html|Cesium Sandcastle Billboard Demo}
	 * @example
	 * // Create a billboard collection with two billboards
	 * var billboards = scene.primitives.add(new Cesium.BillboardCollection());
	 * billboards.add({
	 *   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),
	 *   image : 'url/to/image'
	 * });
	 * billboards.add({
	 *   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),
	 *   image : 'url/to/another/image'
	 * });
	 */
	class BillboardCollection {
		constructor(options?: {
			modelMatrix?: Matrix4;
			debugShowBoundingVolume?: boolean;
			scene?: Scene;
			blendOption?: any;
			color?:Color
		});

		/**
		 * The 4x4 transformation matrix that transforms each billboard in this collection from model to world coordinates.
		 * When this is the identity matrix, the billboards are drawn in world coordinates, i.e., Earth's WGS84 coordinates.
		 * Local reference frames can be used by providing a different transformation matrix, like that returned
		 * by {@link Transforms.eastNorthUpToFixedFrame}.
		 * @type {Matrix4}
		 * @default {@link Matrix4.IDENTITY}
		 * @example
		 * var center = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);
		 * billboards.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);
		 * billboards.add({
		 *   image : 'url/to/image',
		 *   position : new Cesium.Cartesian3(0.0, 0.0, 0.0) // center
		 * });
		 * billboards.add({
		 *   image : 'url/to/image',
		 *   position : new Cesium.Cartesian3(1000000.0, 0.0, 0.0) // east
		 * });
		 * billboards.add({
		 *   image : 'url/to/image',
		 *   position : new Cesium.Cartesian3(0.0, 1000000.0, 0.0) // north
		 * });
		 * billboards.add({
		 *   image : 'url/to/image',
		 *   position : new Cesium.Cartesian3(0.0, 0.0, 1000000.0) // up
		 * });
		 * @see Transforms.eastNorthUpToFixedFrame
		 */
		modelMatrix: Matrix4;

		/**
		 * This property is for debugging only; it is not for production use nor is it optimized.
		 * <p>
		 * Draws the bounding sphere for each draw command in the primitive.
		 * </p>
		 * @type {Boolean}
		 * @default false
		 */
		debugShowBoundingVolume: boolean;

		/**
		 * The billboard blending option. The default is used for rendering both opaque and translucent billboards.
		 * However, if either all of the billboards are completely opaque or all are completely translucent,
		 * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve
		 * performance by up to 2x.
		 * @type {BlendOption}
		 * @default BlendOption.OPAQUE_AND_TRANSLUCENT
		 */
		blendOption: any;

		/**
		 * Returns the number of billboards in this collection.  This is commonly used with
		 * {@link BillboardCollection#get} to iterate over all the billboards
		 * in the collection.
		 * @memberof BillboardCollection.prototype
		 * @type {Number}
		 */
		length: number;

		/**
		 * Creates and adds a billboard with the specified initial properties to the collection.
		 * The added billboard is returned so it can be modified or removed from the collection later.
		 * @param {Object}[billboard] A template describing the billboard's properties as shown in Example 1.
		 * @returns {Billboard} The billboard that was added to the collection.
		 * @performance Calling <code>add</code> is expected constant time.  However, the collection's vertex buffer
		 * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For
		 * best performance, add as many billboards as possible before calling <code>update</code>.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * // Example 1:  Add a billboard, specifying all the default values.
		 * var b = billboards.add({
		 *   show : true,
		 *   position : Cesium.Cartesian3.ZERO,
		 *   pixelOffset : Cesium.Cartesian2.ZERO,
		 *   eyeOffset : Cesium.Cartesian3.ZERO,
		 *   heightReference : Cesium.HeightReference.NONE,
		 *   horizontalOrigin : Cesium.HorizontalOrigin.CENTER,
		 *   verticalOrigin : Cesium.VerticalOrigin.CENTER,
		 *   scale : 1.0,
		 *   image : 'url/to/image',
		 *   imageSubRegion : undefined,
		 *   color : Cesium.Color.WHITE,
		 *   id : undefined,
		 *   rotation : 0.0,
		 *   alignedAxis : Cesium.Cartesian3.ZERO,
		 *   width : undefined,
		 *   height : undefined,
		 *   scaleByDistance : undefined,
		 *   translucencyByDistance : undefined,
		 *   pixelOffsetScaleByDistance : undefined,
		 *   sizeInMeters : false,
		 *   distanceDisplayCondition : undefined
		 * });
		 * @example
		 * // Example 2:  Specify only the billboard's cartographic position.
		 * var b = billboards.add({
		 *   position : Cesium.Cartesian3.fromDegrees(longitude, latitude, height)
		 * });
		 * @see BillboardCollection#remove
		 * @see BillboardCollection#removeAll
		 */
		add(billboard?: any): Billboard;

		/**
		 * Removes a billboard from the collection.
		 * @param {Billboard} billboard The billboard to remove.
		 * @returns {Boolean} <code>true</code> if the billboard was removed; <code>false</code> if the billboard was not found in the collection.
		 * @performance Calling <code>remove</code> is expected constant time.  However, the collection's vertex buffer
		 * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For
		 * best performance, remove as many billboards as possible before calling <code>update</code>.
		 * If you intend to temporarily hide a billboard, it is usually more efficient to call
		 * {@link Billboard#show} instead of removing and re-adding the billboard.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * var b = billboards.add(...);
		 * billboards.remove(b);  // Returns true
		 * @see BillboardCollection#add
		 * @see BillboardCollection#removeAll
		 * @see Billboard#show
		 */
		remove(billboard: Billboard): boolean;

		/**
		 * Removes all billboards from the collection.
		 * @performance <code>O(n)</code>.  It is more efficient to remove all the billboards
		 * from a collection and then add new ones than to create a new collection entirely.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * billboards.add(...);
		 * billboards.add(...);
		 * billboards.removeAll();
		 * @see BillboardCollection#add
		 * @see BillboardCollection#remove
		 */
		removeAll(): void;

		/**
		 * Check whether this collection contains a given billboard.
		 * @param {Billboard} [billboard] The billboard to check for.
		 * @returns {Boolean} true if this collection contains the billboard, false otherwise.
		 * @see BillboardCollection#get
		 */
		contains(billboard?: Billboard): boolean;

		/**
		 * Returns the billboard in the collection at the specified index.  Indices are zero-based
		 * and increase as billboards are added.  Removing a billboard shifts all billboards after
		 * it to the left, changing their indices.  This function is commonly used with
		 * {@link BillboardCollection#length} to iterate over all the billboards
		 * in the collection.
		 * @param {Number} index The zero-based index of the billboard.
		 * @returns {Billboard} The billboard at the specified index.
		 * @performance Expected constant time.  If billboards were removed from the collection and
		 * {@link BillboardCollection#update} was not called, an implicit <code>O(n)</code>
		 * operation is performed.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * // Toggle the show property of every billboard in the collection
		 * var len = billboards.length;
		 * for (var i = 0; i < len; ++i) {
		 *   var b = billboards.get(i);
		 *   b.show = !b.show;
		 * }
		 * @see BillboardCollection#length
		 */
		get(index: number): Billboard;

		/**
		 * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
		 * get the draw commands needed to render this primitive.
		 * <p>
		 * Do not call this function directly.  This is documented just to
		 * list the exceptions that may be propagated when the scene is rendered:
		 * </p>
		 * @exception {RuntimeError} image with id must be in the atlas.
		 */
		update(): void;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <br /><br />
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
		 * @see BillboardCollection#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
		 * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
		 * <br /><br />
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * billboards = billboards && billboards.destroy();
		 * @see BillboardCollection#isDestroyed
		 */
		destroy(): void;

	}

	/**
	 * Provides tiled imagery using the Bing Maps Imagery REST API.
	 * @alias BingMapsImageryProvider
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Resource|String} options.url The url of the Bing Maps server hosting the imagery.
	 * @param {String} [options.key] The Bing Maps key for your application, which can be
	 *        created at {@link https://www.bingmapsportal.com/}.
	 *        If this parameter is not provided, {@link BingMapsApi.defaultKey} is used, which is undefined by default.
	 * @param {String} [options.tileProtocol] The protocol to use when loading tiles, e.g. 'http:' or 'https:'.
	 *        By default, tiles are loaded using the same protocol as the page.
	 * @param {BingMapsStyle} [options.mapStyle=BingMapsStyle.AERIAL] The type of Bing Maps imagery to load.
	 * @param {String} [options.culture=''] The culture to use when requesting Bing Maps imagery. Not
	 *        all cultures are supported. See {@link http://msdn.microsoft.com/en-us/library/hh441729.aspx}
	 *        for information on the supported cultures.
	 * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If not specified, the WGS84 ellipsoid is used.
	 * @param {TileDiscardPolicy} [options.tileDiscardPolicy] The policy that determines if a tile
	 *        is invalid and should be discarded.  If this value is not specified, a default
	 *        {@link DiscardMissingTileImagePolicy} is used which requests
	 *        tile 0,0 at the maximum tile level and checks pixels (0,0), (120,140), (130,160),
	 *        (200,50), and (200,200).  If all of these pixels are transparent, the discard check is
	 *        disabled and no tiles are discarded.  If any of them have a non-transparent color, any
	 *        tile that has the same values in these pixel locations is discarded.  The end result of
	 *        these defaults should be correct tile discarding for a standard Bing Maps server.  To ensure
	 *        that no tiles are discarded, construct and pass a {@link NeverTileDiscardPolicy} for this
	 *        parameter.
	 * @see ArcGisMapServerImageryProvider
	 * @see GoogleEarthEnterpriseMapsProvider
	 * @see createOpenStreetMapImageryProvider
	 * @see SingleTileImageryProvider
	 * @see createTileMapServiceImageryProvider
	 * @see WebMapServiceImageryProvider
	 * @see WebMapTileServiceImageryProvider
	 * @see UrlTemplateImageryProvider
	 * @example
	 * var bing = new Cesium.BingMapsImageryProvider({
	 *     url : 'https://dev.virtualearth.net',
	 *     key : 'get-yours-at-https://www.bingmapsportal.com/',
	 *     mapStyle : Cesium.BingMapsStyle.AERIAL
	 * });
	 * @see {@link http://msdn.microsoft.com/en-us/library/ff701713.aspx|Bing Maps REST Services}
	 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
	 */
	class BingMapsImageryProvider {
		constructor(options: {
			url: Resource | string;
			key?: string;
			tileProtocol?: string;
			mapStyle?: any;
			culture?: string;
			ellipsoid?: Ellipsoid;
			tileDiscardPolicy?: TileDiscardPolicy;
		});

		/**
		 * The default {@link ImageryLayer#gamma} to use for imagery layers created for this provider.
		 * Changing this value after creating an {@link ImageryLayer} for this provider will have
		 * no effect.  Instead, set the layer's {@link ImageryLayer#gamma} property.
		 * @type {Number}
		 * @default 1.0
		 */
		defaultGamma: number;

		/**
		 * Gets the name of the BingMaps server url hosting the imagery.
		 * @memberof BingMapsImageryProvider.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly url: string;

		/**
		 * Gets the proxy used by this provider.
		 * @memberof BingMapsImageryProvider.prototype
		 * @type {Proxy}
		 * @readonly
		 */
		readonly proxy: Proxy;

		/**
		 * Gets the Bing Maps key.
		 * @memberof BingMapsImageryProvider.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly key: string;

		/**
		 * Gets the type of Bing Maps imagery to load.
		 * @memberof BingMapsImageryProvider.prototype
		 * @type {BingMapsStyle}
		 * @readonly
		 */
		readonly mapStyle: any;

		/**
		 * The culture to use when requesting Bing Maps imagery. Not
		 * all cultures are supported. See {@link http://msdn.microsoft.com/en-us/library/hh441729.aspx}
		 * for information on the supported cultures.
		 * @memberof BingMapsImageryProvider.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly culture: string;

		/**
		 * Gets the width of each tile, in pixels. This function should
		 * not be called before {@link BingMapsImageryProvider#ready} returns true.
		 * @memberof BingMapsImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly tileWidth: number;

		/**
		 * Gets the height of each tile, in pixels.  This function should
		 * not be called before {@link BingMapsImageryProvider#ready} returns true.
		 * @memberof BingMapsImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly tileHeight: number;

		/**
		 * Gets the maximum level-of-detail that can be requested.  This function should
		 * not be called before {@link BingMapsImageryProvider#ready} returns true.
		 * @memberof BingMapsImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly maximumLevel: number;

		/**
		 * Gets the minimum level-of-detail that can be requested.  This function should
		 * not be called before {@link BingMapsImageryProvider#ready} returns true.
		 * @memberof BingMapsImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly minimumLevel: number;

		/**
		 * Gets the tiling scheme used by this provider.  This function should
		 * not be called before {@link BingMapsImageryProvider#ready} returns true.
		 * @memberof BingMapsImageryProvider.prototype
		 * @type {TilingScheme}
		 * @readonly
		 */
		readonly tilingScheme: TilingScheme;

		/**
		 * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should
		 * not be called before {@link BingMapsImageryProvider#ready} returns true.
		 * @memberof BingMapsImageryProvider.prototype
		 * @type {Rectangle}
		 * @readonly
		 */
		readonly rectangle: Rectangle;

		/**
		 * Gets the tile discard policy.  If not undefined, the discard policy is responsible
		 * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
		 * returns undefined, no tiles are filtered.  This function should
		 * not be called before {@link BingMapsImageryProvider#ready} returns true.
		 * @memberof BingMapsImageryProvider.prototype
		 * @type {TileDiscardPolicy}
		 * @readonly
		 */
		readonly tileDiscardPolicy: TileDiscardPolicy;

		/**
		 * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
		 * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
		 * are passed an instance of {@link TileProviderError}.
		 * @memberof BingMapsImageryProvider.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly errorEvent: Event;

		/**
		 * Gets a value indicating whether or not the provider is ready for use.
		 * @memberof BingMapsImageryProvider.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly ready: boolean;

		/**
		 * Gets a promise that resolves to true when the provider is ready for use.
		 * @memberof BingMapsImageryProvider.prototype
		 * @type {Promise.<Boolean>}
		 * @readonly
		 */
		readonly readyPromise: any;

		/**
		 * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
		 * the source of the imagery.  This function should not be called before {@link BingMapsImageryProvider#ready} returns true.
		 * @memberof BingMapsImageryProvider.prototype
		 * @type {Credit}
		 * @readonly
		 */
		readonly credit: Credit;

		/**
		 * Gets a value indicating whether or not the images provided by this imagery provider
		 * include an alpha channel.  If this property is false, an alpha channel, if present, will
		 * be ignored.  If this property is true, any images without an alpha channel will be treated
		 * as if their alpha is 1.0 everywhere.  Setting this property to false reduces memory usage
		 * and texture upload time.
		 * @memberof BingMapsImageryProvider.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly hasAlphaChannel: boolean;

		/**
		 * Gets the credits to be displayed when a given tile is displayed.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level;
		 * @returns {Credit[]} The credits to be displayed when the tile is displayed.
		 * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.
		 */
		getTileCredits(x: number, y: number, level: number): (Credit)[];

		/**
		 * Requests the image for a given tile.  This function should
		 * not be called before {@link BingMapsImageryProvider#ready} returns true.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level.
		 * @param {Request} [request] The request object. Intended for internal use only.
		 * @returns {Promise.<Image|Canvas>|undefined} A promise for the image that will resolve when the image is available, or
		 *          undefined if there are too many active requests to the server, and the request
		 *          should be retried later.  The resolved image may be either an
		 *          Image or a Canvas DOM object.
		 * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.
		 */
		requestImage(x: number, y: number, level: number, request?: Request): any | any | undefined;

		/**
		 * Picking features is not currently supported by this imagery provider, so this function simply returns
		 * undefined.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level.
		 * @param {Number} longitude The longitude at which to pick features.
		 * @param {Number} latitude  The latitude at which to pick features.
		 * @return {Promise.<ImageryLayerFeatureInfo[]>|undefined} A promise for the picked features that will resolve when the asynchronous
		 *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}
		 *                   instances.  The array may be empty if no features are found at the given location.
		 *                   It may also be undefined if picking is not supported.
		 */
		pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): any | undefined;

		/**
		 * Converts a tiles (x, y, level) position into a quadkey used to request an image
		 * from a Bing Maps server.
		 * @param {Number} x The tile's x coordinate.
		 * @param {Number} y The tile's y coordinate.
		 * @param {Number} level The tile's zoom level.
		 * @see {@link http://msdn.microsoft.com/en-us/library/bb259689.aspx|Bing Maps Tile System}
		 * @see BingMapsImageryProvider#quadKeyToTileXY
		 */
		static tileXYToQuadKey(x: number, y: number, level: number): void;

		/**
		 * Converts a tile's quadkey used to request an image from a Bing Maps server into the
		 * (x, y, level) position.
		 * @param {String} quadkey The tile's quad key
		 * @see {@link http://msdn.microsoft.com/en-us/library/bb259689.aspx|Bing Maps Tile System}
		 * @see BingMapsImageryProvider#tileXYToQuadKey
		 */
		static quadKeyToTileXY(quadkey: string): void;

		/**
		 * Gets or sets the URL to the Bing logo for display in the credit.
		 * @memberof BingMapsImageryProvider
		 * @type {String}
		 */
		static logoUrl: string;

	}

	/**
	 * Determines how opaque and translucent parts of billboards, points, and labels are blended with the scene.
	 * @exports BlendOption
	 */
	namespace BlendOption {
		/**
		 * The billboards, points, or labels in the collection are completely opaque.
		 * @type {Number}
		 * @constant
		 */
		const OPAQUE: number;

		/**
		 * The billboards, points, or labels in the collection are completely translucent.
		 * @type {Number}
		 * @constant
		 */
		const TRANSLUCENT: number;

		/**
		 * The billboards, points, or labels in the collection are both opaque and translucent.
		 * @type {Number}
		 * @constant
		 */
		const OPAQUE_AND_TRANSLUCENT: number;

	}

	/**
	 * A ParticleEmitter that emits particles within a box.
	 * Particles will be positioned randomly within the box and have initial velocities emanating from the center of the box.
	 * @alias BoxEmitter
	 * @constructor
	 * @param {Cartesian3} dimensions The width, height and depth dimensions of the box.
	 */
	class BoxEmitter {
		constructor(dimensions: Cartesian3);

		/**
		 * The width, height and depth dimensions of the box in meters.
		 * @memberof BoxEmitter.prototype
		 * @type {Cartesian3}
		 * @default new Cartesian3(1.0, 1.0, 1.0)
		 */
		dimensions: Cartesian3;

	}

	/**
	 * The camera is defined by a position, orientation, and view frustum.
	 * <br /><br />
	 * The orientation forms an orthonormal basis with a view, up and right = view x up unit vectors.
	 * <br /><br />
	 * The viewing frustum is defined by 6 planes.
	 * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components
	 * define the unit vector normal to the plane, and the w component is the distance of the
	 * plane from the origin/camera position.
	 * @alias Camera
	 * @constructor
	 * @param {Scene} scene The scene.
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Camera.html|Cesium Sandcastle Camera Demo}
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Camera%20Tutorial.html">Sandcastle Example</a> from the <a href="https://cesiumjs.org/2013/02/13/Cesium-Camera-Tutorial/|Camera Tutorial}
	 * @example
	 * // Create a camera looking down the negative z-axis, positioned at the origin,
	 * // with a field of view of 60 degrees, and 1:1 aspect ratio.
	 * var camera = new Cesium.Camera(scene);
	 * camera.position = new Cesium.Cartesian3();
	 * camera.direction = Cesium.Cartesian3.negate(Cesium.Cartesian3.UNIT_Z, new Cesium.Cartesian3());
	 * camera.up = Cesium.Cartesian3.clone(Cesium.Cartesian3.UNIT_Y);
	 * camera.frustum.fov = Cesium.Math.PI_OVER_THREE;
	 * camera.frustum.near = 1.0;
	 * camera.frustum.far = 2.0;
	 */
	class EngineCamera {
		constructor(scene: Scene);

		/**
		 * The position of the camera.
		 * @type {Cartesian3}
		 */
		position: Cartesian3;

		/**
		 * The view direction of the camera.
		 * @type {Cartesian3}
		 */
		direction: Cartesian3;

		/**
		 * The up direction of the camera.
		 * @type {Cartesian3}
		 */
		up: Cartesian3;

		/**
		 * The right direction of the camera.
		 * @type {Cartesian3}
		 */
		right: Cartesian3;

		/**
		 * The region of space in view.
		 * @type {Frustum}
		 * @default PerspectiveFrustum()
		 * @see PerspectiveFrustum
		 * @see PerspectiveOffCenterFrustum
		 * @see OrthographicFrustum
		 */
		frustum: any;

		/**
		 * The default amount to move the camera when an argument is not
		 * provided to the move methods.
		 * @type {Number}
		 * @default 100000.0;
		 */
		defaultMoveAmount: number;

		/**
		 * The default amount to rotate the camera when an argument is not
		 * provided to the look methods.
		 * @type {Number}
		 * @default Math.PI / 60.0
		 */
		defaultLookAmount: number;

		/**
		 * The default amount to rotate the camera when an argument is not
		 * provided to the rotate methods.
		 * @type {Number}
		 * @default Math.PI / 3600.0
		 */
		defaultRotateAmount: number;

		/**
		 * The default amount to move the camera when an argument is not
		 * provided to the zoom methods.
		 * @type {Number}
		 * @default 100000.0;
		 */
		defaultZoomAmount: number;

		/**
		 * If set, the camera will not be able to rotate past this axis in either direction.
		 * @type {Cartesian3}
		 * @default undefined
		 */
		constrainedAxis: Cartesian3;

		/**
		 * The factor multiplied by the the map size used to determine where to clamp the camera position
		 * when zooming out from the surface. The default is 1.5. Only valid for 2D and the map is rotatable.
		 * @type {Number}
		 * @default 1.5
		 */
		maximumZoomFactor: number;

		/**
		 * The amount the camera has to change before the <code>changed</code> event is raised. The value is a percentage in the [0, 1] range.
		 * @type {number}
		 * @default 0.5
		 */
		percentageChanged: number;

		/**
		 * The default rectangle the camera will view on creation.
		 * @type Rectangle
		 */
		static DEFAULT_VIEW_RECTANGLE: Rectangle;

		/**
		 * A scalar to multiply to the camera position and add it back after setting the camera to view the rectangle.
		 * A value of zero means the camera will view the entire {@link Camera#DEFAULT_VIEW_RECTANGLE}, a value greater than zero
		 * will move it further away from the extent, and a value less than zero will move it close to the extent.
		 * @type Number
		 */
		static DEFAULT_VIEW_FACTOR: number;

		/**
		 * The default heading/pitch/range that is used when the camera flies to a location that contains a bounding sphere.
		 * @type HeadingPitchRange
		 */
		static DEFAULT_OFFSET: HeadingPitchRange;

		/**
		 * Gets the camera's reference frame. The inverse of this transformation is appended to the view matrix.
		 * @memberof Camera.prototype
		 * @type {Matrix4}
		 * @readonly
		 * @default {@link Matrix4.IDENTITY}
		 */
		readonly transform: Matrix4;

		/**
		 * Gets the inverse camera transform.
		 * @memberof Camera.prototype
		 * @type {Matrix4}
		 * @readonly
		 * @default {@link Matrix4.IDENTITY}
		 */
		readonly inverseTransform: Matrix4;

		/**
		 * Gets the view matrix.
		 * @memberof Camera.prototype
		 * @type {Matrix4}
		 * @readonly
		 * @see Camera#inverseViewMatrix
		 */
		readonly viewMatrix: Matrix4;

		/**
		 * Gets the inverse view matrix.
		 * @memberof Camera.prototype
		 * @type {Matrix4}
		 * @readonly
		 * @see Camera#viewMatrix
		 */
		readonly inverseViewMatrix: Matrix4;

		/**
		 * Gets the {@link Cartographic} position of the camera, with longitude and latitude
		 * expressed in radians and height in meters.  In 2D and Columbus View, it is possible
		 * for the returned longitude and latitude to be outside the range of valid longitudes
		 * and latitudes when the camera is outside the map.
		 * @memberof Camera.prototype
		 * @type {Cartographic}
		 * @readonly
		 */
		readonly positionCartographic: Cartographic;

		/**
		 * Gets the position of the camera in world coordinates.
		 * @memberof Camera.prototype
		 * @type {Cartesian3}
		 * @readonly
		 */
		readonly positionWC: Cartesian3;

		/**
		 * Gets the view direction of the camera in world coordinates.
		 * @memberof Camera.prototype
		 * @type {Cartesian3}
		 * @readonly
		 */
		readonly directionWC: Cartesian3;

		/**
		 * Gets the up direction of the camera in world coordinates.
		 * @memberof Camera.prototype
		 * @type {Cartesian3}
		 * @readonly
		 */
		readonly upWC: Cartesian3;

		/**
		 * Gets the right direction of the camera in world coordinates.
		 * @memberof Camera.prototype
		 * @type {Cartesian3}
		 * @readonly
		 */
		readonly rightWC: Cartesian3;

		/**
		 * Gets the camera heading in radians.
		 * @memberof Camera.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly heading: number;

		/**
		 * Gets the camera pitch in radians.
		 * @memberof Camera.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly pitch: number;

		/**
		 * Gets the camera roll in radians.
		 * @memberof Camera.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly roll: number;

		/**
		 * Gets the event that will be raised at when the camera starts to move.
		 * @memberof Camera.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly moveStart: Event;

		/**
		 * Gets the event that will be raised when the camera has stopped moving.
		 * @memberof Camera.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly moveEnd: Event;

		/**
		 * Gets the event that will be raised when the camera has changed by <code>percentageChanged</code>.
		 * @memberof Camera.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly changed: Event;

		/**
		 * Sets the camera position, orientation and transform.
		 * @param {Object} options Object with the following properties:
		 * @param {Cartesian3|Rectangle} [options.destination] The final position of the camera in WGS84 (world) coordinates or a rectangle that would be visible from a top-down view.
		 * @param {Object} [options.orientation] An object that contains either direction and up properties or heading, pitch and roll properties. By default, the direction will point
		 * towards the center of the frame in 3D and in the negative z direction in Columbus view. The up direction will point towards local north in 3D and in the positive
		 * y direction in Columbus view. Orientation is not used in 2D when in infinite scrolling mode.
		 * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame of the camera.
		 * @example
		 * // 1. Set position with a top-down view
		 * viewer.camera.setView({
		 *     destination : Cesium.Cartesian3.fromDegrees(-117.16, 32.71, 15000.0)
		 * });
		 * // 2 Set view with heading, pitch and roll
		 * viewer.camera.setView({
		 *     destination : cartesianPosition,
		 *     orientation: {
		 *         heading : Cesium.Math.toRadians(90.0), // east, default value is 0.0 (north)
		 *         pitch : Cesium.Math.toRadians(-90),    // default value (looking down)
		 *         roll : 0.0                             // default value
		 *     }
		 * });
		 * // 3. Change heading, pitch and roll with the camera position remaining the same.
		 * viewer.camera.setView({
		 *     orientation: {
		 *         heading : Cesium.Math.toRadians(90.0), // east, default value is 0.0 (north)
		 *         pitch : Cesium.Math.toRadians(-90),    // default value (looking down)
		 *         roll : 0.0                             // default value
		 *     }
		 * });
		 * // 4. View rectangle with a top-down view
		 * viewer.camera.setView({
		 *     destination : Cesium.Rectangle.fromDegrees(west, south, east, north)
		 * });
		 * // 5. Set position with an orientation using unit vectors.
		 * viewer.camera.setView({
		 *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),
		 *     orientation : {
		 *         direction : new Cesium.Cartesian3(-0.04231243104240401, -0.20123236049443421, -0.97862924300734),
		 *         up : new Cesium.Cartesian3(-0.47934589305293746, -0.8553216253114552, 0.1966022179118339)
		 *     }
		 * });
		 */
		setView(options: {
			destination?: Cartesian3 | Rectangle;
			orientation?: any;
			endTransform?: Matrix4;
		}): void;

		/**
		 * Fly the camera to the home view.  Use {@link Camera#.DEFAULT_VIEW_RECTANGLE} to set
		 * the default view for the 3D scene.  The home view for 2D and columbus view shows the
		 * entire map.
		 * @param {Number} [duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight. See {@link Camera#flyTo}
		 */
		flyHome(duration?: number): void;

		/**
		 * Transform a vector or point from world coordinates to the camera's reference frame.
		 * @param {Cartesian4} cartesian The vector or point to transform.
		 * @param {Cartesian4} [result] The object onto which to store the result.
		 * @returns {Cartesian4} The transformed vector or point.
		 */
		worldToCameraCoordinates(cartesian: Cartesian4, result?: Cartesian4): Cartesian4;

		/**
		 * Transform a point from world coordinates to the camera's reference frame.
		 * @param {Cartesian3} cartesian The point to transform.
		 * @param {Cartesian3} [result] The object onto which to store the result.
		 * @returns {Cartesian3} The transformed point.
		 */
		worldToCameraCoordinatesPoint(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;

		/**
		 * Transform a vector from world coordinates to the camera's reference frame.
		 * @param {Cartesian3} cartesian The vector to transform.
		 * @param {Cartesian3} [result] The object onto which to store the result.
		 * @returns {Cartesian3} The transformed vector.
		 */
		worldToCameraCoordinatesVector(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;

		/**
		 * Transform a vector or point from the camera's reference frame to world coordinates.
		 * @param {Cartesian4} cartesian The vector or point to transform.
		 * @param {Cartesian4} [result] The object onto which to store the result.
		 * @returns {Cartesian4} The transformed vector or point.
		 */
		cameraToWorldCoordinates(cartesian: Cartesian4, result?: Cartesian4): Cartesian4;

		/**
		 * Transform a point from the camera's reference frame to world coordinates.
		 * @param {Cartesian3} cartesian The point to transform.
		 * @param {Cartesian3} [result] The object onto which to store the result.
		 * @returns {Cartesian3} The transformed point.
		 */
		cameraToWorldCoordinatesPoint(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;

		/**
		 * Transform a vector from the camera's reference frame to world coordinates.
		 * @param {Cartesian3} cartesian The vector to transform.
		 * @param {Cartesian3} [result] The object onto which to store the result.
		 * @returns {Cartesian3} The transformed vector.
		 */
		cameraToWorldCoordinatesVector(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;

		/**
		 * Translates the camera's position by <code>amount</code> along <code>direction</code>.
		 * @param {Cartesian3} direction The direction to move.
		 * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
		 * @see Camera#moveBackward
		 * @see Camera#moveForward
		 * @see Camera#moveLeft
		 * @see Camera#moveRight
		 * @see Camera#moveUp
		 * @see Camera#moveDown
		 */
		move(direction: Cartesian3, amount?: number): void;

		/**
		 * Translates the camera's position by <code>amount</code> along the camera's view vector.
		 * When in 2D mode, this will zoom in the camera instead of translating the camera's position.
		 * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
		 * @see Camera#moveBackward
		 */
		moveForward(amount?: number): void;

		/**
		 * Translates the camera's position by <code>amount</code> along the opposite direction
		 * of the camera's view vector.
		 * When in 2D mode, this will zoom out the camera instead of translating the camera's position.
		 * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
		 * @see Camera#moveForward
		 */
		moveBackward(amount?: number): void;

		/**
		 * Translates the camera's position by <code>amount</code> along the camera's up vector.
		 * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
		 * @see Camera#moveDown
		 */
		moveUp(amount?: number): void;

		/**
		 * Translates the camera's position by <code>amount</code> along the opposite direction
		 * of the camera's up vector.
		 * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
		 * @see Camera#moveUp
		 */
		moveDown(amount?: number): void;

		/**
		 * Translates the camera's position by <code>amount</code> along the camera's right vector.
		 * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
		 * @see Camera#moveLeft
		 */
		moveRight(amount?: number): void;

		/**
		 * Translates the camera's position by <code>amount</code> along the opposite direction
		 * of the camera's right vector.
		 * @param {Number} [amount] The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
		 * @see Camera#moveRight
		 */
		moveLeft(amount?: number): void;

		/**
		 * Rotates the camera around its up vector by amount, in radians, in the opposite direction
		 * of its right vector if not in 2D mode.
		 * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
		 * @see Camera#lookRight
		 */
		lookLeft(amount?: number): void;

		/**
		 * Rotates the camera around its up vector by amount, in radians, in the direction
		 * of its right vector if not in 2D mode.
		 * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
		 * @see Camera#lookLeft
		 */
		lookRight(amount?: number): void;

		/**
		 * Rotates the camera around its right vector by amount, in radians, in the direction
		 * of its up vector if not in 2D mode.
		 * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
		 * @see Camera#lookDown
		 */
		lookUp(amount?: number): void;

		/**
		 * Rotates the camera around its right vector by amount, in radians, in the opposite direction
		 * of its up vector if not in 2D mode.
		 * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
		 * @see Camera#lookUp
		 */
		lookDown(amount?: number): void;

		/**
		 * Rotate each of the camera's orientation vectors around <code>axis</code> by <code>angle</code>
		 * @param {Cartesian3} axis The axis to rotate around.
		 * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
		 * @see Camera#lookUp
		 * @see Camera#lookDown
		 * @see Camera#lookLeft
		 * @see Camera#lookRight
		 */
		look(axis: Cartesian3, angle?: number): void;

		/**
		 * Rotate the camera counter-clockwise around its direction vector by amount, in radians.
		 * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
		 * @see Camera#twistRight
		 */
		twistLeft(amount?: number): void;

		/**
		 * Rotate the camera clockwise around its direction vector by amount, in radians.
		 * @param {Number} [amount] The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
		 * @see Camera#twistLeft
		 */
		twistRight(amount?: number): void;

		/**
		 * Rotates the camera around <code>axis</code> by <code>angle</code>. The distance
		 * of the camera's position to the center of the camera's reference frame remains the same.
		 * @param {Cartesian3} axis The axis to rotate around given in world coordinates.
		 * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.
		 * @see Camera#rotateUp
		 * @see Camera#rotateDown
		 * @see Camera#rotateLeft
		 * @see Camera#rotateRight
		 */
		rotate(axis: Cartesian3, angle?: number): void;

		/**
		 * Rotates the camera around the center of the camera's reference frame by angle downwards.
		 * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.
		 * @see Camera#rotateUp
		 * @see Camera#rotate
		 */
		rotateDown(angle?: number): void;

		/**
		 * Rotates the camera around the center of the camera's reference frame by angle upwards.
		 * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.
		 * @see Camera#rotateDown
		 * @see Camera#rotate
		 */
		rotateUp(angle?: number): void;

		/**
		 * Rotates the camera around the center of the camera's reference frame by angle to the right.
		 * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.
		 * @see Camera#rotateLeft
		 * @see Camera#rotate
		 */
		rotateRight(angle?: number): void;

		/**
		 * Rotates the camera around the center of the camera's reference frame by angle to the left.
		 * @param {Number} [angle] The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.
		 * @see Camera#rotateRight
		 * @see Camera#rotate
		 */
		rotateLeft(angle?: number): void;

		/**
		 * Zooms <code>amount</code> along the camera's view vector.
		 * @param {Number} [amount] The amount to move. Defaults to <code>defaultZoomAmount</code>.
		 * @see Camera#zoomOut
		 */
		zoomIn(amount?: number): void;

		/**
		 * Zooms <code>amount</code> along the opposite direction of
		 * the camera's view vector.
		 * @param {Number} [amount] The amount to move. Defaults to <code>defaultZoomAmount</code>.
		 * @see Camera#zoomIn
		 */
		zoomOut(amount?: number): void;

		/**
		 * Gets the magnitude of the camera position. In 3D, this is the vector magnitude. In 2D and
		 * Columbus view, this is the distance to the map.
		 * @returns {Number} The magnitude of the position.
		 */
		getMagnitude(): number;

		/**
		 * Sets the camera position and orientation using a target and offset. The target must be given in
		 * world coordinates. The offset can be either a cartesian or heading/pitch/range in the local east-north-up reference frame centered at the target.
		 * If the offset is a cartesian, then it is an offset from the center of the reference frame defined by the transformation matrix. If the offset
		 * is heading/pitch/range, then the heading and the pitch angles are defined in the reference frame defined by the transformation matrix.
		 * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch
		 * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center.
		 * In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the
		 * target will be the magnitude of the offset. The heading will be determined from the offset. If the heading cannot be
		 * determined from the offset, the heading will be north.
		 * @param {Cartesian3} target The target position in world coordinates.
		 * @param {Cartesian3|HeadingPitchRange} offset The offset from the target in the local east-north-up reference frame centered at the target.
		 * @exception {DeveloperError} lookAt is not supported while morphing.
		 * @example
		 * // 1. Using a cartesian offset
		 * var center = Cesium.Cartesian3.fromDegrees(-98.0, 40.0);
		 * viewer.camera.lookAt(center, new Cesium.Cartesian3(0.0, -4790000.0, 3930000.0));
		 * // 2. Using a HeadingPitchRange offset
		 * var center = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);
		 * var heading = Cesium.Math.toRadians(50.0);
		 * var pitch = Cesium.Math.toRadians(-20.0);
		 * var range = 5000.0;
		 * viewer.camera.lookAt(center, new Cesium.HeadingPitchRange(heading, pitch, range));
		 */
		lookAt(target: Cartesian3, offset: Cartesian3 | HeadingPitchRange): void;

		/**
		 * Sets the camera position and orientation using a target and transformation matrix. The offset can be either a cartesian or heading/pitch/range.
		 * If the offset is a cartesian, then it is an offset from the center of the reference frame defined by the transformation matrix. If the offset
		 * is heading/pitch/range, then the heading and the pitch angles are defined in the reference frame defined by the transformation matrix.
		 * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch
		 * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center.
		 * In 2D, there must be a top down view. The camera will be placed above the center of the reference frame. The height above the
		 * target will be the magnitude of the offset. The heading will be determined from the offset. If the heading cannot be
		 * determined from the offset, the heading will be north.
		 * @param {Matrix4} transform The transformation matrix defining the reference frame.
		 * @param {Cartesian3|HeadingPitchRange} [offset] The offset from the target in a reference frame centered at the target.
		 * @exception {DeveloperError} lookAtTransform is not supported while morphing.
		 * @example
		 * // 1. Using a cartesian offset
		 * var transform = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(-98.0, 40.0));
		 * viewer.camera.lookAtTransform(transform, new Cesium.Cartesian3(0.0, -4790000.0, 3930000.0));
		 * // 2. Using a HeadingPitchRange offset
		 * var transform = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(-72.0, 40.0));
		 * var heading = Cesium.Math.toRadians(50.0);
		 * var pitch = Cesium.Math.toRadians(-20.0);
		 * var range = 5000.0;
		 * viewer.camera.lookAtTransform(transform, new Cesium.HeadingPitchRange(heading, pitch, range));
		 */
		lookAtTransform(transform: Matrix4, offset?: Cartesian3 | HeadingPitchRange): void;

		/**
		 * Get the camera position needed to view a rectangle on an ellipsoid or map
		 * @param {Rectangle} rectangle The rectangle to view.
		 * @param {Cartesian3} [result] The camera position needed to view the rectangle
		 * @returns {Cartesian3} The camera position needed to view the rectangle
		 */
		getRectangleCameraCoordinates(rectangle: Rectangle, result?: Cartesian3): Cartesian3;

		/**
		 * Pick an ellipsoid or map.
		 * @param {Cartesian2} windowPosition The x and y coordinates of a pixel.
		 * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid to pick.
		 * @param {Cartesian3} [result] The object onto which to store the result.
		 * @returns {Cartesian3} If the ellipsoid or map was picked, returns the point on the surface of the ellipsoid or map
		 * in world coordinates. If the ellipsoid or map was not picked, returns undefined.
		 */
		pickEllipsoid(windowPosition: Cartesian2, ellipsoid?: Ellipsoid, result?: Cartesian3): Cartesian3;

		/**
		 * Create a ray from the camera position through the pixel at <code>windowPosition</code>
		 * in world coordinates.
		 * @param {Cartesian2} windowPosition The x and y coordinates of a pixel.
		 * @param {Ray} [result] The object onto which to store the result.
		 * @returns {Ray} Returns the {@link Cartesian3} position and direction of the ray.
		 */
		getPickRay(windowPosition: Cartesian2, result?: Ray): Ray;

		/**
		 * Return the distance from the camera to the front of the bounding sphere.
		 * @param {BoundingSphere} boundingSphere The bounding sphere in world coordinates.
		 * @returns {Number} The distance to the bounding sphere.
		 */
		distanceToBoundingSphere(boundingSphere: BoundingSphere): number;

		/**
		 * Return the pixel size in meters.
		 * @param {BoundingSphere} boundingSphere The bounding sphere in world coordinates.
		 * @param {Number} drawingBufferWidth The drawing buffer width.
		 * @param {Number} drawingBufferHeight The drawing buffer height.
		 * @returns {Number} The pixel size in meters.
		 */
		getPixelSize(boundingSphere: BoundingSphere, drawingBufferWidth: number, drawingBufferHeight: number): number;

		/**
		 * Cancels the current camera flight if one is in progress.
		 * The camera is left at it's current location.
		 */
		cancelFlight(): void;

		/**
		 * Flies the camera from its current position to a new position.
		 * @param {Object} options Object with the following properties:
		 * @param {Cartesian3|Rectangle} options.destination The final position of the camera in WGS84 (world) coordinates or a rectangle that would be visible from a top-down view.
		 * @param {Object} [options.orientation] An object that contains either direction and up properties or heading, pith and roll properties. By default, the direction will point
		 * towards the center of the frame in 3D and in the negative z direction in Columbus view. The up direction will point towards local north in 3D and in the positive
		 * y direction in Columbus view.  Orientation is not used in 2D when in infinite scrolling mode.
		 * @param {Number} [options.duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight.
		 * @param {Camera~Function} [options.complete] The function to execute when the flight is complete.
		 * @param {Camera~Function} [options.cancel] The function to execute if the flight is cancelled.
		 * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame the camera will be in when the flight is completed.
		 * @param {Number} [options.maximumHeight] The maximum height at the peak of the flight.
		 * @param {Number} [options.pitchAdjustHeight] If camera flyes higher than that value, adjust pitch duiring the flight to look down, and keep Earth in viewport.
		 * @param {Number} [options.flyOverLongitude] There are always two ways between 2 points on globe. This option force camera to choose fight direction to fly over that longitude.
		 * @param {Number} [options.flyOverLongitudeWeight] Fly over the lon specifyed via flyOverLongitude only if that way is not longer than short way times flyOverLongitudeWeight.
		 * @param {EasingFunction|Function} [options.easingFunction] Controls how the time is interpolated over the duration of the flight.
		 * @exception {DeveloperError} If either direction or up is given, then both are required.
		 * @example
		 * // 1. Fly to a position with a top-down view
		 * viewer.camera.flyTo({
		 *     destination : Cesium.Cartesian3.fromDegrees(-117.16, 32.71, 15000.0)
		 * });
		 * // 2. Fly to a Rectangle with a top-down view
		 * viewer.camera.flyTo({
		 *     destination : Cesium.Rectangle.fromDegrees(west, south, east, north)
		 * });
		 * // 3. Fly to a position with an orientation using unit vectors.
		 * viewer.camera.flyTo({
		 *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),
		 *     orientation : {
		 *         direction : new Cesium.Cartesian3(-0.04231243104240401, -0.20123236049443421, -0.97862924300734),
		 *         up : new Cesium.Cartesian3(-0.47934589305293746, -0.8553216253114552, 0.1966022179118339)
		 *     }
		 * });
		 * // 4. Fly to a position with an orientation using heading, pitch and roll.
		 * viewer.camera.flyTo({
		 *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),
		 *     orientation : {
		 *         heading : Cesium.Math.toRadians(175.0),
		 *         pitch : Cesium.Math.toRadians(-35.0),
		 *         roll : 0.0
		 *     }
		 * });
		 */
		flyTo(options: {
			destination: Cartesian3 | Rectangle;
			orientation?: any;
			duration?: number;
			complete?: Function;
			cancel?: Function;
			endTransform?: Matrix4;
			maximumHeight?: number;
			pitchAdjustHeight?: number;
			flyOverLongitude?: number;
			flyOverLongitudeWeight?: number;
			easingFunction?: any | Function;
		}): void;

		/**
		 * Sets the camera so that the current view contains the provided bounding sphere.
		 * <p>The offset is heading/pitch/range in the local east-north-up reference frame centered at the center of the bounding sphere.
		 * The heading and the pitch angles are defined in the local east-north-up reference frame.
		 * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch
		 * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center. If the range is
		 * zero, a range will be computed such that the whole bounding sphere is visible.</p>
		 * <p>In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the
		 * target will be the range. The heading will be determined from the offset. If the heading cannot be
		 * determined from the offset, the heading will be north.</p>
		 * @param {BoundingSphere} boundingSphere The bounding sphere to view, in world coordinates.
		 * @param {HeadingPitchRange} [offset] The offset from the target in the local east-north-up reference frame centered at the target.
		 * @exception {DeveloperError} viewBoundingSphere is not supported while morphing.
		 */
		viewBoundingSphere(boundingSphere: BoundingSphere, offset?: HeadingPitchRange): void;

		/**
		 * Flies the camera to a location where the current view contains the provided bounding sphere.
		 * <p> The offset is heading/pitch/range in the local east-north-up reference frame centered at the center of the bounding sphere.
		 * The heading and the pitch angles are defined in the local east-north-up reference frame.
		 * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch
		 * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center. If the range is
		 * zero, a range will be computed such that the whole bounding sphere is visible.</p>
		 * <p>In 2D and Columbus View, there must be a top down view. The camera will be placed above the target looking down. The height above the
		 * target will be the range. The heading will be aligned to local north.</p>
		 * @param {BoundingSphere} boundingSphere The bounding sphere to view, in world coordinates.
		 * @param {Object} [options] Object with the following properties:
		 * @param {Number} [options.duration] The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight.
		 * @param {HeadingPitchRange} [options.offset] The offset from the target in the local east-north-up reference frame centered at the target.
		 * @param {Camera~Function} [options.complete] The function to execute when the flight is complete.
		 * @param {Camera~Function} [options.cancel] The function to execute if the flight is cancelled.
		 * @param {Matrix4} [options.endTransform] Transform matrix representing the reference frame the camera will be in when the flight is completed.
		 * @param {Number} [options.maximumHeight] The maximum height at the peak of the flight.
		 * @param {Number} [options.pitchAdjustHeight] If camera flyes higher than that value, adjust pitch duiring the flight to look down, and keep Earth in viewport.
		 * @param {Number} [options.flyOverLongitude] There are always two ways between 2 points on globe. This option force camera to choose fight direction to fly over that longitude.
		 * @param {Number} [options.flyOverLongitudeWeight] Fly over the lon specifyed via flyOverLongitude only if that way is not longer than short way times flyOverLongitudeWeight.
		 * @param {EasingFunction|Function} [options.easingFunction] Controls how the time is interpolated over the duration of the flight.
		 */
		flyToBoundingSphere(boundingSphere: BoundingSphere, options?: {
			duration?: number;
			offset?: HeadingPitchRange;
			complete?: Function;
			cancel?: Function;
			endTransform?: Matrix4;
			maximumHeight?: number;
			pitchAdjustHeight?: number;
			flyOverLongitude?: number;
			flyOverLongitudeWeight?: number;
			easingFunction?: any | Function;
		}): void;

		/**
		 * Computes the approximate visible rectangle on the ellipsoid.
		 * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid that you want to know the visible region.
		 * @param {Rectangle} [result] The rectangle in which to store the result
		 * @returns {Rectangle|undefined} The visible rectangle or undefined if the ellipsoid isn't visible at all.
		 */
		computeViewRectangle(ellipsoid?: Ellipsoid, result?: Rectangle): Rectangle | undefined;

		/**
		 * Switches the frustum/projection to perspective.
		 * This function is a no-op in 2D which must always be orthographic.
		 */
		switchToPerspectiveFrustum(): void;

		/**
		 * Switches the frustum/projection to orthographic.
		 * This function is a no-op in 2D which will always be orthographic.
		 */
		switchToOrthographicFrustum(): void;


	}

	/**
	 * Aggregates input events. For example, suppose the following inputs are received between frames:
	 * left mouse button down, mouse move, mouse move, left mouse button up. These events will be aggregated into
	 * one event with a start and end position of the mouse.
	 * @alias CameraEventAggregator
	 * @constructor
	 * @param {Canvas} [canvas=document] The element to handle events for.
	 * @see ScreenSpaceEventHandler
	 */
	class CameraEventAggregator {
		constructor(canvas?: any);

		/**
		 * Gets the current mouse position.
		 * @memberof CameraEventAggregator.prototype
		 * @type {Cartesian2}
		 */
		currentMousePosition: Cartesian2;

		/**
		 * Gets whether any mouse button is down, a touch has started, or the wheel has been moved.
		 * @memberof CameraEventAggregator.prototype
		 * @type {Boolean}
		 */
		anyButtonDown: boolean;

		/**
		 * Gets if a mouse button down or touch has started and has been moved.
		 * @param {CameraEventType} type The camera event type.
		 * @param {KeyboardEventModifier} [modifier] The keyboard modifier.
		 * @returns {Boolean} Returns <code>true</code> if a mouse button down or touch has started and has been moved; otherwise, <code>false</code>
		 */
		isMoving(type: any, modifier?: any): boolean;

		/**
		 * Gets the aggregated start and end position of the current event.
		 * @param {CameraEventType} type The camera event type.
		 * @param {KeyboardEventModifier} [modifier] The keyboard modifier.
		 * @returns {Object} An object with two {@link Cartesian2} properties: <code>startPosition</code> and <code>endPosition</code>.
		 */
		getMovement(type: any, modifier?: any): any;

		/**
		 * Gets the start and end position of the last move event (not the aggregated event).
		 * @param {CameraEventType} type The camera event type.
		 * @param {KeyboardEventModifier} [modifier] The keyboard modifier.
		 * @returns {Object|undefined} An object with two {@link Cartesian2} properties: <code>startPosition</code> and <code>endPosition</code> or <code>undefined</code>.
		 */
		getLastMovement(type: any, modifier?: any): any | undefined;

		/**
		 * Gets whether the mouse button is down or a touch has started.
		 * @param {CameraEventType} type The camera event type.
		 * @param {KeyboardEventModifier} [modifier] The keyboard modifier.
		 * @returns {Boolean} Whether the mouse button is down or a touch has started.
		 */
		isButtonDown(type: any, modifier?: any): boolean;

		/**
		 * Gets the mouse position that started the aggregation.
		 * @param {CameraEventType} type The camera event type.
		 * @param {KeyboardEventModifier} [modifier] The keyboard modifier.
		 * @returns {Cartesian2} The mouse position.
		 */
		getStartMousePosition(type: any, modifier?: any): Cartesian2;

		/**
		 * Gets the time the button was pressed or the touch was started.
		 * @param {CameraEventType} type The camera event type.
		 * @param {KeyboardEventModifier} [modifier] The keyboard modifier.
		 * @returns {Date} The time the button was pressed or the touch was started.
		 */
		getButtonPressTime(type: any, modifier?: any): Date;

		/**
		 * Gets the time the button was released or the touch was ended.
		 * @param {CameraEventType} type The camera event type.
		 * @param {KeyboardEventModifier} [modifier] The keyboard modifier.
		 * @returns {Date} The time the button was released or the touch was ended.
		 */
		getButtonReleaseTime(type: any, modifier?: any): Date;

		/**
		 * Signals that all of the events have been handled and the aggregator should be reset to handle new events.
		 */
		reset(): void;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <br /><br />
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
		 * @see CameraEventAggregator#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Removes mouse listeners held by this object.
		 * <br /><br />
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * handler = handler && handler.destroy();
		 * @see CameraEventAggregator#isDestroyed
		 */
		destroy(): void;

	}

	/**
	 * A tile in a {@link Cesium3DTileset}.  When a tile is first created, its content is not loaded;
	 * the content is loaded on-demand when needed based on the view.
	 * <p>
	 * Do not construct this directly, instead access tiles through {@link Cesium3DTileset#tileVisible}.
	 * </p>
	 * @alias Cesium3DTile
	 * @constructor
	 */
	class Cesium3DTile {
		constructor();

		/**
		 * The local transform of this tile.
		 * @type {Matrix4}
		 */
		transform: Matrix4;

		/**
		 * The final computed transform of this tile.
		 * @type {Matrix4}
		 * @readonly
		 */
		readonly computedTransform: Matrix4;

		/**
		 * The error, in meters, introduced if this tile is rendered and its children are not.
		 * This is used to compute screen space error, i.e., the error measured in pixels.
		 * @type {Number}
		 * @readonly
		 */
		readonly geometricError: number;

		/**
		 * Gets the tile's children.
		 * @type {Cesium3DTile[]}
		 * @readonly
		 */
		readonly children: (Cesium3DTile)[];

		/**
		 * This tile's parent or <code>undefined</code> if this tile is the root.
		 * <p>
		 * When a tile's content points to an external tileset JSON file, the external tileset's
		 * root tile's parent is not <code>undefined</code>; instead, the parent references
		 * the tile (with its content pointing to an external tileset JSON file) as if the two tilesets were merged.
		 * </p>
		 * @type {Cesium3DTile}
		 * @readonly
		 */
		readonly parent: Cesium3DTile;

		/**
		 * The time in seconds after the tile's content is ready when the content expires and new content is requested.
		 * @type {Number}
		 */
		expireDuration: number;

		/**
		 * The date when the content expires and new content is requested.
		 * @type {JulianDate}
		 */
		expireDate: JulianDate;

		/**
		 * The tileset containing this tile.
		 * @memberof Cesium3DTile.prototype
		 * @type {Cesium3DTileset}
		 * @readonly
		 */
		readonly tileset: Cesium3DTileset;

		/**
		 * The tile's content.  This represents the actual tile's payload,
		 * not the content's metadata in the tileset JSON file.
		 * @memberof Cesium3DTile.prototype
		 * @type {Cesium3DTileContent}
		 * @readonly
		 */
		readonly content: Cesium3DTileContent;

		/**
		 * Get the bounding sphere derived from the tile's bounding volume.
		 * @memberof Cesium3DTile.prototype
		 * @type {BoundingSphere}
		 * @readonly
		 */
		readonly boundingSphere: BoundingSphere;

		/**
		 * Returns the <code>extras</code> property in the tileset JSON for this tile, which contains application specific metadata.
		 * Returns <code>undefined</code> if <code>extras</code> does not exist.
		 * @memberof Cesium3DTile.prototype
		 * @type {*}
		 * @readonly
		 * @see {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification#specifying-extensions-and-application-specific-extras|Extras in the 3D Tiles specification.}
		 */
		readonly extras: any;

	}

	/**
	 * Defines how per-feature colors set from the Cesium API or declarative styling blend with the source colors from
	 * the original feature, e.g. glTF material or per-point color in the tile.
	 * <p>
	 * When <code>REPLACE</code> or <code>MIX</code> are used and the source color is a glTF material, the technique must assign the
	 * <code>_3DTILESDIFFUSE</code> semantic to the diffuse color parameter. Otherwise only <code>HIGHLIGHT</code> is supported.
	 * </p>
	 * <p>
	 * A feature whose color evaluates to white (1.0, 1.0, 1.0) is always rendered without color blending, regardless of the
	 * tileset's color blend mode.
	 * </p>
	 * <pre><code>
	 * "techniques": {
	 *   "technique0": {
	 *     "parameters": {
	 *       "diffuse": {
	 *         "semantic": "_3DTILESDIFFUSE",
	 *         "type": 35666
	 *       }
	 *     }
	 *   }
	 * }
	 * </code></pre>
	 * @exports Cesium3DTileColorBlendMode
	 */
	namespace Cesium3DTileColorBlendMode {
		/**
		 * Multiplies the source color by the feature color.
		 * @type {Number}
		 * @constant
		 */
		const HIGHLIGHT: number;

		/**
		 * Replaces the source color with the feature color.
		 * @type {Number}
		 * @constant
		 */
		const REPLACE: number;

		/**
		 * Blends the source color and feature color together.
		 * @type {Number}
		 * @constant
		 */
		const MIX: number;

	}

	/**
	 * The content of a tile in a {@link Cesium3DTileset}.
	 * <p>
	 * Derived classes of this interface provide access to individual features in the tile.
	 * Access derived objects through {@link Cesium3DTile#content}.
	 * </p>
	 * <p>
	 * This type describes an interface and is not intended to be instantiated directly.
	 * </p>
	 * @alias Cesium3DTileContent
	 * @constructor
	 */
	class Cesium3DTileContent {
		constructor();

		/**
		 * Gets the number of features in the tile.
		 * @memberof Cesium3DTileContent.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly featuresLength: number;

		/**
		 * Gets the number of points in the tile.
		 * <p>
		 * Only applicable for tiles with Point Cloud content. This is different than {@link Cesium3DTileContent#featuresLength} which
		 * equals the number of groups of points as distinguished by the <code>BATCH_ID</code> feature table semantic.
		 * </p>
		 * @see {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification/TileFormats/PointCloud#batched-points}
		 * @memberof Cesium3DTileContent.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly pointsLength: number;

		/**
		 * Gets the number of triangles in the tile.
		 * @memberof Cesium3DTileContent.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly trianglesLength: number;

		/**
		 * Gets the tile's geometry memory in bytes.
		 * @memberof Cesium3DTileContent.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly geometryByteLength: number;

		/**
		 * Gets the tile's texture memory in bytes.
		 * @memberof Cesium3DTileContent.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly texturesByteLength: number;

		/**
		 * Gets the amount of memory used by the batch table textures, in bytes.
		 * @memberof Cesium3DTileContent.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly batchTableByteLength: number;

		/**
		 * Gets the array of {@link Cesium3DTileContent} objects that represent the
		 * content a composite's inner tiles, which can also be composites.
		 * @see {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification/TileFormats/Composite}
		 * @memberof Cesium3DTileContent.prototype
		 * @type {Array}
		 * @readonly
		 */
		readonly innerContents: any[];

		/**
		 * Gets the promise that will be resolved when the tile's content is ready to render.
		 * @memberof Cesium3DTileContent.prototype
		 * @type {Promise.<Cesium3DTileContent>}
		 * @readonly
		 */
		readonly readyPromise: any;

		/**
		 * Gets the tileset for this tile.
		 * @memberof Cesium3DTileContent.prototype
		 * @type {Cesium3DTileset}
		 * @readonly
		 */
		readonly tileset: Cesium3DTileset;

		/**
		 * Gets the tile containing this content.
		 * @memberof Cesium3DTileContent.prototype
		 * @type {Cesium3DTile}
		 * @readonly
		 */
		readonly tile: Cesium3DTile;

		/**
		 * Gets the url of the tile's content.
		 * @memberof Cesium3DTileContent.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly url: string;

		/**
		 * Determines if the tile's batch table has a property.  If it does, each feature in
		 * the tile will have the property.
		 * @param {Number} batchId The batchId for the feature.
		 * @param {String} name The case-sensitive name of the property.
		 * @returns {Boolean} <code>true</code> if the property exists; otherwise, <code>false</code>.
		 */
		hasProperty(batchId: number, name: string): boolean;

		/**
		 * Returns the {@link Cesium3DTileFeature} object for the feature with the
		 * given <code>batchId</code>.  This object is used to get and modify the
		 * feature's properties.
		 * <p>
		 * Features in a tile are ordered by <code>batchId</code>, an index used to retrieve their metadata from the batch table.
		 * </p>
		 * @see {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification/TileFormats/BatchTable}.
		 * @param {Number} batchId The batchId for the feature.
		 * @returns {Cesium3DTileFeature} The corresponding {@link Cesium3DTileFeature} object.
		 * @exception {DeveloperError} batchId must be between zero and {@link Cesium3DTileContent#featuresLength} - 1.
		 */
		getFeature(batchId: number): Cesium3DTileFeature;

	}

	/**
	 * A feature of a {@link Cesium3DTileset}.
	 * <p>
	 * Provides access to a feature's properties stored in the tile's batch table, as well
	 * as the ability to show/hide a feature and change its highlight color via
	 * {@link Cesium3DTileFeature#show} and {@link Cesium3DTileFeature#color}, respectively.
	 * </p>
	 * <p>
	 * Modifications to a <code>Cesium3DTileFeature</code> object have the lifetime of the tile's
	 * content.  If the tile's content is unloaded, e.g., due to it going out of view and needing
	 * to free space in the cache for visible tiles, listen to the {@link Cesium3DTileset#tileUnload} event to save any
	 * modifications. Also listen to the {@link Cesium3DTileset#tileVisible} event to reapply any modifications.
	 * </p>
	 * <p>
	 * Do not construct this directly.  Access it through {@link Cesium3DTileContent#getFeature}
	 * or picking using {@link Scene#pick} and {@link Scene#pickPosition}.
	 * </p>
	 * @alias Cesium3DTileFeature
	 * @constructor
	 * @example
	 * // On mouse over, display all the properties for a feature in the console log.
	 * handler.setInputAction(function(movement) {
	 *     var feature = scene.pick(movement.endPosition);
	 *     if (feature instanceof Cesium.Cesium3DTileFeature) {
	 *         var propertyNames = feature.getPropertyNames();
	 *         var length = propertyNames.length;
	 *         for (var i = 0; i < length; ++i) {
	 *             var propertyName = propertyNames[i];
	 *             console.log(propertyName + ': ' + feature.getProperty(propertyName));
	 *         }
	 *     }
	 * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
	 */
	class Cesium3DTileFeature {
		constructor();

		/**
		 * Gets or sets if the feature will be shown. This is set for all features
		 * when a style's show is evaluated.
		 * @memberof Cesium3DTileFeature.prototype
		 * @type {Boolean}
		 * @default true
		 */
		show: boolean;

		/**
		 * Gets or sets the highlight color multiplied with the feature's color.  When
		 * this is white, the feature's color is not changed. This is set for all features
		 * when a style's color is evaluated.
		 * @memberof Cesium3DTileFeature.prototype
		 * @type {Color}
		 * @default {@link Color.WHITE}
		 */
		color: Color;

		/**
		 * Gets the tileset containing the feature.
		 * @memberof Cesium3DTileFeature.prototype
		 * @type {Cesium3DTileset}
		 * @readonly
		 */
		readonly tileset: Cesium3DTileset;

		/**
		 * All objects returned by {@link Scene#pick} have a <code>primitive</code> property. This returns
		 * the tileset containing the feature.
		 * @memberof Cesium3DTileFeature.prototype
		 * @type {Cesium3DTileset}
		 * @readonly
		 */
		readonly primitive: Cesium3DTileset;

		/**
		 * Returns whether the feature contains this property. This includes properties from this feature's
		 * class and inherited classes when using a batch table hierarchy.
		 * @see {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/extensions/3DTILES_batch_table_hierarchy}
		 * @param {String} name The case-sensitive name of the property.
		 * @returns {Boolean} Whether the feature contains this property.
		 */
		hasProperty(name: string): boolean;

		/**
		 * Returns an array of property names for the feature. This includes properties from this feature's
		 * class and inherited classes when using a batch table hierarchy.
		 * @see {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/extensions/3DTILES_batch_table_hierarchy}
		 * @param {String[]} results An array into which to store the results.
		 * @returns {String[]} The names of the feature's properties.
		 */
		getPropertyNames(results: string[]): string[];

		/**
		 * Returns a copy of the value of the feature's property with the given name. This includes properties from this feature's
		 * class and inherited classes when using a batch table hierarchy.
		 * @see {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/extensions/3DTILES_batch_table_hierarchy}
		 * @param {String} name The case-sensitive name of the property.
		 * @returns {*} The value of the property or <code>undefined</code> if the property does not exist.
		 * @example
		 * // Display all the properties for a feature in the console log.
		 * var propertyNames = feature.getPropertyNames();
		 * var length = propertyNames.length;
		 * for (var i = 0; i < length; ++i) {
		 *     var propertyName = propertyNames[i];
		 *     console.log(propertyName + ': ' + feature.getProperty(propertyName));
		 * }
		 */
		getProperty(name: string): any;

		/**
		 * Sets the value of the feature's property with the given name.
		 * <p>
		 * If a property with the given name doesn't exist, it is created.
		 * </p>
		 * @param {String} name The case-sensitive name of the property.
		 * @param {*} value The value of the property that will be copied.
		 * @exception {DeveloperError} Inherited batch table hierarchy property is read only.
		 * @example
		 * var height = feature.getProperty('Height'); // e.g., the height of a building
		 * @example
		 * var name = 'clicked';
		 * if (feature.getProperty(name)) {
		 *     console.log('already clicked');
		 * } else {
		 *     feature.setProperty(name, true);
		 *     console.log('first click');
		 * }
		 */
		setProperty(name: string, value: any): void;

	}

	/**
	 * A point feature of a {@link Cesium3DTileset}.
	 * <p>
	 * Provides access to a feature's properties stored in the tile's batch table, as well
	 * as the ability to show/hide a feature and change its point properties
	 * </p>
	 * <p>
	 * Modifications to a <code>Cesium3DTilePointFeature</code> object have the lifetime of the tile's
	 * content.  If the tile's content is unloaded, e.g., due to it going out of view and needing
	 * to free space in the cache for visible tiles, listen to the {@link Cesium3DTileset#tileUnload} event to save any
	 * modifications. Also listen to the {@link Cesium3DTileset#tileVisible} event to reapply any modifications.
	 * </p>
	 * <p>
	 * Do not construct this directly.  Access it through {@link Cesium3DTileContent#getFeature}
	 * or picking using {@link Scene#pick} and {@link Scene#pickPosition}.
	 * </p>
	 * @alias Cesium3DTilePointFeature
	 * @constructor
	 * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.
	 * @example
	 * // On mouse over, display all the properties for a feature in the console log.
	 * handler.setInputAction(function(movement) {
	 *     var feature = scene.pick(movement.endPosition);
	 *     if (feature instanceof Cesium.Cesium3DTilePointFeature) {
	 *         var propertyNames = feature.getPropertyNames();
	 *         var length = propertyNames.length;
	 *         for (var i = 0; i < length; ++i) {
	 *             var propertyName = propertyNames[i];
	 *             console.log(propertyName + ': ' + feature.getProperty(propertyName));
	 *         }
	 *     }
	 * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
	 */
	class Cesium3DTilePointFeature {
		constructor();

		/**
		 * Gets or sets if the feature will be shown. This is set for all features
		 * when a style's show is evaluated.
		 * @memberof Cesium3DTilePointFeature.prototype
		 * @type {Boolean}
		 * @default true
		 */
		show: boolean;

		/**
		 * Gets or sets the color of the point of this feature.
		 * <p>
		 * Only applied when <code>image</code> is <code>undefined</code>.
		 * </p>
		 * @memberof Cesium3DTilePointFeature.prototype
		 * @type {Color}
		 */
		color: Color;

		/**
		 * Gets or sets the point size of this feature.
		 * <p>
		 * Only applied when <code>image</code> is <code>undefined</code>.
		 * </p>
		 * @memberof Cesium3DTilePointFeature.prototype
		 * @type {Number}
		 */
		pointSize: number;

		/**
		 * Gets or sets the point outline color of this feature.
		 * <p>
		 * Only applied when <code>image</code> is <code>undefined</code>.
		 * </p>
		 * @memberof Cesium3DTilePointFeature.prototype
		 * @type {Color}
		 */
		pointOutlineColor: Color;

		/**
		 * Gets or sets the point outline width in pixels of this feature.
		 * <p>
		 * Only applied when <code>image</code> is <code>undefined</code>.
		 * </p>
		 * @memberof Cesium3DTilePointFeature.prototype
		 * @type {Number}
		 */
		pointOutlineWidth: number;

		/**
		 * Gets or sets the label color of this feature.
		 * <p>
		 * The color will be applied to the label if <code>labelText</code> is defined.
		 * </p>
		 * @memberof Cesium3DTilePointFeature.prototype
		 * @type {Color}
		 */
		labelColor: Color;

		/**
		 * Gets or sets the label outline color of this feature.
		 * <p>
		 * The outline color will be applied to the label if <code>labelText</code> is defined.
		 * </p>
		 * @memberof Cesium3DTilePointFeature.prototype
		 * @type {Color}
		 */
		labelOutlineColor: Color;

		/**
		 * Gets or sets the outline width in pixels of this feature.
		 * <p>
		 * The outline width will be applied to the point if <code>labelText</code> is defined.
		 * </p>
		 * @memberof Cesium3DTilePointFeature.prototype
		 * @type {Number}
		 */
		labelOutlineWidth: number;

		/**
		 * Gets or sets the font of this feature.
		 * <p>
		 * Only applied when the <code>labelText</code> is defined.
		 * </p>
		 * @memberof Cesium3DTilePointFeature.prototype
		 * @type {String}
		 */
		font: string;

		/**
		 * Gets or sets the fill and outline style of this feature.
		 * <p>
		 * Only applied when <code>labelText</code> is defined.
		 * </p>
		 * @memberof Cesium3DTilePointFeature.prototype
		 * @type {LabelStyle}
		 */
		labelStyle: any;

		/**
		 * Gets or sets the text for this feature.
		 * @memberof Cesium3DTilePointFeature.prototype
		 * @type {String}
		 */
		labelText: string;

		/**
		 * Gets or sets the background color of the text for this feature.
		 * <p>
		 * Only applied when <code>labelText</code> is defined.
		 * </p>
		 * @memberof Cesium3DTilePointFeature.prototype
		 * @type {Color}
		 */
		backgroundColor: Color;

		/**
		 * Gets or sets the background padding of the text for this feature.
		 * <p>
		 * Only applied when <code>labelText</code> is defined.
		 * </p>
		 * @memberof Cesium3DTilePointFeature.prototype
		 * @type {Cartesian2}
		 */
		backgroundPadding: Cartesian2;

		/**
		 * Gets or sets whether to display the background of the text for this feature.
		 * <p>
		 * Only applied when <code>labelText</code> is defined.
		 * </p>
		 * @memberof Cesium3DTilePointFeature.prototype
		 * @type {Boolean}
		 */
		backgroundEnabled: boolean;

		/**
		 * Gets or sets the near and far scaling properties for this feature.
		 * @memberof Cesium3DTilePointFeature.prototype
		 * @type {NearFarScalar}
		 */
		scaleByDistance: NearFarScalar;

		/**
		 * Gets or sets the near and far translucency properties for this feature.
		 * @memberof Cesium3DTilePointFeature.prototype
		 * @type {NearFarScalar}
		 */
		translucencyByDistance: NearFarScalar;

		/**
		 * Gets or sets the condition specifying at what distance from the camera that this feature will be displayed.
		 * @memberof Cesium3DTilePointFeature.prototype
		 * @type {DistanceDisplayCondition}
		 */
		distanceDisplayCondition: DistanceDisplayCondition;

		/**
		 * Gets or sets the height offset in meters of this feature.
		 * @memberof Cesium3DTilePointFeature.prototype
		 * @type {Number}
		 */
		heightOffset: number;

		/**
		 * Gets or sets whether the anchor line is displayed.
		 * <p>
		 * Only applied when <code>heightOffset</code> is defined.
		 * </p>
		 * @memberof Cesium3DTilePointFeature.prototype
		 * @type {Boolean}
		 */
		anchorLineEnabled: boolean;

		/**
		 * Gets or sets the color for the anchor line.
		 * <p>
		 * Only applied when <code>heightOffset</code> is defined.
		 * </p>
		 * @memberof Cesium3DTilePointFeature.prototype
		 * @type {Color}
		 */
		anchorLineColor: Color;

		/**
		 * Gets or sets the image of this feature.
		 * @memberof Cesium3DTilePointFeature.prototype
		 * @type {String}
		 */
		image: string;

		/**
		 * Gets or sets the distance where depth testing will be disabled.
		 * @memberof Cesium3DTilePointFeature.prototype
		 * @type {Number}
		 */
		disableDepthTestDistance: number;

		/**
		 * Gets or sets the horizontal origin of this point, which determines if the point is
		 * to the left, center, or right of its anchor position.
		 * @memberof Cesium3DTilePointFeature.prototype
		 * @type {HorizontalOrigin}
		 */
		horizontalOrigin: any;

		/**
		 * Gets or sets the vertical origin of this point, which determines if the point is
		 * to the bottom, center, or top of its anchor position.
		 * @memberof Cesium3DTilePointFeature.prototype
		 * @type {VerticalOrigin}
		 */
		verticalOrigin: any;

		/**
		 * Gets or sets the horizontal origin of this point's text, which determines if the point's text is
		 * to the left, center, or right of its anchor position.
		 * @memberof Cesium3DTilePointFeature.prototype
		 * @type {HorizontalOrigin}
		 */
		labelHorizontalOrigin: any;

		/**
		 * Get or sets the vertical origin of this point's text, which determines if the point's text is
		 * to the bottom, center, top, or baseline of it's anchor point.
		 * @memberof Cesium3DTilePointFeature.prototype
		 * @type {VerticalOrigin}
		 */
		labelVerticalOrigin: any;

		/**
		 * Gets the tileset containing the feature.
		 * @memberof Cesium3DTilePointFeature.prototype
		 * @type {Cesium3DTileset}
		 * @readonly
		 */
		readonly tileset: Cesium3DTileset;

		/**
		 * All objects returned by {@link Scene#pick} have a <code>primitive</code> property. This returns
		 * the tileset containing the feature.
		 * @memberof Cesium3DTilePointFeature.prototype
		 * @type {Cesium3DTileset}
		 * @readonly
		 */
		readonly primitive: Cesium3DTileset;

		/**
		 * Returns whether the feature contains this property. This includes properties from this feature's
		 * class and inherited classes when using a batch table hierarchy.
		 * @see {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/extensions/3DTILES_batch_table_hierarchy}
		 * @param {String} name The case-sensitive name of the property.
		 * @returns {Boolean} Whether the feature contains this property.
		 */
		hasProperty(name: string): boolean;

		/**
		 * Returns an array of property names for the feature. This includes properties from this feature's
		 * class and inherited classes when using a batch table hierarchy.
		 * @see {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/extensions/3DTILES_batch_table_hierarchy}
		 * @param {String[]} results An array into which to store the results.
		 * @returns {String[]} The names of the feature's properties.
		 */
		getPropertyNames(results: string[]): string[];

		/**
		 * Returns a copy of the value of the feature's property with the given name. This includes properties from this feature's
		 * class and inherited classes when using a batch table hierarchy.
		 * @see {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/extensions/3DTILES_batch_table_hierarchy}
		 * @param {String} name The case-sensitive name of the property.
		 * @returns {*} The value of the property or <code>undefined</code> if the property does not exist.
		 * @example
		 * // Display all the properties for a feature in the console log.
		 * var propertyNames = feature.getPropertyNames();
		 * var length = propertyNames.length;
		 * for (var i = 0; i < length; ++i) {
		 *     var propertyName = propertyNames[i];
		 *     console.log(propertyName + ': ' + feature.getProperty(propertyName));
		 * }
		 */
		getProperty(name: string): any;

		/**
		 * Sets the value of the feature's property with the given name.
		 * <p>
		 * If a property with the given name doesn't exist, it is created.
		 * </p>
		 * @param {String} name The case-sensitive name of the property.
		 * @param {*} value The value of the property that will be copied.
		 * @exception {DeveloperError} Inherited batch table hierarchy property is read only.
		 * @example
		 * var height = feature.getProperty('Height'); // e.g., the height of a building
		 * @example
		 * var name = 'clicked';
		 * if (feature.getProperty(name)) {
		 *     console.log('already clicked');
		 * } else {
		 *     feature.setProperty(name, true);
		 *     console.log('first click');
		 * }
		 */
		setProperty(name: string, value: any): void;

	}

	/**
	 * A {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification|3D Tiles tileset},
	 * used for streaming massive heterogeneous 3D geospatial datasets.
	 * @alias Cesium3DTileset
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Resource|String|Promise<Resource>|Promise<String>} options.url The url to a tileset JSON file.
	 * @param {Boolean} [options.show=true] Determines if the tileset will be shown.
	 * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] A 4x4 transformation matrix that transforms the tileset's root tile.
	 * @param {ShadowMode} [options.shadows=ShadowMode.ENABLED] Determines whether the tileset casts or receives shadows from each light source.
	 * @param {Number} [options.maximumScreenSpaceError=16] The maximum screen space error used to drive level of detail refinement.
	 * @param {Number} [options.maximumMemoryUsage=512] The maximum amount of memory in MB that can be used by the tileset.
	 * @param {Boolean} [options.cullWithChildrenBounds=true] Optimization option. Whether to cull tiles using the union of their children bounding volumes.
	 * @param {Boolean} [options.dynamicScreenSpaceError=false] Optimization option. Reduce the screen space error for tiles that are further away from the camera.
	 * @param {Number} [options.dynamicScreenSpaceErrorDensity=0.00278] Density used to adjust the dynamic screen space error, similar to fog density.
	 * @param {Number} [options.dynamicScreenSpaceErrorFactor=4.0] A factor used to increase the computed dynamic screen space error.
	 * @param {Number} [options.dynamicScreenSpaceErrorHeightFalloff=0.25] A ratio of the tileset's height at which the density starts to falloff.
	 * @param {Boolean} [options.skipLevelOfDetail=true] Optimization option. Determines if level of detail skipping should be applied during the traversal.
	 * @param {Number} [options.baseScreenSpaceError=1024] When <code>skipLevelOfDetail</code> is <code>true</code>, the screen space error that must be reached before skipping levels of detail.
	 * @param {Number} [options.skipScreenSpaceErrorFactor=16] When <code>skipLevelOfDetail</code> is <code>true</code>, a multiplier defining the minimum screen space error to skip. Used in conjunction with <code>skipLevels</code> to determine which tiles to load.
	 * @param {Number} [options.skipLevels=1] When <code>skipLevelOfDetail</code> is <code>true</code>, a constant defining the minimum number of levels to skip when loading tiles. When it is 0, no levels are skipped. Used in conjunction with <code>skipScreenSpaceErrorFactor</code> to determine which tiles to load.
	 * @param {Boolean} [options.immediatelyLoadDesiredLevelOfDetail=false] When <code>skipLevelOfDetail</code> is <code>true</code>, only tiles that meet the maximum screen space error will ever be downloaded. Skipping factors are ignored and just the desired tiles are loaded.
	 * @param {Boolean} [options.loadSiblings=false] When <code>skipLevelOfDetail</code> is <code>true</code>, determines whether siblings of visible tiles are always downloaded during traversal.
	 * @param {ClippingPlaneCollection} [options.clippingPlanes] The {@link ClippingPlaneCollection} used to selectively disable rendering the tileset.
	 * @param {ClassificationType} [options.classificationType] Determines whether terrain, 3D Tiles or both will be classified by this tileset. See {@link Cesium3DTileset#classificationType} for details about restrictions and limitations.
	 * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid determining the size and shape of the globe.
	 * @param {Object} [options.pointCloudShading] Options for constructing a {@link PointCloudShading} object to control point attenuation based on geometric error and lighting.
	 * @param {Boolean} [options.debugFreezeFrame=false] For debugging only. Determines if only the tiles from last frame should be used for rendering.
	 * @param {Boolean} [options.debugColorizeTiles=false] For debugging only. When true, assigns a random color to each tile.
	 * @param {Boolean} [options.debugWireframe=false] For debugging only. When true, render's each tile's content as a wireframe.
	 * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. When true, renders the bounding volume for each tile.
	 * @param {Boolean} [options.debugShowContentBoundingVolume=false] For debugging only. When true, renders the bounding volume for each tile's content.
	 * @param {Boolean} [options.debugShowViewerRequestVolume=false] For debugging only. When true, renders the viewer request volume for each tile.
	 * @param {Boolean} [options.debugShowGeometricError=false] For debugging only. When true, draws labels to indicate the geometric error of each tile.
	 * @param {Boolean} [options.debugShowRenderingStatistics=false] For debugging only. When true, draws labels to indicate the number of commands, points, triangles and features for each tile.
	 * @param {Boolean} [options.debugShowMemoryUsage=false] For debugging only. When true, draws labels to indicate the texture and geometry memory in megabytes used by each tile.
	 * @param {Boolean} [options.debugShowUrl=false] For debugging only. When true, draws labels to indicate the url of each tile.
	 * @exception {DeveloperError} The tileset must be 3D Tiles version 0.0 or 1.0.
	 * @example
	 * var tileset = scene.primitives.add(new Cesium.Cesium3DTileset({
	 *      url : 'http://localhost:8002/tilesets/Seattle/tileset.json'
	 * }));
	 * @example
	 * // Common setting for the skipLevelOfDetail optimization
	 * var tileset = scene.primitives.add(new Cesium.Cesium3DTileset({
	 *      url : 'http://localhost:8002/tilesets/Seattle/tileset.json',
	 *      skipLevelOfDetail : true,
	 *      baseScreenSpaceError : 1024,
	 *      skipScreenSpaceErrorFactor : 16,
	 *      skipLevels : 1,
	 *      immediatelyLoadDesiredLevelOfDetail : false,
	 *      loadSiblings : false,
	 *      cullWithChildrenBounds : true
	 * }));
	 * @example
	 * // Common settings for the dynamicScreenSpaceError optimization
	 * var tileset = scene.primitives.add(new Cesium.Cesium3DTileset({
	 *      url : 'http://localhost:8002/tilesets/Seattle/tileset.json',
	 *      dynamicScreenSpaceError : true,
	 *      dynamicScreenSpaceErrorDensity : 0.00278,
	 *      dynamicScreenSpaceErrorFactor : 4.0,
	 *      dynamicScreenSpaceErrorHeightFalloff : 0.25
	 * }));
	 * @see {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification|3D Tiles specification}
	 */
	class Cesium3DTileset {
		constructor(options: {
			url: Resource | string | any | any;
			show?: boolean;
			modelMatrix?: Matrix4;
			shadows?: any;
			maximumScreenSpaceError?: number;
			maximumMemoryUsage?: number;
			cullWithChildrenBounds?: boolean;
			dynamicScreenSpaceError?: boolean;
			dynamicScreenSpaceErrorDensity?: number;
			dynamicScreenSpaceErrorFactor?: number;
			dynamicScreenSpaceErrorHeightFalloff?: number;
			skipLevelOfDetail?: boolean;
			baseScreenSpaceError?: number;
			skipScreenSpaceErrorFactor?: number;
			skipLevels?: number;
			immediatelyLoadDesiredLevelOfDetail?: boolean;
			loadSiblings?: boolean;
			clippingPlanes?: ClippingPlaneCollection;
			classificationType?: any;
			ellipsoid?: Ellipsoid;
			pointCloudShading?: any;
			debugFreezeFrame?: boolean;
			debugColorizeTiles?: boolean;
			debugWireframe?: boolean;
			debugShowBoundingVolume?: boolean;
			debugShowContentBoundingVolume?: boolean;
			debugShowViewerRequestVolume?: boolean;
			debugShowGeometricError?: boolean;
			debugShowRenderingStatistics?: boolean;
			debugShowMemoryUsage?: boolean;
			debugShowUrl?: boolean;
		});

		/**
		 * Optimization option. Whether the tileset should refine based on a dynamic screen space error. Tiles that are further
		 * away will be rendered with lower detail than closer tiles. This improves performance by rendering fewer
		 * tiles and making less requests, but may result in a slight drop in visual quality for tiles in the distance.
		 * The algorithm is biased towards "street views" where the camera is close to the ground plane of the tileset and looking
		 * at the horizon. In addition results are more accurate for tightly fitting bounding volumes like box and region.
		 * @type {Boolean}
		 * @default false
		 */
		dynamicScreenSpaceError: boolean;

		/**
		 * A scalar that determines the density used to adjust the dynamic screen space error, similar to {@link Fog}. Increasing this
		 * value has the effect of increasing the maximum screen space error for all tiles, but in a non-linear fashion.
		 * The error starts at 0.0 and increases exponentially until a midpoint is reached, and then approaches 1.0 asymptotically.
		 * This has the effect of keeping high detail in the closer tiles and lower detail in the further tiles, with all tiles
		 * beyond a certain distance all roughly having an error of 1.0.
		 * <p>
		 * The dynamic error is in the range [0.0, 1.0) and is multiplied by <code>dynamicScreenSpaceErrorFactor</code> to produce the
		 * final dynamic error. This dynamic error is then subtracted from the tile's actual screen space error.
		 * </p>
		 * <p>
		 * Increasing <code>dynamicScreenSpaceErrorDensity</code> has the effect of moving the error midpoint closer to the camera.
		 * It is analogous to moving fog closer to the camera.
		 * </p>
		 * @type {Number}
		 * @default 0.00278
		 */
		dynamicScreenSpaceErrorDensity: number;

		/**
		 * A factor used to increase the screen space error of tiles for dynamic screen space error. As this value increases less tiles
		 * are requested for rendering and tiles in the distance will have lower detail. If set to zero, the feature will be disabled.
		 * @type {Number}
		 * @default 4.0
		 */
		dynamicScreenSpaceErrorFactor: number;

		/**
		 * A ratio of the tileset's height at which the density starts to falloff. If the camera is below this height the
		 * full computed density is applied, otherwise the density falls off. This has the effect of higher density at
		 * street level views.
		 * <p>
		 * Valid values are between 0.0 and 1.0.
		 * </p>
		 * @type {Number}
		 * @default 0.25
		 */
		dynamicScreenSpaceErrorHeightFalloff: number;

		/**
		 * Determines whether the tileset casts or receives shadows from each light source.
		 * <p>
		 * Enabling shadows has a performance impact. A tileset that casts shadows must be rendered twice, once from the camera and again from the light's point of view.
		 * </p>
		 * <p>
		 * Shadows are rendered only when {@link Viewer#shadows} is <code>true</code>.
		 * </p>
		 * @type {ShadowMode}
		 * @default ShadowMode.ENABLED
		 */
		shadows: any;

		/**
		 * Determines if the tileset will be shown.
		 * @type {Boolean}
		 * @default true
		 */
		show: boolean;

		/**
		 * Defines how per-feature colors set from the Cesium API or declarative styling blend with the source colors from
		 * the original feature, e.g. glTF material or per-point color in the tile.
		 * @type {Cesium3DTileColorBlendMode}
		 * @default Cesium3DTileColorBlendMode.HIGHLIGHT
		 */
		colorBlendMode: any;

		/**
		 * Defines the value used to linearly interpolate between the source color and feature color when the {@link Cesium3DTileset#colorBlendMode} is <code>MIX</code>.
		 * A value of 0.0 results in the source color while a value of 1.0 results in the feature color, with any value in-between
		 * resulting in a mix of the source color and feature color.
		 * @type {Number}
		 * @default 0.5
		 */
		colorBlendAmount: number;

		/**
		 * Options for controlling point size based on geometric error and eye dome lighting.
		 * @type {PointCloudShading}
		 */
		pointCloudShading: PointCloudShading;

		/**
		 * The event fired to indicate progress of loading new tiles.  This event is fired when a new tile
		 * is requested, when a requested tile is finished downloading, and when a downloaded tile has been
		 * processed and is ready to render.
		 * <p>
		 * The number of pending tile requests, <code>numberOfPendingRequests</code>, and number of tiles
		 * processing, <code>numberOfTilesProcessing</code> are passed to the event listener.
		 * </p>
		 * <p>
		 * This event is fired at the end of the frame after the scene is rendered.
		 * </p>
		 * @type {Event}
		 * @default new Event()
		 * @example
		 * tileset.loadProgress.addEventListener(function(numberOfPendingRequests, numberOfTilesProcessing) {
		 *     if ((numberOfPendingRequests === 0) && (numberOfTilesProcessing === 0)) {
		 *         console.log('Stopped loading');
		 *         return;
		 *     }
		 *     console.log('Loading: requests: ' + numberOfPendingRequests + ', processing: ' + numberOfTilesProcessing);
		 * });
		 */
		loadProgress: Event;

		/**
		 * The event fired to indicate that all tiles that meet the screen space error this frame are loaded. The tileset
		 * is completely loaded for this view.
		 * <p>
		 * This event is fired at the end of the frame after the scene is rendered.
		 * </p>
		 * @type {Event}
		 * @default new Event()
		 * @example
		 * tileset.allTilesLoaded.addEventListener(function() {
		 *     console.log('All tiles are loaded');
		 * });
		 * @see Cesium3DTileset#tilesLoaded
		 */
		allTilesLoaded: Event;

		/**
		 * The event fired to indicate that a tile's content was loaded.
		 * <p>
		 * The loaded {@link Cesium3DTile} is passed to the event listener.
		 * </p>
		 * <p>
		 * This event is fired during the tileset traversal while the frame is being rendered
		 * so that updates to the tile take effect in the same frame.  Do not create or modify
		 * Cesium entities or primitives during the event listener.
		 * </p>
		 * @type {Event}
		 * @default new Event()
		 * @example
		 * tileset.tileLoad.addEventListener(function(tile) {
		 *     console.log('A tile was loaded.');
		 * });
		 */
		tileLoad: Event;

		/**
		 * The event fired to indicate that a tile's content was unloaded.
		 * <p>
		 * The unloaded {@link Cesium3DTile} is passed to the event listener.
		 * </p>
		 * <p>
		 * This event is fired immediately before the tile's content is unloaded while the frame is being
		 * rendered so that the event listener has access to the tile's content.  Do not create
		 * or modify Cesium entities or primitives during the event listener.
		 * </p>
		 * @type {Event}
		 * @default new Event()
		 * @example
		 * tileset.tileUnload.addEventListener(function(tile) {
		 *     console.log('A tile was unloaded from the cache.');
		 * });
		 * @see Cesium3DTileset#maximumMemoryUsage
		 * @see Cesium3DTileset#trimLoadedTiles
		 */
		tileUnload: Event;

		/**
		 * The event fired to indicate that a tile's content failed to load.
		 * <p>
		 * If there are no event listeners, error messages will be logged to the console.
		 * </p>
		 * <p>
		 * The error object passed to the listener contains two properties:
		 * <ul>
		 * <li><code>url</code>: the url of the failed tile.</li>
		 * <li><code>message</code>: the error message.</li>
		 * </ul>
		 * @type {Event}
		 * @default new Event()
		 * @example
		 * tileset.tileFailed.addEventListener(function(error) {
		 *     console.log('An error occurred loading tile: ' + error.url);
		 *     console.log('Error: ' + error.message);
		 * });
		 */
		tileFailed: Event;

		/**
		 * This event fires once for each visible tile in a frame.  This can be used to manually
		 * style a tileset.
		 * <p>
		 * The visible {@link Cesium3DTile} is passed to the event listener.
		 * </p>
		 * <p>
		 * This event is fired during the tileset traversal while the frame is being rendered
		 * so that updates to the tile take effect in the same frame.  Do not create or modify
		 * Cesium entities or primitives during the event listener.
		 * </p>
		 * @type {Event}
		 * @default new Event()
		 * @example
		 * tileset.tileVisible.addEventListener(function(tile) {
		 *     if (tile.content instanceof Cesium.Batched3DModel3DTileContent) {
		 *         console.log('A Batched 3D Model tile is visible.');
		 *     }
		 * });
		 * @example
		 * // Apply a red style and then manually set random colors for every other feature when the tile becomes visible.
		 * tileset.style = new Cesium.Cesium3DTileStyle({
		 *     color : 'color("red")'
		 * });
		 * tileset.tileVisible.addEventListener(function(tile) {
		 *     var content = tile.content;
		 *     var featuresLength = content.featuresLength;
		 *     for (var i = 0; i < featuresLength; i+=2) {
		 *         content.getFeature(i).color = Cesium.Color.fromRandom();
		 *     }
		 * });
		 */
		tileVisible: Event;

		/**
		 * Optimization option. Determines if level of detail skipping should be applied during the traversal.
		 * <p>
		 * The common strategy for replacement-refinement traversal is to store all levels of the tree in memory and require
		 * all children to be loaded before the parent can refine. With this optimization levels of the tree can be skipped
		 * entirely and children can be rendered alongside their parents. The tileset requires significantly less memory when
		 * using this optimization.
		 * </p>
		 * @type {Boolean}
		 * @default true
		 */
		skipLevelOfDetail: boolean;

		/**
		 * The screen space error that must be reached before skipping levels of detail.
		 * <p>
		 * Only used when {@link Cesium3DTileset#skipLevelOfDetail} is <code>true</code>.
		 * </p>
		 * @type {Number}
		 * @default 1024
		 */
		baseScreenSpaceError: number;

		/**
		 * Multiplier defining the minimum screen space error to skip.
		 * For example, if a tile has screen space error of 100, no tiles will be loaded unless they
		 * are leaves or have a screen space error <code><= 100 / skipScreenSpaceErrorFactor</code>.
		 * <p>
		 * Only used when {@link Cesium3DTileset#skipLevelOfDetail} is <code>true</code>.
		 * </p>
		 * @type {Number}
		 * @default 16
		 */
		skipScreenSpaceErrorFactor: number;

		/**
		 * Constant defining the minimum number of levels to skip when loading tiles. When it is 0, no levels are skipped.
		 * For example, if a tile is level 1, no tiles will be loaded unless they are at level greater than 2.
		 * <p>
		 * Only used when {@link Cesium3DTileset#skipLevelOfDetail} is <code>true</code>.
		 * </p>
		 * @type {Number}
		 * @default 1
		 */
		skipLevels: number;

		/**
		 * When true, only tiles that meet the maximum screen space error will ever be downloaded.
		 * Skipping factors are ignored and just the desired tiles are loaded.
		 * <p>
		 * Only used when {@link Cesium3DTileset#skipLevelOfDetail} is <code>true</code>.
		 * </p>
		 * @type {Boolean}
		 * @default false
		 */
		immediatelyLoadDesiredLevelOfDetail: boolean;

		/**
		 * Determines whether siblings of visible tiles are always downloaded during traversal.
		 * This may be useful for ensuring that tiles are already available when the viewer turns left/right.
		 * <p>
		 * Only used when {@link Cesium3DTileset#skipLevelOfDetail} is <code>true</code>.
		 * </p>
		 * @type {Boolean}
		 * @default false
		 */
		loadSiblings: boolean;

		/**
		 * This property is for debugging only; it is not optimized for production use.
		 * <p>
		 * Determines if only the tiles from last frame should be used for rendering.  This
		 * effectively "freezes" the tileset to the previous frame so it is possible to zoom
		 * out and see what was rendered.
		 * </p>
		 * @type {Boolean}
		 * @default false
		 */
		debugFreezeFrame: boolean;

		/**
		 * This property is for debugging only; it is not optimized for production use.
		 * <p>
		 * When true, assigns a random color to each tile.  This is useful for visualizing
		 * what features belong to what tiles, especially with additive refinement where features
		 * from parent tiles may be interleaved with features from child tiles.
		 * </p>
		 * @type {Boolean}
		 * @default false
		 */
		debugColorizeTiles: boolean;

		/**
		 * This property is for debugging only; it is not optimized for production use.
		 * <p>
		 * When true, renders each tile's content as a wireframe.
		 * </p>
		 * @type {Boolean}
		 * @default false
		 */
		debugWireframe: boolean;

		/**
		 * This property is for debugging only; it is not optimized for production use.
		 * <p>
		 * When true, renders the bounding volume for each visible tile.  The bounding volume is
		 * white if the tile has a content bounding volume or is empty; otherwise, it is red.  Tiles that don't meet the
		 * screen space error and are still refining to their descendants are yellow.
		 * </p>
		 * @type {Boolean}
		 * @default false
		 */
		debugShowBoundingVolume: boolean;

		/**
		 * This property is for debugging only; it is not optimized for production use.
		 * <p>
		 * When true, renders the bounding volume for each visible tile's content. The bounding volume is
		 * blue if the tile has a content bounding volume; otherwise it is red.
		 * </p>
		 * @type {Boolean}
		 * @default false
		 */
		debugShowContentBoundingVolume: boolean;

		/**
		 * This property is for debugging only; it is not optimized for production use.
		 * <p>
		 * When true, renders the viewer request volume for each tile.
		 * </p>
		 * @type {Boolean}
		 * @default false
		 */
		debugShowViewerRequestVolume: boolean;

		/**
		 * This property is for debugging only; it is not optimized for production use.
		 * <p>
		 * When true, draws labels to indicate the geometric error of each tile.
		 * </p>
		 * @type {Boolean}
		 * @default false
		 */
		debugShowGeometricError: boolean;

		/**
		 * This property is for debugging only; it is not optimized for production use.
		 * <p>
		 * When true, draws labels to indicate the number of commands, points, triangles and features of each tile.
		 * </p>
		 * @type {Boolean}
		 * @default false
		 */
		debugShowRenderingStatistics: boolean;

		/**
		 * This property is for debugging only; it is not optimized for production use.
		 * <p>
		 * When true, draws labels to indicate the geometry and texture memory usage of each tile.
		 * </p>
		 * @type {Boolean}
		 * @default false
		 */
		debugShowMemoryUsage: boolean;

		/**
		 * This property is for debugging only; it is not optimized for production use.
		 * <p>
		 * When true, draws labels to indicate the url of each tile.
		 * </p>
		 * @type {Boolean}
		 * @default false
		 */
		debugShowUrl: boolean;

		/**
		 * Gets the tileset's asset object property, which contains metadata about the tileset.
		 * <p>
		 * See the {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification#reference-asset|asset schema reference}
		 * in the 3D Tiles spec for the full set of properties.
		 * </p>
		 * @memberof Cesium3DTileset.prototype
		 * @type {Object}
		 * @readonly
		 * @exception {DeveloperError} The tileset is not loaded.  Use Cesium3DTileset.readyPromise or wait for Cesium3DTileset.ready to be true.
		 */
		readonly asset: any;

		/**
		 * The {@link ClippingPlaneCollection} used to selectively disable rendering the tileset.
		 * @memberof Cesium3DTileset.prototype
		 * @type {ClippingPlaneCollection}
		 */
		clippingPlanes: ClippingPlaneCollection;

		/**
		 * Gets the tileset's properties dictionary object, which contains metadata about per-feature properties.
		 * <p>
		 * See the {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification#reference-properties|properties schema reference}
		 * in the 3D Tiles spec for the full set of properties.
		 * </p>
		 * @memberof Cesium3DTileset.prototype
		 * @type {Object}
		 * @readonly
		 * @exception {DeveloperError} The tileset is not loaded.  Use Cesium3DTileset.readyPromise or wait for Cesium3DTileset.ready to be true.
		 * @example
		 * console.log('Maximum building height: ' + tileset.properties.height.maximum);
		 * console.log('Minimum building height: ' + tileset.properties.height.minimum);
		 * @see Cesium3DTileFeature#getProperty
		 * @see Cesium3DTileFeature#setProperty
		 */
		readonly properties: any;

		/**
		 * When <code>true</code>, the tileset's root tile is loaded and the tileset is ready to render.
		 * This is set to <code>true</code> right before {@link Cesium3DTileset#readyPromise} is resolved.
		 * @memberof Cesium3DTileset.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default false
		 */
		readonly ready: boolean;

		/**
		 * Gets the promise that will be resolved when the tileset's root tile is loaded and the tileset is ready to render.
		 * <p>
		 * This promise is resolved at the end of the frame before the first frame the tileset is rendered in.
		 * </p>
		 * @memberof Cesium3DTileset.prototype
		 * @type {Promise.<Cesium3DTileset>}
		 * @readonly
		 * @example
		 * tileset.readyPromise.then(function(tileset) {
		 *     // tile.properties is not defined until readyPromise resolves.
		 *     var properties = tileset.properties;
		 *     if (Cesium.defined(properties)) {
		 *         for (var name in properties) {
		 *             console.log(properties[name]);
		 *         }
		 *     }
		 * });
		 */
		readonly readyPromise: any;

		/**
		 * When <code>true</code>, all tiles that meet the screen space error this frame are loaded. The tileset is
		 * completely loaded for this view.
		 * @memberof Cesium3DTileset.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default false
		 * @see Cesium3DTileset#allTilesLoaded
		 */
		readonly tilesLoaded: boolean;

		/**
		 * The url to a tileset JSON file.
		 * @memberof Cesium3DTileset.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly url: string;

		/**
		 * The base path that non-absolute paths in tileset JSON file are relative to.
		 * @memberof Cesium3DTileset.prototype
		 * @type {String}
		 * @readonly
		 * @deprecated
		 */
		readonly basePath: string;

		/**
		 * The style, defined using the
		 * {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification/Styling|3D Tiles Styling language},
		 * applied to each feature in the tileset.
		 * <p>
		 * Assign <code>undefined</code> to remove the style, which will restore the visual
		 * appearance of the tileset to its default when no style was applied.
		 * </p>
		 * <p>
		 * The style is applied to a tile before the {@link Cesium3DTileset#tileVisible}
		 * event is raised, so code in <code>tileVisible</code> can manually set a feature's
		 * properties (e.g. color and show) after the style is applied. When
		 * a new style is assigned any manually set properties are overwritten.
		 * </p>
		 * @memberof Cesium3DTileset.prototype
		 * @type {Cesium3DTileStyle}
		 * @default undefined
		 * @example
		 * tileset.style = new Cesium.Cesium3DTileStyle({
		 *    color : {
		 *        conditions : [
		 *            ['${Height} >= 100', 'color("purple", 0.5)'],
		 *            ['${Height} >= 50', 'color("red")'],
		 *            ['true', 'color("blue")']
		 *        ]
		 *    },
		 *    show : '${Height} > 0',
		 *    meta : {
		 *        description : '"Building id ${id} has height ${Height}."'
		 *    }
		 * });
		 * @see {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification/Styling|3D Tiles Styling language}
		 */
		style: Cesium3DTileStyle;

		/**
		 * The maximum screen space error used to drive level of detail refinement.  This value helps determine when a tile
		 * refines to its descendants, and therefore plays a major role in balancing performance with visual quality.
		 * <p>
		 * A tile's screen space error is roughly equivalent to the number of pixels wide that would be drawn if a sphere with a
		 * radius equal to the tile's <b>geometric error</b> were rendered at the tile's position. If this value exceeds
		 * <code>maximumScreenSpaceError</code> the tile refines to its descendants.
		 * </p>
		 * <p>
		 * Depending on the tileset, <code>maximumScreenSpaceError</code> may need to be tweaked to achieve the right balance.
		 * Higher values provide better performance but lower visual quality.
		 * </p>
		 * @memberof Cesium3DTileset.prototype
		 * @type {Number}
		 * @default 16
		 * @exception {DeveloperError} <code>maximumScreenSpaceError</code> must be greater than or equal to zero.
		 */
		maximumScreenSpaceError: number;

		/**
		 * The maximum amount of GPU memory (in MB) that may be used to cache tiles. This value is estimated from
		 * geometry, textures, and batch table textures of loaded tiles. For point clouds, this value also
		 * includes per-point metadata.
		 * <p>
		 * Tiles not in view are unloaded to enforce this.
		 * </p>
		 * <p>
		 * If decreasing this value results in unloading tiles, the tiles are unloaded the next frame.
		 * </p>
		 * <p>
		 * If tiles sized more than <code>maximumMemoryUsage</code> are needed
		 * to meet the desired screen space error, determined by {@link Cesium3DTileset#maximumScreenSpaceError},
		 * for the current view, then the memory usage of the tiles loaded will exceed
		 * <code>maximumMemoryUsage</code>.  For example, if the maximum is 256 MB, but
		 * 300 MB of tiles are needed to meet the screen space error, then 300 MB of tiles may be loaded.  When
		 * these tiles go out of view, they will be unloaded.
		 * </p>
		 * @memberof Cesium3DTileset.prototype
		 * @type {Number}
		 * @default 512
		 * @exception {DeveloperError} <code>maximumMemoryUsage</code> must be greater than or equal to zero.
		 * @see Cesium3DTileset#totalMemoryUsageInBytes
		 */
		maximumMemoryUsage: number;

		/**
		 * The root tile.
		 * @memberOf Cesium3DTileset.prototype
		 * @type {Cesium3DTile}
		 * @readonly
		 * @exception {DeveloperError} The tileset is not loaded.  Use Cesium3DTileset.readyPromise or wait for Cesium3DTileset.ready to be true.
		 */
		readonly root: Cesium3DTile;

		/**
		 * The tileset's bounding sphere.
		 * @memberof Cesium3DTileset.prototype
		 * @type {BoundingSphere}
		 * @readonly
		 * @exception {DeveloperError} The tileset is not loaded.  Use Cesium3DTileset.readyPromise or wait for Cesium3DTileset.ready to be true.
		 * @example
		 * var tileset = viewer.scene.primitives.add(new Cesium.Cesium3DTileset({
		 *     url : 'http://localhost:8002/tilesets/Seattle/tileset.json'
		 * }));
		 * tileset.readyPromise.then(function(tileset) {
		 *     // Set the camera to view the newly added tileset
		 *     viewer.camera.viewBoundingSphere(tileset.boundingSphere, new Cesium.HeadingPitchRange(0, -0.5, 0));
		 * });
		 */
		readonly boundingSphere: BoundingSphere;

		/**
		 * A 4x4 transformation matrix that transforms the entire tileset.
		 * @memberof Cesium3DTileset.prototype
		 * @type {Matrix4}
		 * @default Matrix4.IDENTITY
		 * @example
		 * // Adjust a tileset's height from the globe's surface.
		 * var heightOffset = 20.0;
		 * var boundingSphere = tileset.boundingSphere;
		 * var cartographic = Cesium.Cartographic.fromCartesian(boundingSphere.center);
		 * var surface = Cesium.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, 0.0);
		 * var offset = Cesium.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, heightOffset);
		 * var translation = Cesium.Cartesian3.subtract(offset, surface, new Cesium.Cartesian3());
		 * tileset.modelMatrix = Cesium.Matrix4.fromTranslation(translation);
		 */
		modelMatrix: Matrix4;

		/**
		 * Returns the time, in milliseconds, since the tileset was loaded and first updated.
		 * @memberof Cesium3DTileset.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly timeSinceLoad: number;

		/**
		 * The total amount of GPU memory in bytes used by the tileset. This value is estimated from
		 * geometry, texture, and batch table textures of loaded tiles. For point clouds, this value also
		 * includes per-point metadata.
		 * @memberof Cesium3DTileset.prototype
		 * @type {Number}
		 * @readonly
		 * @see Cesium3DTileset#maximumMemoryUsage
		 */
		readonly totalMemoryUsageInBytes: number;

		/**
		 * Determines whether terrain, 3D Tiles or both will be classified by this tileset.
		 * <p>
		 * This option is only applied to tilesets containing batched 3D models, geometry data, or vector data. Even when undefined, vector data and geometry data
		 * must render as classifications and will default to rendering on both terrain and other 3D Tiles tilesets.
		 * </p>
		 * <p>
		 * When enabled for batched 3D model tilesets, there are a few requirements/limitations on the glTF:
		 * <ul>
		 *     <li>POSITION and _BATCHID semantics are required.</li>
		 *     <li>All indices with the same batch id must occupy contiguous sections of the index buffer.</li>
		 *     <li>All shaders and techniques are ignored. The generated shader simply multiplies the position by the model-view-projection matrix.</li>
		 *     <li>The only supported extensions are CESIUM_RTC and WEB3D_quantized_attributes.</li>
		 *     <li>Only one node is supported.</li>
		 *     <li>Only one mesh per node is supported.</li>
		 *     <li>Only one primitive per mesh is supported.</li>
		 * </ul>
		 * </p>
		 * @memberof Cesium3DTileset.prototype
		 * @type {ClassificationType}
		 * @default undefined
		 * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.
		 * @readonly
		 */
		readonly classificationType: any;

		/**
		 * Gets an ellipsoid describing the shape of the globe.
		 * @memberof Cesium3DTileset.prototype
		 * @type {Ellipsoid}
		 * @readonly
		 */
		readonly ellipsoid: Ellipsoid;

		/**
		 * Returns the <code>extras</code> property at the top-level of the tileset JSON, which contains application specific metadata.
		 * Returns <code>undefined</code> if <code>extras</code> does not exist.
		 * @memberof Cesium3DTileset.prototype
		 * @exception {DeveloperError} The tileset is not loaded.  Use Cesium3DTileset.readyPromise or wait for Cesium3DTileset.ready to be true.
		 * @type {*}
		 * @readonly
		 * @see {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification#specifying-extensions-and-application-specific-extras|Extras in the 3D Tiles specification.}
		 */
		readonly extras: any;

		/**
		 * Provides a hook to override the method used to request the tileset json
		 * useful when fetching tilesets from remote servers
		 * @param {Resource|String} tilesetUrl The url of the json file to be fetched
		 * @returns {Promise.<Object>} A promise that resolves with the fetched json data
		 */
		static loadJson(tilesetUrl: Resource | string): any;

		/**
		 * Marks the tileset's {@link Cesium3DTileset#style} as dirty, which forces all
		 * features to re-evaluate the style in the next frame each is visible.
		 */
		makeStyleDirty(): void;

		/**
		 * Unloads all tiles that weren't selected the previous frame.  This can be used to
		 * explicitly manage the tile cache and reduce the total number of tiles loaded below
		 * {@link Cesium3DTileset#maximumMemoryUsage}.
		 * <p>
		 * Tile unloads occur at the next frame to keep all the WebGL delete calls
		 * within the render loop.
		 * </p>
		 */
		trimLoadedTiles(): void;

		/**
		 * <code>true</code> if the tileset JSON file lists the extension in extensionsUsed; otherwise, <code>false</code>.
		 * @param {String} extensionName The name of the extension to check.
		 * @returns {Boolean} <code>true</code> if the tileset JSON file lists the extension in extensionsUsed; otherwise, <code>false</code>.
		 */
		hasExtension(extensionName: string): boolean;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <br /><br />
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
		 * @see Cesium3DTileset#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
		 * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
		 * <br /><br />
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * tileset = tileset && tileset.destroy();
		 * @see Cesium3DTileset#isDestroyed
		 */
		destroy(): void;

	}

	/**
	 * A style that is applied to a {@link Cesium3DTileset}.
	 * <p>
	 * Evaluates an expression defined using the
	 * {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification/Styling|3D Tiles Styling language}.
	 * </p>
	 * @alias Cesium3DTileStyle
	 * @constructor
	 * @param {Resource|String|Object} [style] The url of a style or an object defining a style.
	 * @example
	 * tileset.style = new Cesium.Cesium3DTileStyle({
	 *     color : {
	 *         conditions : [
	 *             ['${Height} >= 100', 'color("purple", 0.5)'],
	 *             ['${Height} >= 50', 'color("red")'],
	 *             ['true', 'color("blue")']
	 *         ]
	 *     },
	 *     show : '${Height} > 0',
	 *     meta : {
	 *         description : '"Building id ${id} has height ${Height}."'
	 *     }
	 * });
	 * @example
	 * tileset.style = new Cesium.Cesium3DTileStyle({
	 *     color : 'vec4(${Temperature})',
	 *     pointSize : '${Temperature} * 2.0'
	 * });
	 * @see {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification/Styling|3D Tiles Styling language}
	 */
	class Cesium3DTileStyle {
		constructor(style?: Resource | string | any);

		/**
		 * Gets the object defining the style using the
		 * {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification/Styling|3D Tiles Styling language}.
		 * @memberof Cesium3DTileStyle.prototype
		 * @type {Object}
		 * @readonly
		 * @default undefined
		 * @exception {DeveloperError} The style is not loaded.  Use Cesium3DTileStyle.readyPromise or wait for Cesium3DTileStyle.ready to be true.
		 */
		readonly style: any;

		/**
		 * When <code>true</code>, the style is ready and its expressions can be evaluated.  When
		 * a style is constructed with an object, as opposed to a url, this is <code>true</code> immediately.
		 * @memberof Cesium3DTileStyle.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default false
		 */
		readonly ready: boolean;

		/**
		 * Gets the promise that will be resolved when the the style is ready and its expressions can be evaluated.
		 * @memberof Cesium3DTileStyle.prototype
		 * @type {Promise.<Cesium3DTileStyle>}
		 * @readonly
		 */
		readonly readyPromise: any;

		/**
		 * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>show</code> property. Alternatively a boolean, string, or object defining a show style can be used.
		 * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
		 * <p>
		 * The expression must return or convert to a <code>Boolean</code>.
		 * </p>
		 * <p>
		 * This expression is applicable to all tile formats.
		 * </p>
		 * @memberof Cesium3DTileStyle.prototype
		 * @type {StyleExpression}
		 * @exception {DeveloperError} The style is not loaded.  Use {@link Cesium3DTileStyle#readyPromise} or wait for {@link Cesium3DTileStyle#ready} to be true.
		 * @example
		 * var style = new Cesium3DTileStyle({
		 *     show : '(regExp("^Chest").test(${County})) && (${YearBuilt} >= 1970)'
		 * });
		 * style.show.evaluate(feature); // returns true or false depending on the feature's properties
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override show expression with a custom function
		 * style.show = {
		 *     evaluate : function(feature) {
		 *         return true;
		 *     }
		 * };
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override show expression with a boolean
		 * style.show = true;
		 * };
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override show expression with a string
		 * style.show = '${Height} > 0';
		 * };
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override show expression with a condition
		 * style.show = {
		 *     conditions: [
		 *         ['${height} > 2', 'false'],
		 *         ['true', 'true']
		 *     ];
		 * };
		 */
		show: StyleExpression;

		/**
		 * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>color</code> property. Alternatively a string or object defining a color style can be used.
		 * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
		 * <p>
		 * The expression must return a <code>Color</code>.
		 * </p>
		 * <p>
		 * This expression is applicable to all tile formats.
		 * </p>
		 * @memberof Cesium3DTileStyle.prototype
		 * @type {StyleExpression}
		 * @exception {DeveloperError} The style is not loaded.  Use {@link Cesium3DTileStyle#readyPromise} or wait for {@link Cesium3DTileStyle#ready} to be true.
		 * @example
		 * var style = new Cesium3DTileStyle({
		 *     color : '(${Temperature} > 90) ? color("red") : color("white")'
		 * });
		 * style.color.evaluateColor(feature, result); // returns a Cesium.Color object
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override color expression with a custom function
		 * style.color = {
		 *     evaluateColor : function(feature, result) {
		 *         return Cesium.Color.clone(Cesium.Color.WHITE, result);
		 *     }
		 * };
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override color expression with a string
		 * style.color = 'color("blue")';
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override color expression with a condition
		 * style.color = {
		 *     conditions : [
		 *         ['${height} > 2', 'color("cyan")'],
		 *         ['true', 'color("blue")']
		 *     ]
		 * };
		 */
		color: StyleExpression;

		/**
		 * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>pointSize</code> property. Alternatively a string or object defining a point size style can be used.
		 * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
		 * <p>
		 * The expression must return a <code>Number</code>.
		 * </p>
		 * <p>
		 * This expression is only applicable to point features in a Vector tile or a Point Cloud tile.
		 * </p>
		 * @memberof Cesium3DTileStyle.prototype
		 * @type {StyleExpression}
		 * @exception {DeveloperError} The style is not loaded.  Use {@link Cesium3DTileStyle#readyPromise} or wait for {@link Cesium3DTileStyle#ready} to be true.
		 * @example
		 * var style = new Cesium3DTileStyle({
		 *     pointSize : '(${Temperature} > 90) ? 2.0 : 1.0'
		 * });
		 * style.pointSize.evaluate(feature); // returns a Number
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override pointSize expression with a custom function
		 * style.pointSize = {
		 *     evaluate : function(feature) {
		 *         return 1.0;
		 *     }
		 * };
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override pointSize expression with a number
		 * style.pointSize = 1.0;
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override pointSize expression with a string
		 * style.pointSize = '${height} / 10';
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override pointSize expression with a condition
		 * style.pointSize =  {
		 *     conditions : [
		 *         ['${height} > 2', '1.0'],
		 *         ['true', '2.0']
		 *     ]
		 * };
		 */
		pointSize: StyleExpression;

		/**
		 * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>pointOutlineColor</code> property. Alternatively a string or object defining a color style can be used.
		 * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
		 * <p>
		 * The expression must return a <code>Color</code>.
		 * </p>
		 * <p>
		 * This expression is only applicable to point features in a Vector tile.
		 * </p>
		 * @memberof Cesium3DTileStyle.prototype
		 * @type {StyleExpression}
		 * @exception {DeveloperError} The style is not loaded.  Use {@link Cesium3DTileStyle#readyPromise} or wait for {@link Cesium3DTileStyle#ready} to be true.
		 * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override pointOutlineColor expression with a string
		 * style.pointOutlineColor = 'color("blue")';
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override pointOutlineColor expression with a condition
		 * style.pointOutlineColor = {
		 *     conditions : [
		 *         ['${height} > 2', 'color("cyan")'],
		 *         ['true', 'color("blue")']
		 *     ]
		 * };
		 */
		pointOutlineColor: StyleExpression;

		/**
		 * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>pointOutlineWidth</code> property. Alternatively a string or object defining a number style can be used.
		 * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
		 * <p>
		 * The expression must return a <code>Number</code>.
		 * </p>
		 * <p>
		 * This expression is only applicable to point features in a Vector tile.
		 * </p>
		 * @memberof Cesium3DTileStyle.prototype
		 * @type {StyleExpression}
		 * @exception {DeveloperError} The style is not loaded.  Use {@link Cesium3DTileStyle#readyPromise} or wait for {@link Cesium3DTileStyle#ready} to be true.
		 * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override pointOutlineWidth expression with a string
		 * style.pointOutlineWidth = '5';
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override pointOutlineWidth expression with a condition
		 * style.pointOutlineWidth = {
		 *     conditions : [
		 *         ['${height} > 2', '5'],
		 *         ['true', '0']
		 *     ]
		 * };
		 */
		pointOutlineWidth: StyleExpression;

		/**
		 * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>labelColor</code> property. Alternatively a string or object defining a color style can be used.
		 * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
		 * <p>
		 * The expression must return a <code>Color</code>.
		 * </p>
		 * <p>
		 * This expression is only applicable to point features in a Vector tile.
		 * </p>
		 * @memberof Cesium3DTileStyle.prototype
		 * @type {StyleExpression}
		 * @exception {DeveloperError} The style is not loaded.  Use {@link Cesium3DTileStyle#readyPromise} or wait for {@link Cesium3DTileStyle#ready} to be true.
		 * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override labelColor expression with a string
		 * style.labelColor = 'color("blue")';
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override labelColor expression with a condition
		 * style.labelColor = {
		 *     conditions : [
		 *         ['${height} > 2', 'color("cyan")'],
		 *         ['true', 'color("blue")']
		 *     ]
		 * };
		 */
		labelColor: StyleExpression;

		/**
		 * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>labelOutlineColor</code> property. Alternatively a string or object defining a color style can be used.
		 * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
		 * <p>
		 * The expression must return a <code>Color</code>.
		 * </p>
		 * <p>
		 * This expression is only applicable to point features in a Vector tile.
		 * </p>
		 * @memberof Cesium3DTileStyle.prototype
		 * @type {StyleExpression}
		 * @exception {DeveloperError} The style is not loaded.  Use {@link Cesium3DTileStyle#readyPromise} or wait for {@link Cesium3DTileStyle#ready} to be true.
		 * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override labelOutlineColor expression with a string
		 * style.labelOutlineColor = 'color("blue")';
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override labelOutlineColor expression with a condition
		 * style.labelOutlineColor = {
		 *     conditions : [
		 *         ['${height} > 2', 'color("cyan")'],
		 *         ['true', 'color("blue")']
		 *     ]
		 * };
		 */
		labelOutlineColor: StyleExpression;

		/**
		 * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>labelOutlineWidth</code> property. Alternatively a string or object defining a number style can be used.
		 * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
		 * <p>
		 * The expression must return a <code>Number</code>.
		 * </p>
		 * <p>
		 * This expression is only applicable to point features in a Vector tile.
		 * </p>
		 * @memberof Cesium3DTileStyle.prototype
		 * @type {StyleExpression}
		 * @exception {DeveloperError} The style is not loaded.  Use {@link Cesium3DTileStyle#readyPromise} or wait for {@link Cesium3DTileStyle#ready} to be true.
		 * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override labelOutlineWidth expression with a string
		 * style.labelOutlineWidth = '5';
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override labelOutlineWidth expression with a condition
		 * style.labelOutlineWidth = {
		 *     conditions : [
		 *         ['${height} > 2', '5'],
		 *         ['true', '0']
		 *     ]
		 * };
		 */
		labelOutlineWidth: StyleExpression;

		/**
		 * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>font</code> property. Alternatively a string or object defining a string style can be used.
		 * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
		 * <p>
		 * The expression must return a <code>String</code>.
		 * </p>
		 * <p>
		 * This expression is only applicable to point features in a Vector tile.
		 * </p>
		 * @memberof Cesium3DTileStyle.prototype
		 * @type {StyleExpression}
		 * @exception {DeveloperError} The style is not loaded.  Use {@link Cesium3DTileStyle#readyPromise} or wait for {@link Cesium3DTileStyle#ready} to be true.
		 * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.
		 * @example
		 * var style = new Cesium3DTileStyle({
		 *     font : '(${Temperature} > 90) ? "30px Helvetica" : "24px Helvetica"'
		 * });
		 * style.font.evaluate(feature); // returns a String
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override font expression with a custom function
		 * style.font = {
		 *     evaluate : function(feature) {
		 *         return '24px Helvetica';
		 *     }
		 * };
		 */
		font: StyleExpression;

		/**
		 * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>label style</code> property. Alternatively a string or object defining a number style can be used.
		 * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
		 * <p>
		 * The expression must return a <code>LabelStyle</code>.
		 * </p>
		 * <p>
		 * This expression is only applicable to point features in a Vector tile.
		 * </p>
		 * @memberof Cesium3DTileStyle.prototype
		 * @type {StyleExpression}
		 * @exception {DeveloperError} The style is not loaded.  Use {@link Cesium3DTileStyle#readyPromise} or wait for {@link Cesium3DTileStyle#ready} to be true.
		 * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.
		 * @example
		 * var style = new Cesium3DTileStyle({
		 *     labelStyle : '(${Temperature} > 90) ? ' + LabelStyle.FILL_AND_OUTLINE + ' : ' + LabelStyle.FILL
		 * });
		 * style.labelStyle.evaluate(feature); // returns a LabelStyle
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override labelStyle expression with a custom function
		 * style.labelStyle = {
		 *     evaluate : function(feature) {
		 *         return LabelStyle.FILL;
		 *     }
		 * };
		 */
		labelStyle: StyleExpression;

		/**
		 * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>labelText</code> property. Alternatively a string or object defining a string style can be used.
		 * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
		 * <p>
		 * The expression must return a <code>String</code>.
		 * </p>
		 * <p>
		 * This expression is only applicable to point features in a Vector tile.
		 * </p>
		 * @memberof Cesium3DTileStyle.prototype
		 * @type {StyleExpression}
		 * @exception {DeveloperError} The style is not loaded.  Use {@link Cesium3DTileStyle#readyPromise} or wait for {@link Cesium3DTileStyle#ready} to be true.
		 * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.
		 * @example
		 * var style = new Cesium3DTileStyle({
		 *     labelText : '(${Temperature} > 90) ? ">90" : "<=90"'
		 * });
		 * style.labelText.evaluate(feature); // returns a String
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override labelText expression with a custom function
		 * style.labelText = {
		 *     evaluate : function(feature) {
		 *         return 'Example label text';
		 *     }
		 * };
		 */
		labelText: StyleExpression;

		/**
		 * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>backgroundColor</code> property. Alternatively a string or object defining a color style can be used.
		 * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
		 * <p>
		 * The expression must return a <code>Color</code>.
		 * </p>
		 * <p>
		 * This expression is only applicable to point features in a Vector tile.
		 * </p>
		 * @memberof Cesium3DTileStyle.prototype
		 * @type {StyleExpression}
		 * @exception {DeveloperError} The style is not loaded.  Use {@link Cesium3DTileStyle#readyPromise} or wait for {@link Cesium3DTileStyle#ready} to be true.
		 * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override backgroundColor expression with a string
		 * style.backgroundColor = 'color("blue")';
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override backgroundColor expression with a condition
		 * style.backgroundColor = {
		 *     conditions : [
		 *         ['${height} > 2', 'color("cyan")'],
		 *         ['true', 'color("blue")']
		 *     ]
		 * };
		 */
		backgroundColor: StyleExpression;

		/**
		 * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>backgroundPadding</code> property. Alternatively a string or object defining a vec2 style can be used.
		 * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
		 * <p>
		 * The expression must return a <code>Cartesian2</code>.
		 * </p>
		 * <p>
		 * This expression is only applicable to point features in a Vector tile.
		 * </p>
		 * @memberof Cesium3DTileStyle.prototype
		 * @type {StyleExpression}
		 * @exception {DeveloperError} The style is not loaded.  Use {@link Cesium3DTileStyle#readyPromise} or wait for {@link Cesium3DTileStyle#ready} to be true.
		 * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override backgroundPadding expression with a string
		 * style.backgroundPadding = 'vec2(5.0, 7.0)';
		 * style.backgroundPadding.evaluate(feature); // returns a Cartesian2
		 */
		backgroundPadding: StyleExpression;

		/**
		 * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>backgroundEnabled</code> property. Alternatively a string or object defining a boolean style can be used.
		 * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
		 * <p>
		 * The expression must return a <code>Boolean</code>.
		 * </p>
		 * <p>
		 * This expression is only applicable to point features in a Vector tile.
		 * </p>
		 * @memberof Cesium3DTileStyle.prototype
		 * @type {StyleExpression}
		 * @exception {DeveloperError} The style is not loaded.  Use {@link Cesium3DTileStyle#readyPromise} or wait for {@link Cesium3DTileStyle#ready} to be true.
		 * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override backgroundEnabled expression with a string
		 * style.backgroundEnabled = 'true';
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override backgroundEnabled expression with a condition
		 * style.backgroundEnabled = {
		 *     conditions : [
		 *         ['${height} > 2', 'true'],
		 *         ['true', 'false']
		 *     ]
		 * };
		 */
		backgroundEnabled: StyleExpression;

		/**
		 * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>scaleByDistance</code> property. Alternatively a string or object defining a vec4 style can be used.
		 * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
		 * <p>
		 * The expression must return a <code>Cartesian4</code>.
		 * </p>
		 * <p>
		 * This expression is only applicable to point features in a Vector tile.
		 * </p>
		 * @memberof Cesium3DTileStyle.prototype
		 * @type {StyleExpression}
		 * @exception {DeveloperError} The style is not loaded.  Use {@link Cesium3DTileStyle#readyPromise} or wait for {@link Cesium3DTileStyle#ready} to be true.
		 * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override scaleByDistance expression with a string
		 * style.scaleByDistance = 'vec4(1.5e2, 2.0, 1.5e7, 0.5)';
		 * style.scaleByDistance.evaluate(feature); // returns a Cartesian4
		 */
		scaleByDistance: StyleExpression;

		/**
		 * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>translucencyByDistance</code> property. Alternatively a string or object defining a vec4 style can be used.
		 * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
		 * <p>
		 * The expression must return a <code>Cartesian4</code>.
		 * </p>
		 * <p>
		 * This expression is only applicable to point features in a Vector tile.
		 * </p>
		 * @memberof Cesium3DTileStyle.prototype
		 * @type {StyleExpression}
		 * @exception {DeveloperError} The style is not loaded.  Use {@link Cesium3DTileStyle#readyPromise} or wait for {@link Cesium3DTileStyle#ready} to be true.
		 * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override translucencyByDistance expression with a string
		 * style.translucencyByDistance = 'vec4(1.5e2, 1.0, 1.5e7, 0.2)';
		 * style.translucencyByDistance.evaluate(feature); // returns a Cartesian4
		 */
		translucencyByDistance: StyleExpression;

		/**
		 * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>distanceDisplayCondition</code> property. Alternatively a string or object defining a vec2 style can be used.
		 * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
		 * <p>
		 * The expression must return a <code>Cartesian2</code>.
		 * </p>
		 * <p>
		 * This expression is only applicable to point features in a Vector tile.
		 * </p>
		 * @memberof Cesium3DTileStyle.prototype
		 * @type {StyleExpression}
		 * @exception {DeveloperError} The style is not loaded.  Use {@link Cesium3DTileStyle#readyPromise} or wait for {@link Cesium3DTileStyle#ready} to be true.
		 * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override distanceDisplayCondition expression with a string
		 * style.distanceDisplayCondition = 'vec2(0.0, 5.5e6)';
		 * style.distanceDisplayCondition.evaluate(feature); // returns a Cartesian2
		 */
		distanceDisplayCondition: StyleExpression;

		/**
		 * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>heightOffset</code> property. Alternatively a string or object defining a number style can be used.
		 * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
		 * <p>
		 * The expression must return a <code>Number</code>.
		 * </p>
		 * <p>
		 * This expression is only applicable to point features in a Vector tile.
		 * </p>
		 * @memberof Cesium3DTileStyle.prototype
		 * @type {StyleExpression}
		 * @exception {DeveloperError} The style is not loaded.  Use {@link Cesium3DTileStyle#readyPromise} or wait for {@link Cesium3DTileStyle#ready} to be true.
		 * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override heightOffset expression with a string
		 * style.heightOffset = '2.0';
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override heightOffset expression with a condition
		 * style.heightOffset = {
		 *     conditions : [
		 *         ['${height} > 2', '4.0'],
		 *         ['true', '2.0']
		 *     ]
		 * };
		 */
		heightOffset: StyleExpression;

		/**
		 * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>anchorLineEnabled</code> property. Alternatively a string or object defining a boolean style can be used.
		 * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
		 * <p>
		 * The expression must return a <code>Boolean</code>.
		 * </p>
		 * <p>
		 * This expression is only applicable to point features in a Vector tile.
		 * </p>
		 * @memberof Cesium3DTileStyle.prototype
		 * @type {StyleExpression}
		 * @exception {DeveloperError} The style is not loaded.  Use {@link Cesium3DTileStyle#readyPromise} or wait for {@link Cesium3DTileStyle#ready} to be true.
		 * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override anchorLineEnabled expression with a string
		 * style.anchorLineEnabled = 'true';
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override anchorLineEnabled expression with a condition
		 * style.anchorLineEnabled = {
		 *     conditions : [
		 *         ['${height} > 2', 'true'],
		 *         ['true', 'false']
		 *     ]
		 * };
		 */
		anchorLineEnabled: StyleExpression;

		/**
		 * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>anchorLineColor</code> property. Alternatively a string or object defining a color style can be used.
		 * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
		 * <p>
		 * The expression must return a <code>Color</code>.
		 * </p>
		 * <p>
		 * This expression is only applicable to point features in a Vector tile.
		 * </p>
		 * @memberof Cesium3DTileStyle.prototype
		 * @type {StyleExpression}
		 * @exception {DeveloperError} The style is not loaded.  Use {@link Cesium3DTileStyle#readyPromise} or wait for {@link Cesium3DTileStyle#ready} to be true.
		 * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override anchorLineColor expression with a string
		 * style.anchorLineColor = 'color("blue")';
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override anchorLineColor expression with a condition
		 * style.anchorLineColor = {
		 *     conditions : [
		 *         ['${height} > 2', 'color("cyan")'],
		 *         ['true', 'color("blue")']
		 *     ]
		 * };
		 */
		anchorLineColor: StyleExpression;

		/**
		 * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>image</code> property. Alternatively a string or object defining a string style can be used.
		 * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
		 * <p>
		 * The expression must return a <code>String</code>.
		 * </p>
		 * <p>
		 * This expression is only applicable to point features in a Vector tile.
		 * </p>
		 * @memberof Cesium3DTileStyle.prototype
		 * @type {StyleExpression}
		 * @exception {DeveloperError} The style is not loaded.  Use {@link Cesium3DTileStyle#readyPromise} or wait for {@link Cesium3DTileStyle#ready} to be true.
		 * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.
		 * @example
		 * var style = new Cesium3DTileStyle({
		 *     image : '(${Temperature} > 90) ? "/url/to/image1" : "/url/to/image2"'
		 * });
		 * style.image.evaluate(feature); // returns a String
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override image expression with a custom function
		 * style.image = {
		 *     evaluate : function(feature) {
		 *         return '/url/to/image';
		 *     }
		 * };
		 */
		image: StyleExpression;

		/**
		 * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>disableDepthTestDistance</code> property. Alternatively a string or object defining a number style can be used.
		 * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
		 * <p>
		 * The expression must return a <code>Number</code>.
		 * </p>
		 * <p>
		 * This expression is only applicable to point features in a Vector tile.
		 * </p>
		 * @memberof Cesium3DTileStyle.prototype
		 * @type {StyleExpression}
		 * @exception {DeveloperError} The style is not loaded.  Use {@link Cesium3DTileStyle#readyPromise} or wait for {@link Cesium3DTileStyle#ready} to be true.
		 * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override disableDepthTestDistance expression with a string
		 * style.disableDepthTestDistance = '1000.0';
		 * style.disableDepthTestDistance.evaluate(feature); // returns a Number
		 */
		disableDepthTestDistance: StyleExpression;

		/**
		 * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>horizontalOrigin</code> property. Alternatively a string or object defining a number style can be used.
		 * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
		 * <p>
		 * The expression must return a <code>HorizontalOrigin</code>.
		 * </p>
		 * <p>
		 * This expression is only applicable to point features in a Vector tile.
		 * </p>
		 * @memberof Cesium3DTileStyle.prototype
		 * @type {StyleExpression}
		 * @exception {DeveloperError} The style is not loaded.  Use {@link Cesium3DTileStyle#readyPromise} or wait for {@link Cesium3DTileStyle#ready} to be true.
		 * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.
		 * @example
		 * var style = new Cesium3DTileStyle({
		 *     horizontalOrigin : HorizontalOrigin.LEFT
		 * });
		 * style.horizontalOrigin.evaluate(feature); // returns a HorizontalOrigin
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override horizontalOrigin expression with a custom function
		 * style.horizontalOrigin = {
		 *     evaluate : function(feature) {
		 *         return HorizontalOrigin.CENTER;
		 *     }
		 * };
		 */
		horizontalOrigin: StyleExpression;

		/**
		 * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>verticalOrigin</code> property. Alternatively a string or object defining a number style can be used.
		 * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
		 * <p>
		 * The expression must return a <code>VerticalOrigin</code>.
		 * </p>
		 * <p>
		 * This expression is only applicable to point features in a Vector tile.
		 * </p>
		 * @memberof Cesium3DTileStyle.prototype
		 * @type {StyleExpression}
		 * @exception {DeveloperError} The style is not loaded.  Use {@link Cesium3DTileStyle#readyPromise} or wait for {@link Cesium3DTileStyle#ready} to be true.
		 * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.
		 * @example
		 * var style = new Cesium3DTileStyle({
		 *     verticalOrigin : VerticalOrigin.TOP
		 * });
		 * style.verticalOrigin.evaluate(feature); // returns a VerticalOrigin
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override verticalOrigin expression with a custom function
		 * style.verticalOrigin = {
		 *     evaluate : function(feature) {
		 *         return VerticalOrigin.CENTER;
		 *     }
		 * };
		 */
		verticalOrigin: StyleExpression;

		/**
		 * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>labelHorizontalOrigin</code> property. Alternatively a string or object defining a number style can be used.
		 * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
		 * <p>
		 * The expression must return a <code>HorizontalOrigin</code>.
		 * </p>
		 * <p>
		 * This expression is only applicable to point features in a Vector tile.
		 * </p>
		 * @memberof Cesium3DTileStyle.prototype
		 * @type {StyleExpression}
		 * @exception {DeveloperError} The style is not loaded.  Use {@link Cesium3DTileStyle#readyPromise} or wait for {@link Cesium3DTileStyle#ready} to be true.
		 * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.
		 * @example
		 * var style = new Cesium3DTileStyle({
		 *     labelHorizontalOrigin : HorizontalOrigin.LEFT
		 * });
		 * style.labelHorizontalOrigin.evaluate(feature); // returns a HorizontalOrigin
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override labelHorizontalOrigin expression with a custom function
		 * style.labelHorizontalOrigin = {
		 *     evaluate : function(feature) {
		 *         return HorizontalOrigin.CENTER;
		 *     }
		 * };
		 */
		labelHorizontalOrigin: StyleExpression;

		/**
		 * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>labelVerticalOrigin</code> property. Alternatively a string or object defining a number style can be used.
		 * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
		 * <p>
		 * The expression must return a <code>VerticalOrigin</code>.
		 * </p>
		 * <p>
		 * This expression is only applicable to point features in a Vector tile.
		 * </p>
		 * @memberof Cesium3DTileStyle.prototype
		 * @type {StyleExpression}
		 * @exception {DeveloperError} The style is not loaded.  Use {@link Cesium3DTileStyle#readyPromise} or wait for {@link Cesium3DTileStyle#ready} to be true.
		 * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.
		 * @example
		 * var style = new Cesium3DTileStyle({
		 *     labelVerticalOrigin : VerticalOrigin.TOP
		 * });
		 * style.labelVerticalOrigin.evaluate(feature); // returns a VerticalOrigin
		 * @example
		 * var style = new Cesium.Cesium3DTileStyle();
		 * // Override labelVerticalOrigin expression with a custom function
		 * style.labelVerticalOrigin = {
		 *     evaluate : function(feature) {
		 *         return VerticalOrigin.CENTER;
		 *     }
		 * };
		 */
		labelVerticalOrigin: StyleExpression;

		/**
		 * Gets or sets the object containing application-specific expression that can be explicitly
		 * evaluated, e.g., for display in a UI.
		 * @memberof Cesium3DTileStyle.prototype
		 * @type {StyleExpression}
		 * @exception {DeveloperError} The style is not loaded.  Use {@link Cesium3DTileStyle#readyPromise} or wait for {@link Cesium3DTileStyle#ready} to be true.
		 * @example
		 * var style = new Cesium3DTileStyle({
		 *     meta : {
		 *         description : '"Building id ${id} has height ${Height}."'
		 *     }
		 * });
		 * style.meta.description.evaluate(feature); // returns a String with the substituted variables
		 */
		meta: StyleExpression;

	}

	/**
	 * A ParticleEmitter that emits particles from a circle.
	 * Particles will be positioned within a circle and have initial velocities going along the z vector.
	 * @alias CircleEmitter
	 * @constructor
	 * @param {Number} [radius=1.0] The radius of the circle in meters.
	 */
	class CircleEmitter {
		constructor(radius?: number);

		/**
		 * The radius of the circle in meters.
		 * @memberof CircleEmitter.prototype
		 * @type {Number}
		 * @default 1.0
		 */
		radius: number;

		/**
		 * The angle of the cone in radians.
		 * @memberof CircleEmitter.prototype
		 * @type {Number}
		 * @default Cesium.Math.toRadians(30.0)
		 */
		angle: number;

	}

	/**
	 * A classification primitive represents a volume enclosing geometry in the {@link Scene} to be highlighted.
	 * <p>
	 * A primitive combines geometry instances with an {@link Appearance} that describes the full shading, including
	 * {@link Material} and {@link RenderState}.  Roughly, the geometry instance defines the structure and placement,
	 * and the appearance defines the visual characteristics.  Decoupling geometry and appearance allows us to mix
	 * and match most of them and add a new geometry or appearance independently of each other.
	 * Only {@link PerInstanceColorAppearance} with the same color across all instances is supported at this time when using
	 * ClassificationPrimitive directly.
	 * For full {@link Appearance} support when classifying terrain use {@link GroundPrimitive} instead.
	 * </p>
	 * <p>
	 * For correct rendering, this feature requires the EXT_frag_depth WebGL extension. For hardware that do not support this extension, there
	 * will be rendering artifacts for some viewing angles.
	 * </p>
	 * <p>
	 * Valid geometries are {@link BoxGeometry}, {@link CylinderGeometry}, {@link EllipsoidGeometry}, {@link PolylineVolumeGeometry}, and {@link SphereGeometry}.
	 * </p>
	 * <p>
	 * Geometries that follow the surface of the ellipsoid, such as {@link CircleGeometry}, {@link CorridorGeometry}, {@link EllipseGeometry}, {@link PolygonGeometry}, and {@link RectangleGeometry},
	 * are also valid if they are extruded volumes; otherwise, they will not be rendered.
	 * </p>
	 * @alias ClassificationPrimitive
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Array|GeometryInstance} [options.geometryInstances] The geometry instances to render. This can either be a single instance or an array of length one.
	 * @param {Appearance} [options.appearance] The appearance used to render the primitive. Defaults to PerInstanceColorAppearance when GeometryInstances have a color attribute.
	 * @param {Boolean} [options.show=true] Determines if this primitive will be shown.
	 * @param {Boolean} [options.vertexCacheOptimize=false] When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.
	 * @param {Boolean} [options.interleave=false] When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.
	 * @param {Boolean} [options.compressVertices=true] When <code>true</code>, the geometry vertices are compressed, which will save memory.
	 * @param {Boolean} [options.releaseGeometryInstances=true] When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
	 * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.
	 * @param {Boolean} [options.asynchronous=true] Determines if the primitive will be created asynchronously or block until ready. If false initializeTerrainHeights() must be called first.
	 * @param {ClassificationType} [options.classificationType=ClassificationType.BOTH] Determines whether terrain, 3D Tiles or both will be classified.
	 * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.
	 * @param {Boolean} [options.debugShowShadowVolume=false] For debugging only. Determines if the shadow volume for each geometry in the primitive is drawn. Must be <code>true</code> on
	 *                  creation for the volumes to be created before the geometry is released or options.releaseGeometryInstance must be <code>false</code>.
	 * @see Primitive
	 * @see GroundPrimitive
	 * @see GeometryInstance
	 * @see Appearance
	 */
	class ClassificationPrimitive {
		constructor(options?: {
			geometryInstances?: any[] | GeometryInstance;
			appearance?: Appearance;
			show?: boolean;
			vertexCacheOptimize?: boolean;
			interleave?: boolean;
			compressVertices?: boolean;
			releaseGeometryInstances?: boolean;
			allowPicking?: boolean;
			asynchronous?: boolean;
			classificationType?: any;
			debugShowBoundingVolume?: boolean;
			debugShowShadowVolume?: boolean;
		});

		/**
		 * The geometry instance rendered with this primitive.  This may
		 * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>
		 * is <code>true</code> when the primitive is constructed.
		 * <p>
		 * Changing this property after the primitive is rendered has no effect.
		 * </p>
		 * <p>
		 * Because of the rendering technique used, all geometry instances must be the same color.
		 * If there is an instance with a differing color, a <code>DeveloperError</code> will be thrown
		 * on the first attempt to render.
		 * </p>
		 * @readonly
		 * @type {Array|GeometryInstance}
		 * @default undefined
		 */
		readonly geometryInstances: any[] | GeometryInstance;

		/**
		 * Determines if the primitive will be shown.  This affects all geometry
		 * instances in the primitive.
		 * @type {Boolean}
		 * @default true
		 */
		show: boolean;

		/**
		 * Determines whether terrain, 3D Tiles or both will be classified.
		 * @type {ClassificationType}
		 * @default ClassificationType.BOTH
		 */
		classificationType: any;

		/**
		 * This property is for debugging only; it is not for production use nor is it optimized.
		 * <p>
		 * Draws the bounding sphere for each draw command in the primitive.
		 * </p>
		 * @type {Boolean}
		 * @default false
		 */
		debugShowBoundingVolume: boolean;

		/**
		 * This property is for debugging only; it is not for production use nor is it optimized.
		 * <p>
		 * Draws the shadow volume for each geometry in the primitive.
		 * </p>
		 * @type {Boolean}
		 * @default false
		 */
		debugShowShadowVolume: boolean;

		/**
		 * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.
		 * @memberof ClassificationPrimitive.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		readonly vertexCacheOptimize: boolean;

		/**
		 * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.
		 * @memberof ClassificationPrimitive.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default false
		 */
		readonly interleave: boolean;

		/**
		 * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
		 * @memberof ClassificationPrimitive.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		readonly releaseGeometryInstances: boolean;

		/**
		 * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.
		 * @memberof ClassificationPrimitive.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		readonly allowPicking: boolean;

		/**
		 * Determines if the geometry instances will be created and batched on a web worker.
		 * @memberof ClassificationPrimitive.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		readonly asynchronous: boolean;

		/**
		 * When <code>true</code>, geometry vertices are compressed, which will save memory.
		 * @memberof ClassificationPrimitive.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		readonly compressVertices: boolean;

		/**
		 * Determines if the primitive is complete and ready to render.  If this property is
		 * true, the primitive will be rendered the next time that {@link ClassificationPrimitive#update}
		 * is called.
		 * @memberof ClassificationPrimitive.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly ready: boolean;

		/**
		 * Gets a promise that resolves when the primitive is ready to render.
		 * @memberof ClassificationPrimitive.prototype
		 * @type {Promise.<ClassificationPrimitive>}
		 * @readonly
		 */
		readonly readyPromise: any;

		/**
		 * Determines if ClassificationPrimitive rendering is supported.
		 * @param {Scene} scene The scene.
		 * @returns {Boolean} <code>true</code> if ClassificationPrimitives are supported; otherwise, returns <code>false</code>
		 */
		static isSupported(scene: Scene): boolean;

		/**
		 * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
		 * get the draw commands needed to render this primitive.
		 * <p>
		 * Do not call this function directly.  This is documented just to
		 * list the exceptions that may be propagated when the scene is rendered:
		 * </p>
		 * @exception {DeveloperError} All instance geometries must have the same primitiveType.
		 * @exception {DeveloperError} Appearance and material have a uniform with the same name.
		 * @exception {DeveloperError} Not all of the geometry instances have the same color attribute.
		 */
		update(): void;

		/**
		 * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.
		 * @param {*} id The id of the {@link GeometryInstance}.
		 * @returns {Object} The typed array in the attribute's format or undefined if the is no instance with id.
		 * @exception {DeveloperError} must call update before calling getGeometryInstanceAttributes.
		 * @example
		 * var attributes = primitive.getGeometryInstanceAttributes('an id');
		 * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);
		 * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);
		 */
		getGeometryInstanceAttributes(id: any): any;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <p>
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * </p>
		 * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
		 * @see ClassificationPrimitive#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
		 * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
		 * <p>
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * </p>
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * e = e && e.destroy();
		 * @see ClassificationPrimitive#isDestroyed
		 */
		destroy(): void;

	}

	/**
	 * Whether a classification affects terrain, 3D Tiles or both.
	 * @exports ClassificationType
	 */
	namespace ClassificationType {
		/**
		 * Only terrain will be classified.
		 * @type {Number}
		 * @constant
		 */
		const TERRAIN: number;

		/**
		 * Only 3D Tiles will be classified.
		 * @type {Number}
		 * @constant
		 */
		const CESIUM_3D_TILE: number;

		/**
		 * Both terrain and 3D Tiles will be classified.
		 * @type {Number}
		 * @constant
		 */
		const BOTH: number;

	}

	/**
	 * A Plane in Hessian Normal form to be used with {@link ClippingPlaneCollection}.
	 * Compatible with mathematics functions in {@link Plane}
	 * @alias ClippingPlane
	 * @constructor
	 * @param {Cartesian3} normal The plane's normal (normalized).
	 * @param {Number} distance The shortest distance from the origin to the plane.  The sign of
	 * <code>distance</code> determines which side of the plane the origin
	 * is on.  If <code>distance</code> is positive, the origin is in the half-space
	 * in the direction of the normal; if negative, the origin is in the half-space
	 * opposite to the normal; if zero, the plane passes through the origin.
	 */
	class ClippingPlane {
		constructor(normal: Cartesian3, distance: number);

		/**
		 * The shortest distance from the origin to the plane.  The sign of
		 * <code>distance</code> determines which side of the plane the origin
		 * is on.  If <code>distance</code> is positive, the origin is in the half-space
		 * in the direction of the normal; if negative, the origin is in the half-space
		 * opposite to the normal; if zero, the plane passes through the origin.
		 * @type {Number}
		 * @memberof ClippingPlane.prototype
		 */
		distance: number;

		/**
		 * The plane's normal.
		 * @type {Cartesian3}
		 * @memberof ClippingPlane.prototype
		 */
		normal: Cartesian3;

		/**
		 * Create a ClippingPlane from a Plane object.
		 * @param {Plane} plane The plane containing parameters to copy
		 * @param {ClippingPlane} [result] The object on which to store the result
		 * @returns {ClippingPlane} The ClippingPlane generated from the plane's parameters.
		 */
		static fromPlane(plane: Plane, result?: ClippingPlane): ClippingPlane;

		/**
		 * Clones the ClippingPlane without setting its ownership.
		 * @param {ClippingPlane} clippingPlane The ClippingPlane to be cloned
		 * @param {ClippingPlane} [result] The object on which to store the cloned parameters.
		 * @returns {ClippingPlane} a clone of the input ClippingPlane
		 */
		static clone(clippingPlane: ClippingPlane, result?: ClippingPlane): ClippingPlane;

	}

	/**
	 * Specifies a set of clipping planes. Clipping planes selectively disable rendering in a region on the
	 * outside of the specified list of {@link ClippingPlane} objects for a single gltf model, 3D Tileset, or the globe.
	 * @alias ClippingPlaneCollection
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {ClippingPlane[]} [options.planes=[]] An array of {@link ClippingPlane} objects used to selectively disable rendering on the outside of each plane.
	 * @param {Boolean} [options.enabled=true] Determines whether the clipping planes are active.
	 * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix specifying an additional transform relative to the clipping planes original coordinate system.
	 * @param {Boolean} [options.unionClippingRegions=false] If true, a region will be clipped if included in any plane in the collection. Otherwise, the region to be clipped must intersect the regions defined by all planes in this collection.
	 * @param {Color} [options.edgeColor=Color.WHITE] The color applied to highlight the edge along which an object is clipped.
	 * @param {Number} [options.edgeWidth=0.0] The width, in pixels, of the highlight applied to the edge along which an object is clipped.
	 */
	class ClippingPlaneCollection {
		constructor(options?: {
			planes?: (ClippingPlane)[];
			enabled?: boolean;
			modelMatrix?: Matrix4;
			unionClippingRegions?: boolean;
			edgeColor?: Color;
			edgeWidth?: number;
		});

		/**
		 * The 4x4 transformation matrix specifying an additional transform relative to the clipping planes
		 * original coordinate system.
		 * @type {Matrix4}
		 * @default Matrix4.IDENTITY
		 */
		modelMatrix: Matrix4;

		/**
		 * The color applied to highlight the edge along which an object is clipped.
		 * @type {Color}
		 * @default Color.WHITE
		 */
		edgeColor: Color;

		/**
		 * The width, in pixels, of the highlight applied to the edge along which an object is clipped.
		 * @type {Number}
		 * @default 0.0
		 */
		edgeWidth: number;

		/**
		 * An event triggered when a new clipping plane is added to the collection.  Event handlers
		 * are passed the new plane and the index at which it was added.
		 * @type {Event}
		 * @default Event()
		 */
		planeAdded: Event;

		/**
		 * An event triggered when a new clipping plane is removed from the collection.  Event handlers
		 * are passed the new plane and the index from which it was removed.
		 * @type {Event}
		 * @default Event()
		 */
		planeRemoved: Event;

		/**
		 * Returns the number of planes in this collection.  This is commonly used with
		 * {@link ClippingPlaneCollection#get} to iterate over all the planes
		 * in the collection.
		 * @memberof ClippingPlaneCollection.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly length: number;

		/**
		 * If true, a region will be clipped if included in any plane in the collection. Otherwise, the region
		 * to be clipped must intersect the regions defined by all planes in this collection.
		 * @memberof ClippingPlaneCollection.prototype
		 * @type {Boolean}
		 * @default false
		 */
		unionClippingRegions: boolean;

		/**
		 * If true, clipping will be enabled.
		 * @memberof ClippingPlaneCollection.prototype
		 * @type {Boolean}
		 * @default true
		 */
		enabled: boolean;

		/**
		 * Adds the specified {@link ClippingPlane} to the collection to be used to selectively disable rendering
		 * on the outside of each plane. Use {@link ClippingPlaneCollection#unionClippingRegions} to modify
		 * how modify the clipping behavior of multiple planes.
		 * @param {ClippingPlane} plane The ClippingPlane to add to the collection.
		 * @see ClippingPlaneCollection#unionClippingRegions
		 * @see ClippingPlaneCollection#remove
		 * @see ClippingPlaneCollection#removeAll
		 */
		add(plane: ClippingPlane): void;

		/**
		 * Returns the plane in the collection at the specified index.  Indices are zero-based
		 * and increase as planes are added.  Removing a plane shifts all planes after
		 * it to the left, changing their indices.  This function is commonly used with
		 * {@link ClippingPlaneCollection#length} to iterate over all the planes
		 * in the collection.
		 * @param {Number} index The zero-based index of the plane.
		 * @returns {ClippingPlane} The ClippingPlane at the specified index.
		 * @see ClippingPlaneCollection#length
		 */
		get(index: number): ClippingPlane;

		/**
		 * Checks whether this collection contains a ClippingPlane equal to the given ClippingPlane.
		 * @param {ClippingPlane} [clippingPlane] The ClippingPlane to check for.
		 * @returns {Boolean} true if this collection contains the ClippingPlane, false otherwise.
		 * @see ClippingPlaneCollection#get
		 */
		contains(clippingPlane?: ClippingPlane): boolean;

		/**
		 * Removes the first occurrence of the given ClippingPlane from the collection.
		 * @param {ClippingPlane} clippingPlane
		 * @returns {Boolean} <code>true</code> if the plane was removed; <code>false</code> if the plane was not found in the collection.
		 * @see ClippingPlaneCollection#add
		 * @see ClippingPlaneCollection#contains
		 * @see ClippingPlaneCollection#removeAll
		 */
		remove(clippingPlane: ClippingPlane): boolean;

		/**
		 * Removes all planes from the collection.
		 * @see ClippingPlaneCollection#add
		 * @see ClippingPlaneCollection#remove
		 */
		removeAll(): void;

		/**
		 * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
		 * build the resources for clipping planes.
		 * <p>
		 * Do not call this function directly.
		 * </p>
		 */
		update(): void;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <br /><br />
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
		 * @see ClippingPlaneCollection#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
		 * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
		 * <br /><br />
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * clippingPlanes = clippingPlanes && clippingPlanes .destroy();
		 * @see ClippingPlaneCollection#isDestroyed
		 */
		destroy(): void;

	}

	/**
	 * Defines different modes for blending between a target color and a primitive's source color.
	 * HIGHLIGHT multiplies the source color by the target color
	 * REPLACE replaces the source color with the target color
	 * MIX blends the source color and target color together
	 * @exports ColorBlendMode
	 * @see Model.colorBlendMode
	 */
	namespace ColorBlendMode {
	}

	/**
	 * An expression for a style applied to a {@link Cesium3DTileset}.
	 * <p>
	 * Evaluates a conditions expression defined using the
	 * {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification/Styling|3D Tiles Styling language}.
	 * </p>
	 * <p>
	 * Implements the {@link StyleExpression} interface.
	 * </p>
	 * @alias ConditionsExpression
	 * @constructor
	 * @param {Object} [conditionsExpression] The conditions expression defined using the 3D Tiles Styling language.
	 * @param {Object} [defines] Defines in the style.
	 * @example
	 * var expression = new Cesium.ConditionsExpression({
	 *     conditions : [
	 *         ['${Area} > 10, 'color("#FF0000")'],
	 *         ['${id} !== "1"', 'color("#00FF00")'],
	 *         ['true', 'color("#FFFFFF")']
	 *     ]
	 * });
	 * expression.evaluateColor(feature, result); // returns a Cesium.Color object
	 */
	class ConditionsExpression {
		constructor(conditionsExpression?: any, defines?: any);

		/**
		 * Gets the conditions expression defined in the 3D Tiles Styling language.
		 * @memberof ConditionsExpression.prototype
		 * @type {Object}
		 * @readonly
		 * @default undefined
		 */
		readonly conditionsExpression: any;

		/**
		 * Evaluates the result of an expression, optionally using the provided feature's properties. If the result of
		 * the expression in the
		 * {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification/Styling|3D Tiles Styling language}
		 * is of type <code>Boolean</code>, <code>Number</code>, or <code>String</code>, the corresponding JavaScript
		 * primitive type will be returned. If the result is a <code>RegExp</code>, a Javascript <code>RegExp</code>
		 * object will be returned. If the result is a <code>Cartesian2</code>, <code>Cartesian3</code>, or <code>Cartesian4</code>,
		 * a {@link Cartesian2}, {@link Cartesian3}, or {@link Cartesian4} object will be returned. If the <code>result</code> argument is
		 * a {@link Color}, the {@link Cartesian4} value is converted to a {@link Color} and then returned.
		 * @param {Cesium3DTileFeature} feature The feature whose properties may be used as variables in the expression.
		 * @param {Object} [result] The object onto which to store the result.
		 * @returns {Boolean|Number|String|RegExp|Cartesian2|Cartesian3|Cartesian4|Color} The result of evaluating the expression.
		 */
		evaluate(feature: Cesium3DTileFeature, result?: any): boolean | number | string | RegExp | Cartesian2 | Cartesian3 | Cartesian4 | Color;

		/**
		 * Evaluates the result of a Color expression, using the values defined by a feature.
		 * <p>
		 * This is equivalent to {@link ConditionsExpression#evaluate} but always returns a {@link Color} object.
		 * </p>
		 * @param {Cesium3DTileFeature} feature The feature whose properties may be used as variables in the expression.
		 * @param {Color} [result] The object in which to store the result
		 * @returns {Color} The modified result parameter or a new Color instance if one was not provided.
		 */
		evaluateColor(feature: Cesium3DTileFeature, result?: Color): Color;

	}

	/**
	 * A ParticleEmitter that emits particles within a cone.
	 * Particles will be positioned at the tip of the cone and have initial velocities going towards the base.
	 * @alias ConeEmitter
	 * @constructor
	 * @param {Number} [angle=Cesium.Math.toRadians(30.0)] The angle of the cone in radians.
	 */
	class ConeEmitter {
		constructor(angle?: number);

	}

	/**
	 * Creates a {@link UrlTemplateImageryProvider} instance that provides tiled imagery hosted by OpenStreetMap
	 * or another provider of Slippy tiles.  The default url connects to OpenStreetMap's volunteer-run
	 * servers, so you must conform to their
	 * {@link http://wiki.openstreetmap.org/wiki/Tile_usage_policy|Tile Usage Policy}.
	 * @exports createOpenStreetMapImageryProvider
	 * @param {Object} [options] Object with the following properties:
	 * @param {String} [options.url='https://a.tile.openstreetmap.org'] The OpenStreetMap server url.
	 * @param {String} [options.fileExtension='png'] The file extension for images on the server.
	 * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle of the layer.
	 * @param {Number} [options.minimumLevel=0] The minimum level-of-detail supported by the imagery provider.
	 * @param {Number} [options.maximumLevel] The maximum level-of-detail supported by the imagery provider, or undefined if there is no limit.
	 * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If not specified, the WGS84 ellipsoid is used.
	 * @param {Credit|String} [options.credit='MapQuest, Open Street Map and contributors, CC-BY-SA'] A credit for the data source, which is displayed on the canvas.
	 * @returns {UrlTemplateImageryProvider} The imagery provider.
	 * @exception {DeveloperError} The rectangle and minimumLevel indicate that there are more than four tiles at the minimum level. Imagery providers with more than four tiles at the minimum level are not supported.
	 * @see ArcGisMapServerImageryProvider
	 * @see BingMapsImageryProvider
	 * @see GoogleEarthEnterpriseMapsProvider
	 * @see SingleTileImageryProvider
	 * @see createTileMapServiceImageryProvider
	 * @see WebMapServiceImageryProvider
	 * @see WebMapTileServiceImageryProvider
	 * @see UrlTemplateImageryProvider
	 * @example
	 * var osm = Cesium.createOpenStreetMapImageryProvider({
	 *     url : 'https://a.tile.openstreetmap.org/'
	 * });
	 * @see {@link http://wiki.openstreetmap.org/wiki/Main_Page|OpenStreetMap Wiki}
	 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
	 */
	namespace createOpenStreetMapImageryProvider {
	}

	/**
	 * Creates a {@link Primitive} to visualize well-known vector vertex attributes:
	 * <code>normal</code>, <code>tangent</code>, and <code>bitangent</code>.  Normal
	 * is red; tangent is green; and bitangent is blue.  If an attribute is not
	 * present, it is not drawn.
	 * @exports createTangentSpaceDebugPrimitive
	 * @param {Object} options Object with the following properties:
	 * @param {Geometry} options.geometry The <code>Geometry</code> instance with the attribute.
	 * @param {Number} [options.length=10000.0] The length of each line segment in meters.  This can be negative to point the vector in the opposite direction.
	 * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The model matrix that transforms to transform the geometry from model to world coordinates.
	 * @returns {Primitive} A new <code>Primitive</code> instance with geometry for the vectors.
	 * @example
	 * scene.primitives.add(Cesium.createTangentSpaceDebugPrimitive({
	 *    geometry : instance.geometry,
	 *    length : 100000.0,
	 *    modelMatrix : instance.modelMatrix
	 * }));
	 */
	namespace createTangentSpaceDebugPrimitive {
	}

	/**
	 * Creates a {@link UrlTemplateImageryProvider} instance that provides tiled imagery as generated by
	 * {@link http://www.maptiler.org/|MapTiler}, {@link http://www.klokan.cz/projects/gdal2tiles/|GDAL2Tiles}, etc.
	 * @exports createTileMapServiceImageryProvider
	 * @param {Object} [options] Object with the following properties:
	 * @param {Resource|String|Promise<Resource>|Promise<String>} [options.url='.'] Path to image tiles on server.
	 * @param {String} [options.fileExtension='png'] The file extension for images on the server.
	 * @param {Credit|String} [options.credit=''] A credit for the data source, which is displayed on the canvas.
	 * @param {Number} [options.minimumLevel=0] The minimum level-of-detail supported by the imagery provider.  Take care when specifying
	 *                 this that the number of tiles at the minimum level is small, such as four or less.  A larger number is likely
	 *                 to result in rendering problems.
	 * @param {Number} [options.maximumLevel] The maximum level-of-detail supported by the imagery provider, or undefined if there is no limit.
	 * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the image.
	 * @param {TilingScheme} [options.tilingScheme] The tiling scheme specifying how the ellipsoidal
	 * surface is broken into tiles.  If this parameter is not provided, a {@link WebMercatorTilingScheme}
	 * is used.
	 * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If the tilingScheme is specified,
	 *                    this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither
	 *                    parameter is specified, the WGS84 ellipsoid is used.
	 * @param {Number} [options.tileWidth=256] Pixel width of image tiles.
	 * @param {Number} [options.tileHeight=256] Pixel height of image tiles.
	 * @param {Boolean} [options.flipXY] Older versions of gdal2tiles.py flipped X and Y values in tilemapresource.xml.
	 * Specifying this option will do the same, allowing for loading of these incorrect tilesets.
	 * @returns {UrlTemplateImageryProvider} The imagery provider.
	 * @see ArcGisMapServerImageryProvider
	 * @see BingMapsImageryProvider
	 * @see GoogleEarthEnterpriseMapsProvider
	 * @see createOpenStreetMapImageryProvider
	 * @see SingleTileImageryProvider
	 * @see WebMapServiceImageryProvider
	 * @see WebMapTileServiceImageryProvider
	 * @see UrlTemplateImageryProvider
	 * @see {@link http://www.maptiler.org/|MapTiler}
	 * @see {@link http://www.klokan.cz/projects/gdal2tiles/|GDAL2Tiles}
	 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
	 * @example
	 * var tms = Cesium.createTileMapServiceImageryProvider({
	 *    url : '../images/cesium_maptiler/Cesium_Logo_Color',
	 *    fileExtension: 'png',
	 *    maximumLevel: 4,
	 *    rectangle: new Cesium.Rectangle(
	 *        Cesium.Math.toRadians(-120.0),
	 *        Cesium.Math.toRadians(20.0),
	 *        Cesium.Math.toRadians(-60.0),
	 *        Cesium.Math.toRadians(40.0))
	 * });
	 */
	namespace createTileMapServiceImageryProvider {
	}

	/**
	 * Creates an {@link IonImageryProvider} instance for ion's default global base imagery layer, currently Bing Maps.
	 * @exports createWorldImagery
	 * @param {Object} [options] Object with the following properties:
	 * @param {IonWorldImageryStyle} [options.style=IonWorldImageryStyle] The style of base imagery, only AERIAL, AERIAL_WITH_LABELS, and ROAD are currently supported.
	 * @returns {IonImageryProvider}
	 * @see Ion
	 * @example
	 * // Create Cesium World Terrain with default settings
	 * var viewer = new Cesium.Viewer('cesiumContainer', {
	 *     imageryProvider : Cesium.createWorldImagery();
	 * });
	 * @example
	 * // Create Cesium World Terrain with water and normals.
	 * var viewer = new Cesium.Viewer('cesiumContainer', {
	 *     imageryProvider : Cesium.createWorldImagery({
	 *         style: Cesium.IonWorldImageryStyle.AERIAL_WITH_LABELS
	 *     })
	 * });
	 */
	namespace createWorldImagery {
	}

	/**
	 * The credit display is responsible for displaying credits on screen.
	 * @param {HTMLElement} container The HTML element where credits will be displayed
	 * @param {String} [delimiter= ' • '] The string to separate text credits
	 * @param {HTMLElement} [viewport=document.body] The HTML element that will contain the credits popup
	 * @alias CreditDisplay
	 * @constructor
	 * @example
	 * var creditDisplay = new Cesium.CreditDisplay(creditContainer);
	 */
	class CreditDisplay {
		constructor(container: HTMLElement, delimiter?: string, viewport?: HTMLElement);

		/**
		 * The HTML element where credits will be displayed.
		 * @type {HTMLElement}
		 */
		container: HTMLElement;

		/**
		 * Adds a credit to the list of current credits to be displayed in the credit container
		 * @param {Credit} credit The credit to display
		 */
		addCredit(credit: Credit): void;

		/**
		 * Adds credits that will persist until they are removed
		 * @param {Credit} credit The credit to added to defaults
		 */
		addDefaultCredit(credit: Credit): void;

		/**
		 * Removes a default credit
		 * @param {Credit} credit The credit to be removed from defaults
		 */
		removeDefaultCredit(credit: Credit): void;

		/**
		 * Updates the credit display before a new frame is rendered.
		 */
		update(): void;

		/**
		 * Resets the credit display to a beginning of frame state, clearing out current credits.
		 */
		beginFrame(): void;

		/**
		 * Sets the credit display to the end of frame state, displaying credits from the last frame in the credit container.
		 */
		endFrame(): void;

		/**
		 * Destroys the resources held by this object.  Destroying an object allows for deterministic
		 * release of resources, instead of relying on the garbage collector to destroy this object.
		 * <br /><br />
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 */
		destroy(): void;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <br /><br />
		 * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
		 */
		isDestroyed(): boolean;

		/**
		 * Gets or sets the Cesium logo credit.
		 * @memberof CreditDisplay
		 * @type {Credit}
		 */
		static cesiumCredit: Credit;

	}

	/**
	 * Visualizes a vertex attribute by displaying it as a color for debugging.
	 * <p>
	 * Components for well-known unit-length vectors, i.e., <code>normal</code>,
	 * <code>tangent</code>, and <code>bitangent</code>, are scaled and biased
	 * from [-1.0, 1.0] to (-1.0, 1.0).
	 * </p>
	 * @alias DebugAppearance
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {String} options.attributeName The name of the attribute to visualize.
	 * @param {Boolean} [options.perInstanceAttribute=false] Boolean that determines whether this attribute is a per-instance geometry attribute.
	 * @param {String} [options.glslDatatype='vec3'] The GLSL datatype of the attribute.  Supported datatypes are <code>float</code>, <code>vec2</code>, <code>vec3</code>, and <code>vec4</code>.
	 * @param {String} [options.vertexShaderSource] Optional GLSL vertex shader source to override the default vertex shader.
	 * @param {String} [options.fragmentShaderSource] Optional GLSL fragment shader source to override the default fragment shader.
	 * @param {RenderState} [options.renderState] Optional render state to override the default render state.
	 * @exception {DeveloperError} options.glslDatatype must be float, vec2, vec3, or vec4.
	 * @example
	 * var primitive = new Cesium.Primitive({
	 *   geometryInstances : // ...
	 *   appearance : new Cesium.DebugAppearance({
	 *     attributeName : 'normal'
	 *   })
	 * });
	 */
	class DebugAppearance {
		constructor(options: {
			attributeName: string;
			perInstanceAttribute?: boolean;
			glslDatatype?: string;
			vertexShaderSource?: string;
			fragmentShaderSource?: string;
			renderState?: any;
		});

		/**
		 * This property is part of the {@link Appearance} interface, but is not
		 * used by {@link DebugAppearance} since a fully custom fragment shader is used.
		 * @type Material
		 * @default undefined
		 */
		material: Material;

		/**
		 * When <code>true</code>, the geometry is expected to appear translucent.
		 * @type {Boolean}
		 * @default false
		 */
		translucent: boolean;

		/**
		 * The GLSL source code for the vertex shader.
		 * @memberof DebugAppearance.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly vertexShaderSource: string;

		/**
		 * The GLSL source code for the fragment shader.  The full fragment shader
		 * source is built procedurally taking into account the {@link DebugAppearance#material}.
		 * Use {@link DebugAppearance#getFragmentShaderSource} to get the full source.
		 * @memberof DebugAppearance.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly fragmentShaderSource: string;

		/**
		 * The WebGL fixed-function state to use when rendering the geometry.
		 * @memberof DebugAppearance.prototype
		 * @type {Object}
		 * @readonly
		 */
		readonly renderState: any;

		/**
		 * When <code>true</code>, the geometry is expected to be closed.
		 * @memberof DebugAppearance.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default false
		 */
		readonly closed: boolean;

		/**
		 * The name of the attribute being visualized.
		 * @memberof DebugAppearance.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly attributeName: string;

		/**
		 * The GLSL datatype of the attribute being visualized.
		 * @memberof DebugAppearance.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly glslDatatype: string;

		/**
		 * Returns the full GLSL fragment shader source, which for {@link DebugAppearance} is just
		 * {@link DebugAppearance#fragmentShaderSource}.
		 * @function
		 * @returns {String} The full GLSL fragment shader source.
		 */
		getFragmentShaderSource(): string;

		/**
		 * Determines if the geometry is translucent based on {@link DebugAppearance#translucent}.
		 * @function
		 * @returns {Boolean} <code>true</code> if the appearance is translucent.
		 */
		isTranslucent(): boolean;

		/**
		 * Creates a render state.  This is not the final render state instance; instead,
		 * it can contain a subset of render state properties identical to the render state
		 * created in the context.
		 * @function
		 * @returns {Object} The render state.
		 */
		getRenderState(): any;

	}

	/**
	 * Draws the outline of the camera's view frustum.
	 * @alias DebugCameraPrimitive
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Camera} options.camera The camera.
	 * @param {Color} [options.color=Color.CYAN] The color of the debug outline.
	 * @param {Boolean} [options.updateOnChange=true] Whether the primitive updates when the underlying camera changes.
	 * @param {Boolean} [options.show=true] Determines if this primitive will be shown.
	 * @param {Object} [options.id] A user-defined object to return when the instance is picked with {@link Scene#pick}.
	 * @example
	 * primitives.add(new Cesium.DebugCameraPrimitive({
	 *   camera : camera,
	 *   color : Cesium.Color.YELLOW
	 * }));
	 */
	class DebugCameraPrimitive {
		constructor(options: {
			camera: Camera;
			color?: Color;
			updateOnChange?: boolean;
			show?: boolean;
			id?: any;
		});

		/**
		 * Determines if this primitive will be shown.
		 * @type Boolean
		 * @default true
		 */
		show: boolean;

		/**
		 * User-defined value returned when the primitive is picked.
		 * @type {*}
		 * @default undefined
		 * @see Scene#pick
		 */
		id: any;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <p>
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * </p>
		 * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
		 * @see DebugCameraPrimitive#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
		 * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
		 * <p>
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * </p>
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * p = p && p.destroy();
		 * @see DebugCameraPrimitive#isDestroyed
		 */
		destroy(): void;

	}

	/**
	 * Draws the axes of a reference frame defined by a matrix that transforms to world
	 * coordinates, i.e., Earth's WGS84 coordinates.  The most prominent example is
	 * a primitives <code>modelMatrix</code>.
	 * <p>
	 * The X axis is red; Y is green; and Z is blue.
	 * </p>
	 * <p>
	 * This is for debugging only; it is not optimized for production use.
	 * </p>
	 * @alias DebugModelMatrixPrimitive
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Number} [options.length=10000000.0] The length of the axes in meters.
	 * @param {Number} [options.width=2.0] The width of the axes in pixels.
	 * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 matrix that defines the reference frame, i.e., origin plus axes, to visualize.
	 * @param {Boolean} [options.show=true] Determines if this primitive will be shown.
	 * @param {Object} [options.id] A user-defined object to return when the instance is picked with {@link Scene#pick}
	 * @example
	 * primitives.add(new Cesium.DebugModelMatrixPrimitive({
	 *   modelMatrix : primitive.modelMatrix,  // primitive to debug
	 *   length : 100000.0,
	 *   width : 10.0
	 * }));
	 */
	class DebugModelMatrixPrimitive {
		constructor(options?: {
			length?: number;
			width?: number;
			modelMatrix?: Matrix4;
			show?: boolean;
			id?: any;
		});

		/**
		 * The length of the axes in meters.
		 * @type {Number}
		 * @default 10000000.0
		 */
		length: number;

		/**
		 * The width of the axes in pixels.
		 * @type {Number}
		 * @default 2.0
		 */
		width: number;

		/**
		 * Determines if this primitive will be shown.
		 * @type Boolean
		 * @default true
		 */
		show: boolean;

		/**
		 * The 4x4 matrix that defines the reference frame, i.e., origin plus axes, to visualize.
		 * @type {Matrix4}
		 * @default {@link Matrix4.IDENTITY}
		 */
		modelMatrix: Matrix4;

		/**
		 * User-defined value returned when the primitive is picked.
		 * @type {*}
		 * @default undefined
		 * @see Scene#pick
		 */
		id: any;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <p>
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * </p>
		 * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
		 * @see DebugModelMatrixPrimitive#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
		 * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
		 * <p>
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * </p>
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * p = p && p.destroy();
		 * @see DebugModelMatrixPrimitive#isDestroyed
		 */
		destroy(): void;

	}

	/**
	 * A policy for discarding tile images that match a known image containing a
	 * "missing" image.
	 * @alias DiscardMissingTileImagePolicy
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Resource|String} options.missingImageUrl The URL of the known missing image.
	 * @param {Cartesian2[]} options.pixelsToCheck An array of {@link Cartesian2} pixel positions to
	 *        compare against the missing image.
	 * @param {Boolean} [options.disableCheckIfAllPixelsAreTransparent=false] If true, the discard check will be disabled
	 *                  if all of the pixelsToCheck in the missingImageUrl have an alpha value of 0.  If false, the
	 *                  discard check will proceed no matter the values of the pixelsToCheck.
	 */
	class DiscardMissingTileImagePolicy {
		constructor(options: {
			missingImageUrl: Resource | string;
			pixelsToCheck: (Cartesian2)[];
			disableCheckIfAllPixelsAreTransparent?: boolean;
		});

		/**
		 * Determines if the discard policy is ready to process images.
		 * @returns {Boolean} True if the discard policy is ready to process images; otherwise, false.
		 */
		isReady(): boolean;

		/**
		 * Given a tile image, decide whether to discard that image.
		 * @param {Image} image An image to test.
		 * @returns {Boolean} True if the image should be discarded; otherwise, false.
		 * @exception {DeveloperError} <code>shouldDiscardImage</code> must not be called before the discard policy is ready.
		 */
		shouldDiscardImage(image: any): boolean;

	}

	/**
	 * An appearance for geometry on the surface of the ellipsoid like {@link PolygonGeometry}
	 * and {@link RectangleGeometry}, which supports all materials like {@link MaterialAppearance}
	 * with {@link MaterialAppearance.MaterialSupport.ALL}.  However, this appearance requires
	 * fewer vertex attributes since the fragment shader can procedurally compute <code>normal</code>,
	 * <code>tangent</code>, and <code>bitangent</code>.
	 * @alias EllipsoidSurfaceAppearance
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Boolean} [options.flat=false] When <code>true</code>, flat shading is used in the fragment shader, which means lighting is not taking into account.
	 * @param {Boolean} [options.faceForward=options.aboveGround] When <code>true</code>, the fragment shader flips the surface normal as needed to ensure that the normal faces the viewer to avoid dark spots.  This is useful when both sides of a geometry should be shaded like {@link WallGeometry}.
	 * @param {Boolean} [options.translucent=true] When <code>true</code>, the geometry is expected to appear translucent so {@link EllipsoidSurfaceAppearance#renderState} has alpha blending enabled.
	 * @param {Boolean} [options.aboveGround=false] When <code>true</code>, the geometry is expected to be on the ellipsoid's surface - not at a constant height above it - so {@link EllipsoidSurfaceAppearance#renderState} has backface culling enabled.
	 * @param {Material} [options.material=Material.ColorType] The material used to determine the fragment color.
	 * @param {String} [options.vertexShaderSource] Optional GLSL vertex shader source to override the default vertex shader.
	 * @param {String} [options.fragmentShaderSource] Optional GLSL fragment shader source to override the default fragment shader.
	 * @param {RenderState} [options.renderState] Optional render state to override the default render state.
	 * @see {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric|Fabric}
	 * @example
	 * var primitive = new Cesium.Primitive({
	 *   geometryInstances : new Cesium.GeometryInstance({
	 *     geometry : new Cesium.PolygonGeometry({
	 *       vertexFormat : Cesium.EllipsoidSurfaceAppearance.VERTEX_FORMAT,
	 *       // ...
	 *     })
	 *   }),
	 *   appearance : new Cesium.EllipsoidSurfaceAppearance({
	 *     material : Cesium.Material.fromType('Stripe')
	 *   })
	 * });
	 */
	class EllipsoidSurfaceAppearance {
		constructor(options?: {
			flat?: boolean;
			faceForward?: boolean;
			translucent?: boolean;
			aboveGround?: boolean;
			material?: Material;
			vertexShaderSource?: string;
			fragmentShaderSource?: string;
			renderState?: any;
		});

		/**
		 * The material used to determine the fragment color.  Unlike other {@link EllipsoidSurfaceAppearance}
		 * properties, this is not read-only, so an appearance's material can change on the fly.
		 * @type Material
		 * @default {@link Material.ColorType}
		 * @see {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric|Fabric}
		 */
		material: Material;

		/**
		 * When <code>true</code>, the geometry is expected to appear translucent.
		 * @type {Boolean}
		 * @default true
		 */
		translucent: boolean;

		/**
		 * The GLSL source code for the vertex shader.
		 * @memberof EllipsoidSurfaceAppearance.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly vertexShaderSource: string;

		/**
		 * The GLSL source code for the fragment shader.  The full fragment shader
		 * source is built procedurally taking into account {@link EllipsoidSurfaceAppearance#material},
		 * {@link EllipsoidSurfaceAppearance#flat}, and {@link EllipsoidSurfaceAppearance#faceForward}.
		 * Use {@link EllipsoidSurfaceAppearance#getFragmentShaderSource} to get the full source.
		 * @memberof EllipsoidSurfaceAppearance.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly fragmentShaderSource: string;

		/**
		 * The WebGL fixed-function state to use when rendering the geometry.
		 * <p>
		 * The render state can be explicitly defined when constructing a {@link EllipsoidSurfaceAppearance}
		 * instance, or it is set implicitly via {@link EllipsoidSurfaceAppearance#translucent}
		 * and {@link EllipsoidSurfaceAppearance#aboveGround}.
		 * </p>
		 * @memberof EllipsoidSurfaceAppearance.prototype
		 * @type {Object}
		 * @readonly
		 */
		readonly renderState: any;

		/**
		 * When <code>true</code>, the geometry is expected to be closed so
		 * {@link EllipsoidSurfaceAppearance#renderState} has backface culling enabled.
		 * If the viewer enters the geometry, it will not be visible.
		 * @memberof EllipsoidSurfaceAppearance.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default false
		 */
		readonly closed: boolean;

		/**
		 * The {@link VertexFormat} that this appearance instance is compatible with.
		 * A geometry can have more vertex attributes and still be compatible - at a
		 * potential performance cost - but it can't have less.
		 * @memberof EllipsoidSurfaceAppearance.prototype
		 * @type VertexFormat
		 * @readonly
		 * @default {@link EllipsoidSurfaceAppearance.VERTEX_FORMAT}
		 */
		readonly vertexFormat: VertexFormat;

		/**
		 * When <code>true</code>, flat shading is used in the fragment shader,
		 * which means lighting is not taking into account.
		 * @memberof EllipsoidSurfaceAppearance.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default false
		 */
		readonly flat: boolean;

		/**
		 * When <code>true</code>, the fragment shader flips the surface normal
		 * as needed to ensure that the normal faces the viewer to avoid
		 * dark spots.  This is useful when both sides of a geometry should be
		 * shaded like {@link WallGeometry}.
		 * @memberof EllipsoidSurfaceAppearance.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		readonly faceForward: boolean;

		/**
		 * When <code>true</code>, the geometry is expected to be on the ellipsoid's
		 * surface - not at a constant height above it - so {@link EllipsoidSurfaceAppearance#renderState}
		 * has backface culling enabled.
		 * @memberof EllipsoidSurfaceAppearance.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default false
		 */
		readonly aboveGround: boolean;

		/**
		 * The {@link VertexFormat} that all {@link EllipsoidSurfaceAppearance} instances
		 * are compatible with, which requires only <code>position</code> and <code>st</code>
		 * attributes.  Other attributes are procedurally computed in the fragment shader.
		 * @type VertexFormat
		 * @constant
		 */
		static VERTEX_FORMAT: VertexFormat;

		/**
		 * Procedurally creates the full GLSL fragment shader source.  For {@link EllipsoidSurfaceAppearance},
		 * this is derived from {@link EllipsoidSurfaceAppearance#fragmentShaderSource}, {@link EllipsoidSurfaceAppearance#flat},
		 * and {@link EllipsoidSurfaceAppearance#faceForward}.
		 * @function
		 * @returns {String} The full GLSL fragment shader source.
		 */
		getFragmentShaderSource(): string;

		/**
		 * Determines if the geometry is translucent based on {@link EllipsoidSurfaceAppearance#translucent} and {@link Material#isTranslucent}.
		 * @function
		 * @returns {Boolean} <code>true</code> if the appearance is translucent.
		 */
		isTranslucent(): boolean;

		/**
		 * Creates a render state.  This is not the final render state instance; instead,
		 * it can contain a subset of render state properties identical to the render state
		 * created in the context.
		 * @function
		 * @returns {Object} The render state.
		 */
		getRenderState(): any;

	}

	/**
	 * An expression for a style applied to a {@link Cesium3DTileset}.
	 * <p>
	 * Evaluates an expression defined using the
	 * {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification/Styling|3D Tiles Styling language}.
	 * </p>
	 * <p>
	 * Implements the {@link StyleExpression} interface.
	 * </p>
	 * @alias Expression
	 * @constructor
	 * @param {String} [expression] The expression defined using the 3D Tiles Styling language.
	 * @param {Object} [defines] Defines in the style.
	 * @example
	 * var expression = new Cesium.Expression('(regExp("^Chest").test(${County})) && (${YearBuilt} >= 1970)');
	 * expression.evaluate(feature); // returns true or false depending on the feature's properties
	 * @example
	 * var expression = new Cesium.Expression('(${Temperature} > 90) ? color("red") : color("white")');
	 * expression.evaluateColor(feature, result); // returns a Cesium.Color object
	 */
	class Expression {
		constructor(expression?: string, defines?: any);

		/**
		 * Gets the expression defined in the 3D Tiles Styling language.
		 * @memberof Expression.prototype
		 * @type {String}
		 * @readonly
		 * @default undefined
		 */
		readonly expression: string;

		/**
		 * Evaluates the result of an expression, optionally using the provided feature's properties. If the result of
		 * the expression in the
		 * {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification/Styling|3D Tiles Styling language}
		 * is of type <code>Boolean</code>, <code>Number</code>, or <code>String</code>, the corresponding JavaScript
		 * primitive type will be returned. If the result is a <code>RegExp</code>, a Javascript <code>RegExp</code>
		 * object will be returned. If the result is a <code>Cartesian2</code>, <code>Cartesian3</code>, or <code>Cartesian4</code>,
		 * a {@link Cartesian2}, {@link Cartesian3}, or {@link Cartesian4} object will be returned. If the <code>result</code> argument is
		 * a {@link Color}, the {@link Cartesian4} value is converted to a {@link Color} and then returned.
		 * @param {Cesium3DTileFeature} feature The feature whose properties may be used as variables in the expression.
		 * @param {Object} [result] The object onto which to store the result.
		 * @returns {Boolean|Number|String|RegExp|Cartesian2|Cartesian3|Cartesian4|Color} The result of evaluating the expression.
		 */
		evaluate(feature: Cesium3DTileFeature, result?: any): boolean | number | string | RegExp | Cartesian2 | Cartesian3 | Cartesian4 | Color;

		/**
		 * Evaluates the result of a Color expression, optionally using the provided feature's properties.
		 * <p>
		 * This is equivalent to {@link Expression#evaluate} but always returns a {@link Color} object.
		 * </p>
		 * @param {Cesium3DTileFeature} feature The feature whose properties may be used as variables in the expression.
		 * @param {Color} [result] The object in which to store the result
		 * @returns {Color} The modified result parameter or a new Color instance if one was not provided.
		 */
		evaluateColor(feature: Cesium3DTileFeature, result?: Color): Color;

	}

	/**
	 * Blends the atmosphere to geometry far from the camera for horizon views. Allows for additional
	 * performance improvements by rendering less geometry and dispatching less terrain requests.
	 * @alias Fog
	 * @constructor
	 */
	class Fog {
		constructor();

		/**
		 * <code>true</code> if fog is enabled, <code>false</code> otherwise.
		 * @type {Boolean}
		 * @default true
		 */
		enabled: boolean;

		/**
		 * A scalar that determines the density of the fog. Terrain that is in full fog are culled.
		 * The density of the fog increases as this number approaches 1.0 and becomes less dense as it approaches zero.
		 * The more dense the fog is, the more aggressively the terrain is culled. For example, if the camera is a height of
		 * 1000.0m above the ellipsoid, increasing the value to 3.0e-3 will cause many tiles close to the viewer be culled.
		 * Decreasing the value will push the fog further from the viewer, but decrease performance as more of the terrain is rendered.
		 * @type {Number}
		 * @default 2.0e-4
		 */
		density: number;

		/**
		 * A factor used to increase the screen space error of terrain tiles when they are partially in fog. The effect is to reduce
		 * the number of terrain tiles requested for rendering. If set to zero, the feature will be disabled. If the value is increased
		 * for mountainous regions, less tiles will need to be requested, but the terrain meshes near the horizon may be a noticeably
		 * lower resolution. If the value is increased in a relatively flat area, there will be little noticeable change on the horizon.
		 * @type {Number}
		 * @default 2.0
		 */
		screenSpaceErrorFactor: number;

		/**
		 * The minimum brightness of the fog color from lighting. A value of 0.0 can cause the fog to be completely black. A value of 1.0 will not affect
		 * the brightness at all.
		 * @type {Number}
		 * @default 0.1
		 */
		minimumBrightness: number;

	}

	/**
	 * Monitors the frame rate (frames per second) in a {@link Scene} and raises an event if the frame rate is
	 * lower than a threshold.  Later, if the frame rate returns to the required level, a separate event is raised.
	 * To avoid creating multiple FrameRateMonitors for a single {@link Scene}, use {@link FrameRateMonitor.fromScene}
	 * instead of constructing an instance explicitly.
	 * @alias FrameRateMonitor
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Scene} options.scene The Scene instance for which to monitor performance.
	 * @param {Number} [options.samplingWindow=5.0] The length of the sliding window over which to compute the average frame rate, in seconds.
	 * @param {Number} [options.quietPeriod=2.0] The length of time to wait at startup and each time the page becomes visible (i.e. when the user
	 *        switches back to the tab) before starting to measure performance, in seconds.
	 * @param {Number} [options.warmupPeriod=5.0] The length of the warmup period, in seconds.  During the warmup period, a separate
	 *        (usually lower) frame rate is required.
	 * @param {Number} [options.minimumFrameRateDuringWarmup=4] The minimum frames-per-second that are required for acceptable performance during
	 *        the warmup period.  If the frame rate averages less than this during any samplingWindow during the warmupPeriod, the
	 *        lowFrameRate event will be raised and the page will redirect to the redirectOnLowFrameRateUrl, if any.
	 * @param {Number} [options.minimumFrameRateAfterWarmup=8] The minimum frames-per-second that are required for acceptable performance after
	 *        the end of the warmup period.  If the frame rate averages less than this during any samplingWindow after the warmupPeriod, the
	 *        lowFrameRate event will be raised and the page will redirect to the redirectOnLowFrameRateUrl, if any.
	 */
	class FrameRateMonitor {
		constructor(options?: {
			scene: Scene;
			samplingWindow?: number;
			quietPeriod?: number;
			warmupPeriod?: number;
			minimumFrameRateDuringWarmup?: number;
			minimumFrameRateAfterWarmup?: number;
		});

		/**
		 * Gets or sets the length of the sliding window over which to compute the average frame rate, in seconds.
		 * @type {Number}
		 */
		samplingWindow: number;

		/**
		 * Gets or sets the length of time to wait at startup and each time the page becomes visible (i.e. when the user
		 * switches back to the tab) before starting to measure performance, in seconds.
		 * @type {Number}
		 */
		quietPeriod: number;

		/**
		 * Gets or sets the length of the warmup period, in seconds.  During the warmup period, a separate
		 * (usually lower) frame rate is required.
		 * @type {Number}
		 */
		warmupPeriod: number;

		/**
		 * Gets or sets the minimum frames-per-second that are required for acceptable performance during
		 * the warmup period.  If the frame rate averages less than this during any <code>samplingWindow</code> during the <code>warmupPeriod</code>, the
		 * <code>lowFrameRate</code> event will be raised and the page will redirect to the <code>redirectOnLowFrameRateUrl</code>, if any.
		 * @type {Number}
		 */
		minimumFrameRateDuringWarmup: number;

		/**
		 * Gets or sets the minimum frames-per-second that are required for acceptable performance after
		 * the end of the warmup period.  If the frame rate averages less than this during any <code>samplingWindow</code> after the <code>warmupPeriod</code>, the
		 * <code>lowFrameRate</code> event will be raised and the page will redirect to the <code>redirectOnLowFrameRateUrl</code>, if any.
		 * @type {Number}
		 */
		minimumFrameRateAfterWarmup: number;

		/**
		 * The default frame rate monitoring settings.  These settings are used when {@link FrameRateMonitor.fromScene}
		 * needs to create a new frame rate monitor, and for any settings that are not passed to the
		 * {@link FrameRateMonitor} constructor.
		 * @memberof FrameRateMonitor
		 * @type {Object}
		 */
		static defaultSettings: any;

		/**
		 * Gets the {@link FrameRateMonitor} for a given scene.  If the scene does not yet have
		 * a {@link FrameRateMonitor}, one is created with the {@link FrameRateMonitor.defaultSettings}.
		 * @param {Scene} scene The scene for which to get the {@link FrameRateMonitor}.
		 * @returns {FrameRateMonitor} The scene's {@link FrameRateMonitor}.
		 */
		static fromScene(scene: Scene): FrameRateMonitor;

		/**
		 * Gets the {@link Scene} instance for which to monitor performance.
		 * @memberof FrameRateMonitor.prototype
		 * @type {Scene}
		 */
		scene: Scene;

		/**
		 * Gets the event that is raised when a low frame rate is detected.  The function will be passed
		 * the {@link Scene} instance as its first parameter and the average number of frames per second
		 * over the sampling window as its second parameter.
		 * @memberof FrameRateMonitor.prototype
		 * @type {Event}
		 */
		lowFrameRate: Event;

		/**
		 * Gets the event that is raised when the frame rate returns to a normal level after having been low.
		 * The function will be passed the {@link Scene} instance as its first parameter and the average
		 * number of frames per second over the sampling window as its second parameter.
		 * @memberof FrameRateMonitor.prototype
		 * @type {Event}
		 */
		nominalFrameRate: Event;

		/**
		 * Gets the most recently computed average frames-per-second over the last <code>samplingWindow</code>.
		 * This property may be undefined if the frame rate has not been computed.
		 * @memberof FrameRateMonitor.prototype
		 * @type {Number}
		 */
		lastFramesPerSecond: number;

		/**
		 * Pauses monitoring of the frame rate.  To resume monitoring, {@link FrameRateMonitor#unpause}
		 * must be called once for each time this function is called.
		 * @memberof FrameRateMonitor
		 */
		pause(): void;

		/**
		 * Resumes monitoring of the frame rate.  If {@link FrameRateMonitor#pause} was called
		 * multiple times, this function must be called the same number of times in order to
		 * actually resume monitoring.
		 * @memberof FrameRateMonitor
		 */
		unpause(): void;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <br /><br />
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * @memberof FrameRateMonitor
		 * @returns {Boolean} True if this object was destroyed; otherwise, false.
		 * @see FrameRateMonitor#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Unsubscribes this instance from all events it is listening to.
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * @memberof FrameRateMonitor
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @see FrameRateMonitor#isDestroyed
		 */
		destroy(): void;

	}

	/**
	 * Describes the format in which to request GetFeatureInfo from a Web Map Service (WMS) server.
	 * @alias GetFeatureInfoFormat
	 * @constructor
	 * @param {String} type The type of response to expect from a GetFeatureInfo request.  Valid
	 *        values are 'json', 'xml', 'html', or 'text'.
	 * @param {String} [format] The info format to request from the WMS server.  This is usually a
	 *        MIME type such as 'application/json' or text/xml'.  If this parameter is not specified, the provider will request 'json'
	 *        using 'application/json', 'xml' using 'text/xml', 'html' using 'text/html', and 'text' using 'text/plain'.
	 * @param {Function} [callback] A function to invoke with the GetFeatureInfo response from the WMS server
	 *        in order to produce an array of picked {@link ImageryLayerFeatureInfo} instances.  If this parameter is not specified,
	 *        a default function for the type of response is used.
	 */
	class GetFeatureInfoFormat {
		constructor(type: string, format?: string, callback?: Function);

	}

	/**
	 * The globe rendered in the scene, including its terrain ({@link Globe#terrainProvider})
	 * and imagery layers ({@link Globe#imageryLayers}).  Access the globe using {@link Scene#globe}.
	 * @alias Globe
	 * @constructor
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] Determines the size and shape of the
	 * globe.
	 */
	class EngineGlobe {
		constructor(ellipsoid?: Ellipsoid);

		/**
		 * Determines if the globe will be shown.
		 * @type {Boolean}
		 * @default true
		 */
		show: boolean;

		/**
		 * The maximum screen-space error used to drive level-of-detail refinement.  Higher
		 * values will provide better performance but lower visual quality.
		 * @type {Number}
		 * @default 2
		 */
		maximumScreenSpaceError: number;

		/**
		 * The size of the terrain tile cache, expressed as a number of tiles.  Any additional
		 * tiles beyond this number will be freed, as long as they aren't needed for rendering
		 * this frame.  A larger number will consume more memory but will show detail faster
		 * when, for example, zooming out and then back in.
		 * @type {Number}
		 * @default 100
		 */
		tileCacheSize: number;

		/**
		 * Enable lighting the globe with the sun as a light source.
		 * @type {Boolean}
		 * @default false
		 */
		enableLighting: boolean;

		/**
		 * The distance where everything becomes lit. This only takes effect
		 * when <code>enableLighting</code> is <code>true</code>.
		 * @type {Number}
		 * @default 6500000.0
		 */
		lightingFadeOutDistance: number;

		/**
		 * The distance where lighting resumes. This only takes effect
		 * when <code>enableLighting</code> is <code>true</code>.
		 * @type {Number}
		 * @default 9000000.0
		 */
		lightingFadeInDistance: number;

		/**
		 * True if an animated wave effect should be shown in areas of the globe
		 * covered by water; otherwise, false.  This property is ignored if the
		 * <code>terrainProvider</code> does not provide a water mask.
		 * @type {Boolean}
		 * @default true
		 */
		showWaterEffect: boolean;

		/**
		 * True if primitives such as billboards, polylines, labels, etc. should be depth-tested
		 * against the terrain surface, or false if such primitives should always be drawn on top
		 * of terrain unless they're on the opposite side of the globe.  The disadvantage of depth
		 * testing primitives against terrain is that slight numerical noise or terrain level-of-detail
		 * switched can sometimes make a primitive that should be on the surface disappear underneath it.
		 * @type {Boolean}
		 * @default false
		 */
		depthTestAgainstTerrain: boolean;

		/**
		 * Determines whether the globe casts or receives shadows from each light source. Setting the globe
		 * to cast shadows may impact performance since the terrain is rendered again from the light's perspective.
		 * Currently only terrain that is in view casts shadows. By default the globe does not cast shadows.
		 * @type {ShadowMode}
		 * @default ShadowMode.RECEIVE_ONLY
		 */
		shadows: any;

		/**
		 * Gets an ellipsoid describing the shape of this globe.
		 * @memberof Globe.prototype
		 * @type {Ellipsoid}
		 */
		ellipsoid: Ellipsoid;

		/**
		 * Gets the collection of image layers that will be rendered on this globe.
		 * @memberof Globe.prototype
		 * @type {ImageryLayerCollection}
		 */
		imageryLayers: ImageryLayerCollection;

		/**
		 * Gets an event that's raised when an imagery layer is added, shown, hidden, moved, or removed.
		 * @memberof Globe.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly imageryLayersUpdatedEvent: Event;

		/**
		 * Gets an event that's raised when a surface tile is loaded and ready to be rendered.
		 * @memberof Globe.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly tileLoadedEvent: Event;

		/**
		 * Returns <code>true</code> when the tile load queue is empty, <code>false</code> otherwise.  When the load queue is empty,
		 * all terrain and imagery for the current view have been loaded.
		 * @memberof Globe.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly tilesLoaded: boolean;

		/**
		 * Gets or sets the color of the globe when no imagery is available.
		 * @memberof Globe.prototype
		 * @type {Color}
		 */
		baseColor: Color;

		/**
		 * A property specifying a {@link ClippingPlaneCollection} used to selectively disable rendering on the outside of each plane.
		 * @memberof Globe.prototype
		 * @type {ClippingPlaneCollection}
		 */
		clippingPlanes: ClippingPlaneCollection;

		/**
		 * The normal map to use for rendering waves in the ocean.  Setting this property will
		 * only have an effect if the configured terrain provider includes a water mask.
		 * @memberof Globe.prototype
		 * @type {String}
		 * @default buildModuleUrl('Assets/Textures/waterNormalsSmall.jpg')
		 */
		oceanNormalMapUrl: string;

		/**
		 * The terrain provider providing surface geometry for this globe.
		 * @type {TerrainProvider}
		 * @memberof Globe.prototype
		 * @type {TerrainProvider}
		 */
		terrainProvider: TerrainProvider;

		/**
		 * Gets an event that's raised when the terrain provider is changed
		 * @memberof Globe.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly terrainProviderChanged: Event;

		/**
		 * Gets an event that's raised when the length of the tile load queue has changed since the last render frame.  When the load queue is empty,
		 * all terrain and imagery for the current view have been loaded.  The event passes the new length of the tile load queue.
		 * @memberof Globe.prototype
		 * @type {Event}
		 */
		tileLoadProgressEvent: Event;

		/**
		 * Gets or sets the material appearance of the Globe.  This can be one of several built-in {@link Material} objects or a custom material, scripted with
		 * {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric|Fabric}.
		 * @memberof Globe.prototype
		 * @type {Material}
		 */
		material: Material;

		/**
		 * Find an intersection between a ray and the globe surface that was rendered. The ray must be given in world coordinates.
		 * @param {Ray} ray The ray to test for intersection.
		 * @param {Scene} scene The scene.
		 * @param {Cartesian3} [result] The object onto which to store the result.
		 * @returns {Cartesian3|undefined} The intersection or <code>undefined</code> if none was found.
		 * @example
		 * // find intersection of ray through a pixel and the globe
		 * var ray = viewer.camera.getPickRay(windowCoordinates);
		 * var intersection = globe.pick(ray, scene);
		 */
		pick(ray: Ray, scene: Scene, result?: Cartesian3): Cartesian3 | undefined;

		/**
		 * Get the height of the surface at a given cartographic.
		 * @param {Cartographic} cartographic The cartographic for which to find the height.
		 * @returns {Number|undefined} The height of the cartographic or undefined if it could not be found.
		 */
		getHeight(cartographic: Cartographic): number | undefined;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <br /><br />
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * @returns {Boolean} True if this object was destroyed; otherwise, false.
		 * @see Globe#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
		 * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
		 * <br /><br />
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * globe = globe && globe.destroy();
		 * @see Globe#isDestroyed
		 */
		destroy(): void;

	}

	/**
	 * Provides tiled imagery using the Google Earth Enterprise REST API.
	 * Notes: This provider is for use with the 3D Earth API of Google Earth Enterprise,
	 *        {@link GoogleEarthEnterpriseMapsProvider} should be used with 2D Maps API.
	 * @alias GoogleEarthEnterpriseImageryProvider
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Resource|String} options.url The url of the Google Earth Enterprise server hosting the imagery.
	 * @param {GoogleEarthEnterpriseMetadata} options.metadata A metadata object that can be used to share metadata requests with a GoogleEarthEnterpriseTerrainProvider.
	 * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If not specified, the WGS84 ellipsoid is used.
	 * @param {TileDiscardPolicy} [options.tileDiscardPolicy] The policy that determines if a tile
	 *        is invalid and should be discarded. If this value is not specified, a default
	 *        is to discard tiles that fail to download.
	 * @param {Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.
	 * @see GoogleEarthEnterpriseTerrainProvider
	 * @see ArcGisMapServerImageryProvider
	 * @see GoogleEarthEnterpriseMapsProvider
	 * @see createOpenStreetMapImageryProvider
	 * @see SingleTileImageryProvider
	 * @see createTileMapServiceImageryProvider
	 * @see WebMapServiceImageryProvider
	 * @see WebMapTileServiceImageryProvider
	 * @see UrlTemplateImageryProvider
	 * @example
	 * var geeMetadata = new GoogleEarthEnterpriseMetadata('http://www.earthenterprise.org/3d');
	 * var gee = new Cesium.GoogleEarthEnterpriseImageryProvider({
	 *     metadata : geeMetadata
	 * });
	 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
	 */
	class GoogleEarthEnterpriseImageryProvider {
		constructor(options: {
			url: Resource | string;
			metadata: GoogleEarthEnterpriseMetadata;
			ellipsoid?: Ellipsoid;
			tileDiscardPolicy?: TileDiscardPolicy;
			credit?: Credit | string;
		});

		/**
		 * Gets the name of the Google Earth Enterprise server url hosting the imagery.
		 * @memberof GoogleEarthEnterpriseImageryProvider.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly url: string;

		/**
		 * Gets the proxy used by this provider.
		 * @memberof GoogleEarthEnterpriseImageryProvider.prototype
		 * @type {Proxy}
		 * @readonly
		 */
		readonly proxy: Proxy;

		/**
		 * Gets the width of each tile, in pixels. This function should
		 * not be called before {@link GoogleEarthEnterpriseImageryProvider#ready} returns true.
		 * @memberof GoogleEarthEnterpriseImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly tileWidth: number;

		/**
		 * Gets the height of each tile, in pixels.  This function should
		 * not be called before {@link GoogleEarthEnterpriseImageryProvider#ready} returns true.
		 * @memberof GoogleEarthEnterpriseImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly tileHeight: number;

		/**
		 * Gets the maximum level-of-detail that can be requested.  This function should
		 * not be called before {@link GoogleEarthEnterpriseImageryProvider#ready} returns true.
		 * @memberof GoogleEarthEnterpriseImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly maximumLevel: number;

		/**
		 * Gets the minimum level-of-detail that can be requested.  This function should
		 * not be called before {@link GoogleEarthEnterpriseImageryProvider#ready} returns true.
		 * @memberof GoogleEarthEnterpriseImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly minimumLevel: number;

		/**
		 * Gets the tiling scheme used by this provider.  This function should
		 * not be called before {@link GoogleEarthEnterpriseImageryProvider#ready} returns true.
		 * @memberof GoogleEarthEnterpriseImageryProvider.prototype
		 * @type {TilingScheme}
		 * @readonly
		 */
		readonly tilingScheme: TilingScheme;

		/**
		 * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should
		 * not be called before {@link GoogleEarthEnterpriseImageryProvider#ready} returns true.
		 * @memberof GoogleEarthEnterpriseImageryProvider.prototype
		 * @type {Rectangle}
		 * @readonly
		 */
		readonly rectangle: Rectangle;

		/**
		 * Gets the tile discard policy.  If not undefined, the discard policy is responsible
		 * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
		 * returns undefined, no tiles are filtered.  This function should
		 * not be called before {@link GoogleEarthEnterpriseImageryProvider#ready} returns true.
		 * @memberof GoogleEarthEnterpriseImageryProvider.prototype
		 * @type {TileDiscardPolicy}
		 * @readonly
		 */
		readonly tileDiscardPolicy: TileDiscardPolicy;

		/**
		 * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
		 * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
		 * are passed an instance of {@link TileProviderError}.
		 * @memberof GoogleEarthEnterpriseImageryProvider.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly errorEvent: Event;

		/**
		 * Gets a value indicating whether or not the provider is ready for use.
		 * @memberof GoogleEarthEnterpriseImageryProvider.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly ready: boolean;

		/**
		 * Gets a promise that resolves to true when the provider is ready for use.
		 * @memberof GoogleEarthEnterpriseImageryProvider.prototype
		 * @type {Promise.<Boolean>}
		 * @readonly
		 */
		readonly readyPromise: any;

		/**
		 * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
		 * the source of the imagery.  This function should not be called before {@link GoogleEarthEnterpriseImageryProvider#ready} returns true.
		 * @memberof GoogleEarthEnterpriseImageryProvider.prototype
		 * @type {Credit}
		 * @readonly
		 */
		readonly credit: Credit;

		/**
		 * Gets a value indicating whether or not the images provided by this imagery provider
		 * include an alpha channel.  If this property is false, an alpha channel, if present, will
		 * be ignored.  If this property is true, any images without an alpha channel will be treated
		 * as if their alpha is 1.0 everywhere.  Setting this property to false reduces memory usage
		 * and texture upload time.
		 * @memberof GoogleEarthEnterpriseImageryProvider.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly hasAlphaChannel: boolean;

		/**
		 * Gets the credits to be displayed when a given tile is displayed.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level;
		 * @returns {Credit[]} The credits to be displayed when the tile is displayed.
		 * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.
		 */
		getTileCredits(x: number, y: number, level: number): (Credit)[];

		/**
		 * Requests the image for a given tile.  This function should
		 * not be called before {@link GoogleEarthEnterpriseImageryProvider#ready} returns true.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level.
		 * @param {Request} [request] The request object. Intended for internal use only.
		 * @returns {Promise.<Image|Canvas>|undefined} A promise for the image that will resolve when the image is available, or
		 *          undefined if there are too many active requests to the server, and the request
		 *          should be retried later.  The resolved image may be either an
		 *          Image or a Canvas DOM object.
		 * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.
		 */
		requestImage(x: number, y: number, level: number, request?: Request): any | any | undefined;

		/**
		 * Picking features is not currently supported by this imagery provider, so this function simply returns
		 * undefined.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level.
		 * @param {Number} longitude The longitude at which to pick features.
		 * @param {Number} latitude  The latitude at which to pick features.
		 * @return {Promise.<ImageryLayerFeatureInfo[]>|undefined} A promise for the picked features that will resolve when the asynchronous
		 *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}
		 *                   instances.  The array may be empty if no features are found at the given location.
		 *                   It may also be undefined if picking is not supported.
		 */
		pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): any | undefined;

	}

	/**
	 * Provides tiled imagery using the Google Earth Imagery API.
	 * Notes: This imagery provider does not work with the public Google Earth servers. It works with the
	 *        Google Earth Enterprise Server.
	 *        By default the Google Earth Enterprise server does not set the
	 *        {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing} headers. You can either
	 *        use a proxy server which adds these headers, or in the /opt/google/gehttpd/conf/gehttpd.conf
	 *        and add the 'Header set Access-Control-Allow-Origin "*"' option to the '&lt;Directory /&gt;' and
	 *        '&lt;Directory "/opt/google/gehttpd/htdocs"&gt;' directives.
	 *        This provider is for use with 2D Maps API as part of Google Earth Enterprise. For 3D Earth API uses, it
	 *        is necessary to use {@link GoogleEarthEnterpriseImageryProvider}
	 * @alias GoogleEarthEnterpriseMapsProvider
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Resource|String} options.url The url of the Google Earth server hosting the imagery.
	 * @param {Number} options.channel The channel (id) to be used when requesting data from the server.
	 *        The channel number can be found by looking at the json file located at:
	 *        earth.localdomain/default_map/query?request=Json&vars=geeServerDefs The /default_map path may
	 *        differ depending on your Google Earth Enterprise server configuration. Look for the "id" that
	 *        is associated with a "ImageryMaps" requestType. There may be more than one id available.
	 *        Example:
	 *        {
	 *          layers: [
	 *            {
	 *              id: 1002,
	 *              requestType: "ImageryMaps"
	 *            },
	 *            {
	 *              id: 1007,
	 *              requestType: "VectorMapsRaster"
	 *            }
	 *          ]
	 *        }
	 * @param {String} [options.path="/default_map"] The path of the Google Earth server hosting the imagery.
	 * @param {Number} [options.maximumLevel] The maximum level-of-detail supported by the Google Earth
	 *        Enterprise server, or undefined if there is no limit.
	 * @param {TileDiscardPolicy} [options.tileDiscardPolicy] The policy that determines if a tile
	 *        is invalid and should be discarded. To ensure that no tiles are discarded, construct and pass
	 *        a {@link NeverTileDiscardPolicy} for this parameter.
	 * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If not specified, the WGS84 ellipsoid is used.
	 * @exception {RuntimeError} Could not find layer with channel (id) of <code>options.channel</code>.
	 * @exception {RuntimeError} Could not find a version in channel (id) <code>options.channel</code>.
	 * @exception {RuntimeError} Unsupported projection <code>data.projection</code>.
	 * @see ArcGisMapServerImageryProvider
	 * @see BingMapsImageryProvider
	 * @see createOpenStreetMapImageryProvider
	 * @see SingleTileImageryProvider
	 * @see createTileMapServiceImageryProvider
	 * @see WebMapServiceImageryProvider
	 * @see WebMapTileServiceImageryProvider
	 * @see UrlTemplateImageryProvider
	 * @example
	 * var google = new Cesium.GoogleEarthEnterpriseMapsProvider({
	 *     url : 'https://earth.localdomain',
	 *     channel : 1008
	 * });
	 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
	 */
	class GoogleEarthEnterpriseMapsProvider {
		constructor(options: {
			url: Resource | string;
			channel: number;
			path?: string;
			maximumLevel?: number;
			tileDiscardPolicy?: TileDiscardPolicy;
			ellipsoid?: Ellipsoid;
		});

		/**
		 * The default {@link ImageryLayer#gamma} to use for imagery layers created for this provider.
		 * By default, this is set to 1.9.  Changing this value after creating an {@link ImageryLayer} for this provider will have
		 * no effect.  Instead, set the layer's {@link ImageryLayer#gamma} property.
		 * @type {Number}
		 * @default 1.9
		 */
		defaultGamma: number;

		/**
		 * Gets the URL of the Google Earth MapServer.
		 * @memberof GoogleEarthEnterpriseMapsProvider.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly url: string;

		/**
		 * Gets the url path of the data on the Google Earth server.
		 * @memberof GoogleEarthEnterpriseMapsProvider.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly path: string;

		/**
		 * Gets the proxy used by this provider.
		 * @memberof GoogleEarthEnterpriseMapsProvider.prototype
		 * @type {Proxy}
		 * @readonly
		 */
		readonly proxy: Proxy;

		/**
		 * Gets the imagery channel (id) currently being used.
		 * @memberof GoogleEarthEnterpriseMapsProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly channel: number;

		/**
		 * Gets the width of each tile, in pixels. This function should
		 * not be called before {@link GoogleEarthEnterpriseMapsProvider#ready} returns true.
		 * @memberof GoogleEarthEnterpriseMapsProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly tileWidth: number;

		/**
		 * Gets the height of each tile, in pixels.  This function should
		 * not be called before {@link GoogleEarthEnterpriseMapsProvider#ready} returns true.
		 * @memberof GoogleEarthEnterpriseMapsProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly tileHeight: number;

		/**
		 * Gets the maximum level-of-detail that can be requested.  This function should
		 * not be called before {@link GoogleEarthEnterpriseMapsProvider#ready} returns true.
		 * @memberof GoogleEarthEnterpriseMapsProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly maximumLevel: number;

		/**
		 * Gets the minimum level-of-detail that can be requested.  This function should
		 * not be called before {@link GoogleEarthEnterpriseMapsProvider#ready} returns true.
		 * @memberof GoogleEarthEnterpriseMapsProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly minimumLevel: number;

		/**
		 * Gets the tiling scheme used by this provider.  This function should
		 * not be called before {@link GoogleEarthEnterpriseMapsProvider#ready} returns true.
		 * @memberof GoogleEarthEnterpriseMapsProvider.prototype
		 * @type {TilingScheme}
		 * @readonly
		 */
		readonly tilingScheme: TilingScheme;

		/**
		 * Gets the version of the data used by this provider.  This function should
		 * not be called before {@link GoogleEarthEnterpriseMapsProvider#ready} returns true.
		 * @memberof GoogleEarthEnterpriseMapsProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly version: number;

		/**
		 * Gets the type of data that is being requested from the provider.  This function should
		 * not be called before {@link GoogleEarthEnterpriseMapsProvider#ready} returns true.
		 * @memberof GoogleEarthEnterpriseMapsProvider.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly requestType: string;

		/**
		 * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should
		 * not be called before {@link GoogleEarthEnterpriseMapsProvider#ready} returns true.
		 * @memberof GoogleEarthEnterpriseMapsProvider.prototype
		 * @type {Rectangle}
		 * @readonly
		 */
		readonly rectangle: Rectangle;

		/**
		 * Gets the tile discard policy.  If not undefined, the discard policy is responsible
		 * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
		 * returns undefined, no tiles are filtered.  This function should
		 * not be called before {@link GoogleEarthEnterpriseMapsProvider#ready} returns true.
		 * @memberof GoogleEarthEnterpriseMapsProvider.prototype
		 * @type {TileDiscardPolicy}
		 * @readonly
		 */
		readonly tileDiscardPolicy: TileDiscardPolicy;

		/**
		 * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
		 * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
		 * are passed an instance of {@link TileProviderError}.
		 * @memberof GoogleEarthEnterpriseMapsProvider.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly errorEvent: Event;

		/**
		 * Gets a value indicating whether or not the provider is ready for use.
		 * @memberof GoogleEarthEnterpriseMapsProvider.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly ready: boolean;

		/**
		 * Gets a promise that resolves to true when the provider is ready for use.
		 * @memberof GoogleEarthEnterpriseMapsProvider.prototype
		 * @type {Promise.<Boolean>}
		 * @readonly
		 */
		readonly readyPromise: any;

		/**
		 * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
		 * the source of the imagery.  This function should not be called before {@link GoogleEarthEnterpriseMapsProvider#ready} returns true.
		 * @memberof GoogleEarthEnterpriseMapsProvider.prototype
		 * @type {Credit}
		 * @readonly
		 */
		readonly credit: Credit;

		/**
		 * Gets a value indicating whether or not the images provided by this imagery provider
		 * include an alpha channel.  If this property is false, an alpha channel, if present, will
		 * be ignored.  If this property is true, any images without an alpha channel will be treated
		 * as if their alpha is 1.0 everywhere.  When this property is false, memory usage
		 * and texture upload time are reduced.
		 * @memberof GoogleEarthEnterpriseMapsProvider.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly hasAlphaChannel: boolean;

		/**
		 * Gets the credits to be displayed when a given tile is displayed.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level;
		 * @returns {Credit[]} The credits to be displayed when the tile is displayed.
		 * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.
		 */
		getTileCredits(x: number, y: number, level: number): (Credit)[];

		/**
		 * Requests the image for a given tile.  This function should
		 * not be called before {@link GoogleEarthEnterpriseMapsProvider#ready} returns true.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level.
		 * @param {Request} [request] The request object. Intended for internal use only.
		 * @returns {Promise.<Image|Canvas>|undefined} A promise for the image that will resolve when the image is available, or
		 *          undefined if there are too many active requests to the server, and the request
		 *          should be retried later.  The resolved image may be either an
		 *          Image or a Canvas DOM object.
		 * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.
		 */
		requestImage(x: number, y: number, level: number, request?: Request): any | any | undefined;

		/**
		 * Picking features is not currently supported by this imagery provider, so this function simply returns
		 * undefined.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level.
		 * @param {Number} longitude The longitude at which to pick features.
		 * @param {Number} latitude  The latitude at which to pick features.
		 * @return {Promise.<ImageryLayerFeatureInfo[]>|undefined} A promise for the picked features that will resolve when the asynchronous
		 *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}
		 *                   instances.  The array may be empty if no features are found at the given location.
		 *                   It may also be undefined if picking is not supported.
		 */
		pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): any | undefined;

		/**
		 * Gets or sets the URL to the Google Earth logo for display in the credit.
		 * @memberof GoogleEarthEnterpriseMapsProvider
		 * @type {String}
		 */
		static logoUrl: string;

	}

	/**
	 * An {@link ImageryProvider} that draws a wireframe grid on every tile with controllable background and glow.
	 * May be useful for custom rendering effects or debugging terrain.
	 * @alias GridImageryProvider
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {TilingScheme} [options.tilingScheme=new GeographicTilingScheme()] The tiling scheme for which to draw tiles.
	 * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If the tilingScheme is specified,
	 *                    this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither
	 *                    parameter is specified, the WGS84 ellipsoid is used.
	 * @param {Number} [options.cells=8] The number of grids cells.
	 * @param {Color} [options.color=Color(1.0, 1.0, 1.0, 0.4)] The color to draw grid lines.
	 * @param {Color} [options.glowColor=Color(0.0, 1.0, 0.0, 0.05)] The color to draw glow for grid lines.
	 * @param {Number} [options.glowWidth=6] The width of lines used for rendering the line glow effect.
	 * @param {Color} [options.backgroundColor=Color(0.0, 0.5, 0.0, 0.2)] Background fill color.
	 * @param {Number} [options.tileWidth=256] The width of the tile for level-of-detail selection purposes.
	 * @param {Number} [options.tileHeight=256] The height of the tile for level-of-detail selection purposes.
	 * @param {Number} [options.canvasSize=256] The size of the canvas used for rendering.
	 */
	class GridImageryProvider {
		constructor(options?: {
			tilingScheme?: TilingScheme;
			ellipsoid?: Ellipsoid;
			cells?: number;
			color?: Color;
			glowColor?: Color;
			glowWidth?: number;
			backgroundColor?: Color;
			tileWidth?: number;
			tileHeight?: number;
			canvasSize?: number;
		});

		/**
		 * Gets the proxy used by this provider.
		 * @memberof GridImageryProvider.prototype
		 * @type {Proxy}
		 * @readonly
		 */
		readonly proxy: Proxy;

		/**
		 * Gets the width of each tile, in pixels. This function should
		 * not be called before {@link GridImageryProvider#ready} returns true.
		 * @memberof GridImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly tileWidth: number;

		/**
		 * Gets the height of each tile, in pixels.  This function should
		 * not be called before {@link GridImageryProvider#ready} returns true.
		 * @memberof GridImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly tileHeight: number;

		/**
		 * Gets the maximum level-of-detail that can be requested.  This function should
		 * not be called before {@link GridImageryProvider#ready} returns true.
		 * @memberof GridImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly maximumLevel: number;

		/**
		 * Gets the minimum level-of-detail that can be requested.  This function should
		 * not be called before {@link GridImageryProvider#ready} returns true.
		 * @memberof GridImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly minimumLevel: number;

		/**
		 * Gets the tiling scheme used by this provider.  This function should
		 * not be called before {@link GridImageryProvider#ready} returns true.
		 * @memberof GridImageryProvider.prototype
		 * @type {TilingScheme}
		 * @readonly
		 */
		readonly tilingScheme: TilingScheme;

		/**
		 * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should
		 * not be called before {@link GridImageryProvider#ready} returns true.
		 * @memberof GridImageryProvider.prototype
		 * @type {Rectangle}
		 * @readonly
		 */
		readonly rectangle: Rectangle;

		/**
		 * Gets the tile discard policy.  If not undefined, the discard policy is responsible
		 * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
		 * returns undefined, no tiles are filtered.  This function should
		 * not be called before {@link GridImageryProvider#ready} returns true.
		 * @memberof GridImageryProvider.prototype
		 * @type {TileDiscardPolicy}
		 * @readonly
		 */
		readonly tileDiscardPolicy: TileDiscardPolicy;

		/**
		 * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
		 * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
		 * are passed an instance of {@link TileProviderError}.
		 * @memberof GridImageryProvider.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly errorEvent: Event;

		/**
		 * Gets a value indicating whether or not the provider is ready for use.
		 * @memberof GridImageryProvider.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly ready: boolean;

		/**
		 * Gets a promise that resolves to true when the provider is ready for use.
		 * @memberof GridImageryProvider.prototype
		 * @type {Promise.<Boolean>}
		 * @readonly
		 */
		readonly readyPromise: any;

		/**
		 * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
		 * the source of the imagery.  This function should not be called before {@link GridImageryProvider#ready} returns true.
		 * @memberof GridImageryProvider.prototype
		 * @type {Credit}
		 * @readonly
		 */
		readonly credit: Credit;

		/**
		 * Gets a value indicating whether or not the images provided by this imagery provider
		 * include an alpha channel.  If this property is false, an alpha channel, if present, will
		 * be ignored.  If this property is true, any images without an alpha channel will be treated
		 * as if their alpha is 1.0 everywhere.  When this property is false, memory usage
		 * and texture upload time are reduced.
		 * @memberof GridImageryProvider.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly hasAlphaChannel: boolean;

		/**
		 * Draws a grid of lines into a canvas.
		 */
		_drawGrid(): void;

		/**
		 * Render a grid into a canvas with background and glow
		 */
		_createGridCanvas(): void;

		/**
		 * Gets the credits to be displayed when a given tile is displayed.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level;
		 * @returns {Credit[]} The credits to be displayed when the tile is displayed.
		 * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.
		 */
		getTileCredits(x: number, y: number, level: number): (Credit)[];

		/**
		 * Requests the image for a given tile.  This function should
		 * not be called before {@link GridImageryProvider#ready} returns true.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level.
		 * @param {Request} [request] The request object. Intended for internal use only.
		 * @returns {Promise.<Image|Canvas>|undefined} A promise for the image that will resolve when the image is available, or
		 *          undefined if there are too many active requests to the server, and the request
		 *          should be retried later.  The resolved image may be either an
		 *          Image or a Canvas DOM object.
		 */
		requestImage(x: number, y: number, level: number, request?: Request): any | any | undefined;

		/**
		 * Picking features is not currently supported by this imagery provider, so this function simply returns
		 * undefined.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level.
		 * @param {Number} longitude The longitude at which to pick features.
		 * @param {Number} latitude  The latitude at which to pick features.
		 * @return {Promise.<ImageryLayerFeatureInfo[]>|undefined} A promise for the picked features that will resolve when the asynchronous
		 *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}
		 *                   instances.  The array may be empty if no features are found at the given location.
		 *                   It may also be undefined if picking is not supported.
		 */
		pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): any | undefined;

	}

	/**
	 * A GroundPolylinePrimitive represents a polyline draped over the terrain in the {@link Scene}.
	 * <p>
	 * Only to be used with GeometryInstances containing {@link GroundPolylineGeometry}.
	 * @alias GroundPolylinePrimitive
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Array|GeometryInstance} [options.geometryInstances] GeometryInstances containing GroundPolylineGeometry
	 * @param {Appearance} [options.appearance] The Appearance used to render the polyline. Defaults to a white color {@link Material} on a {@link PolylineMaterialAppearance}.
	 * @param {Boolean} [options.show=true] Determines if this primitive will be shown.
	 * @param {Boolean} [options.interleave=false] When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.
	 * @param {Boolean} [options.releaseGeometryInstances=true] When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
	 * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.
	 * @param {Boolean} [options.asynchronous=true] Determines if the primitive will be created asynchronously or block until ready. If false initializeTerrainHeights() must be called first.
	 * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.
	 * @param {Boolean} [options.debugShowShadowVolume=false] For debugging only. Determines if the shadow volume for each geometry in the primitive is drawn. Must be <code>true</code> on creation to have effect.
	 * @example
	 * // 1. Draw a polyline on terrain with a basic color material
	 * var instance = new Cesium.GeometryInstance({
	 *   geometry : new Cesium.GroundPolylineGeometry({
	 *      positions : Cesium.Cartesian3.fromDegreesArray([
	 *          -112.1340164450331, 36.05494287836128,
	 *          -112.08821010582645, 36.097804071380715
	 *      ]),
	 *      width : 4.0
	 *   }),
	 *   id : 'object returned when this instance is picked and to get/set per-instance attributes'
	 * });
	 * scene.groundPrimitives.add(new Cesium.GroundPolylinePrimitive({
	 *   geometryInstances : instance,
	 *   appearance : new Cesium.PolylineMaterialAppearance({
	 *     material : Cesium.Material.fromType('Color')
	 *   })
	 * }));
	 * // 2. Draw a looped polyline on terrain with per-instance color and a distance display condition.
	 * // Distance display conditions for polylines on terrain are based on an approximate terrain height
	 * // instead of true terrain height.
	 * var instance = new Cesium.GeometryInstance({
	 *   geometry : new Cesium.GroundPolylineGeometry({
	 *      positions : Cesium.Cartesian3.fromDegreesArray([
	 *          -112.1340164450331, 36.05494287836128,
	 *          -112.08821010582645, 36.097804071380715,
	 *          -112.13296079730024, 36.168769146801104
	 *      ]),
	 *      loop : true,
	 *      width : 4.0
	 *   }),
	 *   attributes : {
	 *      color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.fromCssColorString('green').withAlpha(0.7)),
	 * distanceDisplayCondition : new Cesium.DistanceDisplayConditionGeometryInstanceAttribute(1000, 30000)
	 *   },
	 *   id : 'object returned when this instance is picked and to get/set per-instance attributes'
	 * });
	 * scene.groundPrimitives.add(new Cesium.GroundPolylinePrimitive({
	 *   geometryInstances : instance,
	 *   appearance : Cesium.PolylineColorAppearance()
	 * }));
	 */
	class GroundPolylinePrimitive {
		constructor(options?: {
			geometryInstances?: any[] | GeometryInstance;
			appearance?: Appearance;
			show?: boolean;
			interleave?: boolean;
			releaseGeometryInstances?: boolean;
			allowPicking?: boolean;
			asynchronous?: boolean;
			debugShowBoundingVolume?: boolean;
			debugShowShadowVolume?: boolean;
		});

		/**
		 * The geometry instances rendered with this primitive. This may
		 * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>
		 * is <code>true</code> when the primitive is constructed.
		 * <p>
		 * Changing this property after the primitive is rendered has no effect.
		 * </p>
		 * @readonly
		 * @type {Array|GeometryInstance}
		 * @default undefined
		 */
		readonly geometryInstances: any[] | GeometryInstance;

		/**
		 * The {@link Appearance} used to shade this primitive. Each geometry
		 * instance is shaded with the same appearance.  Some appearances, like
		 * {@link PolylineColorAppearance} allow giving each instance unique
		 * properties.
		 * @type Appearance
		 * @default undefined
		 */
		appearance: Appearance;

		/**
		 * Determines if the primitive will be shown.  This affects all geometry
		 * instances in the primitive.
		 * @type {Boolean}
		 * @default true
		 */
		show: boolean;

		/**
		 * This property is for debugging only; it is not for production use nor is it optimized.
		 * <p>
		 * Draws the bounding sphere for each draw command in the primitive.
		 * </p>
		 * @type {Boolean}
		 * @default false
		 */
		debugShowBoundingVolume: boolean;

		/**
		 * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.
		 * @memberof GroundPolylinePrimitive.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default false
		 */
		readonly interleave: boolean;

		/**
		 * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
		 * @memberof GroundPolylinePrimitive.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		readonly releaseGeometryInstances: boolean;

		/**
		 * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.
		 * @memberof GroundPolylinePrimitive.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		readonly allowPicking: boolean;

		/**
		 * Determines if the geometry instances will be created and batched on a web worker.
		 * @memberof GroundPolylinePrimitive.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		readonly asynchronous: boolean;

		/**
		 * Determines if the primitive is complete and ready to render.  If this property is
		 * true, the primitive will be rendered the next time that {@link GroundPolylinePrimitive#update}
		 * is called.
		 * @memberof GroundPolylinePrimitive.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly ready: boolean;

		/**
		 * Gets a promise that resolves when the primitive is ready to render.
		 * @memberof GroundPolylinePrimitive.prototype
		 * @type {Promise.<GroundPolylinePrimitive>}
		 * @readonly
		 */
		readonly readyPromise: any;

		/**
		 * This property is for debugging only; it is not for production use nor is it optimized.
		 * <p>
		 * If true, draws the shadow volume for each geometry in the primitive.
		 * </p>
		 * @memberof GroundPolylinePrimitive.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default false
		 */
		readonly debugShowShadowVolume: boolean;

		/**
		 * Initializes the minimum and maximum terrain heights. This only needs to be called if you are creating the
		 * GroundPolylinePrimitive synchronously.
		 * @returns {Promise.<*>} A promise that will resolve once the terrain heights have been loaded.
		 */
		static initializeTerrainHeights(): any;

		/**
		 * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
		 * get the draw commands needed to render this primitive.
		 * <p>
		 * Do not call this function directly.  This is documented just to
		 * list the exceptions that may be propagated when the scene is rendered:
		 * </p>
		 * @exception {DeveloperError} For synchronous GroundPolylinePrimitives, you must call GroundPolylinePrimitives.initializeTerrainHeights() and wait for the returned promise to resolve.
		 * @exception {DeveloperError} All GeometryInstances must have color attributes to use PolylineColorAppearance with GroundPolylinePrimitive.
		 */
		update(): void;

		/**
		 * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.
		 * @param {*} id The id of the {@link GeometryInstance}.
		 * @returns {Object} The typed array in the attribute's format or undefined if the is no instance with id.
		 * @exception {DeveloperError} must call update before calling getGeometryInstanceAttributes.
		 * @example
		 * var attributes = primitive.getGeometryInstanceAttributes('an id');
		 * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);
		 * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);
		 */
		getGeometryInstanceAttributes(id: any): any;

		/**
		 * Checks if the given Scene supports GroundPolylinePrimitives.
		 * GroundPolylinePrimitives require support for the WEBGL_depth_texture extension.
		 * @param {Scene} scene The current scene.
		 * @returns {Boolean} Whether or not the current scene supports GroundPolylinePrimitives.
		 */
		static isSupported(scene: Scene): boolean;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <p>
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * </p>
		 * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
		 * @see GroundPolylinePrimitive#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
		 * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
		 * <p>
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * </p>
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * e = e && e.destroy();
		 * @see GroundPolylinePrimitive#isDestroyed
		 */
		destroy(): void;

	}

	/**
	 * A ground primitive represents geometry draped over the terrain in the {@link Scene}.
	 * <p>
	 * A primitive combines geometry instances with an {@link Appearance} that describes the full shading, including
	 * {@link Material} and {@link RenderState}.  Roughly, the geometry instance defines the structure and placement,
	 * and the appearance defines the visual characteristics.  Decoupling geometry and appearance allows us to mix
	 * and match most of them and add a new geometry or appearance independently of each other.
	 * Only {@link PerInstanceColorAppearance} with the same color across all instances is supported at this time when
	 * classifying {@link ClassificationType}.CESIUM_3D_TILE and {@link ClassificationType}.BOTH.
	 * Support for the WEBGL_depth_texture extension is required to use GeometryInstances with different PerInstanceColors
	 * or materials besides PerInstanceColorAppearance.
	 * Textured GroundPrimitives were designed for notional patterns and are not meant for precisely mapping
	 * textures to terrain - for that use case, use {@link SingleTileImageryProvider}.
	 * </p>
	 * <p>
	 * For correct rendering, this feature requires the EXT_frag_depth WebGL extension. For hardware that do not support this extension, there
	 * will be rendering artifacts for some viewing angles.
	 * </p>
	 * <p>
	 * Valid geometries are {@link CircleGeometry}, {@link CorridorGeometry}, {@link EllipseGeometry}, {@link PolygonGeometry}, and {@link RectangleGeometry}.
	 * </p>
	 * @alias GroundPrimitive
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Array|GeometryInstance} [options.geometryInstances] The geometry instances to render.
	 * @param {Appearance} [options.appearance] The appearance used to render the primitive. Defaults to a flat PerInstanceColorAppearance when GeometryInstances have a color attribute.
	 * @param {Boolean} [options.show=true] Determines if this primitive will be shown.
	 * @param {Boolean} [options.vertexCacheOptimize=false] When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.
	 * @param {Boolean} [options.interleave=false] When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.
	 * @param {Boolean} [options.compressVertices=true] When <code>true</code>, the geometry vertices are compressed, which will save memory.
	 * @param {Boolean} [options.releaseGeometryInstances=true] When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
	 * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.
	 * @param {Boolean} [options.asynchronous=true] Determines if the primitive will be created asynchronously or block until ready. If false initializeTerrainHeights() must be called first.
	 * @param {ClassificationType} [options.classificationType=ClassificationType.TERRAIN] Determines whether terrain, 3D Tiles or both will be classified.
	 * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.
	 * @param {Boolean} [options.debugShowShadowVolume=false] For debugging only. Determines if the shadow volume for each geometry in the primitive is drawn. Must be <code>true</code> on
	 *                  creation for the volumes to be created before the geometry is released or options.releaseGeometryInstance must be <code>false</code>.
	 * @example
	 * // Example 1: Create primitive with a single instance
	 * var rectangleInstance = new Cesium.GeometryInstance({
	 *   geometry : new Cesium.RectangleGeometry({
	 *     rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0)
	 *   }),
	 *   id : 'rectangle',
	 *   attributes : {
	 *     color : new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5)
	 *   }
	 * });
	 * scene.primitives.add(new Cesium.GroundPrimitive({
	 *   geometryInstances : rectangleInstance
	 * }));
	 * // Example 2: Batch instances
	 * var color = new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5); // Both instances must have the same color.
	 * var rectangleInstance = new Cesium.GeometryInstance({
	 *   geometry : new Cesium.RectangleGeometry({
	 *     rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0)
	 *   }),
	 *   id : 'rectangle',
	 *   attributes : {
	 *     color : color
	 *   }
	 * });
	 * var ellipseInstance = new Cesium.GeometryInstance({
	 *     geometry : new Cesium.EllipseGeometry({
	 *         center : Cesium.Cartesian3.fromDegrees(-105.0, 40.0),
	 *         semiMinorAxis : 300000.0,
	 *         semiMajorAxis : 400000.0
	 *     }),
	 *     id : 'ellipse',
	 *     attributes : {
	 *         color : color
	 *     }
	 * });
	 * scene.primitives.add(new Cesium.GroundPrimitive({
	 *   geometryInstances : [rectangleInstance, ellipseInstance]
	 * }));
	 * @see Primitive
	 * @see ClassificationPrimitive
	 * @see GeometryInstance
	 * @see Appearance
	 */
	class GroundPrimitive {
		constructor(options?: {
			geometryInstances?: any[] | GeometryInstance;
			appearance?: Appearance;
			show?: boolean;
			vertexCacheOptimize?: boolean;
			interleave?: boolean;
			compressVertices?: boolean;
			releaseGeometryInstances?: boolean;
			allowPicking?: boolean;
			asynchronous?: boolean;
			classificationType?: any;
			debugShowBoundingVolume?: boolean;
			debugShowShadowVolume?: boolean;
		});

		/**
		 * The {@link Appearance} used to shade this primitive. Each geometry
		 * instance is shaded with the same appearance.  Some appearances, like
		 * {@link PerInstanceColorAppearance} allow giving each instance unique
		 * properties.
		 * @type Appearance
		 * @default undefined
		 */
		appearance: Appearance;

		/**
		 * The geometry instances rendered with this primitive.  This may
		 * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>
		 * is <code>true</code> when the primitive is constructed.
		 * <p>
		 * Changing this property after the primitive is rendered has no effect.
		 * </p>
		 * @readonly
		 * @type {Array|GeometryInstance}
		 * @default undefined
		 */
		readonly geometryInstances: any[] | GeometryInstance;

		/**
		 * Determines if the primitive will be shown.  This affects all geometry
		 * instances in the primitive.
		 * @type {Boolean}
		 * @default true
		 */
		show: boolean;

		/**
		 * Determines whether terrain, 3D Tiles or both will be classified.
		 * @type {ClassificationType}
		 * @default ClassificationType.TERRAIN
		 */
		classificationType: any;

		/**
		 * This property is for debugging only; it is not for production use nor is it optimized.
		 * <p>
		 * Draws the bounding sphere for each draw command in the primitive.
		 * </p>
		 * @type {Boolean}
		 * @default false
		 */
		debugShowBoundingVolume: boolean;

		/**
		 * This property is for debugging only; it is not for production use nor is it optimized.
		 * <p>
		 * Draws the shadow volume for each geometry in the primitive.
		 * </p>
		 * @type {Boolean}
		 * @default false
		 */
		debugShowShadowVolume: boolean;

		/**
		 * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.
		 * @memberof GroundPrimitive.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		readonly vertexCacheOptimize: boolean;

		/**
		 * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.
		 * @memberof GroundPrimitive.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default false
		 */
		readonly interleave: boolean;

		/**
		 * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
		 * @memberof GroundPrimitive.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		readonly releaseGeometryInstances: boolean;

		/**
		 * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.
		 * @memberof GroundPrimitive.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		readonly allowPicking: boolean;

		/**
		 * Determines if the geometry instances will be created and batched on a web worker.
		 * @memberof GroundPrimitive.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		readonly asynchronous: boolean;

		/**
		 * When <code>true</code>, geometry vertices are compressed, which will save memory.
		 * @memberof GroundPrimitive.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		readonly compressVertices: boolean;

		/**
		 * Determines if the primitive is complete and ready to render.  If this property is
		 * true, the primitive will be rendered the next time that {@link GroundPrimitive#update}
		 * is called.
		 * @memberof GroundPrimitive.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly ready: boolean;

		/**
		 * Gets a promise that resolves when the primitive is ready to render.
		 * @memberof GroundPrimitive.prototype
		 * @type {Promise.<GroundPrimitive>}
		 * @readonly
		 */
		readonly readyPromise: any;

		/**
		 * Determines if GroundPrimitive rendering is supported.
		 * @function
		 * @param {Scene} scene The scene.
		 * @returns {Boolean} <code>true</code> if GroundPrimitives are supported; otherwise, returns <code>false</code>
		 */
		static isSupported(scene: Scene): boolean;

		/**
		 * Initializes the minimum and maximum terrain heights. This only needs to be called if you are creating the
		 * GroundPrimitive synchronously.
		 * @returns {Promise.<*>} A promise that will resolve once the terrain heights have been loaded.
		 */
		static initializeTerrainHeights(): any;

		/**
		 * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
		 * get the draw commands needed to render this primitive.
		 * <p>
		 * Do not call this function directly.  This is documented just to
		 * list the exceptions that may be propagated when the scene is rendered:
		 * </p>
		 * @exception {DeveloperError} For synchronous GroundPrimitive, you must call GroundPrimitive.initializeTerrainHeights() and wait for the returned promise to resolve.
		 * @exception {DeveloperError} All instance geometries must have the same primitiveType.
		 * @exception {DeveloperError} Appearance and material have a uniform with the same name.
		 */
		update(): void;

		/**
		 * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.
		 * @param {*} id The id of the {@link GeometryInstance}.
		 * @returns {Object} The typed array in the attribute's format or undefined if the is no instance with id.
		 * @exception {DeveloperError} must call update before calling getGeometryInstanceAttributes.
		 * @example
		 * var attributes = primitive.getGeometryInstanceAttributes('an id');
		 * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);
		 * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);
		 */
		getGeometryInstanceAttributes(id: any): any;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <p>
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * </p>
		 * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
		 * @see GroundPrimitive#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
		 * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
		 * <p>
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * </p>
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * e = e && e.destroy();
		 * @see GroundPrimitive#isDestroyed
		 */
		destroy(): void;

		/**
		 * Checks if the given Scene supports materials on GroundPrimitives.
		 * Materials on GroundPrimitives require support for the WEBGL_depth_texture extension.
		 * @param {Scene} scene The current scene.
		 * @returns {Boolean} Whether or not the current scene supports materials on GroundPrimitives.
		 */
		static supportsMaterials(scene: Scene): boolean;

	}

	/**
	 * An imagery layer that displays tiled image data from a single imagery provider
	 * on a {@link Globe}.
	 * @alias ImageryLayer
	 * @constructor
	 * @param {ImageryProvider} imageryProvider The imagery provider to use.
	 * @param {Object} [options] Object with the following properties:
	 * @param {Rectangle} [options.rectangle=imageryProvider.rectangle] The rectangle of the layer.  This rectangle
	 *        can limit the visible portion of the imagery provider.
	 * @param {Number|Function} [options.alpha=1.0] The alpha blending value of this layer, from 0.0 to 1.0.
	 *                          This can either be a simple number or a function with the signature
	 *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
	 *                          current frame state, this layer, and the x, y, and level coordinates of the
	 *                          imagery tile for which the alpha is required, and it is expected to return
	 *                          the alpha value to use for the tile.
	 * @param {Number|Function} [options.brightness=1.0] The brightness of this layer.  1.0 uses the unmodified imagery
	 *                          color.  Less than 1.0 makes the imagery darker while greater than 1.0 makes it brighter.
	 *                          This can either be a simple number or a function with the signature
	 *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
	 *                          current frame state, this layer, and the x, y, and level coordinates of the
	 *                          imagery tile for which the brightness is required, and it is expected to return
	 *                          the brightness value to use for the tile.  The function is executed for every
	 *                          frame and for every tile, so it must be fast.
	 * @param {Number|Function} [options.contrast=1.0] The contrast of this layer.  1.0 uses the unmodified imagery color.
	 *                          Less than 1.0 reduces the contrast while greater than 1.0 increases it.
	 *                          This can either be a simple number or a function with the signature
	 *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
	 *                          current frame state, this layer, and the x, y, and level coordinates of the
	 *                          imagery tile for which the contrast is required, and it is expected to return
	 *                          the contrast value to use for the tile.  The function is executed for every
	 *                          frame and for every tile, so it must be fast.
	 * @param {Number|Function} [options.hue=0.0] The hue of this layer.  0.0 uses the unmodified imagery color.
	 *                          This can either be a simple number or a function with the signature
	 *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
	 *                          current frame state, this layer, and the x, y, and level coordinates
	 *                          of the imagery tile for which the hue is required, and it is expected to return
	 *                          the contrast value to use for the tile.  The function is executed for every
	 *                          frame and for every tile, so it must be fast.
	 * @param {Number|Function} [options.saturation=1.0] The saturation of this layer.  1.0 uses the unmodified imagery color.
	 *                          Less than 1.0 reduces the saturation while greater than 1.0 increases it.
	 *                          This can either be a simple number or a function with the signature
	 *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
	 *                          current frame state, this layer, and the x, y, and level coordinates
	 *                          of the imagery tile for which the saturation is required, and it is expected to return
	 *                          the contrast value to use for the tile.  The function is executed for every
	 *                          frame and for every tile, so it must be fast.
	 * @param {Number|Function} [options.gamma=1.0] The gamma correction to apply to this layer.  1.0 uses the unmodified imagery color.
	 *                          This can either be a simple number or a function with the signature
	 *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
	 *                          current frame state, this layer, and the x, y, and level coordinates of the
	 *                          imagery tile for which the gamma is required, and it is expected to return
	 *                          the gamma value to use for the tile.  The function is executed for every
	 *                          frame and for every tile, so it must be fast.
	 * @param {ImagerySplitDirection|Function} [options.splitDirection=ImagerySplitDirection.NONE] The {@link ImagerySplitDirection} split to apply to this layer.
	 * @param {TextureMinificationFilter} [options.minificationFilter=TextureMinificationFilter.LINEAR] The
	 *                                    texture minification filter to apply to this layer. Possible values
	 *                                    are <code>TextureMinificationFilter.LINEAR</code> and
	 *                                    <code>TextureMinificationFilter.NEAREST</code>.
	 * @param {TextureMagnificationFilter} [options.magnificationFilter=TextureMagnificationFilter.LINEAR] The
	 *                                     texture minification filter to apply to this layer. Possible values
	 *                                     are <code>TextureMagnificationFilter.LINEAR</code> and
	 *                                     <code>TextureMagnificationFilter.NEAREST</code>.
	 * @param {Boolean} [options.show=true] True if the layer is shown; otherwise, false.
	 * @param {Number} [options.maximumAnisotropy=maximum supported] The maximum anisotropy level to use
	 *        for texture filtering.  If this parameter is not specified, the maximum anisotropy supported
	 *        by the WebGL stack will be used.  Larger values make the imagery look better in horizon
	 *        views.
	 * @param {Number} [options.minimumTerrainLevel] The minimum terrain level-of-detail at which to show this imagery layer,
	 *                 or undefined to show it at all levels.  Level zero is the least-detailed level.
	 * @param {Number} [options.maximumTerrainLevel] The maximum terrain level-of-detail at which to show this imagery layer,
	 *                 or undefined to show it at all levels.  Level zero is the least-detailed level.
	 */
	class ImageryLayer {
		constructor(imageryProvider: ImageryProvider, options?: {
			rectangle?: Rectangle;
			alpha?: number | (Function);
			brightness?: number | (Function);
			contrast?: number | (Function);
			hue?: number | (Function);
			saturation?: number | (Function);
			gamma?: number | (Function);
			splitDirection?: any | (Function);
			minificationFilter?: any;
			magnificationFilter?: any;
			show?: boolean;
			maximumAnisotropy?: number;
			minimumTerrainLevel?: number;
			maximumTerrainLevel?: number;
		});

		/**
		 * The alpha blending value of this layer, with 0.0 representing fully transparent and
		 * 1.0 representing fully opaque.
		 * @type {Number}
		 * @default 1.0
		 */
		alpha: number;

		/**
		 * The brightness of this layer.  1.0 uses the unmodified imagery color.  Less than 1.0
		 * makes the imagery darker while greater than 1.0 makes it brighter.
		 * @type {Number}
		 * @default {@link ImageryLayer.DEFAULT_BRIGHTNESS}
		 */
		brightness: number;

		/**
		 * The contrast of this layer.  1.0 uses the unmodified imagery color.  Less than 1.0 reduces
		 * the contrast while greater than 1.0 increases it.
		 * @type {Number}
		 * @default {@link ImageryLayer.DEFAULT_CONTRAST}
		 */
		contrast: number;

		/**
		 * The hue of this layer in radians. 0.0 uses the unmodified imagery color.
		 * @type {Number}
		 * @default {@link ImageryLayer.DEFAULT_HUE}
		 */
		hue: number;

		/**
		 * The saturation of this layer. 1.0 uses the unmodified imagery color. Less than 1.0 reduces the
		 * saturation while greater than 1.0 increases it.
		 * @type {Number}
		 * @default {@link ImageryLayer.DEFAULT_SATURATION}
		 */
		saturation: number;

		/**
		 * The gamma correction to apply to this layer.  1.0 uses the unmodified imagery color.
		 * @type {Number}
		 * @default {@link ImageryLayer.DEFAULT_GAMMA}
		 */
		gamma: number;

		/**
		 * The {@link ImagerySplitDirection} to apply to this layer.
		 * @type {ImagerySplitDirection}
		 * @default {@link ImageryLayer.DEFAULT_SPLIT}
		 */
		splitDirection: any;

		/**
		 * The {@link TextureMinificationFilter} to apply to this layer.
		 * Possible values are {@link TextureMinificationFilter.LINEAR} (the default)
		 * and {@link TextureMinificationFilter.NEAREST}.
		 * To take effect, this property must be set immediately after adding the imagery layer.
		 * Once a texture is loaded it won't be possible to change the texture filter used.
		 * @type {TextureMinificationFilter}
		 * @default {@link ImageryLayer.DEFAULT_MINIFICATION_FILTER}
		 */
		minificationFilter: any;

		/**
		 * The {@link TextureMagnificationFilter} to apply to this layer.
		 * Possible values are {@link TextureMagnificationFilter.LINEAR} (the default)
		 * and {@link TextureMagnificationFilter.NEAREST}.
		 * To take effect, this property must be set immediately after adding the imagery layer.
		 * Once a texture is loaded it won't be possible to change the texture filter used.
		 * @type {TextureMagnificationFilter}
		 * @default {@link ImageryLayer.DEFAULT_MAGNIFICATION_FILTER}
		 */
		magnificationFilter: any;

		/**
		 * Determines if this layer is shown.
		 * @type {Boolean}
		 * @default true
		 */
		show: boolean;

		/**
		 * Gets the imagery provider for this layer.
		 * @memberof ImageryLayer.prototype
		 * @type {ImageryProvider}
		 * @readonly
		 */
		readonly imageryProvider: ImageryProvider;

		/**
		 * Gets the rectangle of this layer.  If this rectangle is smaller than the rectangle of the
		 * {@link ImageryProvider}, only a portion of the imagery provider is shown.
		 * @memberof ImageryLayer.prototype
		 * @type {Rectangle}
		 * @readonly
		 */
		readonly rectangle: Rectangle;

		/**
		 * This value is used as the default brightness for the imagery layer if one is not provided during construction
		 * or by the imagery provider. This value does not modify the brightness of the imagery.
		 * @type {Number}
		 * @default 1.0
		 */
		static DEFAULT_BRIGHTNESS: number;

		/**
		 * This value is used as the default contrast for the imagery layer if one is not provided during construction
		 * or by the imagery provider. This value does not modify the contrast of the imagery.
		 * @type {Number}
		 * @default 1.0
		 */
		static DEFAULT_CONTRAST: number;

		/**
		 * This value is used as the default hue for the imagery layer if one is not provided during construction
		 * or by the imagery provider. This value does not modify the hue of the imagery.
		 * @type {Number}
		 * @default 0.0
		 */
		static DEFAULT_HUE: number;

		/**
		 * This value is used as the default saturation for the imagery layer if one is not provided during construction
		 * or by the imagery provider. This value does not modify the saturation of the imagery.
		 * @type {Number}
		 * @default 1.0
		 */
		static DEFAULT_SATURATION: number;

		/**
		 * This value is used as the default gamma for the imagery layer if one is not provided during construction
		 * or by the imagery provider. This value does not modify the gamma of the imagery.
		 * @type {Number}
		 * @default 1.0
		 */
		static DEFAULT_GAMMA: number;

		/**
		 * This value is used as the default split for the imagery layer if one is not provided during construction
		 * or by the imagery provider.
		 * @type {ImagerySplitDirection}
		 * @default ImagerySplitDirection.NONE
		 */
		static DEFAULT_SPLIT: any;

		/**
		 * This value is used as the default texture minification filter for the imagery layer if one is not provided
		 * during construction or by the imagery provider.
		 * @type {TextureMinificationFilter}
		 * @default TextureMinificationFilter.LINEAR
		 */
		static DEFAULT_MINIFICATION_FILTER: any;

		/**
		 * This value is used as the default texture magnification filter for the imagery layer if one is not provided
		 * during construction or by the imagery provider.
		 * @type {TextureMagnificationFilter}
		 * @default TextureMagnificationFilter.LINEAR
		 */
		static DEFAULT_MAGNIFICATION_FILTER: any;

		/**
		 * Gets a value indicating whether this layer is the base layer in the
		 * {@link ImageryLayerCollection}.  The base layer is the one that underlies all
		 * others.  It is special in that it is treated as if it has global rectangle, even if
		 * it actually does not, by stretching the texels at the edges over the entire
		 * globe.
		 * @returns {Boolean} true if this is the base layer; otherwise, false.
		 */
		isBaseLayer(): boolean;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <br /><br />
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * @returns {Boolean} True if this object was destroyed; otherwise, false.
		 * @see ImageryLayer#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
		 * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
		 * <br /><br />
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * imageryLayer = imageryLayer && imageryLayer.destroy();
		 * @see ImageryLayer#isDestroyed
		 */
		destroy(): void;

		/**
		 * Computes the intersection of this layer's rectangle with the imagery provider's availability rectangle,
		 * producing the overall bounds of imagery that can be produced by this layer.
		 * @returns {Promise.<Rectangle>} A promise to a rectangle which defines the overall bounds of imagery that can be produced by this layer.
		 * @example
		 * // Zoom to an imagery layer.
		 * imageryLayer.getViewableRectangle().then(function (rectangle) {
		 *     return camera.flyTo({
		 *         destination: rectangle
		 *     });
		 * });
		 */
		getViewableRectangle(): any;

	}

	/**
	 * An ordered collection of imagery layers.
	 * @alias ImageryLayerCollection
	 * @constructor
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Imagery%20Adjustment.html|Cesium Sandcastle Imagery Adjustment Demo}
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Imagery%20Layers%20Manipulation.html|Cesium Sandcastle Imagery Manipulation Demo}
	 */
	class ImageryLayerCollection {
		constructor();

		/**
		 * An event that is raised when a layer is added to the collection.  Event handlers are passed the layer that
		 * was added and the index at which it was added.
		 * @type {Event}
		 * @default Event()
		 */
		layerAdded: Event;

		/**
		 * An event that is raised when a layer is removed from the collection.  Event handlers are passed the layer that
		 * was removed and the index from which it was removed.
		 * @type {Event}
		 * @default Event()
		 */
		layerRemoved: Event;

		/**
		 * An event that is raised when a layer changes position in the collection.  Event handlers are passed the layer that
		 * was moved, its new index after the move, and its old index prior to the move.
		 * @type {Event}
		 * @default Event()
		 */
		layerMoved: Event;

		/**
		 * An event that is raised when a layer is shown or hidden by setting the
		 * {@link ImageryLayer#show} property.  Event handlers are passed a reference to this layer,
		 * the index of the layer in the collection, and a flag that is true if the layer is now
		 * shown or false if it is now hidden.
		 * @type {Event}
		 * @default Event()
		 */
		layerShownOrHidden: Event;

		/**
		 * Gets the number of layers in this collection.
		 * @memberof ImageryLayerCollection.prototype
		 * @type {Number}
		 */
		length: number;

		/**
		 * Adds a layer to the collection.
		 * @param {ImageryLayer} layer the layer to add.
		 * @param {Number} [index] the index to add the layer at.  If omitted, the layer will
		 *                         added on top of all existing layers.
		 * @exception {DeveloperError} index, if supplied, must be greater than or equal to zero and less than or equal to the number of the layers.
		 */
		add(layer: ImageryLayer, index?: number): void;

		/**
		 * Creates a new layer using the given ImageryProvider and adds it to the collection.
		 * @param {ImageryProvider} imageryProvider the imagery provider to create a new layer for.
		 * @param {Number} [index] the index to add the layer at.  If omitted, the layer will
		 *                         added on top of all existing layers.
		 * @returns {ImageryLayer} The newly created layer.
		 */
		addImageryProvider(imageryProvider: ImageryProvider, index?: number): ImageryLayer;

		/**
		 * Removes a layer from this collection, if present.
		 * @param {ImageryLayer} layer The layer to remove.
		 * @param {Boolean} [destroy=true] whether to destroy the layers in addition to removing them.
		 * @returns {Boolean} true if the layer was in the collection and was removed,
		 *                    false if the layer was not in the collection.
		 */
		remove(layer: ImageryLayer, destroy?: boolean): boolean;

		/**
		 * Removes all layers from this collection.
		 * @param {Boolean} [destroy=true] whether to destroy the layers in addition to removing them.
		 */
		removeAll(destroy?: boolean): void;

		/**
		 * Checks to see if the collection contains a given layer.
		 * @param {ImageryLayer} layer the layer to check for.
		 * @returns {Boolean} true if the collection contains the layer, false otherwise.
		 */
		contains(layer: ImageryLayer): boolean;

		/**
		 * Determines the index of a given layer in the collection.
		 * @param {ImageryLayer} layer The layer to find the index of.
		 * @returns {Number} The index of the layer in the collection, or -1 if the layer does not exist in the collection.
		 */
		indexOf(layer: ImageryLayer): number;

		/**
		 * Gets a layer by index from the collection.
		 * @param {Number} index the index to retrieve.
		 * @returns {ImageryLayer} The imagery layer at the given index.
		 */
		get(index: number): ImageryLayer;

		/**
		 * Raises a layer up one position in the collection.
		 * @param {ImageryLayer} layer the layer to move.
		 * @exception {DeveloperError} layer is not in this collection.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 */
		raise(layer: ImageryLayer): void;

		/**
		 * Lowers a layer down one position in the collection.
		 * @param {ImageryLayer} layer the layer to move.
		 * @exception {DeveloperError} layer is not in this collection.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 */
		lower(layer: ImageryLayer): void;

		/**
		 * Raises a layer to the top of the collection.
		 * @param {ImageryLayer} layer the layer to move.
		 * @exception {DeveloperError} layer is not in this collection.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 */
		raiseToTop(layer: ImageryLayer): void;

		/**
		 * Lowers a layer to the bottom of the collection.
		 * @param {ImageryLayer} layer the layer to move.
		 * @exception {DeveloperError} layer is not in this collection.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 */
		lowerToBottom(layer: ImageryLayer): void;

		/**
		 * Asynchronously determines the imagery layer features that are intersected by a pick ray.  The intersected imagery
		 * layer features are found by invoking {@link ImageryProvider#pickFeatures} for each imagery layer tile intersected
		 * by the pick ray.  To compute a pick ray from a location on the screen, use {@link Camera.getPickRay}.
		 * @param {Ray} ray The ray to test for intersection.
		 * @param {Scene} scene The scene.
		 * @return {Promise.<ImageryLayerFeatureInfo[]>|undefined} A promise that resolves to an array of features intersected by the pick ray.
		 *                                             If it can be quickly determined that no features are intersected (for example,
		 *                                             because no active imagery providers support {@link ImageryProvider#pickFeatures}
		 *                                             or because the pick ray does not intersect the surface), this function will
		 *                                             return undefined.
		 * @example
		 * var pickRay = viewer.camera.getPickRay(windowPosition);
		 * var featuresPromise = viewer.imageryLayers.pickImageryLayerFeatures(pickRay, viewer.scene);
		 * if (!Cesium.defined(featuresPromise)) {
		 *     console.log('No features picked.');
		 * } else {
		 *     Cesium.when(featuresPromise, function(features) {
		 *         // This function is called asynchronously when the list if picked features is available.
		 *         console.log('Number of features: ' + features.length);
		 *         if (features.length > 0) {
		 *             console.log('First feature name: ' + features[0].name);
		 *         }
		 *     });
		 * }
		 */
		pickImageryLayerFeatures(ray: Ray, scene: Scene): any | undefined;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <br /><br />
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * @returns {Boolean} true if this object was destroyed; otherwise, false.
		 * @see ImageryLayerCollection#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys the WebGL resources held by all layers in this collection.  Explicitly destroying this
		 * object allows for deterministic release of WebGL resources, instead of relying on the garbage
		 * collector.
		 * <br /><br />
		 * Once this object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * layerCollection = layerCollection && layerCollection.destroy();
		 * @see ImageryLayerCollection#isDestroyed
		 */
		destroy(): void;

	}

	/**
	 * Describes a rasterized feature, such as a point, polygon, polyline, etc., in an imagery layer.
	 * @alias ImageryLayerFeatureInfo
	 * @constructor
	 */
	class ImageryLayerFeatureInfo {
		constructor();

		/**
		 * Gets or sets the name of the feature.
		 * @type {String}
		 */
		name: string;

		/**
		 * Gets or sets an HTML description of the feature.  The HTML is not trusted and should
		 * be sanitized before display to the user.
		 * @type {String}
		 */
		description: string;

		/**
		 * Gets or sets the position of the feature, or undefined if the position is not known.
		 * @type {Cartographic}
		 */
		position: Cartographic;

		/**
		 * Gets or sets the raw data describing the feature.  The raw data may be in any
		 * number of formats, such as GeoJSON, KML, etc.
		 * @type {Object}
		 */
		data: any;

		/**
		 * Gets or sets the image layer of the feature.
		 * @type {Object}
		 */
		imageryLayer: any;

		/**
		 * Configures the name of this feature by selecting an appropriate property.  The name will be obtained from
		 * one of the following sources, in this order: 1) the property with the name 'name', 2) the property with the name 'title',
		 * 3) the first property containing the word 'name', 4) the first property containing the word 'title'.  If
		 * the name cannot be obtained from any of these sources, the existing name will be left unchanged.
		 * @param {Object} properties An object literal containing the properties of the feature.
		 */
		configureNameFromProperties(properties: any): void;

		/**
		 * Configures the description of this feature by creating an HTML table of properties and their values.
		 * @param {Object} properties An object literal containing the properties of the feature.
		 */
		configureDescriptionFromProperties(properties: any): void;

	}

	/**
	 * Provides imagery to be displayed on the surface of an ellipsoid.  This type describes an
	 * interface and is not intended to be instantiated directly.
	 * @alias ImageryProvider
	 * @constructor
	 * @see ArcGisMapServerImageryProvider
	 * @see BingMapsImageryProvider
	 * @see createOpenStreetMapImageryProvider
	 * @see createTileMapServiceImageryProvider
	 * @see GoogleEarthEnterpriseImageryProvider
	 * @see GoogleEarthEnterpriseMapsProvider
	 * @see GridImageryProvider
	 * @see MapboxImageryProvider
	 * @see SingleTileImageryProvider
	 * @see TileCoordinatesImageryProvider
	 * @see UrlTemplateImageryProvider
	 * @see WebMapServiceImageryProvider
	 * @see WebMapTileServiceImageryProvider
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Imagery%20Layers.html|Cesium Sandcastle Imagery Layers Demo}
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Imagery%20Layers%20Manipulation.html|Cesium Sandcastle Imagery Manipulation Demo}
	 */
	class ImageryProvider {
		constructor();

		/**
		 * Gets a value indicating whether or not the provider is ready for use.
		 * @memberof ImageryProvider.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly ready: boolean;

		/**
		 * Gets a promise that resolves to true when the provider is ready for use.
		 * @memberof ImageryProvider.prototype
		 * @type {Promise.<Boolean>}
		 * @readonly
		 */
		readonly readyPromise: any;

		/**
		 * Gets the rectangle, in radians, of the imagery provided by the instance.  This function should
		 * not be called before {@link ImageryProvider#ready} returns true.
		 * @memberof ImageryProvider.prototype
		 * @type {Rectangle}
		 * @readonly
		 */
		readonly rectangle: Rectangle;

		/**
		 * Gets the width of each tile, in pixels.  This function should
		 * not be called before {@link ImageryProvider#ready} returns true.
		 * @memberof ImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly tileWidth: number;

		/**
		 * Gets the height of each tile, in pixels.  This function should
		 * not be called before {@link ImageryProvider#ready} returns true.
		 * @memberof ImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly tileHeight: number;

		/**
		 * Gets the maximum level-of-detail that can be requested.  This function should
		 * not be called before {@link ImageryProvider#ready} returns true.
		 * @memberof ImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly maximumLevel: number;

		/**
		 * Gets the minimum level-of-detail that can be requested.  This function should
		 * not be called before {@link ImageryProvider#ready} returns true. Generally,
		 * a minimum level should only be used when the rectangle of the imagery is small
		 * enough that the number of tiles at the minimum level is small.  An imagery
		 * provider with more than a few tiles at the minimum level will lead to
		 * rendering problems.
		 * @memberof ImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly minimumLevel: number;

		/**
		 * Gets the tiling scheme used by the provider.  This function should
		 * not be called before {@link ImageryProvider#ready} returns true.
		 * @memberof ImageryProvider.prototype
		 * @type {TilingScheme}
		 * @readonly
		 */
		readonly tilingScheme: TilingScheme;

		/**
		 * Gets the tile discard policy.  If not undefined, the discard policy is responsible
		 * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
		 * returns undefined, no tiles are filtered.  This function should
		 * not be called before {@link ImageryProvider#ready} returns true.
		 * @memberof ImageryProvider.prototype
		 * @type {TileDiscardPolicy}
		 * @readonly
		 */
		readonly tileDiscardPolicy: TileDiscardPolicy;

		/**
		 * Gets an event that is raised when the imagery provider encounters an asynchronous error..  By subscribing
		 * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
		 * are passed an instance of {@link TileProviderError}.
		 * @memberof ImageryProvider.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly errorEvent: Event;

		/**
		 * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
		 * the source of the imagery. This function should
		 * not be called before {@link ImageryProvider#ready} returns true.
		 * @memberof ImageryProvider.prototype
		 * @type {Credit}
		 * @readonly
		 */
		readonly credit: Credit;

		/**
		 * Gets the proxy used by this provider.
		 * @memberof ImageryProvider.prototype
		 * @type {Proxy}
		 * @readonly
		 */
		readonly proxy: Proxy;

		/**
		 * Gets a value indicating whether or not the images provided by this imagery provider
		 * include an alpha channel.  If this property is false, an alpha channel, if present, will
		 * be ignored.  If this property is true, any images without an alpha channel will be treated
		 * as if their alpha is 1.0 everywhere.  When this property is false, memory usage
		 * and texture upload time are reduced.
		 * @memberof ImageryProvider.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly hasAlphaChannel: boolean;

		/**
		 * Gets the credits to be displayed when a given tile is displayed.
		 * @function
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level;
		 * @returns {Credit[]} The credits to be displayed when the tile is displayed.
		 * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.
		 */
		getTileCredits(x: number, y: number, level: number): (Credit)[];

		/**
		 * Requests the image for a given tile.  This function should
		 * not be called before {@link ImageryProvider#ready} returns true.
		 * @function
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level.
		 * @param {Request} [request] The request object. Intended for internal use only.
		 * @returns {Promise.<Image|Canvas>|undefined} A promise for the image that will resolve when the image is available, or
		 *          undefined if there are too many active requests to the server, and the request
		 *          should be retried later.  The resolved image may be either an
		 *          Image or a Canvas DOM object.
		 * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.
		 */
		requestImage(x: number, y: number, level: number, request?: Request): any | any | undefined;

		/**
		 * Asynchronously determines what features, if any, are located at a given longitude and latitude within
		 * a tile.  This function should not be called before {@link ImageryProvider#ready} returns true.
		 * This function is optional, so it may not exist on all ImageryProviders.
		 * @function
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level.
		 * @param {Number} longitude The longitude at which to pick features.
		 * @param {Number} latitude  The latitude at which to pick features.
		 * @return {Promise.<ImageryLayerFeatureInfo[]>|undefined} A promise for the picked features that will resolve when the asynchronous
		 *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}
		 *                   instances.  The array may be empty if no features are found at the given location.
		 *                   It may also be undefined if picking is not supported.
		 * @exception {DeveloperError} <code>pickFeatures</code> must not be called before the imagery provider is ready.
		 */
		pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): any | undefined;

		/**
		 * Loads an image from a given URL.  If the server referenced by the URL already has
		 * too many requests pending, this function will instead return undefined, indicating
		 * that the request should be retried later.
		 * @param {ImageryProvider} imageryProvider The imagery provider for the URL.
		 * @param {Resource|String} url The URL of the image.
		 * @returns {Promise.<Image|Canvas>|undefined} A promise for the image that will resolve when the image is available, or
		 *          undefined if there are too many active requests to the server, and the request
		 *          should be retried later.  The resolved image may be either an
		 *          Image or a Canvas DOM object.
		 */
		static loadImage(imageryProvider: ImageryProvider, url: Resource | string): any | any | undefined;

	}

	/**
	 * The direction to display an ImageryLayer relative to the {@link Scene#imagerySplitPosition}.
	 * @exports ImagerySplitDirection
	 * @see ImageryLayer#splitDirection
	 */
	namespace ImagerySplitDirection {
		/**
		 * Display the ImageryLayer to the left of the {@link Scene#imagerySplitPosition}.
		 * @type {Number}
		 * @constant
		 */
		const LEFT: number;

		/**
		 *  Always display the ImageryLayer.
		 * @type {Number}
		 * @constant
		 */
		const NONE: number;

		/**
		 * Display the ImageryLayer to the right of the {@link Scene#imagerySplitPosition}.
		 * @type {Number}
		 * @constant
		 */
		const RIGHT: number;

	}

	/**
	 * Provides tiled imagery using the Cesium ion REST API.
	 * @alias IonImageryProvider
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Number} options.assetId An ion imagery asset ID;
	 * @param {String} [options.accessToken=Ion.defaultAccessToken] The access token to use.
	 * @param {String|Resource} [options.server=Ion.defaultServer] The resource to the Cesium ion API server.
	 * @example
	 * viewer.imageryLayers.addImageryProvider(new Cesium.IonImageryProvider({ assetId : 23489024 }));
	 */
	class IonImageryProvider {
		constructor(options: {
			assetId: number;
			accessToken?: string;
			server?: string | Resource;
		});

		/**
		 * The default alpha blending value of this provider, with 0.0 representing fully transparent and
		 * 1.0 representing fully opaque.
		 * @type {Number}
		 * @default undefined
		 */
		defaultAlpha: number;

		/**
		 * The default brightness of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0
		 * makes the imagery darker while greater than 1.0 makes it brighter.
		 * @type {Number}
		 * @default undefined
		 */
		defaultBrightness: number;

		/**
		 * The default contrast of this provider.  1.0 uses the unmodified imagery color.  Less than 1.0 reduces
		 * the contrast while greater than 1.0 increases it.
		 * @type {Number}
		 * @default undefined
		 */
		defaultContrast: number;

		/**
		 * The default hue of this provider in radians. 0.0 uses the unmodified imagery color.
		 * @type {Number}
		 * @default undefined
		 */
		defaultHue: number;

		/**
		 * The default saturation of this provider. 1.0 uses the unmodified imagery color. Less than 1.0 reduces the
		 * saturation while greater than 1.0 increases it.
		 * @type {Number}
		 * @default undefined
		 */
		defaultSaturation: number;

		/**
		 * The default gamma correction to apply to this provider.  1.0 uses the unmodified imagery color.
		 * @type {Number}
		 * @default undefined
		 */
		defaultGamma: number;

		/**
		 * The default texture minification filter to apply to this provider.
		 * @type {TextureMinificationFilter}
		 * @default undefined
		 */
		defaultMinificationFilter: any;

		/**
		 * The default texture magnification filter to apply to this provider.
		 * @type {TextureMagnificationFilter}
		 * @default undefined
		 */
		defaultMagnificationFilter: any;

		/**
		 * Gets a value indicating whether or not the provider is ready for use.
		 * @memberof IonImageryProvider.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly ready: boolean;

		/**
		 * Gets a promise that resolves to true when the provider is ready for use.
		 * @memberof IonImageryProvider.prototype
		 * @type {Promise.<Boolean>}
		 * @readonly
		 */
		readonly readyPromise: any;

		/**
		 * Gets the rectangle, in radians, of the imagery provided by the instance.  This function should
		 * not be called before {@link IonImageryProvider#ready} returns true.
		 * @memberof IonImageryProvider.prototype
		 * @type {Rectangle}
		 * @readonly
		 */
		readonly rectangle: Rectangle;

		/**
		 * Gets the width of each tile, in pixels.  This function should
		 * not be called before {@link IonImageryProvider#ready} returns true.
		 * @memberof IonImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly tileWidth: number;

		/**
		 * Gets the height of each tile, in pixels.  This function should
		 * not be called before {@link IonImageryProvider#ready} returns true.
		 * @memberof IonImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly tileHeight: number;

		/**
		 * Gets the maximum level-of-detail that can be requested.  This function should
		 * not be called before {@link IonImageryProvider#ready} returns true.
		 * @memberof IonImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly maximumLevel: number;

		/**
		 * Gets the minimum level-of-detail that can be requested.  This function should
		 * not be called before {@link IonImageryProvider#ready} returns true. Generally,
		 * a minimum level should only be used when the rectangle of the imagery is small
		 * enough that the number of tiles at the minimum level is small.  An imagery
		 * provider with more than a few tiles at the minimum level will lead to
		 * rendering problems.
		 * @memberof IonImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly minimumLevel: number;

		/**
		 * Gets the tiling scheme used by the provider.  This function should
		 * not be called before {@link IonImageryProvider#ready} returns true.
		 * @memberof IonImageryProvider.prototype
		 * @type {TilingScheme}
		 * @readonly
		 */
		readonly tilingScheme: TilingScheme;

		/**
		 * Gets the tile discard policy.  If not undefined, the discard policy is responsible
		 * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
		 * returns undefined, no tiles are filtered.  This function should
		 * not be called before {@link IonImageryProvider#ready} returns true.
		 * @memberof IonImageryProvider.prototype
		 * @type {TileDiscardPolicy}
		 * @readonly
		 */
		readonly tileDiscardPolicy: TileDiscardPolicy;

		/**
		 * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
		 * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
		 * are passed an instance of {@link TileProviderError}.
		 * @memberof IonImageryProvider.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly errorEvent: Event;

		/**
		 * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
		 * the source of the imagery. This function should
		 * not be called before {@link IonImageryProvider#ready} returns true.
		 * @memberof IonImageryProvider.prototype
		 * @type {Credit}
		 * @readonly
		 */
		readonly credit: Credit;

		/**
		 * Gets a value indicating whether or not the images provided by this imagery provider
		 * include an alpha channel.  If this property is false, an alpha channel, if present, will
		 * be ignored.  If this property is true, any images without an alpha channel will be treated
		 * as if their alpha is 1.0 everywhere.  When this property is false, memory usage
		 * and texture upload time are reduced.
		 * @memberof IonImageryProvider.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly hasAlphaChannel: boolean;

		/**
		 * Gets the credits to be displayed when a given tile is displayed.
		 * @function
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level;
		 * @returns {Credit[]} The credits to be displayed when the tile is displayed.
		 * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.
		 */
		getTileCredits(x: number, y: number, level: number): (Credit)[];

		/**
		 * Requests the image for a given tile.  This function should
		 * not be called before {@link IonImageryProvider#ready} returns true.
		 * @function
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level.
		 * @param {Request} [request] The request object. Intended for internal use only.
		 * @returns {Promise.<Image|Canvas>|undefined} A promise for the image that will resolve when the image is available, or
		 *          undefined if there are too many active requests to the server, and the request
		 *          should be retried later.  The resolved image may be either an
		 *          Image or a Canvas DOM object.
		 * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.
		 */
		requestImage(x: number, y: number, level: number, request?: Request): any | any | undefined;

		/**
		 * Asynchronously determines what features, if any, are located at a given longitude and latitude within
		 * a tile.  This function should not be called before {@link IonImageryProvider#ready} returns true.
		 * This function is optional, so it may not exist on all ImageryProviders.
		 * @function
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level.
		 * @param {Number} longitude The longitude at which to pick features.
		 * @param {Number} latitude  The latitude at which to pick features.
		 * @return {Promise.<ImageryLayerFeatureInfo[]>|undefined} A promise for the picked features that will resolve when the asynchronous
		 *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}
		 *                   instances.  The array may be empty if no features are found at the given location.
		 *                   It may also be undefined if picking is not supported.
		 * @exception {DeveloperError} <code>pickFeatures</code> must not be called before the imagery provider is ready.
		 */
		pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): any | undefined;

	}

	/**
	 * The types of imagery provided by {@link createWorldImagery}.
	 * @exports IonWorldImageryStyle
	 */
	namespace IonWorldImageryStyle {
		/**
		 * Aerial imagery.
		 * @type {Number}
		 * @constant
		 */
		const AERIAL: number;

		/**
		 * Aerial imagery with a road overlay.
		 * @type {Number}
		 * @constant
		 */
		const AERIAL_WITH_LABELS: number;

		/**
		 * Roads without additional imagery.
		 * @type {Number}
		 * @constant
		 */
		const ROAD: number;

	}

	/**
	 * A Label draws viewport-aligned text positioned in the 3D scene.  This constructor
	 * should not be used directly, instead create labels by calling {@link LabelCollection#add}.
	 * @alias Label
	 * @internalConstructor
	 * @class
	 * @exception {DeveloperError} translucencyByDistance.far must be greater than translucencyByDistance.near
	 * @exception {DeveloperError} pixelOffsetScaleByDistance.far must be greater than pixelOffsetScaleByDistance.near
	 * @exception {DeveloperError} distanceDisplayCondition.far must be greater than distanceDisplayCondition.near
	 * @see LabelCollection
	 * @see LabelCollection#add
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Labels.html|Cesium Sandcastle Labels Demo}
	 */
	class EngineLabel {
		constructor();

		/**
		 * Determines if this label will be shown.  Use this to hide or show a label, instead
		 * of removing it and re-adding it to the collection.
		 * @memberof Label.prototype
		 * @type {Boolean}
		 * @default true
		 */
		show: boolean;

		/**
		 * Gets or sets the Cartesian position of this label.
		 * @memberof Label.prototype
		 * @type {Cartesian3}
		 */
		position: Cartesian3;

		/**
		 * Gets or sets the height reference of this billboard.
		 * @memberof Label.prototype
		 * @type {HeightReference}
		 * @default HeightReference.NONE
		 */
		heightReference: any;

		/**
		 * Gets or sets the text of this label.
		 * @memberof Label.prototype
		 * @type {String}
		 */
		text: string;

		/**
		 * Gets or sets the font used to draw this label. Fonts are specified using the same syntax as the CSS 'font' property.
		 * @memberof Label.prototype
		 * @type {String}
		 * @default '30px sans-serif'
		 * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#text-styles|HTML canvas 2D context text styles}
		 */
		font: string;

		/**
		 * Gets or sets the fill color of this label.
		 * @memberof Label.prototype
		 * @type {Color}
		 * @default Color.WHITE
		 * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#fill-and-stroke-styles|HTML canvas 2D context fill and stroke styles}
		 */
		fillColor: Color;

		/**
		 * Gets or sets the outline color of this label.
		 * @memberof Label.prototype
		 * @type {Color}
		 * @default Color.BLACK
		 * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#fill-and-stroke-styles|HTML canvas 2D context fill and stroke styles}
		 */
		outlineColor: Color;

		/**
		 * Gets or sets the outline width of this label.
		 * @memberof Label.prototype
		 * @type {Number}
		 * @default 1.0
		 * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#fill-and-stroke-styles|HTML canvas 2D context fill and stroke styles}
		 */
		outlineWidth: number;

		/**
		 * Determines if a background behind this label will be shown.
		 * @memberof Label.prototype
		 * @default false
		 * @type {Boolean}
		 */
		showBackground: boolean;

		/**
		 * Gets or sets the background color of this label.
		 * @memberof Label.prototype
		 * @type {Color}
		 * @default new Color(0.165, 0.165, 0.165, 0.8)
		 */
		backgroundColor: Color;

		/**
		 * Gets or sets the background padding, in pixels, of this label.  The <code>x</code> value
		 * controls horizontal padding, and the <code>y</code> value controls vertical padding.
		 * @memberof Label.prototype
		 * @type {Cartesian2}
		 * @default new Cartesian2(7, 5)
		 */
		backgroundPadding: Cartesian2;

		/**
		 * Gets or sets the style of this label.
		 * @memberof Label.prototype
		 * @type {LabelStyle}
		 * @default LabelStyle.FILL
		 */
		style: any;

		/**
		 * Gets or sets the pixel offset in screen space from the origin of this label.  This is commonly used
		 * to align multiple labels and billboards at the same position, e.g., an image and text.  The
		 * screen space origin is the top, left corner of the canvas; <code>x</code> increases from
		 * left to right, and <code>y</code> increases from top to bottom.
		 * <br /><br />
		 * <div align='center'>
		 * <table border='0' cellpadding='5'><tr>
		 * <td align='center'><code>default</code><br/><img src='Images/Label.setPixelOffset.default.png' width='250' height='188' /></td>
		 * <td align='center'><code>l.pixeloffset = new Cartesian2(25, 75);</code><br/><img src='Images/Label.setPixelOffset.x50y-25.png' width='250' height='188' /></td>
		 * </tr></table>
		 * The label's origin is indicated by the yellow point.
		 * </div>
		 * @memberof Label.prototype
		 * @type {Cartesian2}
		 * @default Cartesian2.ZERO
		 */
		pixelOffset: Cartesian2;

		/**
		 * Gets or sets near and far translucency properties of a Label based on the Label's distance from the camera.
		 * A label's translucency will interpolate between the {@link NearFarScalar#nearValue} and
		 * {@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
		 * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
		 * Outside of these ranges the label's translucency remains clamped to the nearest bound.  If undefined,
		 * translucencyByDistance will be disabled.
		 * @memberof Label.prototype
		 * @type {NearFarScalar}
		 * @example
		 * // Example 1.
		 * // Set a label's translucencyByDistance to 1.0 when the
		 * // camera is 1500 meters from the label and disappear as
		 * // the camera distance approaches 8.0e6 meters.
		 * text.translucencyByDistance = new Cesium.NearFarScalar(1.5e2, 1.0, 8.0e6, 0.0);
		 * @example
		 * // Example 2.
		 * // disable translucency by distance
		 * text.translucencyByDistance = undefined;
		 */
		translucencyByDistance: NearFarScalar;

		/**
		 * Gets or sets near and far pixel offset scaling properties of a Label based on the Label's distance from the camera.
		 * A label's pixel offset will be scaled between the {@link NearFarScalar#nearValue} and
		 * {@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
		 * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
		 * Outside of these ranges the label's pixel offset scaling remains clamped to the nearest bound.  If undefined,
		 * pixelOffsetScaleByDistance will be disabled.
		 * @memberof Label.prototype
		 * @type {NearFarScalar}
		 * @example
		 * // Example 1.
		 * // Set a label's pixel offset scale to 0.0 when the
		 * // camera is 1500 meters from the label and scale pixel offset to 10.0 pixels
		 * // in the y direction the camera distance approaches 8.0e6 meters.
		 * text.pixelOffset = new Cesium.Cartesian2(0.0, 1.0);
		 * text.pixelOffsetScaleByDistance = new Cesium.NearFarScalar(1.5e2, 0.0, 8.0e6, 10.0);
		 * @example
		 * // Example 2.
		 * // disable pixel offset by distance
		 * text.pixelOffsetScaleByDistance = undefined;
		 */
		pixelOffsetScaleByDistance: NearFarScalar;

		/**
		 * Gets or sets near and far scaling properties of a Label based on the label's distance from the camera.
		 * A label's scale will interpolate between the {@link NearFarScalar#nearValue} and
		 * {@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
		 * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
		 * Outside of these ranges the label's scale remains clamped to the nearest bound.  If undefined,
		 * scaleByDistance will be disabled.
		 * @memberof Label.prototype
		 * @type {NearFarScalar}
		 * @example
		 * // Example 1.
		 * // Set a label's scaleByDistance to scale by 1.5 when the
		 * // camera is 1500 meters from the label and disappear as
		 * // the camera distance approaches 8.0e6 meters.
		 * label.scaleByDistance = new Cesium.NearFarScalar(1.5e2, 1.5, 8.0e6, 0.0);
		 * @example
		 * // Example 2.
		 * // disable scaling by distance
		 * label.scaleByDistance = undefined;
		 */
		scaleByDistance: NearFarScalar;

		/**
		 * Gets and sets the 3D Cartesian offset applied to this label in eye coordinates.  Eye coordinates is a left-handed
		 * coordinate system, where <code>x</code> points towards the viewer's right, <code>y</code> points up, and
		 * <code>z</code> points into the screen.  Eye coordinates use the same scale as world and model coordinates,
		 * which is typically meters.
		 * <br /><br />
		 * An eye offset is commonly used to arrange multiple label or objects at the same position, e.g., to
		 * arrange a label above its corresponding 3D model.
		 * <br /><br />
		 * Below, the label is positioned at the center of the Earth but an eye offset makes it always
		 * appear on top of the Earth regardless of the viewer's or Earth's orientation.
		 * <br /><br />
		 * <div align='center'>
		 * <table border='0' cellpadding='5'><tr>
		 * <td align='center'><img src='Images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>
		 * <td align='center'><img src='Images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>
		 * </tr></table>
		 * <code>l.eyeOffset = new Cartesian3(0.0, 8000000.0, 0.0);</code><br /><br />
		 * </div>
		 * @memberof Label.prototype
		 * @type {Cartesian3}
		 * @default Cartesian3.ZERO
		 */
		eyeOffset: Cartesian3;

		/**
		 * Gets or sets the horizontal origin of this label, which determines if the label is drawn
		 * to the left, center, or right of its anchor position.
		 * <br /><br />
		 * <div align='center'>
		 * <img src='Images/Billboard.setHorizontalOrigin.png' width='648' height='196' /><br />
		 * </div>
		 * @memberof Label.prototype
		 * @type {HorizontalOrigin}
		 * @default HorizontalOrigin.LEFT
		 * @example
		 * // Use a top, right origin
		 * l.horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;
		 * l.verticalOrigin = Cesium.VerticalOrigin.TOP;
		 */
		horizontalOrigin: any;

		/**
		 * Gets or sets the vertical origin of this label, which determines if the label is
		 * to the above, below, or at the center of its anchor position.
		 * <br /><br />
		 * <div align='center'>
		 * <img src='Images/Billboard.setVerticalOrigin.png' width='695' height='175' /><br />
		 * </div>
		 * @memberof Label.prototype
		 * @type {VerticalOrigin}
		 * @default VerticalOrigin.BASELINE
		 * @example
		 * // Use a top, right origin
		 * l.horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;
		 * l.verticalOrigin = Cesium.VerticalOrigin.TOP;
		 */
		verticalOrigin: any;

		/**
		 * Gets or sets the uniform scale that is multiplied with the label's size in pixels.
		 * A scale of <code>1.0</code> does not change the size of the label; a scale greater than
		 * <code>1.0</code> enlarges the label; a positive scale less than <code>1.0</code> shrinks
		 * the label.
		 * <br /><br />
		 * Applying a large scale value may pixelate the label.  To make text larger without pixelation,
		 * use a larger font size when calling {@link Label#font} instead.
		 * <br /><br />
		 * <div align='center'>
		 * <img src='Images/Label.setScale.png' width='400' height='300' /><br/>
		 * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>,
		 * and <code>2.0</code>.
		 * </div>
		 * @memberof Label.prototype
		 * @type {Number}
		 * @default 1.0
		 */
		scale: number;

		/**
		 * Gets or sets the condition specifying at what distance from the camera that this label will be displayed.
		 * @memberof Label.prototype
		 * @type {DistanceDisplayCondition}
		 * @default undefined
		 */
		distanceDisplayCondition: DistanceDisplayCondition;

		/**
		 * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.
		 * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.
		 * @memberof Label.prototype
		 * @type {Number}
		 */
		disableDepthTestDistance: number;

		/**
		 * Gets or sets the user-defined value returned when the label is picked.
		 * @memberof Label.prototype
		 * @type {*}
		 */
		id: any;

		/**
		 * Computes the screen-space position of the label's origin, taking into account eye and pixel offsets.
		 * The screen space origin is the top, left corner of the canvas; <code>x</code> increases from
		 * left to right, and <code>y</code> increases from top to bottom.
		 * @param {Scene} scene The scene the label is in.
		 * @param {Cartesian2} [result] The object onto which to store the result.
		 * @returns {Cartesian2} The screen-space position of the label.
		 * @example
		 * console.log(l.computeScreenSpacePosition(scene).toString());
		 * @see Label#eyeOffset
		 * @see Label#pixelOffset
		 */
		computeScreenSpacePosition(scene: Scene, result?: Cartesian2): Cartesian2;

		/**
		 * Determines if this label equals another label.  Labels are equal if all their properties
		 * are equal.  Labels in different collections can be equal.
		 * @param {Label} other The label to compare for equality.
		 * @returns {Boolean} <code>true</code> if the labels are equal; otherwise, <code>false</code>.
		 */
		equals(other: Label): boolean;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <br /><br />
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * @returns {Boolean} True if this object was destroyed; otherwise, false.
		 */
		isDestroyed(): boolean;

		/**
		 * Determines whether or not run the algorithm, that match the text of the label to right-to-left languages
		 * @memberof Label
		 * @type {Boolean}
		 * @default false
		 * @example
		 * // Example 1.
		 * // Set a label's rightToLeft before init
		 * Cesium.Label.enableRightToLeftDetection = true;
		 * var myLabelEntity = viewer.entities.add({
		 *   label: {
		 *     id: 'my label',
		 *     text: 'זה טקסט בעברית \n ועכשיו יורדים שורה',
		 *   }
		 * });
		 * @example
		 * // Example 2.
		 * var myLabelEntity = viewer.entities.add({
		 *   label: {
		 *     id: 'my label',
		 *     text: 'English text'
		 *   }
		 * });
		 * // Set a label's rightToLeft after init
		 * Cesium.Label.enableRightToLeftDetection = true;
		 * myLabelEntity.text = 'טקסט חדש';
		 */
		static enableRightToLeftDetection: boolean;

	}

	/**
	 * A renderable collection of labels.  Labels are viewport-aligned text positioned in the 3D scene.
	 * Each label can have a different font, color, scale, etc.
	 * <br /><br />
	 * <div align='center'>
	 * <img src='Images/Label.png' width='400' height='300' /><br />
	 * Example labels
	 * </div>
	 * <br /><br />
	 * Labels are added and removed from the collection using {@link LabelCollection#add}
	 * and {@link LabelCollection#remove}.
	 * @alias LabelCollection
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms each label from model to world coordinates.
	 * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.
	 * @param {Scene} [options.scene] Must be passed in for labels that use the height reference property or will be depth tested against the globe.
	 * @param {BlendOption} [options.blendOption=BlendOption.OPAQUE_AND_TRANSLUCENT] The label blending option. The default
	 * is used for rendering both opaque and translucent labels. However, if either all of the labels are completely opaque or all are completely translucent,
	 * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve performance by up to 2x.
	 * @performance For best performance, prefer a few collections, each with many labels, to
	 * many collections with only a few labels each.  Avoid having collections where some
	 * labels change every frame and others do not; instead, create one or more collections
	 * for static labels, and one or more collections for dynamic labels.
	 * @see LabelCollection#add
	 * @see LabelCollection#remove
	 * @see Label
	 * @see BillboardCollection
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Labels.html|Cesium Sandcastle Labels Demo}
	 * @example
	 * // Create a label collection with two labels
	 * var labels = scene.primitives.add(new Cesium.LabelCollection());
	 * labels.add({
	 *   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),
	 *   text : 'A label'
	 * });
	 * labels.add({
	 *   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),
	 *   text : 'Another label'
	 * });
	 */
	class LabelCollection {
		constructor(options?: {
			modelMatrix?: Matrix4;
			debugShowBoundingVolume?: boolean;
			scene?: Scene;
			blendOption?: any;
		});

		/**
		 * The 4x4 transformation matrix that transforms each label in this collection from model to world coordinates.
		 * When this is the identity matrix, the labels are drawn in world coordinates, i.e., Earth's WGS84 coordinates.
		 * Local reference frames can be used by providing a different transformation matrix, like that returned
		 * by {@link Transforms.eastNorthUpToFixedFrame}.
		 * @type Matrix4
		 * @default {@link Matrix4.IDENTITY}
		 * @example
		 * var center = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);
		 * labels.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);
		 * labels.add({
		 *   position : new Cesium.Cartesian3(0.0, 0.0, 0.0),
		 *   text     : 'Center'
		 * });
		 * labels.add({
		 *   position : new Cesium.Cartesian3(1000000.0, 0.0, 0.0),
		 *   text     : 'East'
		 * });
		 * labels.add({
		 *   position : new Cesium.Cartesian3(0.0, 1000000.0, 0.0),
		 *   text     : 'North'
		 * });
		 * labels.add({
		 *   position : new Cesium.Cartesian3(0.0, 0.0, 1000000.0),
		 *   text     : 'Up'
		 * });
		 */
		modelMatrix: Matrix4;

		/**
		 * This property is for debugging only; it is not for production use nor is it optimized.
		 * <p>
		 * Draws the bounding sphere for each draw command in the primitive.
		 * </p>
		 * @type {Boolean}
		 * @default false
		 */
		debugShowBoundingVolume: boolean;

		/**
		 * The label blending option. The default is used for rendering both opaque and translucent labels.
		 * However, if either all of the labels are completely opaque or all are completely translucent,
		 * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve
		 * performance by up to 2x.
		 * @type {BlendOption}
		 * @default BlendOption.OPAQUE_AND_TRANSLUCENT
		 */
		blendOption: any;

		/**
		 * Returns the number of labels in this collection.  This is commonly used with
		 * {@link LabelCollection#get} to iterate over all the labels
		 * in the collection.
		 * @memberof LabelCollection.prototype
		 * @type {Number}
		 */
		length: number;

		/**
		 * Creates and adds a label with the specified initial properties to the collection.
		 * The added label is returned so it can be modified or removed from the collection later.
		 * @param {Object} [options] A template describing the label's properties as shown in Example 1.
		 * @returns {Label} The label that was added to the collection.
		 * @performance Calling <code>add</code> is expected constant time.  However, the collection's vertex buffer
		 * is rewritten; this operations is <code>O(n)</code> and also incurs
		 * CPU to GPU overhead.  For best performance, add as many billboards as possible before
		 * calling <code>update</code>.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * // Example 1:  Add a label, specifying all the default values.
		 * var l = labels.add({
		 *   show : true,
		 *   position : Cesium.Cartesian3.ZERO,
		 *   text : '',
		 *   font : '30px sans-serif',
		 *   fillColor : Cesium.Color.WHITE,
		 *   outlineColor : Cesium.Color.BLACK,
		 *   outlineWidth : 1.0,
		 *   showBackground : false,
		 *   backgroundColor : new Cesium.Color(0.165, 0.165, 0.165, 0.8),
		 *   backgroundPadding : new Cesium.Cartesian2(7, 5),
		 *   style : Cesium.LabelStyle.FILL,
		 *   pixelOffset : Cesium.Cartesian2.ZERO,
		 *   eyeOffset : Cesium.Cartesian3.ZERO,
		 *   horizontalOrigin : Cesium.HorizontalOrigin.LEFT,
		 *   verticalOrigin : Cesium.VerticalOrigin.BASELINE,
		 *   scale : 1.0,
		 *   translucencyByDistance : undefined,
		 *   pixelOffsetScaleByDistance : undefined,
		 *   heightReference : HeightReference.NONE,
		 *   distanceDisplayCondition : undefined
		 * });
		 * @example
		 * // Example 2:  Specify only the label's cartographic position,
		 * // text, and font.
		 * var l = labels.add({
		 *   position : Cesium.Cartesian3.fromRadians(longitude, latitude, height),
		 *   text : 'Hello World',
		 *   font : '24px Helvetica',
		 * });
		 * @see LabelCollection#remove
		 * @see LabelCollection#removeAll
		 */
		add(options?: any): Label;

		/**
		 * Removes a label from the collection.  Once removed, a label is no longer usable.
		 * @param {Label} label The label to remove.
		 * @returns {Boolean} <code>true</code> if the label was removed; <code>false</code> if the label was not found in the collection.
		 * @performance Calling <code>remove</code> is expected constant time.  However, the collection's vertex buffer
		 * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For
		 * best performance, remove as many labels as possible before calling <code>update</code>.
		 * If you intend to temporarily hide a label, it is usually more efficient to call
		 * {@link Label#show} instead of removing and re-adding the label.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * var l = labels.add(...);
		 * labels.remove(l);  // Returns true
		 * @see LabelCollection#add
		 * @see LabelCollection#removeAll
		 * @see Label#show
		 */
		remove(label: Label): boolean;

		/**
		 * Removes all labels from the collection.
		 * @performance <code>O(n)</code>.  It is more efficient to remove all the labels
		 * from a collection and then add new ones than to create a new collection entirely.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * labels.add(...);
		 * labels.add(...);
		 * labels.removeAll();
		 * @see LabelCollection#add
		 * @see LabelCollection#remove
		 */
		removeAll(): void;

		/**
		 * Check whether this collection contains a given label.
		 * @param {Label} label The label to check for.
		 * @returns {Boolean} true if this collection contains the label, false otherwise.
		 * @see LabelCollection#get
		 */
		contains(label: Label): boolean;

		/**
		 * Returns the label in the collection at the specified index.  Indices are zero-based
		 * and increase as labels are added.  Removing a label shifts all labels after
		 * it to the left, changing their indices.  This function is commonly used with
		 * {@link LabelCollection#length} to iterate over all the labels
		 * in the collection.
		 * @param {Number} index The zero-based index of the billboard.
		 * @returns {Label} The label at the specified index.
		 * @performance Expected constant time.  If labels were removed from the collection and
		 * {@link Scene#render} was not called, an implicit <code>O(n)</code>
		 * operation is performed.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * // Toggle the show property of every label in the collection
		 * var len = labels.length;
		 * for (var i = 0; i < len; ++i) {
		 *   var l = billboards.get(i);
		 *   l.show = !l.show;
		 * }
		 * @see LabelCollection#length
		 */
		get(index: number): Label;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <br /><br />
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * @returns {Boolean} True if this object was destroyed; otherwise, false.
		 * @see LabelCollection#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
		 * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
		 * <br /><br />
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * labels = labels && labels.destroy();
		 * @see LabelCollection#isDestroyed
		 */
		destroy(): void;

	}

	/**
	 * Provides tiled imagery hosted by Mapbox.
	 * @alias MapboxImageryProvider
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {String} [options.url='https://api.mapbox.com/v4/'] The Mapbox server url.
	 * @param {String} options.mapId The Mapbox Map ID.
	 * @param {String} [options.accessToken] The public access token for the imagery.
	 * @param {String} [options.format='png'] The format of the image request.
	 * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If not specified, the WGS84 ellipsoid is used.
	 * @param {Number} [options.minimumLevel=0] The minimum level-of-detail supported by the imagery provider.  Take care when specifying
	 *                 this that the number of tiles at the minimum level is small, such as four or less.  A larger number is likely
	 *                 to result in rendering problems.
	 * @param {Number} [options.maximumLevel] The maximum level-of-detail supported by the imagery provider, or undefined if there is no limit.
	 * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the image.
	 * @param {Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.
	 * @example
	 * // Mapbox tile provider
	 * var mapbox = new Cesium.MapboxImageryProvider({
	 *     mapId: 'mapbox.streets',
	 *     accessToken: 'thisIsMyAccessToken'
	 * });
	 * @see {@link https://www.mapbox.com/developers/api/maps/#tiles}
	 * @see {@link https://www.mapbox.com/developers/api/#access-tokens}
	 */
	class MapboxImageryProvider {
		constructor(options?: {
			url?: string;
			mapId: string;
			accessToken?: string;
			format?: string;
			ellipsoid?: Ellipsoid;
			minimumLevel?: number;
			maximumLevel?: number;
			rectangle?: Rectangle;
			credit?: Credit | string;
		});

		/**
		 * Gets the URL of the Mapbox server.
		 * @memberof MapboxImageryProvider.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly url: string;

		/**
		 * Gets a value indicating whether or not the provider is ready for use.
		 * @memberof MapboxImageryProvider.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly ready: boolean;

		/**
		 * Gets a promise that resolves to true when the provider is ready for use.
		 * @memberof MapboxImageryProvider.prototype
		 * @type {Promise.<Boolean>}
		 * @readonly
		 */
		readonly readyPromise: any;

		/**
		 * Gets the rectangle, in radians, of the imagery provided by the instance.  This function should
		 * not be called before {@link MapboxImageryProvider#ready} returns true.
		 * @memberof MapboxImageryProvider.prototype
		 * @type {Rectangle}
		 * @readonly
		 */
		readonly rectangle: Rectangle;

		/**
		 * Gets the width of each tile, in pixels.  This function should
		 * not be called before {@link MapboxImageryProvider#ready} returns true.
		 * @memberof MapboxImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly tileWidth: number;

		/**
		 * Gets the height of each tile, in pixels.  This function should
		 * not be called before {@link MapboxImageryProvider#ready} returns true.
		 * @memberof MapboxImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly tileHeight: number;

		/**
		 * Gets the maximum level-of-detail that can be requested.  This function should
		 * not be called before {@link MapboxImageryProvider#ready} returns true.
		 * @memberof MapboxImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly maximumLevel: number;

		/**
		 * Gets the minimum level-of-detail that can be requested.  This function should
		 * not be called before {@link MapboxImageryProvider#ready} returns true. Generally,
		 * a minimum level should only be used when the rectangle of the imagery is small
		 * enough that the number of tiles at the minimum level is small.  An imagery
		 * provider with more than a few tiles at the minimum level will lead to
		 * rendering problems.
		 * @memberof MapboxImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly minimumLevel: number;

		/**
		 * Gets the tiling scheme used by the provider.  This function should
		 * not be called before {@link MapboxImageryProvider#ready} returns true.
		 * @memberof MapboxImageryProvider.prototype
		 * @type {TilingScheme}
		 * @readonly
		 */
		readonly tilingScheme: TilingScheme;

		/**
		 * Gets the tile discard policy.  If not undefined, the discard policy is responsible
		 * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
		 * returns undefined, no tiles are filtered.  This function should
		 * not be called before {@link MapboxImageryProvider#ready} returns true.
		 * @memberof MapboxImageryProvider.prototype
		 * @type {TileDiscardPolicy}
		 * @readonly
		 */
		readonly tileDiscardPolicy: TileDiscardPolicy;

		/**
		 * Gets an event that is raised when the imagery provider encounters an asynchronous error..  By subscribing
		 * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
		 * are passed an instance of {@link TileProviderError}.
		 * @memberof MapboxImageryProvider.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly errorEvent: Event;

		/**
		 * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
		 * the source of the imagery. This function should
		 * not be called before {@link MapboxImageryProvider#ready} returns true.
		 * @memberof MapboxImageryProvider.prototype
		 * @type {Credit}
		 * @readonly
		 */
		readonly credit: Credit;

		/**
		 * Gets the proxy used by this provider.
		 * @memberof MapboxImageryProvider.prototype
		 * @type {Proxy}
		 * @readonly
		 */
		readonly proxy: Proxy;

		/**
		 * Gets a value indicating whether or not the images provided by this imagery provider
		 * include an alpha channel.  If this property is false, an alpha channel, if present, will
		 * be ignored.  If this property is true, any images without an alpha channel will be treated
		 * as if their alpha is 1.0 everywhere.  When this property is false, memory usage
		 * and texture upload time are reduced.
		 * @memberof MapboxImageryProvider.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly hasAlphaChannel: boolean;

		/**
		 * Gets the credits to be displayed when a given tile is displayed.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level;
		 * @returns {Credit[]} The credits to be displayed when the tile is displayed.
		 * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.
		 */
		getTileCredits(x: number, y: number, level: number): (Credit)[];

		/**
		 * Requests the image for a given tile.  This function should
		 * not be called before {@link MapboxImageryProvider#ready} returns true.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level.
		 * @param {Request} [request] The request object. Intended for internal use only.
		 * @returns {Promise.<Image|Canvas>|undefined} A promise for the image that will resolve when the image is available, or
		 *          undefined if there are too many active requests to the server, and the request
		 *          should be retried later.  The resolved image may be either an
		 *          Image or a Canvas DOM object.
		 * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.
		 */
		requestImage(x: number, y: number, level: number, request?: Request): any | any | undefined;

		/**
		 * Asynchronously determines what features, if any, are located at a given longitude and latitude within
		 * a tile.  This function should not be called before {@link MapboxImageryProvider#ready} returns true.
		 * This function is optional, so it may not exist on all ImageryProviders.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level.
		 * @param {Number} longitude The longitude at which to pick features.
		 * @param {Number} latitude  The latitude at which to pick features.
		 * @return {Promise.<ImageryLayerFeatureInfo[]>|undefined} A promise for the picked features that will resolve when the asynchronous
		 *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}
		 *                   instances.  The array may be empty if no features are found at the given location.
		 *                   It may also be undefined if picking is not supported.
		 * @exception {DeveloperError} <code>pickFeatures</code> must not be called before the imagery provider is ready.
		 */
		pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): any | undefined;

	}

	/**
	 * Describes how the map will operate in 2D.
	 * @exports MapMode2D
	 */
	namespace MapMode2D {
		/**
		 * The 2D map can be rotated about the z axis.
		 * @type {Number}
		 * @constant
		 */
		const ROTATE: number;

		/**
		 * The 2D map can be scrolled infinitely in the horizontal direction.
		 * @type {Number}
		 * @constant
		 */
		const INFINITE_SCROLL: number;

	}

	/**
	 * A Material defines surface appearance through a combination of diffuse, specular,
	 * normal, emission, and alpha components. These values are specified using a
	 * JSON schema called Fabric which gets parsed and assembled into glsl shader code
	 * behind-the-scenes. Check out the {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric|wiki page}
	 * for more details on Fabric.
	 * <br /><br />
	 * <style type="text/css">
	 *  #materialDescriptions code {
	 *      font-weight: normal;
	 *      font-family: Consolas, 'Lucida Console', Monaco, monospace;
	 *      color: #A35A00;
	 *  }
	 *  #materialDescriptions ul, #materialDescriptions ul ul {
	 *      list-style-type: none;
	 *  }
	 *  #materialDescriptions ul ul {
	 *      margin-bottom: 10px;
	 *  }
	 *  #materialDescriptions ul ul li {
	 *      font-weight: normal;
	 *      color: #000000;
	 *      text-indent: -2em;
	 *      margin-left: 2em;
	 *  }
	 *  #materialDescriptions ul li {
	 *      font-weight: bold;
	 *      color: #0053CF;
	 *  }
	 * </style>
	 * Base material types and their uniforms:
	 * <div id='materialDescriptions'>
	 * <ul>
	 *  <li>Color</li>
	 *  <ul>
	 *      <li><code>color</code>:  rgba color object.</li>
	 *  </ul>
	 *  <li>Image</li>
	 *  <ul>
	 *      <li><code>image</code>:  path to image.</li>
	 *      <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
	 *  </ul>
	 *  <li>DiffuseMap</li>
	 *  <ul>
	 *      <li><code>image</code>:  path to image.</li>
	 *      <li><code>channels</code>:  Three character string containing any combination of r, g, b, and a for selecting the desired image channels.</li>
	 *      <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
	 *  </ul>
	 *  <li>AlphaMap</li>
	 *  <ul>
	 *      <li><code>image</code>:  path to image.</li>
	 *      <li><code>channel</code>:  One character string containing r, g, b, or a for selecting the desired image channel. </li>
	 *      <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
	 *  </ul>
	 *  <li>SpecularMap</li>
	 *  <ul>
	 *      <li><code>image</code>: path to image.</li>
	 *      <li><code>channel</code>: One character string containing r, g, b, or a for selecting the desired image channel. </li>
	 *      <li><code>repeat</code>: Object with x and y values specifying the number of times to repeat the image.</li>
	 *  </ul>
	 *  <li>EmissionMap</li>
	 *  <ul>
	 *      <li><code>image</code>:  path to image.</li>
	 *      <li><code>channels</code>:  Three character string containing any combination of r, g, b, and a for selecting the desired image channels. </li>
	 *      <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
	 *  </ul>
	 *  <li>BumpMap</li>
	 *  <ul>
	 *      <li><code>image</code>:  path to image.</li>
	 *      <li><code>channel</code>:  One character string containing r, g, b, or a for selecting the desired image channel. </li>
	 *      <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
	 *      <li><code>strength</code>:  Bump strength value between 0.0 and 1.0 where 0.0 is small bumps and 1.0 is large bumps.</li>
	 *  </ul>
	 *  <li>NormalMap</li>
	 *  <ul>
	 *      <li><code>image</code>:  path to image.</li>
	 *      <li><code>channels</code>:  Three character string containing any combination of r, g, b, and a for selecting the desired image channels. </li>
	 *      <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
	 *      <li><code>strength</code>:  Bump strength value between 0.0 and 1.0 where 0.0 is small bumps and 1.0 is large bumps.</li>
	 *  </ul>
	 *  <li>Grid</li>
	 *  <ul>
	 *      <li><code>color</code>:  rgba color object for the whole material.</li>
	 *      <li><code>cellAlpha</code>: Alpha value for the cells between grid lines.  This will be combined with color.alpha.</li>
	 *      <li><code>lineCount</code>:  Object with x and y values specifying the number of columns and rows respectively.</li>
	 *      <li><code>lineThickness</code>:  Object with x and y values specifying the thickness of grid lines (in pixels where available).</li>
	 *      <li><code>lineOffset</code>:  Object with x and y values specifying the offset of grid lines (range is 0 to 1).</li>
	 *  </ul>
	 *  <li>Stripe</li>
	 *  <ul>
	 *      <li><code>horizontal</code>:  Boolean that determines if the stripes are horizontal or vertical.</li>
	 *      <li><code>evenColor</code>:  rgba color object for the stripe's first color.</li>
	 *      <li><code>oddColor</code>:  rgba color object for the stripe's second color.</li>
	 *      <li><code>offset</code>:  Number that controls at which point into the pattern to begin drawing; with 0.0 being the beginning of the even color, 1.0 the beginning of the odd color, 2.0 being the even color again, and any multiple or fractional values being in between.</li>
	 *      <li><code>repeat</code>:  Number that controls the total number of stripes, half light and half dark.</li>
	 *  </ul>
	 *  <li>Checkerboard</li>
	 *  <ul>
	 *      <li><code>lightColor</code>:  rgba color object for the checkerboard's light alternating color.</li>
	 *      <li><code>darkColor</code>: rgba color object for the checkerboard's dark alternating color.</li>
	 *      <li><code>repeat</code>:  Object with x and y values specifying the number of columns and rows respectively.</li>
	 *  </ul>
	 *  <li>Dot</li>
	 *  <ul>
	 *      <li><code>lightColor</code>:  rgba color object for the dot color.</li>
	 *      <li><code>darkColor</code>:  rgba color object for the background color.</li>
	 *      <li><code>repeat</code>:  Object with x and y values specifying the number of columns and rows of dots respectively.</li>
	 *  </ul>
	 *  <li>Water</li>
	 *  <ul>
	 *      <li><code>baseWaterColor</code>:  rgba color object base color of the water.</li>
	 *      <li><code>blendColor</code>:  rgba color object used when blending from water to non-water areas.</li>
	 *      <li><code>specularMap</code>:  Single channel texture used to indicate areas of water.</li>
	 *      <li><code>normalMap</code>:  Normal map for water normal perturbation.</li>
	 *      <li><code>frequency</code>:  Number that controls the number of waves.</li>
	 *      <li><code>normalMap</code>:  Normal map for water normal perturbation.</li>
	 *      <li><code>animationSpeed</code>:  Number that controls the animations speed of the water.</li>
	 *      <li><code>amplitude</code>:  Number that controls the amplitude of water waves.</li>
	 *      <li><code>specularIntensity</code>:  Number that controls the intensity of specular reflections.</li>
	 *  </ul>
	 *  <li>RimLighting</li>
	 *  <ul>
	 *      <li><code>color</code>:  diffuse color and alpha.</li>
	 *      <li><code>rimColor</code>:  diffuse color and alpha of the rim.</li>
	 *      <li><code>width</code>:  Number that determines the rim's width.</li>
	 *  </ul>
	 *  <li>Fade</li>
	 *  <ul>
	 *      <li><code>fadeInColor</code>: diffuse color and alpha at <code>time</code></li>
	 *      <li><code>fadeOutColor</code>: diffuse color and alpha at <code>maximumDistance</code> from <code>time</code></li>
	 *      <li><code>maximumDistance</code>: Number between 0.0 and 1.0 where the <code>fadeInColor</code> becomes the <code>fadeOutColor</code>. A value of 0.0 gives the entire material a color of <code>fadeOutColor</code> and a value of 1.0 gives the the entire material a color of <code>fadeInColor</code></li>
	 *      <li><code>repeat</code>: true if the fade should wrap around the texture coodinates.</li>
	 *      <li><code>fadeDirection</code>: Object with x and y values specifying if the fade should be in the x and y directions.</li>
	 *      <li><code>time</code>: Object with x and y values between 0.0 and 1.0 of the <code>fadeInColor</code> position</li>
	 *  </ul>
	 *  <li>PolylineArrow</li>
	 *  <ul>
	 *      <li><code>color</code>: diffuse color and alpha.</li>
	 *  </ul>
	 *  <li>PolylineDash</li>
	 *  <ul>
	 *      <li><code>color</code>: color for the line.</li>
	 *      <li><code>gapColor</code>: color for the gaps in the line.</li>
	 *      <li><code>dashLength</code>: Dash length in pixels.</li>
	 *      <li><code>dashPattern</code>: The 16 bit stipple pattern for the line..</li>
	 *  </ul>
	 *  <li>PolylineGlow</li>
	 *  <ul>
	 *      <li><code>color</code>: color and maximum alpha for the glow on the line.</li>
	 *      <li><code>glowPower</code>: strength of the glow, as a percentage of the total line width (less than 1.0).</li>
	 *  </ul>
	 *  <li>PolylineOutline</li>
	 *  <ul>
	 *      <li><code>color</code>: diffuse color and alpha for the interior of the line.</li>
	 *      <li><code>outlineColor</code>: diffuse color and alpha for the outline.</li>
	 *      <li><code>outlineWidth</code>: width of the outline in pixels.</li>
	 *  </ul>
	 *  <li>ElevationContour</li>
	 *  <ul>
	 *      <li><code>color</code>: color and alpha for the contour line.</li>
	 *      <li><code>spacing</code>: spacing for contour lines in meters.</li>
	 *      <li><code>width</code>: Number specifying the width of the grid lines in pixels.</li>
	 *  </ul>
	 *  <li>ElevationRamp</li>
	 *  <ul>
	 *      <li><code>image</code>: color ramp image to use for coloring the terrain.</li>
	 *      <li><code>minimumHeight</code>: minimum height for the ramp.</li>
	 *      <li><code>maximumHeight</code>: maximum height for the ramp.</li>
	 *  </ul>
	 *  <li>SlopeRamp</li>
	 *  <ul>
	 *      <li><code>image</code>: color ramp image to use for coloring the terrain.</li>
	 *  </ul>
	 * </ul>
	 * </ul>
	 * </div>
	 * @alias Material
	 * @param {Object} [options] Object with the following properties:
	 * @param {Boolean} [options.strict=false] Throws errors for issues that would normally be ignored, including unused uniforms or materials.
	 * @param {Boolean|Function} [options.translucent=true] When <code>true</code> or a function that returns <code>true</code>, the geometry
	 *                           with this material is expected to appear translucent.
	 * @param {Object} options.fabric The fabric JSON used to generate the material.
	 * @constructor
	 * @exception {DeveloperError} fabric: uniform has invalid type.
	 * @exception {DeveloperError} fabric: uniforms and materials cannot share the same property.
	 * @exception {DeveloperError} fabric: cannot have source and components in the same section.
	 * @exception {DeveloperError} fabric: property name is not valid. It should be 'type', 'materials', 'uniforms', 'components', or 'source'.
	 * @exception {DeveloperError} fabric: property name is not valid. It should be 'diffuse', 'specular', 'shininess', 'normal', 'emission', or 'alpha'.
	 * @exception {DeveloperError} strict: shader source does not use string.
	 * @exception {DeveloperError} strict: shader source does not use uniform.
	 * @exception {DeveloperError} strict: shader source does not use material.
	 * @see {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric|Fabric wiki page} for a more detailed options of Fabric.
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Materials.html|Cesium Sandcastle Materials Demo}
	 * @example
	 * // Create a color material with fromType:
	 * polygon.material = Cesium.Material.fromType('Color');
	 * polygon.material.uniforms.color = new Cesium.Color(1.0, 1.0, 0.0, 1.0);
	 * // Create the default material:
	 * polygon.material = new Cesium.Material();
	 * // Create a color material with full Fabric notation:
	 * polygon.material = new Cesium.Material({
	 *     fabric : {
	 *         type : 'Color',
	 *         uniforms : {
	 *             color : new Cesium.Color(1.0, 1.0, 0.0, 1.0)
	 *         }
	 *     }
	 * });
	 */
	class EngineMaterial {
		constructor(options?: {
			strict?: boolean;
			translucent?: boolean | (Function);
			fabric: any;
		});

		/**
		 * The material type. Can be an existing type or a new type. If no type is specified in fabric, type is a GUID.
		 * @type {String}
		 * @default undefined
		 */
		type: string;

		/**
		 * The glsl shader source for this material.
		 * @type {String}
		 * @default undefined
		 */
		shaderSource: string;

		/**
		 * Maps sub-material names to Material objects.
		 * @type {Object}
		 * @default undefined
		 */
		materials: any;

		/**
		 * Maps uniform names to their values.
		 * @type {Object}
		 * @default undefined
		 */
		uniforms: any;

		/**
		 * When <code>true</code> or a function that returns <code>true</code>,
		 * the geometry is expected to appear translucent.
		 * @type {Boolean|Function}
		 * @default undefined
		 */
		translucent: boolean | (Function);

		/**
		 * Creates a new material using an existing material type.
		 * <br /><br />
		 * Shorthand for: new Material({fabric : {type : type}});
		 * @param {String} type The base material type.
		 * @param {Object} [uniforms] Overrides for the default uniforms.
		 * @returns {Material} New material object.
		 * @exception {DeveloperError} material with that type does not exist.
		 * @example
		 * var material = Cesium.Material.fromType('Color', {
		 *     color : new Cesium.Color(1.0, 0.0, 0.0, 1.0)
		 * });
		 */
		static fromType(type: string, uniforms?: any): Material;

		/**
		 * Gets whether or not this material is translucent.
		 * @returns <code>true</code> if this material is translucent, <code>false</code> otherwise.
		 */
		isTranslucent(): any;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <br /><br />
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * @returns {Boolean} True if this object was destroyed; otherwise, false.
		 * @see Material#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
		 * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
		 * <br /><br />
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * material = material && material.destroy();
		 * @see Material#isDestroyed
		 */
		destroy(): void;

		/**
		 * Gets or sets the default texture uniform value.
		 * @type {String}
		 */
		static DefaultImageId: string;

		/**
		 * Gets or sets the default cube map texture uniform value.
		 * @type {String}
		 */
		static DefaultCubeMapId: string;

		/**
		 * Gets the name of the color material.
		 * @type {String}
		 * @readonly
		 */
		static readonly ColorType: string;

		/**
		 * Gets the name of the image material.
		 * @type {String}
		 * @readonly
		 */
		static readonly ImageType: string;

		/**
		 * Gets the name of the diffuce map material.
		 * @type {String}
		 * @readonly
		 */
		static readonly DiffuseMapType: string;

		/**
		 * Gets the name of the alpha map material.
		 * @type {String}
		 * @readonly
		 */
		static readonly AlphaMapType: string;

		/**
		 * Gets the name of the specular map material.
		 * @type {String}
		 * @readonly
		 */
		static readonly SpecularMapType: string;

		/**
		 * Gets the name of the emmision map material.
		 * @type {String}
		 * @readonly
		 */
		static readonly EmissionMapType: string;

		/**
		 * Gets the name of the bump map material.
		 * @type {String}
		 * @readonly
		 */
		static readonly BumpMapType: string;

		/**
		 * Gets the name of the normal map material.
		 * @type {String}
		 * @readonly
		 */
		static readonly NormalMapType: string;

		/**
		 * Gets the name of the grid material.
		 * @type {String}
		 * @readonly
		 */
		static readonly GridType: string;

		/**
		 * Gets the name of the stripe material.
		 * @type {String}
		 * @readonly
		 */
		static readonly StripeType: string;

		/**
		 * Gets the name of the checkerboard material.
		 * @type {String}
		 * @readonly
		 */
		static readonly CheckerboardType: string;

		/**
		 * Gets the name of the dot material.
		 * @type {String}
		 * @readonly
		 */
		static readonly DotType: string;

		/**
		 * Gets the name of the water material.
		 * @type {String}
		 * @readonly
		 */
		static readonly WaterType: string;

		/**
		 * Gets the name of the rim lighting material.
		 * @type {String}
		 * @readonly
		 */
		static readonly RimLightingType: string;

		/**
		 * Gets the name of the fade material.
		 * @type {String}
		 * @readonly
		 */
		static readonly FadeType: string;

		/**
		 * Gets the name of the polyline arrow material.
		 * @type {String}
		 * @readonly
		 */
		static readonly PolylineArrowType: string;

		/**
		 * Gets the name of the polyline glow material.
		 * @type {String}
		 * @readonly
		 */
		static readonly PolylineDashType: string;

		/**
		 * Gets the name of the polyline glow material.
		 * @type {String}
		 * @readonly
		 */
		static readonly PolylineGlowType: string;

		/**
		 * Gets the name of the polyline outline material.
		 * @type {String}
		 * @readonly
		 */
		static readonly PolylineOutlineType: string;

		/**
		 * Gets the name of the elevation contour material.
		 * @type {String}
		 * @readonly
		 */
		static readonly ElevationContourType: string;

		/**
		 * Gets the name of the elevation contour material.
		 * @type {String}
		 * @readonly
		 */
		static readonly ElevationRampType: string;

		/**
		 * Gets the name of the slope ramp material.
		 * @type {String}
		 * @readonly
		 */
		static readonly SlopeRampMaterialType: string;

	}

	/**
	 * An appearance for arbitrary geometry (as opposed to {@link EllipsoidSurfaceAppearance}, for example)
	 * that supports shading with materials.
	 * @alias MaterialAppearance
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Boolean} [options.flat=false] When <code>true</code>, flat shading is used in the fragment shader, which means lighting is not taking into account.
	 * @param {Boolean} [options.faceForward=!options.closed] When <code>true</code>, the fragment shader flips the surface normal as needed to ensure that the normal faces the viewer to avoid dark spots.  This is useful when both sides of a geometry should be shaded like {@link WallGeometry}.
	 * @param {Boolean} [options.translucent=true] When <code>true</code>, the geometry is expected to appear translucent so {@link MaterialAppearance#renderState} has alpha blending enabled.
	 * @param {Boolean} [options.closed=false] When <code>true</code>, the geometry is expected to be closed so {@link MaterialAppearance#renderState} has backface culling enabled.
	 * @param {MaterialAppearance.MaterialSupport} [options.materialSupport=MaterialAppearance.MaterialSupport.TEXTURED] The type of materials that will be supported.
	 * @param {Material} [options.material=Material.ColorType] The material used to determine the fragment color.
	 * @param {String} [options.vertexShaderSource] Optional GLSL vertex shader source to override the default vertex shader.
	 * @param {String} [options.fragmentShaderSource] Optional GLSL fragment shader source to override the default fragment shader.
	 * @param {RenderState} [options.renderState] Optional render state to override the default render state.
	 * @see {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric|Fabric}
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Materials.html|Cesium Sandcastle Material Appearance Demo}
	 * @example
	 * var primitive = new Cesium.Primitive({
	 *   geometryInstances : new Cesium.GeometryInstance({
	 *     geometry : new Cesium.WallGeometry({
	 * materialSupport :  Cesium.MaterialAppearance.MaterialSupport.BASIC.vertexFormat,
	 *       // ...
	 *     })
	 *   }),
	 *   appearance : new Cesium.MaterialAppearance({
	 *     material : Cesium.Material.fromType('Color'),
	 *     faceForward : true
	 *   })
	 * });
	 */
	class MaterialAppearance {
		constructor(options?: {
			flat?: boolean;
			faceForward?: boolean;
			translucent?: boolean;
			closed?: boolean;
			materialSupport?: any;
			material?: Material;
			vertexShaderSource?: string;
			fragmentShaderSource?: string;
			renderState?: any;
		});

		/**
		 * The material used to determine the fragment color.  Unlike other {@link MaterialAppearance}
		 * properties, this is not read-only, so an appearance's material can change on the fly.
		 * @type Material
		 * @default {@link Material.ColorType}
		 * @see {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric|Fabric}
		 */
		material: Material;

		/**
		 * When <code>true</code>, the geometry is expected to appear translucent.
		 * @type {Boolean}
		 * @default true
		 */
		translucent: boolean;

		/**
		 * The GLSL source code for the vertex shader.
		 * @memberof MaterialAppearance.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly vertexShaderSource: string;

		/**
		 * The GLSL source code for the fragment shader.  The full fragment shader
		 * source is built procedurally taking into account {@link MaterialAppearance#material},
		 * {@link MaterialAppearance#flat}, and {@link MaterialAppearance#faceForward}.
		 * Use {@link MaterialAppearance#getFragmentShaderSource} to get the full source.
		 * @memberof MaterialAppearance.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly fragmentShaderSource: string;

		/**
		 * The WebGL fixed-function state to use when rendering the geometry.
		 * <p>
		 * The render state can be explicitly defined when constructing a {@link MaterialAppearance}
		 * instance, or it is set implicitly via {@link MaterialAppearance#translucent}
		 * and {@link MaterialAppearance#closed}.
		 * </p>
		 * @memberof MaterialAppearance.prototype
		 * @type {Object}
		 * @readonly
		 */
		readonly renderState: any;

		/**
		 * When <code>true</code>, the geometry is expected to be closed so
		 * {@link MaterialAppearance#renderState} has backface culling enabled.
		 * If the viewer enters the geometry, it will not be visible.
		 * @memberof MaterialAppearance.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default false
		 */
		readonly closed: boolean;

		/**
		 * The type of materials supported by this instance.  This impacts the required
		 * {@link VertexFormat} and the complexity of the vertex and fragment shaders.
		 * @memberof MaterialAppearance.prototype
		 * @type {MaterialAppearance.MaterialSupport}
		 * @readonly
		 * @default {@link MaterialAppearance.MaterialSupport.TEXTURED}
		 */
		readonly materialSupport: any;

		/**
		 * The {@link VertexFormat} that this appearance instance is compatible with.
		 * A geometry can have more vertex attributes and still be compatible - at a
		 * potential performance cost - but it can't have less.
		 * @memberof MaterialAppearance.prototype
		 * @type VertexFormat
		 * @readonly
		 * @default {@link MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat}
		 */
		readonly vertexFormat: VertexFormat;

		/**
		 * When <code>true</code>, flat shading is used in the fragment shader,
		 * which means lighting is not taking into account.
		 * @memberof MaterialAppearance.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default false
		 */
		readonly flat: boolean;

		/**
		 * When <code>true</code>, the fragment shader flips the surface normal
		 * as needed to ensure that the normal faces the viewer to avoid
		 * dark spots.  This is useful when both sides of a geometry should be
		 * shaded like {@link WallGeometry}.
		 * @memberof MaterialAppearance.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		readonly faceForward: boolean;

		/**
		 * Procedurally creates the full GLSL fragment shader source.  For {@link MaterialAppearance},
		 * this is derived from {@link MaterialAppearance#fragmentShaderSource}, {@link MaterialAppearance#material},
		 * {@link MaterialAppearance#flat}, and {@link MaterialAppearance#faceForward}.
		 * @function
		 * @returns {String} The full GLSL fragment shader source.
		 */
		getFragmentShaderSource(): string;

		/**
		 * Determines if the geometry is translucent based on {@link MaterialAppearance#translucent} and {@link Material#isTranslucent}.
		 * @function
		 * @returns {Boolean} <code>true</code> if the appearance is translucent.
		 */
		isTranslucent(): boolean;

		/**
		 * Creates a render state.  This is not the final render state instance; instead,
		 * it can contain a subset of render state properties identical to the render state
		 * created in the context.
		 * @function
		 * @returns {Object} The render state.
		 */
		getRenderState(): any;


	}

	/**
	 * A 3D model based on glTF, the runtime asset format for WebGL, OpenGL ES, and OpenGL.
	 * <p>
	 * Cesium includes support for geometry and materials, glTF animations, and glTF skinning.
	 * In addition, individual glTF nodes are pickable with {@link Scene#pick} and animatable
	 * with {@link Model#getNode}.  glTF cameras and lights are not currently supported.
	 * </p>
	 * <p>
	 * An external glTF asset is created with {@link Model.fromGltf}.  glTF JSON can also be
	 * created at runtime and passed to this constructor function.  In either case, the
	 * {@link Model#readyPromise} is resolved when the model is ready to render, i.e.,
	 * when the external binary, image, and shader files are downloaded and the WebGL
	 * resources are created.
	 * </p>
	 * <p>
	 * Cesium supports glTF assets with the following extensions:
	 * <ul>
	 * <li>
	 * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_binary_glTF/README.md|KHR_binary_glTF}
	 * </li><li>
	 * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_materials_common/README.md|KHR_materials_common}
	 * </li><li>
	 * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Vendor/WEB3D_quantized_attributes/README.md|WEB3D_quantized_attributes}
	 * </li><li>
	 * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_draco_mesh_compression/README.md|KHR_draco_mesh_compression}
	 * </li>
	 * </ul>
	 * </p>
	 * <p>
	 * For high-precision rendering, Cesium supports the {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Vendor/CESIUM_RTC/README.md|CESIUM_RTC} extension, which introduces the
	 * CESIUM_RTC_MODELVIEW parameter semantic that says the node is in WGS84 coordinates translated
	 * relative to a local origin.
	 * </p>
	 * @alias Model
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Object|ArrayBuffer|Uint8Array} [options.gltf] The object for the glTF JSON or an arraybuffer of Binary glTF defined by the KHR_binary_glTF extension.
	 * @param {Resource|String} [options.basePath=''] The base path that paths in the glTF JSON are relative to.
	 * @param {Boolean} [options.show=true] Determines if the model primitive will be shown.
	 * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms the model from model to world coordinates.
	 * @param {Number} [options.scale=1.0] A uniform scale applied to this model.
	 * @param {Number} [options.minimumPixelSize=0.0] The approximate minimum pixel size of the model regardless of zoom.
	 * @param {Number} [options.maximumScale] The maximum scale size of a model. An upper limit for minimumPixelSize.
	 * @param {Object} [options.id] A user-defined object to return when the model is picked with {@link Scene#pick}.
	 * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each glTF mesh and primitive is pickable with {@link Scene#pick}.
	 * @param {Boolean} [options.incrementallyLoadTextures=true] Determine if textures may continue to stream in after the model is loaded.
	 * @param {Boolean} [options.asynchronous=true] Determines if model WebGL resource creation will be spread out over several frames or block until completion once all glTF files are loaded.
	 * @param {Boolean} [options.clampAnimations=true] Determines if the model's animations should hold a pose over frames where no keyframes are specified.
	 * @param {ShadowMode} [options.shadows=ShadowMode.ENABLED] Determines whether the model casts or receives shadows from each light source.
	 * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Draws the bounding sphere for each draw command in the model.
	 * @param {Boolean} [options.debugWireframe=false] For debugging only. Draws the model in wireframe.
	 * @param {HeightReference} [options.heightReference] Determines how the model is drawn relative to terrain.
	 * @param {Scene} [options.scene] Must be passed in for models that use the height reference property.
	 * @param {DistanceDisplayCondition} [options.distanceDisplayCondition] The condition specifying at what distance from the camera that this model will be displayed.
	 * @param {Color} [options.color=Color.WHITE] A color that blends with the model's rendered color.
	 * @param {ColorBlendMode} [options.colorBlendMode=ColorBlendMode.HIGHLIGHT] Defines how the color blends with the model.
	 * @param {Number} [options.colorBlendAmount=0.5] Value used to determine the color strength when the <code>colorBlendMode</code> is <code>MIX</code>. A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with any value in-between resulting in a mix of the two.
	 * @param {Color} [options.silhouetteColor=Color.RED] The silhouette color. If more than 256 models have silhouettes enabled, there is a small chance that overlapping models will have minor artifacts.
	 * @param {Number} [options.silhouetteSize=0.0] The size of the silhouette in pixels.
	 * @param {ClippingPlaneCollection} [options.clippingPlanes] The {@link ClippingPlaneCollection} used to selectively disable rendering the model.
	 * @param {Boolean} [options.dequantizeInShader=true] Determines if a {@link https://github.com/google/draco|Draco} encoded model is dequantized on the GPU. This decreases total memory usage for encoded models.
	 * @exception {DeveloperError} bgltf is not a valid Binary glTF file.
	 * @exception {DeveloperError} Only glTF Binary version 1 is supported.
	 * @see Model.fromGltf
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=3D%20Models.html|Cesium Sandcastle Models Demo}
	 */
	class EngineModel {
		constructor(options?: {
			gltf?: any | ArrayBuffer | Uint8Array;
			basePath?: Resource | string;
			show?: boolean;
			modelMatrix?: Matrix4;
			scale?: number;
			minimumPixelSize?: number;
			maximumScale?: number;
			id?: any;
			allowPicking?: boolean;
			incrementallyLoadTextures?: boolean;
			asynchronous?: boolean;
			clampAnimations?: boolean;
			shadows?: any;
			debugShowBoundingVolume?: boolean;
			debugWireframe?: boolean;
			heightReference?: any;
			scene?: Scene;
			distanceDisplayCondition?: DistanceDisplayCondition;
			color?: Color;
			colorBlendMode?: any;
			colorBlendAmount?: number;
			silhouetteColor?: Color;
			silhouetteSize?: number;
			clippingPlanes?: ClippingPlaneCollection;
			dequantizeInShader?: boolean;
		});

		/**
		 * Determines if the model primitive will be shown.
		 * @type {Boolean}
		 * @default true
		 */
		show: boolean;

		/**
		 * The silhouette color.
		 * @type {Color}
		 * @default Color.RED
		 */
		silhouetteColor: Color;

		/**
		 * The size of the silhouette in pixels.
		 * @type {Number}
		 * @default 0.0
		 */
		silhouetteSize: number;

		/**
		 * The 4x4 transformation matrix that transforms the model from model to world coordinates.
		 * When this is the identity matrix, the model is drawn in world coordinates, i.e., Earth's WGS84 coordinates.
		 * Local reference frames can be used by providing a different transformation matrix, like that returned
		 * by {@link Transforms.eastNorthUpToFixedFrame}.
		 * @type {Matrix4}
		 * @default {@link Matrix4.IDENTITY}
		 * @example
		 * var origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);
		 * m.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);
		 */
		modelMatrix: Matrix4;

		/**
		 * A uniform scale applied to this model before the {@link Model#modelMatrix}.
		 * Values greater than <code>1.0</code> increase the size of the model; values
		 * less than <code>1.0</code> decrease.
		 * @type {Number}
		 * @default 1.0
		 */
		scale: number;

		/**
		 * The approximate minimum pixel size of the model regardless of zoom.
		 * This can be used to ensure that a model is visible even when the viewer
		 * zooms out.  When <code>0.0</code>, no minimum size is enforced.
		 * @type {Number}
		 * @default 0.0
		 */
		minimumPixelSize: number;

		/**
		 * The maximum scale size for a model. This can be used to give
		 * an upper limit to the {@link Model#minimumPixelSize}, ensuring that the model
		 * is never an unreasonable scale.
		 * @type {Number}
		 */
		maximumScale: number;

		/**
		 * User-defined object returned when the model is picked.
		 * @type Object
		 * @default undefined
		 * @see Scene#pick
		 */
		id: any;

		/**
		 * The currently playing glTF animations.
		 * @type {ModelAnimationCollection}
		 */
		activeAnimations: ModelAnimationCollection;

		/**
		 * Determines if the model's animations should hold a pose over frames where no keyframes are specified.
		 * @type {Boolean}
		 */
		clampAnimations: boolean;

		/**
		 * Determines whether the model casts or receives shadows from each light source.
		 * @type {ShadowMode}
		 * @default ShadowMode.ENABLED
		 */
		shadows: any;

		/**
		 * A color that blends with the model's rendered color.
		 * @type {Color}
		 * @default Color.WHITE
		 */
		color: Color;

		/**
		 * Defines how the color blends with the model.
		 * @type {ColorBlendMode}
		 * @default ColorBlendMode.HIGHLIGHT
		 */
		colorBlendMode: any;

		/**
		 * Value used to determine the color strength when the <code>colorBlendMode</code> is <code>MIX</code>.
		 * A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with
		 * any value in-between resulting in a mix of the two.
		 * @type {Number}
		 * @default 0.5
		 */
		colorBlendAmount: number;

		/**
		 * This property is for debugging only; it is not for production use nor is it optimized.
		 * <p>
		 * Draws the bounding sphere for each draw command in the model.  A glTF primitive corresponds
		 * to one draw command.  A glTF mesh has an array of primitives, often of length one.
		 * </p>
		 * @type {Boolean}
		 * @default false
		 */
		debugShowBoundingVolume: boolean;

		/**
		 * This property is for debugging only; it is not for production use nor is it optimized.
		 * <p>
		 * Draws the model in wireframe.
		 * </p>
		 * @type {Boolean}
		 * @default false
		 */
		debugWireframe: boolean;

		/**
		 * The object for the glTF JSON, including properties with default values omitted
		 * from the JSON provided to this model.
		 * @memberof Model.prototype
		 * @type {Object}
		 * @readonly
		 * @default undefined
		 */
		readonly gltf: any;

		/**
		 * The base path that paths in the glTF JSON are relative to.  The base
		 * path is the same path as the path containing the .gltf file
		 * minus the .gltf file, when binary, image, and shader files are
		 * in the same directory as the .gltf.  When this is <code>''</code>,
		 * the app's base path is used.
		 * @memberof Model.prototype
		 * @type {String}
		 * @readonly
		 * @default ''
		 */
		readonly basePath: string;

		/**
		 * The model's bounding sphere in its local coordinate system.  This does not take into
		 * account glTF animations and skins nor does it take into account {@link Model#minimumPixelSize}.
		 * @memberof Model.prototype
		 * @type {BoundingSphere}
		 * @readonly
		 * @default undefined
		 * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.
		 * @example
		 * // Center in WGS84 coordinates
		 * var center = Cesium.Matrix4.multiplyByPoint(model.modelMatrix, model.boundingSphere.center, new Cesium.Cartesian3());
		 */
		readonly boundingSphere: BoundingSphere;

		/**
		 * When <code>true</code>, this model is ready to render, i.e., the external binary, image,
		 * and shader files were downloaded and the WebGL resources were created.  This is set to
		 * <code>true</code> right before {@link Model#readyPromise} is resolved.
		 * @memberof Model.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default false
		 */
		readonly ready: boolean;

		/**
		 * Gets the promise that will be resolved when this model is ready to render, i.e., when the external binary, image,
		 * and shader files were downloaded and the WebGL resources were created.
		 * <p>
		 * This promise is resolved at the end of the frame before the first frame the model is rendered in.
		 * </p>
		 * @memberof Model.prototype
		 * @type {Promise.<Model>}
		 * @readonly
		 * @example
		 * // Play all animations at half-speed when the model is ready to render
		 * Cesium.when(model.readyPromise).then(function(model) {
		 *   model.activeAnimations.addAll({
		 *     speedup : 0.5
		 *   });
		 * }).otherwise(function(error){
		 *   window.alert(error);
		 * });
		 * @see Model#ready
		 */
		readonly readyPromise: any;

		/**
		 * Determines if model WebGL resource creation will be spread out over several frames or
		 * block until completion once all glTF files are loaded.
		 * @memberof Model.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		readonly asynchronous: boolean;

		/**
		 * When <code>true</code>, each glTF mesh and primitive is pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.
		 * @memberof Model.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		readonly allowPicking: boolean;

		/**
		 * Determine if textures may continue to stream in after the model is loaded.
		 * @memberof Model.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		readonly incrementallyLoadTextures: boolean;

		/**
		 * Return the number of pending texture loads.
		 * @memberof Model.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly pendingTextureLoads: number;

		/**
		 * Gets or sets the condition specifying at what distance from the camera that this model will be displayed.
		 * @memberof Model.prototype
		 * @type {DistanceDisplayCondition}
		 * @default undefined
		 */
		distanceDisplayCondition: DistanceDisplayCondition;

		/**
		 * The {@link ClippingPlaneCollection} used to selectively disable rendering the model.
		 * @memberof Model.prototype
		 * @type {ClippingPlaneCollection}
		 */
		clippingPlanes: ClippingPlaneCollection;

		/**
		 * Determines if silhouettes are supported.
		 * @param {Scene} scene The scene.
		 * @returns {Boolean} <code>true</code> if silhouettes are supported; otherwise, returns <code>false</code>
		 */
		static silhouetteSupported(scene: Scene): boolean;

		/**
		 * <p>
		 * Creates a model from a glTF asset.  When the model is ready to render, i.e., when the external binary, image,
		 * and shader files are downloaded and the WebGL resources are created, the {@link Model#readyPromise} is resolved.
		 * </p>
		 * <p>
		 * The model can be a traditional glTF asset with a .gltf extension or a Binary glTF using the
		 * KHR_binary_glTF extension with a .glb extension.
		 * </p>
		 * <p>
		 * Cesium supports glTF assets with the following extensions:
		 * <ul>
		 * <li>
		 * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_binary_glTF/README.md|KHR_binary_glTF}
		 * </li><li>
		 * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_materials_common/README.md|KHR_materials_common}
		 * </li><li>
		 * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Vendor/WEB3D_quantized_attributes/README.md|WEB3D_quantized_attributes}
		 * </li><li>
		 * {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_draco_mesh_compression/README.md|KHR_draco_mesh_compression}
		 * </li>
		 * </ul>
		 * </p>
		 * <p>
		 * For high-precision rendering, Cesium supports the {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Vendor/CESIUM_RTC/README.md|CESIUM_RTC} extension, which introduces the
		 * CESIUM_RTC_MODELVIEW parameter semantic that says the node is in WGS84 coordinates translated
		 * relative to a local origin.
		 * </p>
		 * @param {Object} options Object with the following properties:
		 * @param {Resource|String} options.url The url to the .gltf file.
		 * @param {Resource|String} [options.basePath] The base path that paths in the glTF JSON are relative to.
		 * @param {Boolean} [options.show=true] Determines if the model primitive will be shown.
		 * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms the model from model to world coordinates.
		 * @param {Number} [options.scale=1.0] A uniform scale applied to this model.
		 * @param {Number} [options.minimumPixelSize=0.0] The approximate minimum pixel size of the model regardless of zoom.
		 * @param {Number} [options.maximumScale] The maximum scale for the model.
		 * @param {Object} [options.id] A user-defined object to return when the model is picked with {@link Scene#pick}.
		 * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each glTF mesh and primitive is pickable with {@link Scene#pick}.
		 * @param {Boolean} [options.incrementallyLoadTextures=true] Determine if textures may continue to stream in after the model is loaded.
		 * @param {Boolean} [options.asynchronous=true] Determines if model WebGL resource creation will be spread out over several frames or block until completion once all glTF files are loaded.
		 * @param {Boolean} [options.clampAnimations=true] Determines if the model's animations should hold a pose over frames where no keyframes are specified.
		 * @param {ShadowMode} [options.shadows=ShadowMode.ENABLED] Determines whether the model casts or receives shadows from each light source.
		 * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Draws the bounding sphere for each {@link DrawCommand} in the model.
		 * @param {Boolean} [options.debugWireframe=false] For debugging only. Draws the model in wireframe.
		 * @param {HeightReference} [options.heightReference] Determines how the model is drawn relative to terrain.
		 * @param {Scene} [options.scene] Must be passed in for models that use the height reference property.
		 * @param {DistanceDisplayCondition} [options.distanceDisplayCondition] The condition specifying at what distance from the camera that this model will be displayed.
		 * @param {Color} [options.color=Color.WHITE] A color that blends with the model's rendered color.
		 * @param {ColorBlendMode} [options.colorBlendMode=ColorBlendMode.HIGHLIGHT] Defines how the color blends with the model.
		 * @param {Number} [options.colorBlendAmount=0.5] Value used to determine the color strength when the <code>colorBlendMode</code> is <code>MIX</code>. A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with any value in-between resulting in a mix of the two.
		 * @param {Color} [options.silhouetteColor=Color.RED] The silhouette color. If more than 256 models have silhouettes enabled, there is a small chance that overlapping models will have minor artifacts.
		 * @param {Number} [options.silhouetteSize=0.0] The size of the silhouette in pixels.
		 * @param {ClippingPlaneCollection} [options.clippingPlanes] The {@link ClippingPlaneCollection} used to selectively disable rendering the model.
		 * @param {Boolean} [options.dequantizeInShader=true] Determines if a {@link https://github.com/google/draco|Draco} encoded model is dequantized on the GPU. This decreases total memory usage for encoded models.
		 * @returns {Model} The newly created model.
		 * @exception {DeveloperError} bgltf is not a valid Binary glTF file.
		 * @exception {DeveloperError} Only glTF Binary version 1 is supported.
		 * @example
		 * // Example 1. Create a model from a glTF asset
		 * var model = scene.primitives.add(Cesium.Model.fromGltf({
		 *   url : './duck/duck.gltf'
		 * }));
		 * @example
		 * // Example 2. Create model and provide all properties and events
		 * var origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);
		 * var modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);
		 * var model = scene.primitives.add(Cesium.Model.fromGltf({
		 *   url : './duck/duck.gltf',
		 *   show : true,                     // default
		 *   modelMatrix : modelMatrix,
		 *   scale : 2.0,                     // double size
		 *   minimumPixelSize : 128,          // never smaller than 128 pixels
		 *   maximumScale: 20000,             // never larger than 20000 * model size (overrides minimumPixelSize)
		 *   allowPicking : false,            // not pickable
		 *   debugShowBoundingVolume : false, // default
		 *   debugWireframe : false
		 * }));
		 * model.readyPromise.then(function(model) {
		 *   // Play all animations when the model is ready to render
		 *   model.activeAnimations.addAll();
		 * });
		 */
		static fromGltf(options: {
			url: Resource | string;
			basePath?: Resource | string;
			show?: boolean;
			modelMatrix?: Matrix4;
			scale?: number;
			minimumPixelSize?: number;
			maximumScale?: number;
			id?: any;
			allowPicking?: boolean;
			incrementallyLoadTextures?: boolean;
			asynchronous?: boolean;
			clampAnimations?: boolean;
			shadows?: any;
			debugShowBoundingVolume?: boolean;
			debugWireframe?: boolean;
			heightReference?: any;
			scene?: Scene;
			distanceDisplayCondition?: DistanceDisplayCondition;
			color?: Color;
			colorBlendMode?: any;
			colorBlendAmount?: number;
			silhouetteColor?: Color;
			silhouetteSize?: number;
			clippingPlanes?: ClippingPlaneCollection;
			dequantizeInShader?: boolean;
		}): Model;

		/**
		 * Returns the glTF node with the given <code>name</code> property.  This is used to
		 * modify a node's transform for animation outside of glTF animations.
		 * @param {String} name The glTF name of the node.
		 * @returns {ModelNode} The node or <code>undefined</code> if no node with <code>name</code> exists.
		 * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.
		 * @example
		 * // Apply non-uniform scale to node LOD3sp
		 * var node = model.getNode('LOD3sp');
		 * node.matrix = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(5.0, 1.0, 1.0), node.matrix);
		 */
		getNode(name: string): ModelNode;

		/**
		 * Returns the glTF mesh with the given <code>name</code> property.
		 * @param {String} name The glTF name of the mesh.
		 * @returns {ModelMesh} The mesh or <code>undefined</code> if no mesh with <code>name</code> exists.
		 * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.
		 */
		getMesh(name: string): ModelMesh;

		/**
		 * Returns the glTF material with the given <code>name</code> property.
		 * @param {String} name The glTF name of the material.
		 * @returns {ModelMaterial} The material or <code>undefined</code> if no material with <code>name</code> exists.
		 * @exception {DeveloperError} The model is not loaded.  Use Model.readyPromise or wait for Model.ready to be true.
		 */
		getMaterial(name: string): ModelMaterial;

		/**
		 * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
		 * get the draw commands needed to render this primitive.
		 * <p>
		 * Do not call this function directly.  This is documented just to
		 * list the exceptions that may be propagated when the scene is rendered:
		 * </p>
		 * @exception {RuntimeError} Failed to load external reference.
		 */
		update(): void;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <br /><br />
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
		 * @see Model#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
		 * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
		 * <br /><br />
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * model = model && model.destroy();
		 * @see Model#isDestroyed
		 */
		destroy(): void;

	}

	/**
	 * An active glTF animation.  A glTF asset can contain animations.  An active animation
	 * is an animation that is currently playing or scheduled to be played because it was
	 * added to a model's {@link ModelAnimationCollection}.  An active animation is an
	 * instance of an animation; for example, there can be multiple active animations
	 * for the same glTF animation, each with a different start time.
	 * <p>
	 * Create this by calling {@link ModelAnimationCollection#add}.
	 * </p>
	 * @alias ModelAnimation
	 * @internalConstructor
	 * @class
	 * @see ModelAnimationCollection#add
	 */
	class ModelAnimation {
		constructor();

		/**
		 * When <code>true</code>, the animation is removed after it stops playing.
		 * This is slightly more efficient that not removing it, but if, for example,
		 * time is reversed, the animation is not played again.
		 * @type {Boolean}
		 * @default false
		 */
		removeOnStop: boolean;

		/**
		 * The event fired when this animation is started.  This can be used, for
		 * example, to play a sound or start a particle system, when the animation starts.
		 * <p>
		 * This event is fired at the end of the frame after the scene is rendered.
		 * </p>
		 * @type {Event}
		 * @default new Event()
		 * @example
		 * animation.start.addEventListener(function(model, animation) {
		 *   console.log('Animation started: ' + animation.name);
		 * });
		 */
		start: Event;

		/**
		 * The event fired when on each frame when this animation is updated.  The
		 * current time of the animation, relative to the glTF animation time span, is
		 * passed to the event, which allows, for example, starting new animations at a
		 * specific time relative to a playing animation.
		 * <p>
		 * This event is fired at the end of the frame after the scene is rendered.
		 * </p>
		 * @type {Event}
		 * @default new Event()
		 * @example
		 * animation.update.addEventListener(function(model, animation, time) {
		 *   console.log('Animation updated: ' + animation.name + '. glTF animation time: ' + time);
		 * });
		 */
		update: Event;

		/**
		 * The event fired when this animation is stopped.  This can be used, for
		 * example, to play a sound or start a particle system, when the animation stops.
		 * <p>
		 * This event is fired at the end of the frame after the scene is rendered.
		 * </p>
		 * @type {Event}
		 * @default new Event()
		 * @example
		 * animation.stop.addEventListener(function(model, animation) {
		 *   console.log('Animation stopped: ' + animation.name);
		 * });
		 */
		stop: Event;

		/**
		 * The glTF animation name that identifies this animation.
		 * @memberof ModelAnimation.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly name: string;

		/**
		 * The scene time to start playing this animation.  When this is <code>undefined</code>,
		 * the animation starts at the next frame.
		 * @memberof ModelAnimation.prototype
		 * @type {JulianDate}
		 * @readonly
		 * @default undefined
		 */
		readonly startTime: JulianDate;

		/**
		 * The delay, in seconds, from {@link ModelAnimation#startTime} to start playing.
		 * @memberof ModelAnimation.prototype
		 * @type {Number}
		 * @readonly
		 * @default undefined
		 */
		readonly delay: number;

		/**
		 * The scene time to stop playing this animation.  When this is <code>undefined</code>,
		 * the animation is played for its full duration and perhaps repeated depending on
		 * {@link ModelAnimation#loop}.
		 * @memberof ModelAnimation.prototype
		 * @type {JulianDate}
		 * @readonly
		 * @default undefined
		 */
		readonly stopTime: JulianDate;

		/**
		 * Values greater than <code>1.0</code> increase the speed that the animation is played relative
		 * to the scene clock speed; values less than <code>1.0</code> decrease the speed.  A value of
		 * <code>1.0</code> plays the animation at the speed in the glTF animation mapped to the scene
		 * clock speed.  For example, if the scene is played at 2x real-time, a two-second glTF animation
		 * will play in one second even if <code>speedup</code> is <code>1.0</code>.
		 * @memberof ModelAnimation.prototype
		 * @type {Number}
		 * @readonly
		 * @default 1.0
		 */
		readonly speedup: number;

		/**
		 * When <code>true</code>, the animation is played in reverse.
		 * @memberof ModelAnimation.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default false
		 */
		readonly reverse: boolean;

		/**
		 * Determines if and how the animation is looped.
		 * @memberof ModelAnimation.prototype
		 * @type {ModelAnimationLoop}
		 * @readonly
		 * @default {@link ModelAnimationLoop.NONE}
		 */
		readonly loop: any;

	}

	/**
	 * A collection of active model animations.  Access this using {@link Model#activeAnimations}.
	 * @alias ModelAnimationCollection
	 * @internalConstructor
	 * @class
	 * @see Model#activeAnimations
	 */
	class ModelAnimationCollection {
		constructor();

		/**
		 * The event fired when an animation is added to the collection.  This can be used, for
		 * example, to keep a UI in sync.
		 * @type {Event}
		 * @default new Event()
		 * @example
		 * model.activeAnimations.animationAdded.addEventListener(function(model, animation) {
		 *   console.log('Animation added: ' + animation.name);
		 * });
		 */
		animationAdded: Event;

		/**
		 * The event fired when an animation is removed from the collection.  This can be used, for
		 * example, to keep a UI in sync.
		 * @type {Event}
		 * @default new Event()
		 * @example
		 * model.activeAnimations.animationRemoved.addEventListener(function(model, animation) {
		 *   console.log('Animation removed: ' + animation.name);
		 * });
		 */
		animationRemoved: Event;

		/**
		 * The number of animations in the collection.
		 * @memberof ModelAnimationCollection.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly length: number;

		/**
		 * Creates and adds an animation with the specified initial properties to the collection.
		 * <p>
		 * This raises the {@link ModelAnimationCollection#animationAdded} event so, for example, a UI can stay in sync.
		 * </p>
		 * @param {Object} options Object with the following properties:
		 * @param {String} [options.name] The glTF animation name that identifies the animation. Must be defined if <code>options.id</code> is <code>undefined</code>.
		 * @param {Number} [options.index] The glTF animation index that identifies the animation. Must be defined if <code>options.name</code> is <code>undefined</code>.
		 * @param {JulianDate} [options.startTime] The scene time to start playing the animation.  When this is <code>undefined</code>, the animation starts at the next frame.
		 * @param {Number} [options.delay=0.0] The delay, in seconds, from <code>startTime</code> to start playing.
		 * @param {JulianDate} [options.stopTime] The scene time to stop playing the animation.  When this is <code>undefined</code>, the animation is played for its full duration.
		 * @param {Boolean} [options.removeOnStop=false] When <code>true</code>, the animation is removed after it stops playing.
		 * @param {Number} [options.speedup=1.0] Values greater than <code>1.0</code> increase the speed that the animation is played relative to the scene clock speed; values less than <code>1.0</code> decrease the speed.
		 * @param {Boolean} [options.reverse=false] When <code>true</code>, the animation is played in reverse.
		 * @param {ModelAnimationLoop} [options.loop=ModelAnimationLoop.NONE] Determines if and how the animation is looped.
		 * @returns {ModelAnimation} The animation that was added to the collection.
		 * @exception {DeveloperError} Animations are not loaded.  Wait for the {@link Model#readyPromise} to resolve.
		 * @exception {DeveloperError} options.name must be a valid animation name.
		 * @exception {DeveloperError} options.index must be a valid animation index.
		 * @exception {DeveloperError} Either options.name or options.index must be defined.
		 * @exception {DeveloperError} options.speedup must be greater than zero.
		 * @example
		 * // Example 1. Add an animation by name
		 * model.activeAnimations.add({
		 *   name : 'animation name'
		 * });
		 * // Example 2. Add an animation by index
		 * model.activeAnimations.add({
		 *   index : 0
		 * });
		 * @example
		 * // Example 3. Add an animation and provide all properties and events
		 * var startTime = Cesium.JulianDate.now();
		 * var animation = model.activeAnimations.add({
		 *   name : 'another animation name',
		 *   startTime : startTime,
		 *   delay : 0.0,                          // Play at startTime (default)
		 *   stopTime : Cesium.JulianDate.addSeconds(startTime, 4.0, new Cesium.JulianDate()),
		 *   removeOnStop : false,                 // Do not remove when animation stops (default)
		 *   speedup : 2.0,                        // Play at double speed
		 *   reverse : true,                       // Play in reverse
		 *   loop : Cesium.ModelAnimationLoop.REPEAT      // Loop the animation
		 * });
		 * animation.start.addEventListener(function(model, animation) {
		 *   console.log('Animation started: ' + animation.name);
		 * });
		 * animation.update.addEventListener(function(model, animation, time) {
		 *   console.log('Animation updated: ' + animation.name + '. glTF animation time: ' + time);
		 * });
		 * animation.stop.addEventListener(function(model, animation) {
		 *   console.log('Animation stopped: ' + animation.name);
		 * });
		 */
		add(options: {
			name?: string;
			index?: number;
			startTime?: JulianDate;
			delay?: number;
			stopTime?: JulianDate;
			removeOnStop?: boolean;
			speedup?: number;
			reverse?: boolean;
			loop?: any;
		}): ModelAnimation;

		/**
		 * Creates and adds an animation with the specified initial properties to the collection
		 * for each animation in the model.
		 * <p>
		 * This raises the {@link ModelAnimationCollection#animationAdded} event for each model so, for example, a UI can stay in sync.
		 * </p>
		 * @param {Object} [options] Object with the following properties:
		 * @param {JulianDate} [options.startTime] The scene time to start playing the animations.  When this is <code>undefined</code>, the animations starts at the next frame.
		 * @param {Number} [options.delay=0.0] The delay, in seconds, from <code>startTime</code> to start playing.
		 * @param {JulianDate} [options.stopTime] The scene time to stop playing the animations.  When this is <code>undefined</code>, the animations are played for its full duration.
		 * @param {Boolean} [options.removeOnStop=false] When <code>true</code>, the animations are removed after they stop playing.
		 * @param {Number} [options.speedup=1.0] Values greater than <code>1.0</code> increase the speed that the animations play relative to the scene clock speed; values less than <code>1.0</code> decrease the speed.
		 * @param {Boolean} [options.reverse=false] When <code>true</code>, the animations are played in reverse.
		 * @param {ModelAnimationLoop} [options.loop=ModelAnimationLoop.NONE] Determines if and how the animations are looped.
		 * @returns {ModelAnimation[]} An array of {@link ModelAnimation} objects, one for each animation added to the collection.  If there are no glTF animations, the array is empty.
		 * @exception {DeveloperError} Animations are not loaded.  Wait for the {@link Model#readyPromise} to resolve.
		 * @exception {DeveloperError} options.speedup must be greater than zero.
		 * @example
		 * model.activeAnimations.addAll({
		 *   speedup : 0.5,                        // Play at half-speed
		 *   loop : Cesium.ModelAnimationLoop.REPEAT      // Loop the animations
		 * });
		 */
		addAll(options?: {
			startTime?: JulianDate;
			delay?: number;
			stopTime?: JulianDate;
			removeOnStop?: boolean;
			speedup?: number;
			reverse?: boolean;
			loop?: any;
		}): (ModelAnimation)[];

		/**
		 * Removes an animation from the collection.
		 * <p>
		 * This raises the {@link ModelAnimationCollection#animationRemoved} event so, for example, a UI can stay in sync.
		 * </p>
		 * <p>
		 * An animation can also be implicitly removed from the collection by setting {@link ModelAnimation#removeOnStop} to
		 * <code>true</code>.  The {@link ModelAnimationCollection#animationRemoved} event is still fired when the animation is removed.
		 * </p>
		 * @param {ModelAnimation} animation The animation to remove.
		 * @returns {Boolean} <code>true</code> if the animation was removed; <code>false</code> if the animation was not found in the collection.
		 * @example
		 * var a = model.activeAnimations.add({
		 *   name : 'animation name'
		 * });
		 * model.activeAnimations.remove(a); // Returns true
		 */
		remove(animation: ModelAnimation): boolean;

		/**
		 * Removes all animations from the collection.
		 * <p>
		 * This raises the {@link ModelAnimationCollection#animationRemoved} event for each
		 * animation so, for example, a UI can stay in sync.
		 * </p>
		 */
		removeAll(): void;

		/**
		 * Determines whether this collection contains a given animation.
		 * @param {ModelAnimation} animation The animation to check for.
		 * @returns {Boolean} <code>true</code> if this collection contains the animation, <code>false</code> otherwise.
		 */
		contains(animation: ModelAnimation): boolean;

		/**
		 * Returns the animation in the collection at the specified index.  Indices are zero-based
		 * and increase as animations are added.  Removing an animation shifts all animations after
		 * it to the left, changing their indices.  This function is commonly used to iterate over
		 * all the animations in the collection.
		 * @param {Number} index The zero-based index of the animation.
		 * @returns {ModelAnimation} The animation at the specified index.
		 * @example
		 * // Output the names of all the animations in the collection.
		 * var animations = model.activeAnimations;
		 * var length = animations.length;
		 * for (var i = 0; i < length; ++i) {
		 *   console.log(animations.get(i).name);
		 * }
		 */
		get(index: number): ModelAnimation;

	}

	/**
	 * A model's material with modifiable parameters.  A glTF material
	 * contains parameters defined by the material's technique with values
	 * defined by the technique and potentially overridden by the material.
	 * This class allows changing these values at runtime.
	 * <p>
	 * Use {@link Model#getMaterial} to create an instance.
	 * </p>
	 * @alias ModelMaterial
	 * @internalConstructor
	 * @class
	 * @see Model#getMaterial
	 */
	class ModelMaterial {
		constructor();

		/**
		 * The value of the <code>name</code> property of this material.  This is the
		 * name assigned by the artist when the asset is created.  This can be
		 * different than the name of the material property ({@link ModelMaterial#id}),
		 * which is internal to glTF.
		 * @memberof ModelMaterial.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly name: string;

		/**
		 * The name of the glTF JSON property for this material.  This is guaranteed
		 * to be unique among all materials.  It may not match the material's <code>
		 * name</code> property (@link ModelMaterial#name), which is assigned by
		 * the artist when the asset is created.
		 * @memberof ModelMaterial.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly id: string;

		/**
		 * Assigns a value to a material parameter.  The type for <code>value</code>
		 * depends on the glTF type of the parameter.  It will be a floating-point
		 * number, Cartesian, or matrix.
		 * @param {String} name The name of the parameter.
		 * @param {*} [value] The value to assign to the parameter.
		 * @exception {DeveloperError} name must match a parameter name in the material's technique that is targetable and not optimized out.
		 * @example
		 * material.setValue('diffuse', new Cesium.Cartesian4(1.0, 0.0, 0.0, 1.0));  // vec4
		 * material.setValue('shininess', 256.0);                             // scalar
		 */
		setValue(name: string, value?: any): void;

		/**
		 * Returns the value of the parameter with the given <code>name</code>.  The type of the
		 * returned object depends on the glTF type of the parameter.  It will be a floating-point
		 * number, Cartesian, or matrix.
		 * @param {String} name The name of the parameter.
		 * @returns {*} The value of the parameter or <code>undefined</code> if the parameter does not exist.
		 */
		getValue(name: string): any;

	}

	/**
	 * A model's mesh and its materials.
	 * <p>
	 * Use {@link Model#getMesh} to create an instance.
	 * </p>
	 * @alias ModelMesh
	 * @internalConstructor
	 * @class
	 * @see Model#getMesh
	 */
	class ModelMesh {
		constructor();

		/**
		 * The value of the <code>name</code> property of this mesh.  This is the
		 * name assigned by the artist when the asset is created.  This can be
		 * different than the name of the mesh property ({@link ModelMesh#id}),
		 * which is internal to glTF.
		 * @memberof ModelMesh.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly name: string;

		/**
		 * The name of the glTF JSON property for this mesh.  This is guaranteed
		 * to be unique among all meshes.  It may not match the mesh's <code>
		 * name</code> property (@link ModelMesh#name), which is assigned by
		 * the artist when the asset is created.
		 * @memberof ModelMesh.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly id: string;

		/**
		 * An array of {@link ModelMaterial} instances indexed by the mesh's
		 * primitive indices.
		 * @memberof ModelMesh.prototype
		 * @type {ModelMaterial[]}
		 * @readonly
		 */
		readonly materials: (ModelMaterial)[];

	}

	/**
	 * A model node with a transform for user-defined animations.  A glTF asset can
	 * contain animations that target a node's transform.  This class allows
	 * changing a node's transform externally so animation can be driven by another
	 * source, not just an animation in the glTF asset.
	 * <p>
	 * Use {@link Model#getNode} to create an instance.
	 * </p>
	 * @alias ModelNode
	 * @internalConstructor
	 * @class
	 * @example
	 * var node = model.getNode('LOD3sp');
	 * node.matrix = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(5.0, 1.0, 1.0), node.matrix);
	 * @see Model#getNode
	 */
	class ModelNode {
		constructor();

		/**
		 * The value of the <code>name</code> property of this node.  This is the
		 * name assigned by the artist when the asset is created.  This can be
		 * different than the name of the node property ({@link ModelNode#id}),
		 * which is internal to glTF.
		 * @memberof ModelNode.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly name: string;

		/**
		 * The name of the glTF JSON property for this node.  This is guaranteed
		 * to be unique among all nodes.  It may not match the node's <code>
		 * name</code> property (@link ModelNode#name), which is assigned by
		 * the artist when the asset is created.
		 * @memberof ModelNode.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly id: string;

		/**
		 * Determines if this node and its children will be shown.
		 * @memberof ModelNode.prototype
		 * @type {Boolean}
		 * @default true
		 */
		show: boolean;

		/**
		 * The node's 4x4 matrix transform from its local coordinates to
		 * its parent's.
		 * <p>
		 * For changes to take effect, this property must be assigned to;
		 * setting individual elements of the matrix will not work.
		 * </p>
		 * @memberof ModelNode.prototype
		 * @type {Matrix4}
		 */
		matrix: Matrix4;

	}

	/**
	 * Draws the Moon in 3D.
	 * @alias Moon
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Boolean} [options.show=true] Determines whether the moon will be rendered.
	 * @param {String} [options.textureUrl=buildModuleUrl('Assets/Textures/moonSmall.jpg')] The moon texture.
	 * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.MOON] The moon ellipsoid.
	 * @param {Boolean} [options.onlySunLighting=true] Use the sun as the only light source.
	 * @example
	 * scene.moon = new Cesium.Moon();
	 * @see Scene#moon
	 */
	class Moon {
		constructor(options?: {
			show?: boolean;
			textureUrl?: string;
			ellipsoid?: Ellipsoid;
			onlySunLighting?: boolean;
		});

		/**
		 * Determines if the moon will be shown.
		 * @type {Boolean}
		 * @default true
		 */
		show: boolean;

		/**
		 * The moon texture.
		 * @type {String}
		 * @default buildModuleUrl('Assets/Textures/moonSmall.jpg')
		 */
		textureUrl: string;

		/**
		 * Use the sun as the only light source.
		 * @type {Boolean}
		 * @default true
		 */
		onlySunLighting: boolean;

		/**
		 * Get the ellipsoid that defines the shape of the moon.
		 * @memberof Moon.prototype
		 * @type {Ellipsoid}
		 * @readonly
		 * @default {@link Ellipsoid.MOON}
		 */
		readonly ellipsoid: Ellipsoid;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <br /><br />
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
		 * @see Moon#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
		 * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
		 * <br /><br />
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * moon = moon && moon.destroy();
		 * @see Moon#isDestroyed
		 */
		destroy(): void;

	}

	/**
	 * A {@link TileDiscardPolicy} specifying that tile images should never be discard.
	 * @alias NeverTileDiscardPolicy
	 * @constructor
	 * @see DiscardMissingTileImagePolicy
	 */
	class NeverTileDiscardPolicy {
		constructor();

		/**
		 * Determines if the discard policy is ready to process images.
		 * @returns {Boolean} True if the discard policy is ready to process images; otherwise, false.
		 */
		isReady(): boolean;

		/**
		 * Given a tile image, decide whether to discard that image.
		 * @param {Image} image An image to test.
		 * @returns {Boolean} True if the image should be discarded; otherwise, false.
		 */
		shouldDiscardImage(image: any): boolean;

	}

	/**
	 * A particle emitted by a {@link ParticleSystem}.
	 * @alias Particle
	 * @constructor
	 * @param {Object} options An object with the following properties:
	 * @param {Number} [options.mass=1.0] The mass of the particle in kilograms.
	 * @param {Cartesian3} [options.position=Cartesian3.ZERO] The initial position of the particle in world coordinates.
	 * @param {Cartesian3} [options.velocity=Cartesian3.ZERO] The velocity vector of the particle in world coordinates.
	 * @param {Number} [options.life=Number.MAX_VALUE] The life of the particle in seconds.
	 * @param {Object} [options.image] The URI, HTMLImageElement, or HTMLCanvasElement to use for the billboard.
	 * @param {Color} [options.startColor=Color.WHITE] The color of a particle when it is born.
	 * @param {Color} [options.endColor=Color.WHITE] The color of a particle when it dies.
	 * @param {Number} [options.startScale=1.0] The scale of the particle when it is born.
	 * @param {Number} [options.endScale=1.0] The scale of the particle when it dies.
	 * @param {Cartesian2} [options.imageSize=new Cartesian2(1.0, 1.0)] The dimensions, width by height, to scale the particle image in pixels.
	 */
	class Particle {
		constructor(options: {
			mass?: number;
			position?: Cartesian3;
			velocity?: Cartesian3;
			life?: number;
			image?: any;
			startColor?: Color;
			endColor?: Color;
			startScale?: number;
			endScale?: number;
			imageSize?: Cartesian2;
		});

		/**
		 * The mass of the particle in kilograms.
		 * @type {Number}
		 * @default 1.0
		 */
		mass: number;

		/**
		 * The positon of the particle in world coordinates.
		 * @type {Cartesian3}
		 * @default Cartesian3.ZERO
		 */
		position: Cartesian3;

		/**
		 * The velocity of the particle in world coordinates.
		 * @type {Cartesian3}
		 * @default Cartesian3.ZERO
		 */
		velocity: Cartesian3;

		/**
		 * The life of the particle in seconds.
		 * @type {Number}
		 * @default Number.MAX_VALUE
		 */
		life: number;

		/**
		 * The image to use for the particle.
		 * @type {Object}
		 * @default undefined
		 */
		image: any;

		/**
		 * The color of the particle when it is born.
		 * @type {Color}
		 * @default Color.WHITE
		 */
		startColor: Color;

		/**
		 * The color of the particle when it dies.
		 * @type {Color}
		 * @default Color.WHITE
		 */
		endColor: Color;

		/**
		 * the scale of the particle when it is born.
		 * @type {Number}
		 * @default 1.0
		 */
		startScale: number;

		/**
		 * The scale of the particle when it dies.
		 * @type {Number}
		 * @default 1.0
		 */
		endScale: number;

		/**
		 * The dimensions, width by height, to scale the particle image in pixels.
		 * @type {Cartesian2}
		 * @default new Cartesian(1.0, 1.0)
		 */
		imageSize: Cartesian2;

		/**
		 * Gets the age of the particle in seconds.
		 * @memberof Particle.prototype
		 * @type {Number}
		 */
		age: number;

		/**
		 * Gets the age normalized to a value in the range [0.0, 1.0].
		 * @memberof Particle.prototype
		 * @type {Number}
		 */
		normalizedAge: number;

	}

	/**
	 * Represents a burst of {@link Particle}s from a {@link ParticleSystem} at a given time in the systems lifetime.
	 * @alias ParticleBurst
	 * @constructor
	 * @param {Object} [options] An object with the following properties:
	 * @param {Number} [options.time=0.0] The time in seconds after the beginning of the particle system's lifetime that the burst will occur.
	 * @param {Number} [options.minimum=0.0] The minimum number of particles emmitted in the burst.
	 * @param {Number} [options.maximum=50.0] The maximum number of particles emitted in the burst.
	 */
	class ParticleBurst {
		constructor(options?: {
			time?: number;
			minimum?: number;
			maximum?: number;
		});

		/**
		 * The time in seconds after the eginning of the particle system's lifetime that the burst will occur.
		 * @type {Number}
		 * @default 0.0
		 */
		time: number;

		/**
		 * The minimum number of particles emitted.
		 * @type {Number}
		 * @default 0.0
		 */
		minimum: number;

		/**
		 * The maximum number of particles emitted.
		 * @type {Number}
		 * @default 50.0
		 */
		maximum: number;

		/**
		 * <code>true</code> if the burst has been completed; <code>false</code> otherwise.
		 * @memberof ParticleBurst.prototype
		 * @type {Boolean}
		 */
		complete: boolean;

	}

	/**
	 * <p>
	 * An object that initializes a {@link Particle} from a {@link ParticleSystem}.
	 * </p>
	 * <p>
	 * This type describes an interface and is not intended to be instantiated directly.
	 * </p>
	 * @alias ParticleEmitter
	 * @constructor
	 * @see BoxEmitter
	 * @see CircleEmitter
	 * @see ConeEmitter
	 * @see SphereEmitter
	 */
	class ParticleEmitter {
		constructor();

	}

	/**
	 * A ParticleSystem manages the updating and display of a collection of particles.
	 * @alias ParticleSystem
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Boolean} [options.show=true] Whether to display the particle system.
	 * @param {function} [options.updateFunction] The callback function to be called each frame to update a particle.
	 * @param {ParticleEmitter} [options.emitter=new CircleEmitter(0.5)] The particle emitter for this system.
	 * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms the particle system from model to world coordinates.
	 * @param {Matrix4} [options.emitterModelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms the particle system emitter within the particle systems local coordinate system.
	 * @param {Number} [options.emissionRate=5] The number of particles to emit per second.
	 * @param {ParticleBurst[]} [options.bursts] An array of {@link ParticleBurst}, emitting bursts of particles at periodic times.
	 * @param {Boolean} [options.loop=true] Whether the particle system should loop its bursts when it is complete.
	 * @param {Number} [options.scale=1.0] Sets the scale to apply to the image of the particle for the duration of its particleLife.
	 * @param {Number} [options.startScale] The initial scale to apply to the image of the particle at the beginning of its life.
	 * @param {Number} [options.endScale] The final scale to apply to the image of the particle at the end of its life.
	 * @param {Color} [options.color=Color.WHITE] Sets the color of a particle for the duration of its particleLife.
	 * @param {Color} [options.startColor] The color of the particle at the beginning of its life.
	 * @param {Color} [options.endColor] The color of the particle at the end of its life.
	 * @param {Object} [options.image] The URI, HTMLImageElement, or HTMLCanvasElement to use for the billboard.
	 * @param {Cartesian2} [options.imageSize=new Cartesian2(1.0, 1.0)] If set, overrides the minimumImageSize and maximumImageSize inputs that scale the particle image's dimensions in pixels.
	 * @param {Cartesian2} [options.minimumImageSize] Sets the minimum bound, width by height, above which to randomly scale the particle image's dimensions in pixels.
	 * @param {Cartesian2} [options.maximumImageSize] Sets the maximum bound, width by height, below which to randomly scale the particle image's dimensions in pixels.
	 * @param {Number} [options.speed=1.0] If set, overrides the minimumSpeed and maximumSpeed inputs with this value.
	 * @param {Number} [options.minimumSpeed] Sets the minimum bound in meters per second above which a particle's actual speed will be randomly chosen.
	 * @param {Number} [options.maximumSpeed] Sets the maximum bound in meters per second below which a particle's actual speed will be randomly chosen.
	 * @param {Number} [options.lifetime=Number.MAX_VALUE] How long the particle system will emit particles, in seconds.
	 * @param {Number} [options.particleLife=5.0] If set, overrides the minimumParticleLife and maximumParticleLife inputs with this value.
	 * @param {Number} [options.minimumParticleLife] Sets the minimum bound in seconds for the possible duration of a particle's life above which a particle's actual life will be randomly chosen.
	 * @param {Number} [options.maximumParticleLife] Sets the maximum bound in seconds for the possible duration of a particle's life below which a particle's actual life will be randomly chosen.
	 * @param {Number} [options.mass=1.0] Sets the minimum and maximum mass of particles in kilograms.
	 * @param {Number} [options.minimumMass] Sets the minimum bound for the mass of a particle in kilograms. A particle's actual mass will be chosen as a random amount above this value.
	 * @param {Number} [options.maximumMass] Sets the maximum mass of particles in kilograms. A particle's actual mass will be chosen as a random amount below this value.
	 * @tutorial {@link https://cesiumjs.org/tutorials/Particle-Systems-Tutorial/|Particle Systems Tutorial}
	 * @demo {@link https://cesiumjs.org/Cesium/Build/Apps/Sandcastle/?src=Particle%20System.html&label=Showcases|Particle Systems Tutorial Demo}
	 * @demo {@link https://cesiumjs.org/Cesium/Build/Apps/Sandcastle/?src=Particle%20System%20Fireworks.html&label=Showcases|Particle Systems Fireworks Demo}
	 */
	class ParticleSystem {
		constructor(options?: {
			show?: boolean;
			updateFunction?: Function;
			emitter?: ParticleEmitter;
			modelMatrix?: Matrix4;
			emitterModelMatrix?: Matrix4;
			emissionRate?: number;
			bursts?: (ParticleBurst)[];
			loop?: boolean;
			scale?: number;
			startScale?: number;
			endScale?: number;
			color?: Color;
			startColor?: Color;
			endColor?: Color;
			image?: any;
			imageSize?: Cartesian2;
			minimumImageSize?: Cartesian2;
			maximumImageSize?: Cartesian2;
			speed?: number;
			minimumSpeed?: number;
			maximumSpeed?: number;
			lifetime?: number;
			particleLife?: number;
			minimumParticleLife?: number;
			maximumParticleLife?: number;
			mass?: number;
			minimumMass?: number;
			maximumMass?: number;
		});

		/**
		 * Whether to display the particle system.
		 * @type {Boolean}
		 * @default true
		 */
		show: boolean;

		/**
		 * An array of force callbacks. The callback is passed a {@link Particle} and the difference from the last time
		 * @type {function}
		 * @default undefined
		 */
		updateFunction: Function;

		/**
		 * Whether the particle system should loop it's bursts when it is complete.
		 * @type {Boolean}
		 * @default true
		 */
		loop: boolean;

		/**
		 * The URI, HTMLImageElement, or HTMLCanvasElement to use for the billboard.
		 * @type {Object}
		 * @default undefined
		 */
		image: any;

		/**
		 * The particle emitter for this
		 * @memberof ParticleSystem.prototype
		 * @type {ParticleEmitter}
		 * @default CircleEmitter
		 */
		emitter: ParticleEmitter;

		/**
		 * An array of {@link ParticleBurst}, emitting bursts of particles at periodic times.
		 * @memberof ParticleSystem.prototype
		 * @type {ParticleBurst[]}
		 * @default undefined
		 */
		bursts: (ParticleBurst)[];

		/**
		 * The 4x4 transformation matrix that transforms the particle system from model to world coordinates.
		 * @memberof ParticleSystem.prototype
		 * @type {Matrix4}
		 * @default Matrix4.IDENTITY
		 */
		modelMatrix: Matrix4;

		/**
		 * The 4x4 transformation matrix that transforms the particle system emitter within the particle systems local coordinate system.
		 * @memberof ParticleSystem.prototype
		 * @type {Matrix4}
		 * @default Matrix4.IDENTITY
		 */
		emitterModelMatrix: Matrix4;

		/**
		 * The color of the particle at the beginning of its life.
		 * @memberof ParticleSystem.prototype
		 * @type {Color}
		 * @default Color.WHITE
		 */
		startColor: Color;

		/**
		 * The color of the particle at the end of its life.
		 * @memberof ParticleSystem.prototype
		 * @type {Color}
		 * @default Color.WHITE
		 */
		endColor: Color;

		/**
		 * The initial scale to apply to the image of the particle at the beginning of its life.
		 * @memberof ParticleSystem.prototype
		 * @type {Number}
		 * @default 1.0
		 */
		startScale: number;

		/**
		 * The final scale to apply to the image of the particle at the end of its life.
		 * @memberof ParticleSystem.prototype
		 * @type {Number}
		 * @default 1.0
		 */
		endScale: number;

		/**
		 * The number of particles to emit per second.
		 * @memberof ParticleSystem.prototype
		 * @type {Number}
		 * @default 5
		 */
		emissionRate: number;

		/**
		 * Sets the minimum bound in meters per second above which a particle's actual speed will be randomly chosen.
		 * @memberof ParticleSystem.prototype
		 * @type {Number}
		 * @default 1.0
		 */
		minimumSpeed: number;

		/**
		 * Sets the maximum bound in meters per second below which a particle's actual speed will be randomly chosen.
		 * @memberof ParticleSystem.prototype
		 * @type {Number}
		 * @default 1.0
		 */
		maximumSpeed: number;

		/**
		 * Sets the minimum bound in seconds for the possible duration of a particle's life above which a particle's actual life will be randomly chosen.
		 * @memberof ParticleSystem.prototype
		 * @type {Number}
		 * @default 5.0
		 */
		minimumParticleLife: number;

		/**
		 * Sets the maximum bound in seconds for the possible duration of a particle's life below which a particle's actual life will be randomly chosen.
		 * @memberof ParticleSystem.prototype
		 * @type {Number}
		 * @default 5.0
		 */
		maximumParticleLife: number;

		/**
		 * Sets the minimum mass of particles in kilograms.
		 * @memberof ParticleSystem.prototype
		 * @type {Number}
		 * @default 1.0
		 */
		minimumMass: number;

		/**
		 * Sets the maximum mass of particles in kilograms.
		 * @memberof ParticleSystem.prototype
		 * @type {Number}
		 * @default 1.0
		 */
		maximumMass: number;

		/**
		 * Sets the minimum bound, width by height, above which to randomly scale the particle image's dimensions in pixels.
		 * @memberof ParticleSystem.prototype
		 * @type {Cartesian2}
		 * @default new Cartesian2(1.0, 1.0)
		 */
		minimumImageSize: Cartesian2;

		/**
		 * Sets the maximum bound, width by height, below which to randomly scale the particle image's dimensions in pixels.
		 * @memberof ParticleSystem.prototype
		 * @type {Cartesian2}
		 * @default new Cartesian2(1.0, 1.0)
		 */
		maximumImageSize: Cartesian2;

		/**
		 * How long the particle system will emit particles, in seconds.
		 * @memberof ParticleSystem.prototype
		 * @type {Number}
		 * @default Number.MAX_VALUE
		 */
		lifetime: number;

		/**
		 * Fires an event when the particle system has reached the end of its lifetime.
		 * @memberof ParticleSystem.prototype
		 * @type {Event}
		 */
		complete: Event;

		/**
		 * When <code>true</code>, the particle system has reached the end of its lifetime; <code>false</code> otherwise.
		 * @memberof ParticleSystem.prototype
		 * @type {Boolean}
		 */
		isComplete: boolean;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <br /><br />
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
		 * @see ParticleSystem#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
		 * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
		 * <br /><br />
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @see ParticleSystem#isDestroyed
		 */
		destroy(): void;

	}

	/**
	 * An appearance for {@link GeometryInstance} instances with color attributes.
	 * This allows several geometry instances, each with a different color, to
	 * be drawn with the same {@link Primitive} as shown in the second example below.
	 * @alias PerInstanceColorAppearance
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Boolean} [options.flat=false] When <code>true</code>, flat shading is used in the fragment shader, which means lighting is not taking into account.
	 * @param {Boolean} [options.faceForward=!options.closed] When <code>true</code>, the fragment shader flips the surface normal as needed to ensure that the normal faces the viewer to avoid dark spots.  This is useful when both sides of a geometry should be shaded like {@link WallGeometry}.
	 * @param {Boolean} [options.translucent=true] When <code>true</code>, the geometry is expected to appear translucent so {@link PerInstanceColorAppearance#renderState} has alpha blending enabled.
	 * @param {Boolean} [options.closed=false] When <code>true</code>, the geometry is expected to be closed so {@link PerInstanceColorAppearance#renderState} has backface culling enabled.
	 * @param {String} [options.vertexShaderSource] Optional GLSL vertex shader source to override the default vertex shader.
	 * @param {String} [options.fragmentShaderSource] Optional GLSL fragment shader source to override the default fragment shader.
	 * @param {RenderState} [options.renderState] Optional render state to override the default render state.
	 * @example
	 * // A solid white line segment
	 * var primitive = new Cesium.Primitive({
	 *   geometryInstances : new Cesium.GeometryInstance({
	 *     geometry : new Cesium.SimplePolylineGeometry({
	 *       positions : Cesium.Cartesian3.fromDegreesArray([
	 *         0.0, 0.0,
	 *         5.0, 0.0
	 *       ])
	 *     }),
	 *     attributes : {
	 *       color : Cesium.ColorGeometryInstanceAttribute.fromColor(new Cesium.Color(1.0, 1.0, 1.0, 1.0))
	 *     }
	 *   }),
	 *   appearance : new Cesium.PerInstanceColorAppearance({
	 *     flat : true,
	 *     translucent : false
	 *   })
	 * });
	 * // Two rectangles in a primitive, each with a different color
	 * var instance = new Cesium.GeometryInstance({
	 *   geometry : new Cesium.RectangleGeometry({
	 *     rectangle : Cesium.Rectangle.fromDegrees(0.0, 20.0, 10.0, 30.0)
	 *   }),
	 *   attributes : {
	 *     color : new Cesium.Color(1.0, 0.0, 0.0, 0.5)
	 *   }
	 * });
	 * var anotherInstance = new Cesium.GeometryInstance({
	 *   geometry : new Cesium.RectangleGeometry({
	 *     rectangle : Cesium.Rectangle.fromDegrees(0.0, 40.0, 10.0, 50.0)
	 *   }),
	 *   attributes : {
	 *     color : new Cesium.Color(0.0, 0.0, 1.0, 0.5)
	 *   }
	 * });
	 * var rectanglePrimitive = new Cesium.Primitive({
	 *   geometryInstances : [instance, anotherInstance],
	 *   appearance : new Cesium.PerInstanceColorAppearance()
	 * });
	 */
	class PerInstanceColorAppearance {
		constructor(options?: {
			flat?: boolean;
			faceForward?: boolean;
			translucent?: boolean;
			closed?: boolean;
			vertexShaderSource?: string;
			fragmentShaderSource?: string;
			renderState?: any;
		});

		/**
		 * This property is part of the {@link Appearance} interface, but is not
		 * used by {@link PerInstanceColorAppearance} since a fully custom fragment shader is used.
		 * @type Material
		 * @default undefined
		 */
		material: Material;

		/**
		 * When <code>true</code>, the geometry is expected to appear translucent so
		 * {@link PerInstanceColorAppearance#renderState} has alpha blending enabled.
		 * @type {Boolean}
		 * @default true
		 */
		translucent: boolean;

		/**
		 * The GLSL source code for the vertex shader.
		 * @memberof PerInstanceColorAppearance.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly vertexShaderSource: string;

		/**
		 * The GLSL source code for the fragment shader.
		 * @memberof PerInstanceColorAppearance.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly fragmentShaderSource: string;

		/**
		 * The WebGL fixed-function state to use when rendering the geometry.
		 * <p>
		 * The render state can be explicitly defined when constructing a {@link PerInstanceColorAppearance}
		 * instance, or it is set implicitly via {@link PerInstanceColorAppearance#translucent}
		 * and {@link PerInstanceColorAppearance#closed}.
		 * </p>
		 * @memberof PerInstanceColorAppearance.prototype
		 * @type {Object}
		 * @readonly
		 */
		readonly renderState: any;

		/**
		 * When <code>true</code>, the geometry is expected to be closed so
		 * {@link PerInstanceColorAppearance#renderState} has backface culling enabled.
		 * If the viewer enters the geometry, it will not be visible.
		 * @memberof PerInstanceColorAppearance.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default false
		 */
		readonly closed: boolean;

		/**
		 * The {@link VertexFormat} that this appearance instance is compatible with.
		 * A geometry can have more vertex attributes and still be compatible - at a
		 * potential performance cost - but it can't have less.
		 * @memberof PerInstanceColorAppearance.prototype
		 * @type VertexFormat
		 * @readonly
		 */
		readonly vertexFormat: VertexFormat;

		/**
		 * When <code>true</code>, flat shading is used in the fragment shader,
		 * which means lighting is not taking into account.
		 * @memberof PerInstanceColorAppearance.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default false
		 */
		readonly flat: boolean;

		/**
		 * When <code>true</code>, the fragment shader flips the surface normal
		 * as needed to ensure that the normal faces the viewer to avoid
		 * dark spots.  This is useful when both sides of a geometry should be
		 * shaded like {@link WallGeometry}.
		 * @memberof PerInstanceColorAppearance.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		readonly faceForward: boolean;

		/**
		 * The {@link VertexFormat} that all {@link PerInstanceColorAppearance} instances
		 * are compatible with.  This requires only <code>position</code> and <code>st</code>
		 * attributes.
		 * @type VertexFormat
		 * @constant
		 */
		static VERTEX_FORMAT: VertexFormat;

		/**
		 * The {@link VertexFormat} that all {@link PerInstanceColorAppearance} instances
		 * are compatible with when {@link PerInstanceColorAppearance#flat} is <code>false</code>.
		 * This requires only a <code>position</code> attribute.
		 * @type VertexFormat
		 * @constant
		 */
		static FLAT_VERTEX_FORMAT: VertexFormat;

		/**
		 * Procedurally creates the full GLSL fragment shader source.  For {@link PerInstanceColorAppearance},
		 * this is derived from {@link PerInstanceColorAppearance#fragmentShaderSource}, {@link PerInstanceColorAppearance#flat},
		 * and {@link PerInstanceColorAppearance#faceForward}.
		 * @function
		 * @returns {String} The full GLSL fragment shader source.
		 */
		getFragmentShaderSource(): string;

		/**
		 * Determines if the geometry is translucent based on {@link PerInstanceColorAppearance#translucent}.
		 * @function
		 * @returns {Boolean} <code>true</code> if the appearance is translucent.
		 */
		isTranslucent(): boolean;

		/**
		 * Creates a render state.  This is not the final render state instance; instead,
		 * it can contain a subset of render state properties identical to the render state
		 * created in the context.
		 * @function
		 * @returns {Object} The render state.
		 */
		getRenderState(): any;

	}

	/**
	 * Options for performing point attenuation based on geometric error when rendering
	 * point clouds using 3D Tiles.
	 * @param {Object} [options] Object with the following properties:
	 * @param {Boolean} [options.attenuation=false] Perform point attenuation based on geometric error.
	 * @param {Number} [options.geometricErrorScale=1.0] Scale to be applied to each tile's geometric error.
	 * @param {Number} [options.maximumAttenuation] Maximum attenuation in pixels. Defaults to the Cesium3DTileset's maximumScreenSpaceError.
	 * @param {Number} [options.baseResolution] Average base resolution for the dataset in meters. Substitute for Geometric Error when not available.
	 * @param {Boolean} [options.eyeDomeLighting=true] When true, use eye dome lighting when drawing with point attenuation.
	 * @param {Number} [options.eyeDomeLightingStrength=1.0] Increasing this value increases contrast on slopes and edges.
	 * @param {Number} [options.eyeDomeLightingRadius=1.0] Increase the thickness of contours from eye dome lighting.
	 * @alias PointCloudShading
	 * @constructor
	 */
	class PointCloudShading {
		constructor(options?: {
			attenuation?: boolean;
			geometricErrorScale?: number;
			maximumAttenuation?: number;
			baseResolution?: number;
			eyeDomeLighting?: boolean;
			eyeDomeLightingStrength?: number;
			eyeDomeLightingRadius?: number;
		});

		/**
		 * Perform point attenuation based on geometric error.
		 * @type {Boolean}
		 * @default false
		 */
		attenuation: boolean;

		/**
		 * Scale to be applied to the geometric error before computing attenuation.
		 * @type {Number}
		 * @default 1.0
		 */
		geometricErrorScale: number;

		/**
		 * Maximum point attenuation in pixels. If undefined, the Cesium3DTileset's maximumScreenSpaceError will be used.
		 * @type {Number}
		 */
		maximumAttenuation: number;

		/**
		 * Average base resolution for the dataset in meters.
		 * Used in place of geometric error when geometric error is 0.
		 * If undefined, an approximation will be computed for each tile that has geometric error of 0.
		 * @type {Number}
		 */
		baseResolution: number;

		/**
		 * Use eye dome lighting when drawing with point attenuation
		 * Requires support for EXT_frag_depth, OES_texture_float, and WEBGL_draw_buffers extensions in WebGL 1.0,
		 * otherwise eye dome lighting is ignored.
		 * @type {Boolean}
		 * @default true
		 */
		eyeDomeLighting: boolean;

		/**
		 * Eye dome lighting strength (apparent contrast)
		 * @type {Number}
		 * @default 1.0
		 */
		eyeDomeLightingStrength: number;

		/**
		 * Thickness of contours from eye dome lighting
		 * @type {Number}
		 * @default 1.0
		 */
		eyeDomeLightingRadius: number;

		/**
		 * Determines if point cloud shading is supported.
		 * @param {Scene} scene The scene.
		 * @returns {Boolean} <code>true</code> if point cloud shading is supported; otherwise, returns <code>false</code>
		 */
		static isSupported(scene: Scene): boolean;

	}

	/**
	 * A graphical point positioned in the 3D scene, that is created
	 * and rendered using a {@link PointPrimitiveCollection}.  A point is created and its initial
	 * properties are set by calling {@link PointPrimitiveCollection#add}.
	 * @alias PointPrimitive
	 * @performance Reading a property, e.g., {@link PointPrimitive#show}, is constant time.
	 * Assigning to a property is constant time but results in
	 * CPU to GPU traffic when {@link PointPrimitiveCollection#update} is called.  The per-pointPrimitive traffic is
	 * the same regardless of how many properties were updated.  If most pointPrimitives in a collection need to be
	 * updated, it may be more efficient to clear the collection with {@link PointPrimitiveCollection#removeAll}
	 * and add new pointPrimitives instead of modifying each one.
	 * @exception {DeveloperError} scaleByDistance.far must be greater than scaleByDistance.near
	 * @exception {DeveloperError} translucencyByDistance.far must be greater than translucencyByDistance.near
	 * @exception {DeveloperError} distanceDisplayCondition.far must be greater than distanceDisplayCondition.near
	 * @see PointPrimitiveCollection
	 * @see PointPrimitiveCollection#add
	 * @internalConstructor
	 * @class
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Points.html|Cesium Sandcastle Points Demo}
	 */
	class PointPrimitive {
		constructor();

		/**
		 * Determines if this point will be shown.  Use this to hide or show a point, instead
		 * of removing it and re-adding it to the collection.
		 * @memberof PointPrimitive.prototype
		 * @type {Boolean}
		 */
		show: boolean;

		/**
		 * Gets or sets the Cartesian position of this point.
		 * @memberof PointPrimitive.prototype
		 * @type {Cartesian3}
		 */
		position: Cartesian3;

		/**
		 * Gets or sets near and far scaling properties of a point based on the point's distance from the camera.
		 * A point's scale will interpolate between the {@link NearFarScalar#nearValue} and
		 * {@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
		 * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
		 * Outside of these ranges the point's scale remains clamped to the nearest bound.  This scale
		 * multiplies the pixelSize and outlineWidth to affect the total size of the point.  If undefined,
		 * scaleByDistance will be disabled.
		 * @memberof PointPrimitive.prototype
		 * @type {NearFarScalar}
		 * @example
		 * // Example 1.
		 * // Set a pointPrimitive's scaleByDistance to scale to 15 when the
		 * // camera is 1500 meters from the pointPrimitive and disappear as
		 * // the camera distance approaches 8.0e6 meters.
		 * p.scaleByDistance = new Cesium.NearFarScalar(1.5e2, 15, 8.0e6, 0.0);
		 * @example
		 * // Example 2.
		 * // disable scaling by distance
		 * p.scaleByDistance = undefined;
		 */
		scaleByDistance: NearFarScalar;

		/**
		 * Gets or sets near and far translucency properties of a point based on the point's distance from the camera.
		 * A point's translucency will interpolate between the {@link NearFarScalar#nearValue} and
		 * {@link NearFarScalar#farValue} while the camera distance falls within the upper and lower bounds
		 * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
		 * Outside of these ranges the point's translucency remains clamped to the nearest bound.  If undefined,
		 * translucencyByDistance will be disabled.
		 * @memberof PointPrimitive.prototype
		 * @type {NearFarScalar}
		 * @example
		 * // Example 1.
		 * // Set a point's translucency to 1.0 when the
		 * // camera is 1500 meters from the point and disappear as
		 * // the camera distance approaches 8.0e6 meters.
		 * p.translucencyByDistance = new Cesium.NearFarScalar(1.5e2, 1.0, 8.0e6, 0.0);
		 * @example
		 * // Example 2.
		 * // disable translucency by distance
		 * p.translucencyByDistance = undefined;
		 */
		translucencyByDistance: NearFarScalar;

		/**
		 * Gets or sets the inner size of the point in pixels.
		 * @memberof PointPrimitive.prototype
		 * @type {Number}
		 */
		pixelSize: number;

		/**
		 * Gets or sets the inner color of the point.
		 * The red, green, blue, and alpha values are indicated by <code>value</code>'s <code>red</code>, <code>green</code>,
		 * <code>blue</code>, and <code>alpha</code> properties as shown in Example 1.  These components range from <code>0.0</code>
		 * (no intensity) to <code>1.0</code> (full intensity).
		 * @memberof PointPrimitive.prototype
		 * @type {Color}
		 * @example
		 * // Example 1. Assign yellow.
		 * p.color = Cesium.Color.YELLOW;
		 * @example
		 * // Example 2. Make a pointPrimitive 50% translucent.
		 * p.color = new Cesium.Color(1.0, 1.0, 1.0, 0.5);
		 */
		color: Color;

		/**
		 * Gets or sets the outline color of the point.
		 * @memberof PointPrimitive.prototype
		 * @type {Color}
		 */
		outlineColor: Color;

		/**
		 * Gets or sets the outline width in pixels.  This width adds to pixelSize,
		 * increasing the total size of the point.
		 * @memberof PointPrimitive.prototype
		 * @type {Number}
		 */
		outlineWidth: number;

		/**
		 * Gets or sets the condition specifying at what distance from the camera that this point will be displayed.
		 * @memberof PointPrimitive.prototype
		 * @type {DistanceDisplayCondition}
		 * @default undefined
		 */
		distanceDisplayCondition: DistanceDisplayCondition;

		/**
		 * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.
		 * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.
		 * @memberof PointPrimitive.prototype
		 * @type {Number}
		 * @default 0.0
		 */
		disableDepthTestDistance: number;

		/**
		 * Gets or sets the user-defined value returned when the point is picked.
		 * @memberof PointPrimitive.prototype
		 * @type {*}
		 */
		id: any;

		/**
		 * Computes the screen-space position of the point's origin.
		 * The screen space origin is the top, left corner of the canvas; <code>x</code> increases from
		 * left to right, and <code>y</code> increases from top to bottom.
		 * @param {Scene} scene The scene.
		 * @param {Cartesian2} [result] The object onto which to store the result.
		 * @returns {Cartesian2} The screen-space position of the point.
		 * @exception {DeveloperError} PointPrimitive must be in a collection.
		 * @example
		 * console.log(p.computeScreenSpacePosition(scene).toString());
		 */
		computeScreenSpacePosition(scene: Scene, result?: Cartesian2): Cartesian2;

		/**
		 * Determines if this point equals another point.  Points are equal if all their properties
		 * are equal.  Points in different collections can be equal.
		 * @param {PointPrimitive} other The point to compare for equality.
		 * @returns {Boolean} <code>true</code> if the points are equal; otherwise, <code>false</code>.
		 */
		equals(other: PointPrimitive): boolean;

	}

	/**
	 * A renderable collection of points.
	 * <br /><br />
	 * Points are added and removed from the collection using {@link PointPrimitiveCollection#add}
	 * and {@link PointPrimitiveCollection#remove}.
	 * @alias PointPrimitiveCollection
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms each point from model to world coordinates.
	 * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.
	 * @param {BlendOption} [options.blendOption=BlendOption.OPAQUE_AND_TRANSLUCENT] The point blending option. The default
	 * is used for rendering both opaque and translucent points. However, if either all of the points are completely opaque or all are completely translucent,
	 * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve performance by up to 2x.
	 * @performance For best performance, prefer a few collections, each with many points, to
	 * many collections with only a few points each.  Organize collections so that points
	 * with the same update frequency are in the same collection, i.e., points that do not
	 * change should be in one collection; points that change every frame should be in another
	 * collection; and so on.
	 * @example
	 * // Create a pointPrimitive collection with two points
	 * var points = scene.primitives.add(new Cesium.PointPrimitiveCollection());
	 * points.add({
	 *   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),
	 *   color : Cesium.Color.YELLOW
	 * });
	 * points.add({
	 *   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),
	 *   color : Cesium.Color.CYAN
	 * });
	 * @see PointPrimitiveCollection#add
	 * @see PointPrimitiveCollection#remove
	 * @see PointPrimitive
	 */
	class PointPrimitiveCollection {
		constructor(options?: {
			modelMatrix?: Matrix4;
			debugShowBoundingVolume?: boolean;
			blendOption?: any;
		});

		/**
		 * The 4x4 transformation matrix that transforms each point in this collection from model to world coordinates.
		 * When this is the identity matrix, the pointPrimitives are drawn in world coordinates, i.e., Earth's WGS84 coordinates.
		 * Local reference frames can be used by providing a different transformation matrix, like that returned
		 * by {@link Transforms.eastNorthUpToFixedFrame}.
		 * @type {Matrix4}
		 * @default {@link Matrix4.IDENTITY}
		 * @example
		 * var center = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);
		 * pointPrimitives.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);
		 * pointPrimitives.add({
		 *   color : Cesium.Color.ORANGE,
		 *   position : new Cesium.Cartesian3(0.0, 0.0, 0.0) // center
		 * });
		 * pointPrimitives.add({
		 *   color : Cesium.Color.YELLOW,
		 *   position : new Cesium.Cartesian3(1000000.0, 0.0, 0.0) // east
		 * });
		 * pointPrimitives.add({
		 *   color : Cesium.Color.GREEN,
		 *   position : new Cesium.Cartesian3(0.0, 1000000.0, 0.0) // north
		 * });
		 * pointPrimitives.add({
		 *   color : Cesium.Color.CYAN,
		 *   position : new Cesium.Cartesian3(0.0, 0.0, 1000000.0) // up
		 * });
		 * @see Transforms.eastNorthUpToFixedFrame
		 */
		modelMatrix: Matrix4;

		/**
		 * This property is for debugging only; it is not for production use nor is it optimized.
		 * <p>
		 * Draws the bounding sphere for each draw command in the primitive.
		 * </p>
		 * @type {Boolean}
		 * @default false
		 */
		debugShowBoundingVolume: boolean;

		/**
		 * The point blending option. The default is used for rendering both opaque and translucent points.
		 * However, if either all of the points are completely opaque or all are completely translucent,
		 * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve
		 * performance by up to 2x.
		 * @type {BlendOption}
		 * @default BlendOption.OPAQUE_AND_TRANSLUCENT
		 */
		blendOption: any;

		/**
		 * Returns the number of points in this collection.  This is commonly used with
		 * {@link PointPrimitiveCollection#get} to iterate over all the points
		 * in the collection.
		 * @memberof PointPrimitiveCollection.prototype
		 * @type {Number}
		 */
		length: number;

		/**
		 * Creates and adds a point with the specified initial properties to the collection.
		 * The added point is returned so it can be modified or removed from the collection later.
		 * @param {Object}[pointPrimitive] A template describing the point's properties as shown in Example 1.
		 * @returns {PointPrimitive} The point that was added to the collection.
		 * @performance Calling <code>add</code> is expected constant time.  However, the collection's vertex buffer
		 * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For
		 * best performance, add as many pointPrimitives as possible before calling <code>update</code>.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * // Example 1:  Add a point, specifying all the default values.
		 * var p = pointPrimitives.add({
		 *   show : true,
		 *   position : Cesium.Cartesian3.ZERO,
		 *   pixelSize : 10.0,
		 *   color : Cesium.Color.WHITE,
		 *   outlineColor : Cesium.Color.TRANSPARENT,
		 *   outlineWidth : 0.0,
		 *   id : undefined
		 * });
		 * @example
		 * // Example 2:  Specify only the point's cartographic position.
		 * var p = pointPrimitives.add({
		 *   position : Cesium.Cartesian3.fromDegrees(longitude, latitude, height)
		 * });
		 * @see PointPrimitiveCollection#remove
		 * @see PointPrimitiveCollection#removeAll
		 */
		add(pointPrimitive?: any): PointPrimitive;

		/**
		 * Removes a point from the collection.
		 * @param {PointPrimitive} pointPrimitive The point to remove.
		 * @returns {Boolean} <code>true</code> if the point was removed; <code>false</code> if the point was not found in the collection.
		 * @performance Calling <code>remove</code> is expected constant time.  However, the collection's vertex buffer
		 * is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.  For
		 * best performance, remove as many points as possible before calling <code>update</code>.
		 * If you intend to temporarily hide a point, it is usually more efficient to call
		 * {@link PointPrimitive#show} instead of removing and re-adding the point.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * var p = pointPrimitives.add(...);
		 * pointPrimitives.remove(p);  // Returns true
		 * @see PointPrimitiveCollection#add
		 * @see PointPrimitiveCollection#removeAll
		 * @see PointPrimitive#show
		 */
		remove(pointPrimitive: PointPrimitive): boolean;

		/**
		 * Removes all points from the collection.
		 * @performance <code>O(n)</code>.  It is more efficient to remove all the points
		 * from a collection and then add new ones than to create a new collection entirely.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * pointPrimitives.add(...);
		 * pointPrimitives.add(...);
		 * pointPrimitives.removeAll();
		 * @see PointPrimitiveCollection#add
		 * @see PointPrimitiveCollection#remove
		 */
		removeAll(): void;

		/**
		 * Check whether this collection contains a given point.
		 * @param {PointPrimitive} [pointPrimitive] The point to check for.
		 * @returns {Boolean} true if this collection contains the point, false otherwise.
		 * @see PointPrimitiveCollection#get
		 */
		contains(pointPrimitive?: PointPrimitive): boolean;

		/**
		 * Returns the point in the collection at the specified index.  Indices are zero-based
		 * and increase as points are added.  Removing a point shifts all points after
		 * it to the left, changing their indices.  This function is commonly used with
		 * {@link PointPrimitiveCollection#length} to iterate over all the points
		 * in the collection.
		 * @param {Number} index The zero-based index of the point.
		 * @returns {PointPrimitive} The point at the specified index.
		 * @performance Expected constant time.  If points were removed from the collection and
		 * {@link PointPrimitiveCollection#update} was not called, an implicit <code>O(n)</code>
		 * operation is performed.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * // Toggle the show property of every point in the collection
		 * var len = pointPrimitives.length;
		 * for (var i = 0; i < len; ++i) {
		 *   var p = pointPrimitives.get(i);
		 *   p.show = !p.show;
		 * }
		 * @see PointPrimitiveCollection#length
		 */
		get(index: number): PointPrimitive;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <br /><br />
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
		 * @see PointPrimitiveCollection#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
		 * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
		 * <br /><br />
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * pointPrimitives = pointPrimitives && pointPrimitives.destroy();
		 * @see PointPrimitiveCollection#isDestroyed
		 */
		destroy(): void;

	}

	/**
	 * A renderable polyline. Create this by calling {@link PolylineCollection#add}
	 * @alias EnginePolyline
	 * @internalConstructor
	 * @class
	 * @param {Object} [options] Object with the following properties:
	 * @param {Boolean} [options.show=true] <code>true</code> if this polyline will be shown; otherwise, <code>false</code>.
	 * @param {Number} [options.width=1.0] The width of the polyline in pixels.
	 * @param {Boolean} [options.loop=false] Whether a line segment will be added between the last and first line positions to make this line a loop.
	 * @param {Material} [options.material=Material.ColorType] The material.
	 * @param {Cartesian3[]} [options.positions] The positions.
	 * @param {Object} [options.id] The user-defined object to be returned when this polyline is picked.
	 * @param {DistanceDisplayCondition} [options.distanceDisplayCondition] The condition specifying at what distance from the camera that this polyline will be displayed.
	 * @param {PolylineCollection} [polylineCollection] The renderable polyline collection.
	 * @see PolylineCollection
	 */
	class EnginePolyline {
		constructor(options?: {
			show?: boolean;
			width?: number;
			loop?: boolean;
			material?: Material;
			positions?: (Cartesian3)[];
			id?: any;
			distanceDisplayCondition?: DistanceDisplayCondition;
		}, polylineCollection?: PolylineCollection);

		/**
		 * Determines if this polyline will be shown.  Use this to hide or show a polyline, instead
		 * of removing it and re-adding it to the collection.
		 * @memberof EnginePolyline.prototype
		 * @type {Boolean}
		 */
		show: boolean;

		/**
		 * Gets or sets the positions of the polyline.
		 * @memberof EnginePolyline.prototype
		 * @type {Cartesian3[]}
		 * @example
		 * polyline.positions = Cesium.Cartesian3.fromDegreesArray([
		 *     0.0, 0.0,
		 *     10.0, 0.0,
		 *     0.0, 20.0
		 * ]);
		 */
		positions: (Cartesian3)[];

		/**
		 * Gets or sets the surface appearance of the polyline.  This can be one of several built-in {@link Material} objects or a custom material, scripted with
		 * {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric|Fabric}.
		 * @memberof EnginePolyline.prototype
		 * @type {Material}
		 */
		material: Material;

		/**
		 * Gets or sets the width of the polyline.
		 * @memberof EnginePolyline.prototype
		 * @type {Number}
		 */
		width: number;

		/**
		 * Gets or sets whether a line segment will be added between the first and last polyline positions.
		 * @memberof EnginePolyline.prototype
		 * @type {Boolean}
		 */
		loop: boolean;

		/**
		 * Gets or sets the user-defined value returned when the polyline is picked.
		 * @memberof EnginePolyline.prototype
		 * @type {*}
		 */
		id: any;

		/**
		 * Gets or sets the condition specifying at what distance from the camera that this polyline will be displayed.
		 * @memberof EnginePolyline.prototype
		 * @type {DistanceDisplayCondition}
		 * @default undefined
		 */
		distanceDisplayCondition: DistanceDisplayCondition;

	}

	/**
	 * A renderable collection of polylines.
	 * <br /><br />
	 * <div align="center">
	 * <img src="Images/EnginePolyline.png" width="400" height="300" /><br />
	 * Example polylines
	 * </div>
	 * <br /><br />
	 * Polylines are added and removed from the collection using {@link PolylineCollection#add}
	 * and {@link PolylineCollection#remove}.
	 * @alias PolylineCollection
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms each polyline from model to world coordinates.
	 * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.
	 * @performance For best performance, prefer a few collections, each with many polylines, to
	 * many collections with only a few polylines each.  Organize collections so that polylines
	 * with the same update frequency are in the same collection, i.e., polylines that do not
	 * change should be in one collection; polylines that change every frame should be in another
	 * collection; and so on.
	 * @see PolylineCollection#add
	 * @see PolylineCollection#remove
	 * @see EnginePolyline
	 * @see LabelCollection
	 * @example
	 * // Create a polyline collection with two polylines
	 * var polylines = new Cesium.PolylineCollection();
	 * polylines.add({
	 *   positions : Cesium.Cartesian3.fromDegreesArray([
	 *     -75.10, 39.57,
	 *     -77.02, 38.53,
	 *     -80.50, 35.14,
	 *     -80.12, 25.46]),
	 *   width : 2
	 * });
	 * polylines.add({
	 *   positions : Cesium.Cartesian3.fromDegreesArray([
	 *     -73.10, 37.57,
	 *     -75.02, 36.53,
	 *     -78.50, 33.14,
	 *     -78.12, 23.46]),
	 *   width : 4
	 * });
	 */
	class PolylineCollection {
		constructor(options?: {
			modelMatrix?: Matrix4;
			debugShowBoundingVolume?: boolean;
		});

		/**
		 * The 4x4 transformation matrix that transforms each polyline in this collection from model to world coordinates.
		 * When this is the identity matrix, the polylines are drawn in world coordinates, i.e., Earth's WGS84 coordinates.
		 * Local reference frames can be used by providing a different transformation matrix, like that returned
		 * by {@link Transforms.eastNorthUpToFixedFrame}.
		 * @type {Matrix4}
		 * @default {@link Matrix4.IDENTITY}
		 */
		modelMatrix: Matrix4;

		/**
		 * This property is for debugging only; it is not for production use nor is it optimized.
		 * <p>
		 * Draws the bounding sphere for each draw command in the primitive.
		 * </p>
		 * @type {Boolean}
		 * @default false
		 */
		debugShowBoundingVolume: boolean;

		/**
		 * Returns the number of polylines in this collection.  This is commonly used with
		 * {@link PolylineCollection#get} to iterate over all the polylines
		 * in the collection.
		 * @memberof PolylineCollection.prototype
		 * @type {Number}
		 */
		length: number;

		/**
		 * Creates and adds a polyline with the specified initial properties to the collection.
		 * The added polyline is returned so it can be modified or removed from the collection later.
		 * @param {Object}[polyline] A template describing the polyline's properties as shown in Example 1.
		 * @returns {EnginePolyline} The polyline that was added to the collection.
		 * @performance After calling <code>add</code>, {@link PolylineCollection#update} is called and
		 * the collection's vertex buffer is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.
		 * For best performance, add as many polylines as possible before calling <code>update</code>.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * // Example 1:  Add a polyline, specifying all the default values.
		 * var p = polylines.add({
		 *   show : true,
		 *   positions : ellipsoid.cartographicArrayToCartesianArray([
		 * Cesium.Cartographic.fromDegrees(-75.10, 39.57),
		 * Cesium.Cartographic.fromDegrees(-77.02, 38.53)]),
		 *   width : 1
		 * });
		 * @see PolylineCollection#remove
		 * @see PolylineCollection#removeAll
		 * @see PolylineCollection#update
		 */
		add(polyline?: any): EnginePolyline;

		/**
		 * Removes a polyline from the collection.
		 * @param {EnginePolyline} polyline The polyline to remove.
		 * @returns {Boolean} <code>true</code> if the polyline was removed; <code>false</code> if the polyline was not found in the collection.
		 * @performance After calling <code>remove</code>, {@link PolylineCollection#update} is called and
		 * the collection's vertex buffer is rewritten - an <code>O(n)</code> operation that also incurs CPU to GPU overhead.
		 * For best performance, remove as many polylines as possible before calling <code>update</code>.
		 * If you intend to temporarily hide a polyline, it is usually more efficient to call
		 * {@link EnginePolyline#show} instead of removing and re-adding the polyline.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * var p = polylines.add(...);
		 * polylines.remove(p);  // Returns true
		 * @see PolylineCollection#add
		 * @see PolylineCollection#removeAll
		 * @see PolylineCollection#update
		 * @see EnginePolyline#show
		 */
		remove(polyline: EnginePolyline): boolean;

		/**
		 * Removes all polylines from the collection.
		 * @performance <code>O(n)</code>.  It is more efficient to remove all the polylines
		 * from a collection and then add new ones than to create a new collection entirely.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * polylines.add(...);
		 * polylines.add(...);
		 * polylines.removeAll();
		 * @see PolylineCollection#add
		 * @see PolylineCollection#remove
		 * @see PolylineCollection#update
		 */
		removeAll(): void;

		/**
		 * Determines if this collection contains the specified polyline.
		 * @param {EnginePolyline} polyline The polyline to check for.
		 * @returns {Boolean} true if this collection contains the polyline, false otherwise.
		 * @see PolylineCollection#get
		 */
		contains(polyline: EnginePolyline): boolean;

		/**
		 * Returns the polyline in the collection at the specified index.  Indices are zero-based
		 * and increase as polylines are added.  Removing a polyline shifts all polylines after
		 * it to the left, changing their indices.  This function is commonly used with
		 * {@link PolylineCollection#length} to iterate over all the polylines
		 * in the collection.
		 * @param {Number} index The zero-based index of the polyline.
		 * @returns {EnginePolyline} The polyline at the specified index.
		 * @performance If polylines were removed from the collection and
		 * {@link PolylineCollection#update} was not called, an implicit <code>O(n)</code>
		 * operation is performed.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * // Toggle the show property of every polyline in the collection
		 * var len = polylines.length;
		 * for (var i = 0; i < len; ++i) {
		 *   var p = polylines.get(i);
		 *   p.show = !p.show;
		 * }
		 * @see PolylineCollection#length
		 */
		get(index: number): EnginePolyline;

		/**
		 * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
		 * get the draw commands needed to render this primitive.
		 * <p>
		 * Do not call this function directly.  This is documented just to
		 * list the exceptions that may be propagated when the scene is rendered:
		 * </p>
		 * @exception {RuntimeError} Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero.
		 */
		update(): void;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <br /><br />
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
		 * @see PolylineCollection#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
		 * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
		 * <br /><br />
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * polylines = polylines && polylines.destroy();
		 * @see PolylineCollection#isDestroyed
		 */
		destroy(): void;

	}

	/**
	 * An appearance for {@link GeometryInstance} instances with color attributes and
	 * {@link PolylineGeometry} or {@link GroundPolylineGeometry}.
	 * This allows several geometry instances, each with a different color, to
	 * be drawn with the same {@link Primitive}.
	 * @alias PolylineColorAppearance
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Boolean} [options.translucent=true] When <code>true</code>, the geometry is expected to appear translucent so {@link PolylineColorAppearance#renderState} has alpha blending enabled.
	 * @param {String} [options.vertexShaderSource] Optional GLSL vertex shader source to override the default vertex shader.
	 * @param {String} [options.fragmentShaderSource] Optional GLSL fragment shader source to override the default fragment shader.
	 * @param {RenderState} [options.renderState] Optional render state to override the default render state.
	 * @example
	 * // A solid white line segment
	 * var primitive = new Cesium.Primitive({
	 *   geometryInstances : new Cesium.GeometryInstance({
	 *     geometry : new Cesium.PolylineGeometry({
	 *       positions : Cesium.Cartesian3.fromDegreesArray([
	 *         0.0, 0.0,
	 *         5.0, 0.0
	 *       ]),
	 *       width : 10.0,
	 *       vertexFormat : Cesium.PolylineColorAppearance.VERTEX_FORMAT
	 *     }),
	 *     attributes : {
	 *       color : Cesium.ColorGeometryInstanceAttribute.fromColor(new Cesium.Color(1.0, 1.0, 1.0, 1.0))
	 *     }
	 *   }),
	 *   appearance : new Cesium.PolylineColorAppearance({
	 *     translucent : false
	 *   })
	 * });
	 */
	class PolylineColorAppearance {
		constructor(options?: {
			translucent?: boolean;
			vertexShaderSource?: string;
			fragmentShaderSource?: string;
			renderState?: any;
		});

		/**
		 * This property is part of the {@link Appearance} interface, but is not
		 * used by {@link PolylineColorAppearance} since a fully custom fragment shader is used.
		 * @type Material
		 * @default undefined
		 */
		material: Material;

		/**
		 * When <code>true</code>, the geometry is expected to appear translucent so
		 * {@link PolylineColorAppearance#renderState} has alpha blending enabled.
		 * @type {Boolean}
		 * @default true
		 */
		translucent: boolean;

		/**
		 * The GLSL source code for the vertex shader.
		 * @memberof PolylineColorAppearance.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly vertexShaderSource: string;

		/**
		 * The GLSL source code for the fragment shader.
		 * @memberof PolylineColorAppearance.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly fragmentShaderSource: string;

		/**
		 * The WebGL fixed-function state to use when rendering the geometry.
		 * <p>
		 * The render state can be explicitly defined when constructing a {@link PolylineColorAppearance}
		 * instance, or it is set implicitly via {@link PolylineColorAppearance#translucent}.
		 * </p>
		 * @memberof PolylineColorAppearance.prototype
		 * @type {Object}
		 * @readonly
		 */
		readonly renderState: any;

		/**
		 * When <code>true</code>, the geometry is expected to be closed so
		 * {@link PolylineColorAppearance#renderState} has backface culling enabled.
		 * This is always <code>false</code> for <code>PolylineColorAppearance</code>.
		 * @memberof PolylineColorAppearance.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default false
		 */
		readonly closed: boolean;

		/**
		 * The {@link VertexFormat} that this appearance instance is compatible with.
		 * A geometry can have more vertex attributes and still be compatible - at a
		 * potential performance cost - but it can't have less.
		 * @memberof PolylineColorAppearance.prototype
		 * @type VertexFormat
		 * @readonly
		 * @default {@link PolylineColorAppearance.VERTEX_FORMAT}
		 */
		readonly vertexFormat: VertexFormat;

		/**
		 * The {@link VertexFormat} that all {@link PolylineColorAppearance} instances
		 * are compatible with. This requires only a <code>position</code> attribute.
		 * @type VertexFormat
		 * @constant
		 */
		static VERTEX_FORMAT: VertexFormat;

		/**
		 * Procedurally creates the full GLSL fragment shader source.
		 * @function
		 * @returns {String} The full GLSL fragment shader source.
		 */
		getFragmentShaderSource(): string;

		/**
		 * Determines if the geometry is translucent based on {@link PolylineColorAppearance#translucent}.
		 * @function
		 * @returns {Boolean} <code>true</code> if the appearance is translucent.
		 */
		isTranslucent(): boolean;

		/**
		 * Creates a render state.  This is not the final render state instance; instead,
		 * it can contain a subset of render state properties identical to the render state
		 * created in the context.
		 * @function
		 * @returns {Object} The render state.
		 */
		getRenderState(): any;

	}

	/**
	 * An appearance for {@link PolylineGeometry} that supports shading with materials.
	 * @alias PolylineMaterialAppearance
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Boolean} [options.translucent=true] When <code>true</code>, the geometry is expected to appear translucent so {@link PolylineMaterialAppearance#renderState} has alpha blending enabled.
	 * @param {Material} [options.material=Material.ColorType] The material used to determine the fragment color.
	 * @param {String} [options.vertexShaderSource] Optional GLSL vertex shader source to override the default vertex shader.
	 * @param {String} [options.fragmentShaderSource] Optional GLSL fragment shader source to override the default fragment shader.
	 * @param {RenderState} [options.renderState] Optional render state to override the default render state.
	 * @see {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric|Fabric}
	 * @example
	 * var primitive = new Cesium.Primitive({
	 *   geometryInstances : new Cesium.GeometryInstance({
	 *     geometry : new Cesium.PolylineGeometry({
	 *       positions : Cesium.Cartesian3.fromDegreesArray([
	 *         0.0, 0.0,
	 *         5.0, 0.0
	 *       ]),
	 *       width : 10.0,
	 *       vertexFormat : Cesium.PolylineMaterialAppearance.VERTEX_FORMAT
	 *     })
	 *   }),
	 *   appearance : new Cesium.PolylineMaterialAppearance({
	 *     material : Cesium.Material.fromType('Color')
	 *   })
	 * });
	 */
	class PolylineMaterialAppearance {
		constructor(options?: {
			translucent?: boolean;
			material?: Material;
			vertexShaderSource?: string;
			fragmentShaderSource?: string;
			renderState?: any;
		});

		/**
		 * The material used to determine the fragment color.  Unlike other {@link PolylineMaterialAppearance}
		 * properties, this is not read-only, so an appearance's material can change on the fly.
		 * @type Material
		 * @default {@link Material.ColorType}
		 * @see {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric|Fabric}
		 */
		material: Material;

		/**
		 * When <code>true</code>, the geometry is expected to appear translucent so
		 * {@link PolylineMaterialAppearance#renderState} has alpha blending enabled.
		 * @type {Boolean}
		 * @default true
		 */
		translucent: boolean;

		/**
		 * The GLSL source code for the vertex shader.
		 * @memberof PolylineMaterialAppearance.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly vertexShaderSource: string;

		/**
		 * The GLSL source code for the fragment shader.
		 * @memberof PolylineMaterialAppearance.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly fragmentShaderSource: string;

		/**
		 * The WebGL fixed-function state to use when rendering the geometry.
		 * <p>
		 * The render state can be explicitly defined when constructing a {@link PolylineMaterialAppearance}
		 * instance, or it is set implicitly via {@link PolylineMaterialAppearance#translucent}
		 * and {@link PolylineMaterialAppearance#closed}.
		 * </p>
		 * @memberof PolylineMaterialAppearance.prototype
		 * @type {Object}
		 * @readonly
		 */
		readonly renderState: any;

		/**
		 * When <code>true</code>, the geometry is expected to be closed so
		 * {@link PolylineMaterialAppearance#renderState} has backface culling enabled.
		 * This is always <code>false</code> for <code>PolylineMaterialAppearance</code>.
		 * @memberof PolylineMaterialAppearance.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default false
		 */
		readonly closed: boolean;

		/**
		 * The {@link VertexFormat} that this appearance instance is compatible with.
		 * A geometry can have more vertex attributes and still be compatible - at a
		 * potential performance cost - but it can't have less.
		 * @memberof PolylineMaterialAppearance.prototype
		 * @type VertexFormat
		 * @readonly
		 * @default {@link PolylineMaterialAppearance.VERTEX_FORMAT}
		 */
		readonly vertexFormat: VertexFormat;

		/**
		 * The {@link VertexFormat} that all {@link PolylineMaterialAppearance} instances
		 * are compatible with. This requires <code>position</code> and <code>st</code> attributes.
		 * @type VertexFormat
		 * @constant
		 */
		static VERTEX_FORMAT: VertexFormat;

		/**
		 * Procedurally creates the full GLSL fragment shader source.  For {@link PolylineMaterialAppearance},
		 * this is derived from {@link PolylineMaterialAppearance#fragmentShaderSource} and {@link PolylineMaterialAppearance#material}.
		 * @function
		 * @returns {String} The full GLSL fragment shader source.
		 */
		getFragmentShaderSource(): string;

		/**
		 * Determines if the geometry is translucent based on {@link PolylineMaterialAppearance#translucent} and {@link Material#isTranslucent}.
		 * @function
		 * @returns {Boolean} <code>true</code> if the appearance is translucent.
		 */
		isTranslucent(): boolean;

		/**
		 * Creates a render state.  This is not the final render state instance; instead,
		 * it can contain a subset of render state properties identical to the render state
		 * created in the context.
		 * @function
		 * @returns {Object} The render state.
		 */
		getRenderState(): any;

	}

	/**
	 * Runs a post-process stage on either the texture rendered by the scene or the output of a previous post-process stage.
	 * @alias PostProcessStage
	 * @constructor
	 * @param {Object} options An object with the following properties:
	 * @param {String} options.fragmentShader The fragment shader to use. The default <code>sampler2D</code> uniforms are <code>colorTexture</code> and <code>depthTexture</code>. The color texture is the output of rendering the scene or the previous stage. The depth texture is the output from rendering the scene. The shader should contain one or both uniforms. There is also a <code>vec2</code> varying named <code>v_textureCoordinates</code> that can be used to sample the textures.
	 * @param {Object} [options.uniforms] An object whose properties will be used to set the shaders uniforms. The properties can be constant values or a function. A constant value can also be a URI, data URI, or HTML element to use as a texture.
	 * @param {Number} [options.textureScale=1.0] A number in the range (0.0, 1.0] used to scale the texture dimensions. A scale of 1.0 will render this post-process stage  to a texture the size of the viewport.
	 * @param {Boolean} [options.forcePowerOfTwo=false] Whether or not to force the texture dimensions to be both equal powers of two. The power of two will be the next power of two of the minimum of the dimensions.
	 * @param {PostProcessStageSampleMode} [options.sampleMode=PostProcessStageSampleMode.NEAREST] How to sample the input color texture.
	 * @param {PixelFormat} [options.pixelFormat=PixelFormat.RGBA] The color pixel format of the output texture.
	 * @param {PixelDatatype} [options.pixelDatatype=PixelDatatype.UNSIGNED_BYTE] The pixel data type of the output texture.
	 * @param {Color} [options.clearColor=Color.BLACK] The color to clear the output texture to.
	 * @param {BoundingRectangle} [options.scissorRectangle] The rectangle to use for the scissor test.
	 * @param {String} [options.name=createGuid()] The unique name of this post-process stage for reference by other stages in a composite. If a name is not supplied, a GUID will be generated.
	 * @exception {DeveloperError} options.textureScale must be greater than 0.0 and less than or equal to 1.0.
	 * @exception {DeveloperError} options.pixelFormat must be a color format.
	 * @exception {DeveloperError} When options.pixelDatatype is FLOAT, this WebGL implementation must support the OES_texture_float extension.  Check context.floatingPointTexture.
	 * @see PostProcessStageComposite
	 * @example
	 * // Simple stage to change the color
	 * var fs =
	 *     'uniform sampler2D colorTexture;\n' +
	 *     'varying vec2 v_textureCoordinates;\n' +
	 *     'uniform float scale;\n' +
	 *     'uniform vec3 offset;\n' +
	 *     'void main() {\n' +
	 *     '    vec4 color = texture2D(colorTexture, v_textureCoordinates);\n' +
	 *     '    gl_FragColor = vec4(color.rgb * scale + offset, 1.0);\n' +
	 *     '}\n';
	 * scene.postProcessStages.add(new Cesium.PostProcessStage({
	 *     fragmentShader : fs,
	 *     uniforms : {
	 *         scale : 1.1,
	 *         offset : function() {
	 *             return new Cesium.Cartesian3(0.1, 0.2, 0.3);
	 *         }
	 *     }
	 * }));
	 * @example
	 * // Simple stage to change the color of what is selected.
	 * // If czm_selected returns true, the current fragment belongs to geometry in the selected array.
	 * var fs =
	 *     'uniform sampler2D colorTexture;\n' +
	 *     'varying vec2 v_textureCoordinates;\n' +
	 *     'uniform vec4 highlight;\n' +
	 *     'void main() {\n' +
	 *     '    vec4 color = texture2D(colorTexture, v_textureCoordinates);\n' +
	 *     '    if (czm_selected()) {\n' +
	 *     '        vec3 highlighted = highlight.a * highlight.rgb + (1.0 - highlight.a) * color.rgb;\n' +
	 *     '        gl_FragColor = vec4(highlighted, 1.0);\n' +
	 *     '    } else { \n' +
	 *     '        gl_FragColor = color;\n' +
	 *     '    }\n' +
	 *     '}\n';
	 * var stage = scene.postProcessStages.add(new Cesium.PostProcessStage({
	 *     fragmentShader : fs,
	 *     uniforms : {
	 *         highlight : function() {
	 *             return new Cesium.Color(1.0, 0.0, 0.0, 0.5);
	 *         }
	 *     }
	 * }));
	 * stage.selected = [cesium3DTileFeature];
	 */
	class PostProcessStage {
		constructor(options: {
			fragmentShader: string;
			uniforms?: any;
			textureScale?: number;
			forcePowerOfTwo?: boolean;
			sampleMode?: any;
			pixelFormat?: any;
			pixelDatatype?: any;
			clearColor?: Color;
			scissorRectangle?: BoundingRectangle;
			name?: string;
		});

		/**
		 * Whether or not to execute this post-process stage when ready.
		 * @type {Boolean}
		 */
		enabled: boolean;

		/**
		 * Determines if this post-process stage is ready to be executed. A stage is only executed when both <code>ready</code>
		 * and {@link PostProcessStage#enabled} are <code>true</code>. A stage will not be ready while it is waiting on textures
		 * to load.
		 * @memberof PostProcessStage.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly ready: boolean;

		/**
		 * The unique name of this post-process stage for reference by other stages in a {@link PostProcessStageComposite}.
		 * @memberof PostProcessStage.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly name: string;

		/**
		 * The fragment shader to use when execute this post-process stage.
		 * <p>
		 * The shader must contain a sampler uniform declaration for <code>colorTexture</code>, <code>depthTexture</code>,
		 * or both.
		 * </p>
		 * <p>
		 * The shader must contain a <code>vec2</code> varying declaration for <code>v_textureCoordinates</code> for sampling
		 * the texture uniforms.
		 * </p>
		 * @memberof PostProcessStage.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly fragmentShader: string;

		/**
		 * An object whose properties are used to set the uniforms of the fragment shader.
		 * <p>
		 * The object property values can be either a constant or a function. The function will be called
		 * each frame before the post-process stage is executed.
		 * </p>
		 * <p>
		 * A constant value can also be a URI to an image, a data URI, or an HTML element that can be used as a texture, such as HTMLImageElement or HTMLCanvasElement.
		 * </p>
		 * <p>
		 * If this post-process stage is part of a {@link PostProcessStageComposite} that does not execute in series, the constant value can also be
		 * the name of another stage in a composite. This will set the uniform to the output texture the stage with that name.
		 * </p>
		 * @memberof PostProcessStage.prototype
		 * @type {Object}
		 * @readonly
		 */
		readonly uniforms: any;

		/**
		 * A number in the range (0.0, 1.0] used to scale the output texture dimensions. A scale of 1.0 will render this post-process stage to a texture the size of the viewport.
		 * @memberof PostProcessStage.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly textureScale: number;

		/**
		 * Whether or not to force the output texture dimensions to be both equal powers of two. The power of two will be the next power of two of the minimum of the dimensions.
		 * @memberof PostProcessStage.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly forcePowerOfTwo: number;

		/**
		 * How to sample the input color texture.
		 * @memberof PostProcessStage.prototype
		 * @type {PostProcessStageSampleMode}
		 * @readonly
		 */
		readonly sampleMode: any;

		/**
		 * The color pixel format of the output texture.
		 * @memberof PostProcessStage.prototype
		 * @type {PixelFormat}
		 * @readonly
		 */
		readonly pixelFormat: any;

		/**
		 * The pixel data type of the output texture.
		 * @memberof PostProcessStage.prototype
		 * @type {PixelDatatype}
		 * @readonly
		 */
		readonly pixelDatatype: any;

		/**
		 * The color to clear the output texture to.
		 * @memberof PostProcessStage.prototype
		 * @type {Color}
		 * @readonly
		 */
		readonly clearColor: Color;

		/**
		 * The {@link BoundingRectangle} to use for the scissor test. A default bounding rectangle will disable the scissor test.
		 * @memberof PostProcessStage.prototype
		 * @type {BoundingRectangle}
		 * @readonly
		 */
		readonly scissorRectangle: BoundingRectangle;

		/**
		 * The features selected for applying the post-process.
		 * <p>
		 * In the fragment shader, use <code>czm_selected</code> to determine whether or not to apply the post-process
		 * stage to that fragment. For example:
		 * <code>
		 * if (czm_selected(v_textureCoordinates)) {
		 *     // apply post-process stage
		 * } else {
		 *     gl_FragColor = texture2D(colorTexture, v_textureCordinates);
		 * }
		 * </code>
		 * </p>
		 * @memberof PostProcessStage.prototype
		 * @type {Array}
		 */
		selected: any[];

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <p>
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * </p>
		 * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
		 * @see PostProcessStage#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
		 * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
		 * <p>
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * </p>
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @see PostProcessStage#isDestroyed
		 */
		destroy(): void;

	}

	/**
	 * A collection of {@link PostProcessStage}s and/or {@link PostProcessStageComposite}s.
	 * <p>
	 * The input texture for each post-process stage is the texture rendered to by the scene or the texture rendered
	 * to by the previous stage in the collection.
	 * </p>
	 * <p>
	 * If the ambient occlusion or bloom stages are enabled, they will execute before all other stages.
	 * </p>
	 * <p>
	 * If the FXAA stage is enabled, it will execute after all other stages.
	 * </p>
	 * @alias PostProcessStageCollection
	 * @constructor
	 */
	class PostProcessStageCollection {
		constructor();

		/**
		 * Determines if all of the post-process stages in the collection are ready to be executed.
		 * @memberof PostProcessStageCollection.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly ready: boolean;

		/**
		 * A post-process stage for Fast Approximate Anti-aliasing.
		 * <p>
		 * When enabled, this stage will execute after all others.
		 * </p>
		 * @memberof PostProcessStageCollection.prototype
		 * @type {PostProcessStage}
		 * @readonly
		 */
		readonly fxaa: PostProcessStage;

		/**
		 * A post-process stage that applies Horizon-based Ambient Occlusion (HBAO) to the input texture.
		 * <p>
		 * Ambient occlusion simulates shadows from ambient light. These shadows would always be present when the
		 * surface receives light and regardless of the light's position.
		 * </p>
		 * <p>
		 * The uniforms have the following properties: <code>intensity</code>, <code>bias</code>, <code>lengthCap</code>,
		 * <code>stepSize</code>, <code>frustumLength</code>, <code>ambientOcclusionOnly</code>,
		 * <code>delta</code>, <code>sigma</code>, and <code>blurStepSize</code>.
		 * </p>
		 * <ul>
		 * <li><code>intensity</code> is a scalar value used to lighten or darken the shadows exponentially. Higher values make the shadows darker. The default value is <code>3.0</code>.</li>
		 * <li><code>bias</code> is a scalar value representing an angle in radians. If the dot product between the normal of the sample and the vector to the camera is less than this value,
		 * sampling stops in the current direction. This is used to remove shadows from near planar edges. The default value is <code>0.1</code>.</li>
		 * <li><code>lengthCap</code> is a scalar value representing a length in meters. If the distance from the current sample to first sample is greater than this value,
		 * sampling stops in the current direction. The default value is <code>0.26</code>.</li>
		 * <li><code>stepSize</code> is a scalar value indicating the distance to the next texel sample in the current direction. The default value is <code>1.95</code>.</li>
		 * <li><code>frustumLength</code> is a scalar value in meters. If the current fragment has a distance from the camera greater than this value, ambient occlusion is not computed for the fragment.
		 * The default value is <code>1000.0</code>.</li>
		 * <li><code>ambientOcclusionOnly</code> is a boolean value. When <code>true</code>, only the shadows generated are written to the output. When <code>false</code>, the input texture is modulated
		 * with the ambient occlusion. This is a useful debug option for seeing the effects of changing the uniform values. The default value is <code>false</code>.</li>
		 * </ul>
		 * <p>
		 * <code>delta</code>, <code>sigma</code>, and <code>blurStepSize</code> are the same properties as {@link PostProcessStageLibrary#createBlurStage}.
		 * The blur is applied to the shadows generated from the image to make them smoother.
		 * </p>
		 * <p>
		 * When enabled, this stage will execute before all others.
		 * </p>
		 * @memberof PostProcessStageCollection.prototype
		 * @type {PostProcessStageComposite}
		 * @readonly
		 */
		readonly ambientOcclusion: PostProcessStageComposite;

		/**
		 * A post-process stage for a bloom effect.
		 * <p>
		 * A bloom effect adds glow effect, makes bright areas brighter, and dark areas darker.
		 * </p>
		 * <p>
		 * This stage has the following uniforms: <code>contrast</code>, <code>brightness</code>, <code>glowOnly</code>,
		 * <code>delta</code>, <code>sigma</code>, and <code>stepSize</code>.
		 * </p>
		 * <ul>
		 * <li><code>contrast</code> is a scalar value in the range [-255.0, 255.0] and affects the contract of the effect. The default value is <code>128.0</code>.</li>
		 * <li><code>brightness</code> is a scalar value. The input texture RGB value is converted to hue, saturation, and brightness (HSB) then this value is
		 * added to the brightness. The default value is <code>-0.3</code>.</li>
		 * <li><code>glowOnly</code> is a boolean value. When <code>true</code>, only the glow effect will be shown. When <code>false</code>, the glow will be added to the input texture.
		 * The default value is <code>false</code>. This is a debug option for viewing the effects when changing the other uniform values.</li>
		 * </ul>
		 * <p>
		 * <code>delta</code>, <code>sigma</code>, and <code>stepSize</code> are the same properties as {@link PostProcessStageLibrary#createBlurStage}.
		 * The blur is applied to the shadows generated from the image to make them smoother.
		 * </p>
		 * <p>
		 * When enabled, this stage will execute before all others.
		 * </p>
		 * @memberOf PostProcessStageCollection.prototype
		 * @type {PostProcessStageComposite}
		 * @readonly
		 */
		readonly bloom: PostProcessStageComposite;

		/**
		 * The number of post-process stages in this collection.
		 * @memberof PostProcessStageCollection.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly length: number;

		/**
		 * Adds the post-process stage to the collection.
		 * @param {PostProcessStage|PostProcessStageComposite} stage The post-process stage to add to the collection.
		 * @return {PostProcessStage|PostProcessStageComposite} The post-process stage that was added to the collection.
		 * @exception {DeveloperError} The post-process stage has already been added to the collection or does not have a unique name.
		 */
		add(stage: PostProcessStage | PostProcessStageComposite): PostProcessStage | PostProcessStageComposite;

		/**
		 * Removes a post-process stage from the collection and destroys it.
		 * @param {PostProcessStage|PostProcessStageComposite} stage The post-process stage to remove from the collection.
		 * @return {Boolean} Whether the post-process stage was removed.
		 */
		remove(stage: PostProcessStage | PostProcessStageComposite): boolean;

		/**
		 * Returns whether the collection contains a post-process stage.
		 * @param {PostProcessStage|PostProcessStageComposite} stage The post-process stage.
		 * @return {Boolean} Whether the collection contains the post-process stage.
		 */
		contains(stage: PostProcessStage | PostProcessStageComposite): boolean;

		/**
		 * Gets the post-process stage at <code>index</code>.
		 * @param {Number} index The index of the post-process stage.
		 * @return {PostProcessStage|PostProcessStageComposite} The post-process stage at index.
		 */
		get(index: number): PostProcessStage | PostProcessStageComposite;

		/**
		 * Removes all post-process stages from the collection and destroys them.
		 */
		removeAll(): void;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <p>
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * </p>
		 * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
		 * @see PostProcessStageCollection#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
		 * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
		 * <p>
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * </p>
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @see PostProcessStageCollection#isDestroyed
		 */
		destroy(): void;

	}

	/**
	 * A collection of {@link PostProcessStage}s or other post-process composite stages that execute together logically.
	 * <p>
	 * All stages are executed in the order of the array. The input texture changes based on the value of <code>inputPreviousStageTexture</code>.
	 * If <code>inputPreviousStageTexture</code> is <code>true</code>, the input to each stage is the output texture rendered to by the scene or of the stage that executed before it.
	 * If <code>inputPreviousStageTexture</code> is <code>false</code>, the input texture is the same for each stage in the composite. The input texture is the texture rendered to by the scene
	 * or the output texture of the previous stage.
	 * </p>
	 * @alias PostProcessStageComposite
	 * @constructor
	 * @param {Object} options An object with the following properties:
	 * @param {Array} options.stages An array of {@link PostProcessStage}s or composites to be executed in order.
	 * @param {Boolean} [options.inputPreviousStageTexture=true] Whether to execute each post-process stage where the input to one stage is the output of the previous. Otherwise, the input to each contained stage is the output of the stage that executed before the composite.
	 * @param {String} [options.name=createGuid()] The unique name of this post-process stage for reference by other composites. If a name is not supplied, a GUID will be generated.
	 * @param {Object} [options.uniforms] An alias to the uniforms of post-process stages.
	 * @exception {DeveloperError} options.stages.length must be greater than 0.0.
	 * @see PostProcessStage
	 * @example
	 * // Example 1: separable blur filter
	 * // The input to blurXDirection is the texture rendered to by the scene or the output of the previous stage.
	 * // The input to blurYDirection is the texture rendered to by blurXDirection.
	 * scene.postProcessStages.add(new Cesium.PostProcessStageComposite({
	 *     stages : [blurXDirection, blurYDirection]
	 * }));
	 * @example
	 * // Example 2: referencing the output of another post-process stage
	 * scene.postProcessStages.add(new Cesium.PostProcessStageComposite({
	 *     inputPreviousStageTexture : false,
	 *     stages : [
	 *         // The same as Example 1.
	 *         new Cesium.PostProcessStageComposite({
	 *             inputPreviousStageTexture : true
	 *             stages : [blurXDirection, blurYDirection],
	 *             name : 'blur'
	 *         }),
	 *         // The input texture for this stage is the same input texture to blurXDirection since inputPreviousStageTexture is false
	 *         new Cesium.PostProcessStage({
	 *             fragmentShader : compositeShader,
	 *             uniforms : {
	 *                 blurTexture : 'blur' // The output of the composite with name 'blur' (the texture that blurYDirection rendered to).
	 *             }
	 *         })
	 *     ]
	 * });
	 * @example
	 * // Example 3: create a uniform alias
	 * var uniforms = {};
	 * Cesium.defineProperties(uniforms, {
	 *     filterSize : {
	 *         get : function() {
	 *             return blurXDirection.uniforms.filterSize;
	 *         },
	 *         set : function(value) {
	 *             blurXDirection.uniforms.filterSize = blurYDirection.uniforms.filterSize = value;
	 *         }
	 *     }
	 * });
	 * scene.postProcessStages.add(new Cesium.PostProcessStageComposite({
	 *     stages : [blurXDirection, blurYDirection],
	 *     uniforms : uniforms
	 * }));
	 */
	class PostProcessStageComposite {
		constructor(options: {
			stages: any[];
			inputPreviousStageTexture?: boolean;
			name?: string;
			uniforms?: any;
		});

		/**
		 * Determines if this post-process stage is ready to be executed.
		 * @memberof PostProcessStageComposite.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly ready: boolean;

		/**
		 * The unique name of this post-process stage for reference by other stages in a PostProcessStageComposite.
		 * @memberof PostProcessStageComposite.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly name: string;

		/**
		 * Whether or not to execute this post-process stage when ready.
		 * @memberof PostProcessStageComposite.prototype
		 * @type {Boolean}
		 */
		enabled: boolean;

		/**
		 * An alias to the uniform values of the post-process stages. May be <code>undefined</code>; in which case, get each stage to set uniform values.
		 * @memberof PostProcessStageComposite.prototype
		 * @type {Object}
		 */
		uniforms: any;

		/**
		 * All post-process stages are executed in the order of the array. The input texture changes based on the value of <code>inputPreviousStageTexture</code>.
		 * If <code>inputPreviousStageTexture</code> is <code>true</code>, the input to each stage is the output texture rendered to by the scene or of the stage that executed before it.
		 * If <code>inputPreviousStageTexture</code> is <code>false</code>, the input texture is the same for each stage in the composite. The input texture is the texture rendered to by the scene
		 * or the output texture of the previous stage.
		 * @memberof PostProcessStageComposite.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly inputPreviousStageTexture: boolean;

		/**
		 * The number of post-process stages in this composite.
		 * @memberof PostProcessStageComposite.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly length: number;

		/**
		 * The features selected for applying the post-process.
		 * @memberof PostProcessStageComposite.prototype
		 * @type {Array}
		 */
		selected: any[];

		/**
		 * Gets the post-process stage at <code>index</code>
		 * @param {Number} index The index of the post-process stage or composite.
		 * @return {PostProcessStage|PostProcessStageComposite} The post-process stage or composite at index.
		 * @exception {DeveloperError} index must be greater than or equal to 0.
		 * @exception {DeveloperError} index must be less than {@link PostProcessStageComposite#length}.
		 */
		get(index: number): PostProcessStage | PostProcessStageComposite;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <p>
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * </p>
		 * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
		 * @see PostProcessStageComposite#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
		 * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
		 * <p>
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * </p>
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @see PostProcessStageComposite#isDestroyed
		 */
		destroy(): void;

	}

	/**
	 * Contains functions for creating common post-process stages.
	 * @exports PostProcessStageLibrary
	 */
	namespace PostProcessStageLibrary {
		/**
		 * Creates a post-process stage that applies a Gaussian blur to the input texture. This stage is usually applied in conjunction with another stage.
		 * <p>
		 * This stage has the following uniforms: <code>delta</code>, <code>sigma</code>, and <code>stepSize</code>.
		 * </p>
		 * <p>
		 * <code>delta</code> and <code>sigma</code> are used to compute the weights of a Gaussian filter. The equation is <code>exp((-0.5 * delta * delta) / (sigma * sigma))</code>.
		 * The default value for <code>delta</code> is <code>1.0</code>. The default value for <code>sigma</code> is <code>2.0</code>.
		 * <code>stepSize</code> is the distance to the next texel. The default is <code>1.0</code>.
		 * </p>
		 * @return {PostProcessStageComposite} A post-process stage that applies a Gaussian blur to the input texture.
		 */
		function createBlurStage(): PostProcessStageComposite;

		/**
		 * Creates a post-process stage that applies a depth of field effect.
		 * <p>
		 * Depth of field simulates camera focus. Objects in the scene that are in focus
		 * will be clear whereas objects not in focus will be blurred.
		 * </p>
		 * <p>
		 * This stage has the following uniforms: <code>focalDistance</code>, <code>delta</code>, <code>sigma</code>, and <code>stepSize</code>.
		 * </p>
		 * <p>
		 * <code>focalDistance</code> is the distance in meters from the camera to set the camera focus.
		 * </p>
		 * <p>
		 * <code>delta</code>, <code>sigma</code>, and <code>stepSize</code> are the same properties as {@link PostProcessStageLibrary#createBlurStage}.
		 * The blur is applied to the areas out of focus.
		 * </p>
		 * @return {PostProcessStageComposite} A post-process stage that applies a depth of field effect.
		 */
		function createDepthOfFieldStage(): PostProcessStageComposite;

		/**
		 * Whether or not a depth of field stage is supported.
		 * <p>
		 * This stage requires the WEBGL_depth_texture extension.
		 * </p>
		 * @param {Scene} scene The scene.
		 * @return {Boolean} Whether this post process stage is supported.
		 * @see {Context#depthTexture}
		 * @see {@link http://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/|WEBGL_depth_texture}
		 */
		function isDepthOfFieldSupported(scene: Scene): boolean;

		/**
		 * Creates a post-process stage that detects edges.
		 * <p>
		 * Writes the color to the output texture with alpha set to 1.0 when it is on an edge.
		 * </p>
		 * <p>
		 * This stage has the following uniforms: <code>color</code> and <code>length</code>
		 * </p>
		 * <ul>
		 * <li><code>color</code> is the color of the highlighted edge. The default is {@link Color#BLACK}.</li>
		 * <li><code>length</code> is the length of the edges in pixels. The default is <code>0.5</code>.</li>
		 * </ul>
		 * <p>
		 * This stage is not supported in 2D.
		 * </p>
		 * @return {PostProcessStageComposite} A post-process stage that applies an edge detection effect.
		 * @example
		 * // multiple silhouette effects
		 * var yellowEdge = Cesium.PostProcessLibrary.createEdgeDetectionStage();
		 * yellowEdge.uniforms.color = Cesium.Color.YELLOW;
		 * yellowEdge.selected = [feature0];
		 * var greenEdge = Cesium.PostProcessLibrary.createEdgeDetectionStage();
		 * greenEdge.uniforms.color = Cesium.Color.LIME;
		 * greenEdge.selected = [feature1];
		 * // draw edges around feature0 and feature1
		 * postProcessStages.add(Cesium.PostProcessLibrary.createSilhouetteEffect([yellowEdge, greenEdge]);
		 */
		function createEdgeDetectionStage(): PostProcessStageComposite;

		/**
		 * Whether or not an edge detection stage is supported.
		 * <p>
		 * This stage requires the WEBGL_depth_texture extension.
		 * </p>
		 * @param {Scene} scene The scene.
		 * @return {Boolean} Whether this post process stage is supported.
		 * @see {Context#depthTexture}
		 * @see {@link http://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/|WEBGL_depth_texture}
		 */
		function isEdgeDetectionSupported(scene: Scene): boolean;

		/**
		 * Creates a post-process stage that applies a silhouette effect.
		 * <p>
		 * A silhouette effect composites the color from the edge detection pass with input color texture.
		 * </p>
		 * <p>
		 * This stage has the following uniforms when <code>edgeDetectionStages</code> is <code>undefined</code>: <code>color</code> and <code>length</code>
		 * </p>
		 * <p>
		 * <code>color</code> is the color of the highlighted edge. The default is {@link Color#BLACK}.
		 * <code>length</code> is the length of the edges in pixels. The default is <code>0.5</code>.
		 * </p>
		 * @return {PostProcessStageComposite} A post-process stage that applies a silhouette effect.
		 */
		function createSilhouetteStage(): PostProcessStageComposite;

		/**
		 * Whether or not a silhouette stage is supported.
		 * <p>
		 * This stage requires the WEBGL_depth_texture extension.
		 * </p>
		 * @param {Scene} scene The scene.
		 * @return {Boolean} Whether this post process stage is supported.
		 * @see {Context#depthTexture}
		 * @see {@link http://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/|WEBGL_depth_texture}
		 */
		function isSilhouetteSupported(scene: Scene): boolean;

		/**
		 * Whether or not an ambient occlusion stage is supported.
		 * <p>
		 * This stage requires the WEBGL_depth_texture extension.
		 * </p>
		 * @param {Scene} scene The scene.
		 * @return {Boolean} Whether this post process stage is supported.
		 * @see {Context#depthTexture}
		 * @see {@link http://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/|WEBGL_depth_texture}
		 */
		function isAmbientOcclusionSupported(scene: Scene): boolean;

		/**
		 * Creates a post-process stage that renders the input texture with black and white gradations.
		 * <p>
		 * This stage has one uniform value, <code>gradations</code>, which scales the luminance of each pixel.
		 * </p>
		 * @return {PostProcessStage} A post-process stage that renders the input texture with black and white gradations.
		 */
		function createBlackAndWhiteStage(): PostProcessStage;

		/**
		 * Creates a post-process stage that saturates the input texture.
		 * <p>
		 * This stage has one uniform value, <code>brightness</code>, which scales the saturation of each pixel.
		 * </p>
		 * @return {PostProcessStage} A post-process stage that saturates the input texture.
		 */
		function createBrightnessStage(): PostProcessStage;

		/**
		 * Creates a post-process stage that adds a night vision effect to the input texture.
		 * @return {PostProcessStage} A post-process stage that adds a night vision effect to the input texture.
		 */
		function createNightVisionStage(): PostProcessStage;

		/**
		 * Creates a post-process stage that applies an effect simulating light flaring a camera lens.
		 * <p>
		 * This stage has the following uniforms: <code>dirtTexture</code>, <code>starTexture</code>, <code>intensity</code>, <code>distortion</code>, <code>ghostDispersal</code>,
		 * <code>haloWidth</code>, and <code>earthRadius</code>.
		 * <ul>
		 * <li><code>dirtTexture</code> is a texture sampled to simulate dirt on the lens.</li>
		 * <li><code>starTexture</code> is the texture sampled for the star pattern of the flare.</li>
		 * <li><code>intensity</code> is a scalar multiplied by the result of the lens flare. The default value is <code>2.0</code>.</li>
		 * <li><code>distortion</code> is a scalar value that affects the chromatic effect distortion. The default value is <code>10.0</code>.</li>
		 * <li><code>ghostDispersal</code> is a scalar indicating how far the halo effect is from the center of the texture. The default value is <code>0.4</code>.</li>
		 * <li><code>haloWidth</code> is a scalar representing the width of the halo  from the ghost dispersal. The default value is <code>0.4</code>.</li>
		 * <li><code>earthRadius</code> is the maximum radius of the earth. The default value is <code>Ellipsoid.WGS84.maximumRadius</code>.</li>
		 * </ul>
		 * </p>
		 * @return {PostProcessStage} A post-process stage for applying a lens flare effect.
		 */
		function createLensFlareStage(): PostProcessStage;

	}

	/**
	 * Determines how input texture to a {@link PostProcessStage} is sampled.
	 * @exports PostProcessStageSampleMode
	 */
	namespace PostProcessStageSampleMode {
		/**
		 * Samples the texture by returning the closest texel.
		 * @type {Number}
		 * @constant
		 */
		const NEAREST: number;

		/**
		 * Samples the texture through bi-linear interpolation of the four nearest texels.
		 * @type {Number}
		 * @constant
		 */
		const LINEAR: number;

	}

	/**
	 * A primitive represents geometry in the {@link Scene}.  The geometry can be from a single {@link GeometryInstance}
	 * as shown in example 1 below, or from an array of instances, even if the geometry is from different
	 * geometry types, e.g., an {@link RectangleGeometry} and an {@link EllipsoidGeometry} as shown in Code Example 2.
	 * <p>
	 * A primitive combines geometry instances with an {@link Appearance} that describes the full shading, including
	 * {@link Material} and {@link RenderState}.  Roughly, the geometry instance defines the structure and placement,
	 * and the appearance defines the visual characteristics.  Decoupling geometry and appearance allows us to mix
	 * and match most of them and add a new geometry or appearance independently of each other.
	 * </p>
	 * <p>
	 * Combining multiple instances into one primitive is called batching, and significantly improves performance for static data.
	 * Instances can be individually picked; {@link Scene#pick} returns their {@link GeometryInstance#id}.  Using
	 * per-instance appearances like {@link PerInstanceColorAppearance}, each instance can also have a unique color.
	 * </p>
	 * <p>
	 * {@link Geometry} can either be created and batched on a web worker or the main thread. The first two examples
	 * show geometry that will be created on a web worker by using the descriptions of the geometry. The third example
	 * shows how to create the geometry on the main thread by explicitly calling the <code>createGeometry</code> method.
	 * </p>
	 * @alias Primitive
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {GeometryInstance[]|GeometryInstance} [options.geometryInstances] The geometry instances - or a single geometry instance - to render.
	 * @param {Appearance} [options.appearance] The appearance used to render the primitive.
	 * @param {Boolean} [options.show=true] Determines if this primitive will be shown.
	 * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] The 4x4 transformation matrix that transforms the primitive (all geometry instances) from model to world coordinates.
	 * @param {Boolean} [options.vertexCacheOptimize=false] When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.
	 * @param {Boolean} [options.interleave=false] When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.
	 * @param {Boolean} [options.compressVertices=true] When <code>true</code>, the geometry vertices are compressed, which will save memory.
	 * @param {Boolean} [options.releaseGeometryInstances=true] When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
	 * @param {Boolean} [options.allowPicking=true] When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.
	 * @param {Boolean} [options.cull=true] When <code>true</code>, the renderer frustum culls and horizon culls the primitive's commands based on their bounding volume.  Set this to <code>false</code> for a small performance gain if you are manually culling the primitive.
	 * @param {Boolean} [options.asynchronous=true] Determines if the primitive will be created asynchronously or block until ready.
	 * @param {Boolean} [options.debugShowBoundingVolume=false] For debugging only. Determines if this primitive's commands' bounding spheres are shown.
	 * @param {ShadowMode} [options.shadows=ShadowMode.DISABLED] Determines whether this primitive casts or receives shadows from each light source.
	 * @example
	 * // 1. Draw a translucent ellipse on the surface with a checkerboard pattern
	 * var instance = new Cesium.GeometryInstance({
	 *   geometry : new Cesium.EllipseGeometry({
	 *       center : Cesium.Cartesian3.fromDegrees(-100.0, 20.0),
	 *       semiMinorAxis : 500000.0,
	 *       semiMajorAxis : 1000000.0,
	 *       rotation : Cesium.Math.PI_OVER_FOUR,
	 *       vertexFormat : Cesium.VertexFormat.POSITION_AND_ST
	 *   }),
	 *   id : 'object returned when this instance is picked and to get/set per-instance attributes'
	 * });
	 * scene.primitives.add(new Cesium.Primitive({
	 *   geometryInstances : instance,
	 *   appearance : new Cesium.EllipsoidSurfaceAppearance({
	 *     material : Cesium.Material.fromType('Checkerboard')
	 *   })
	 * }));
	 * @example
	 * // 2. Draw different instances each with a unique color
	 * var rectangleInstance = new Cesium.GeometryInstance({
	 *   geometry : new Cesium.RectangleGeometry({
	 *     rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0),
	 *     vertexFormat : Cesium.PerInstanceColorAppearance.VERTEX_FORMAT
	 *   }),
	 *   id : 'rectangle',
	 *   attributes : {
	 *     color : new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5)
	 *   }
	 * });
	 * var ellipsoidInstance = new Cesium.GeometryInstance({
	 *   geometry : new Cesium.EllipsoidGeometry({
	 *     radii : new Cesium.Cartesian3(500000.0, 500000.0, 1000000.0),
	 *     vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL
	 *   }),
	 *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(
	 *     Cesium.Cartesian3.fromDegrees(-95.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 500000.0), new Cesium.Matrix4()),
	 *   id : 'ellipsoid',
	 *   attributes : {
	 *     color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)
	 *   }
	 * });
	 * scene.primitives.add(new Cesium.Primitive({
	 *   geometryInstances : [rectangleInstance, ellipsoidInstance],
	 *   appearance : new Cesium.PerInstanceColorAppearance()
	 * }));
	 * @example
	 * // 3. Create the geometry on the main thread.
	 * scene.primitives.add(new Cesium.Primitive({
	 *   geometryInstances : new Cesium.GeometryInstance({
	 *       geometry : Cesium.EllipsoidGeometry.createGeometry(new Cesium.EllipsoidGeometry({
	 *         radii : new Cesium.Cartesian3(500000.0, 500000.0, 1000000.0),
	 *         vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL
	 *       })),
	 *       modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(
	 *         Cesium.Cartesian3.fromDegrees(-95.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 500000.0), new Cesium.Matrix4()),
	 *       id : 'ellipsoid',
	 *       attributes : {
	 *         color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)
	 *       }
	 *   }),
	 *   appearance : new Cesium.PerInstanceColorAppearance()
	 * }));
	 * @see GeometryInstance
	 * @see Appearance
	 * @see ClassificationPrimitive
	 * @see GroundPrimitive
	 */
	class Primitive {
		constructor(options?: {
			geometryInstances?: (GeometryInstance)[] | GeometryInstance;
			appearance?: Appearance;
			show?: boolean;
			modelMatrix?: Matrix4;
			vertexCacheOptimize?: boolean;
			interleave?: boolean;
			compressVertices?: boolean;
			releaseGeometryInstances?: boolean;
			allowPicking?: boolean;
			cull?: boolean;
			asynchronous?: boolean;
			debugShowBoundingVolume?: boolean;
			shadows?: any;
		});

		/**
		 * The geometry instances rendered with this primitive.  This may
		 * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>
		 * is <code>true</code> when the primitive is constructed.
		 * <p>
		 * Changing this property after the primitive is rendered has no effect.
		 * </p>
		 * @readonly
		 * @type GeometryInstance[]|GeometryInstance
		 * @default undefined
		 */
		readonly geometryInstances: (GeometryInstance)[] | GeometryInstance;

		/**
		 * The {@link Appearance} used to shade this primitive. Each geometry
		 * instance is shaded with the same appearance.  Some appearances, like
		 * {@link PerInstanceColorAppearance} allow giving each instance unique
		 * properties.
		 * @type Appearance
		 * @default undefined
		 */
		appearance: Appearance;

		/**
		 * The {@link Appearance} used to shade this primitive when it fails the depth test. Each geometry
		 * instance is shaded with the same appearance.  Some appearances, like
		 * {@link PerInstanceColorAppearance} allow giving each instance unique
		 * properties.
		 * <p>
		 * When using an appearance that requires a color attribute, like PerInstanceColorAppearance,
		 * add a depthFailColor per-instance attribute instead.
		 * </p>
		 * <p>
		 * Requires the EXT_frag_depth WebGL extension to render properly. If the extension is not supported,
		 * there may be artifacts.
		 * </p>
		 * @type Appearance
		 * @default undefined
		 */
		depthFailAppearance: Appearance;

		/**
		 * The 4x4 transformation matrix that transforms the primitive (all geometry instances) from model to world coordinates.
		 * When this is the identity matrix, the primitive is drawn in world coordinates, i.e., Earth's WGS84 coordinates.
		 * Local reference frames can be used by providing a different transformation matrix, like that returned
		 * by {@link Transforms.eastNorthUpToFixedFrame}.
		 * <p>
		 * This property is only supported in 3D mode.
		 * </p>
		 * @type Matrix4
		 * @default Matrix4.IDENTITY
		 * @example
		 * var origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);
		 * p.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);
		 */
		modelMatrix: Matrix4;

		/**
		 * Determines if the primitive will be shown.  This affects all geometry
		 * instances in the primitive.
		 * @type Boolean
		 * @default true
		 */
		show: boolean;

		/**
		 * When <code>true</code>, the renderer frustum culls and horizon culls the primitive's commands
		 * based on their bounding volume.  Set this to <code>false</code> for a small performance gain
		 * if you are manually culling the primitive.
		 * @type {Boolean}
		 * @default true
		 */
		cull: boolean;

		/**
		 * This property is for debugging only; it is not for production use nor is it optimized.
		 * <p>
		 * Draws the bounding sphere for each draw command in the primitive.
		 * </p>
		 * @type {Boolean}
		 * @default false
		 */
		debugShowBoundingVolume: boolean;

		/**
		 * Determines whether this primitive casts or receives shadows from each light source.
		 * @type {ShadowMode}
		 * @default ShadowMode.DISABLED
		 */
		shadows: any;

		/**
		 * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.
		 * @memberof Primitive.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		readonly vertexCacheOptimize: boolean;

		/**
		 * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.
		 * @memberof Primitive.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default false
		 */
		readonly interleave: boolean;

		/**
		 * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
		 * @memberof Primitive.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		readonly releaseGeometryInstances: boolean;

		/**
		 * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.         *
		 * @memberof Primitive.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		readonly allowPicking: boolean;

		/**
		 * Determines if the geometry instances will be created and batched on a web worker.
		 * @memberof Primitive.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		readonly asynchronous: boolean;

		/**
		 * When <code>true</code>, geometry vertices are compressed, which will save memory.
		 * @memberof Primitive.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		readonly compressVertices: boolean;

		/**
		 * Determines if the primitive is complete and ready to render.  If this property is
		 * true, the primitive will be rendered the next time that {@link Primitive#update}
		 * is called.
		 * @memberof Primitive.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly ready: boolean;

		/**
		 * Gets a promise that resolves when the primitive is ready to render.
		 * @memberof Primitive.prototype
		 * @type {Promise.<Primitive>}
		 * @readonly
		 */
		readonly readyPromise: any;

		/**
		 * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
		 * get the draw commands needed to render this primitive.
		 * <p>
		 * Do not call this function directly.  This is documented just to
		 * list the exceptions that may be propagated when the scene is rendered:
		 * </p>
		 * @exception {DeveloperError} All instance geometries must have the same primitiveType.
		 * @exception {DeveloperError} Appearance and material have a uniform with the same name.
		 * @exception {DeveloperError} Primitive.modelMatrix is only supported in 3D mode.
		 * @exception {RuntimeError} Vertex texture fetch support is required to render primitives with per-instance attributes. The maximum number of vertex texture image units must be greater than zero.
		 */
		update(): void;

		/**
		 * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.
		 * @param {*} id The id of the {@link GeometryInstance}.
		 * @returns {Object} The typed array in the attribute's format or undefined if the is no instance with id.
		 * @exception {DeveloperError} must call update before calling getGeometryInstanceAttributes.
		 * @example
		 * var attributes = primitive.getGeometryInstanceAttributes('an id');
		 * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);
		 * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);
		 * attributes.distanceDisplayCondition = Cesium.DistanceDisplayConditionGeometryInstanceAttribute.toValue(100.0, 10000.0);
		 * attributes.offset = Cesium.OffsetGeometryInstanceAttribute.toValue(Cartesian3.IDENTITY);
		 */
		getGeometryInstanceAttributes(id: any): any;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <p>
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * </p>
		 * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
		 * @see Primitive#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
		 * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
		 * <p>
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * </p>
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * e = e && e.destroy();
		 * @see Primitive#isDestroyed
		 */
		destroy(): void;

	}

	/**
	 * A collection of primitives.  This is most often used with {@link Scene#primitives},
	 * but <code>PrimitiveCollection</code> is also a primitive itself so collections can
	 * be added to collections forming a hierarchy.
	 * @alias PrimitiveCollection
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Boolean} [options.show=true] Determines if the primitives in the collection will be shown.
	 * @param {Boolean} [options.destroyPrimitives=true] Determines if primitives in the collection are destroyed when they are removed.
	 * @example
	 * var billboards = new Cesium.BillboardCollection();
	 * var labels = new Cesium.LabelCollection();
	 * var collection = new Cesium.PrimitiveCollection();
	 * collection.add(billboards);
	 * scene.primitives.add(collection);  // Add collection
	 * scene.primitives.add(labels);      // Add regular primitive
	 */
	class PrimitiveCollection {
		constructor(options?: {
			show?: boolean;
			destroyPrimitives?: boolean;
		});

		/**
		 * Determines if primitives in this collection will be shown.
		 * @type {Boolean}
		 * @default true
		 */
		show: boolean;

		/**
		 * Determines if primitives in the collection are destroyed when they are removed by
		 * {@link PrimitiveCollection#destroy} or  {@link PrimitiveCollection#remove} or implicitly
		 * by {@link PrimitiveCollection#removeAll}.
		 * @type {Boolean}
		 * @default true
		 * @example
		 * // Example 1. Primitives are destroyed by default.
		 * var primitives = new Cesium.PrimitiveCollection();
		 * var labels = primitives.add(new Cesium.LabelCollection());
		 * primitives = primitives.destroy();
		 * var b = labels.isDestroyed(); // true
		 * @example
		 * // Example 2. Do not destroy primitives in a collection.
		 * var primitives = new Cesium.PrimitiveCollection();
		 * primitives.destroyPrimitives = false;
		 * var labels = primitives.add(new Cesium.LabelCollection());
		 * primitives = primitives.destroy();
		 * var b = labels.isDestroyed(); // false
		 * labels = labels.destroy();    // explicitly destroy
		 */
		destroyPrimitives: boolean;

		/**
		 * Gets the number of primitives in the collection.
		 * @memberof PrimitiveCollection.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly length: number;

		/**
		 * Adds a primitive to the collection.
		 * @param {Object} primitive The primitive to add.
		 * @returns {Object} The primitive added to the collection.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * var billboards = scene.primitives.add(new Cesium.BillboardCollection());
		 */
		add(primitive: any): any;

		/**
		 * Removes a primitive from the collection.
		 * @param {Object} [primitive] The primitive to remove.
		 * @returns {Boolean} <code>true</code> if the primitive was removed; <code>false</code> if the primitive is <code>undefined</code> or was not found in the collection.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * var billboards = scene.primitives.add(new Cesium.BillboardCollection());
		 * scene.primitives.remove(p);  // Returns true
		 * @see PrimitiveCollection#destroyPrimitives
		 */
		remove(primitive?: any): boolean;

		/**
		 * Removes and destroys a primitive, regardless of destroyPrimitives setting.
		 * @param {Primitive} primitive
		 */
		removeAndDestroy(primitive: Primitive): void;

		/**
		 * Removes all primitives in the collection.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @see PrimitiveCollection#destroyPrimitives
		 */
		removeAll(): void;

		/**
		 * Determines if this collection contains a primitive.
		 * @param {Object} [primitive] The primitive to check for.
		 * @returns {Boolean} <code>true</code> if the primitive is in the collection; <code>false</code> if the primitive is <code>undefined</code> or was not found in the collection.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @see PrimitiveCollection#get
		 */
		contains(primitive?: any): boolean;

		/**
		 * Raises a primitive "up one" in the collection.  If all primitives in the collection are drawn
		 * on the globe surface, this visually moves the primitive up one.
		 * @param {Object} [primitive] The primitive to raise.
		 * @exception {DeveloperError} primitive is not in this collection.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @see PrimitiveCollection#raiseToTop
		 * @see PrimitiveCollection#lower
		 * @see PrimitiveCollection#lowerToBottom
		 */
		raise(primitive?: any): void;

		/**
		 * Raises a primitive to the "top" of the collection.  If all primitives in the collection are drawn
		 * on the globe surface, this visually moves the primitive to the top.
		 * @param {Object} [primitive] The primitive to raise the top.
		 * @exception {DeveloperError} primitive is not in this collection.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @see PrimitiveCollection#raise
		 * @see PrimitiveCollection#lower
		 * @see PrimitiveCollection#lowerToBottom
		 */
		raiseToTop(primitive?: any): void;

		/**
		 * Lowers a primitive "down one" in the collection.  If all primitives in the collection are drawn
		 * on the globe surface, this visually moves the primitive down one.
		 * @param {Object} [primitive] The primitive to lower.
		 * @exception {DeveloperError} primitive is not in this collection.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @see PrimitiveCollection#lowerToBottom
		 * @see PrimitiveCollection#raise
		 * @see PrimitiveCollection#raiseToTop
		 */
		lower(primitive?: any): void;

		/**
		 * Lowers a primitive to the "bottom" of the collection.  If all primitives in the collection are drawn
		 * on the globe surface, this visually moves the primitive to the bottom.
		 * @param {Object} [primitive] The primitive to lower to the bottom.
		 * @exception {DeveloperError} primitive is not in this collection.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @see PrimitiveCollection#lower
		 * @see PrimitiveCollection#raise
		 * @see PrimitiveCollection#raiseToTop
		 */
		lowerToBottom(primitive?: any): void;

		/**
		 * Returns the primitive in the collection at the specified index.
		 * @param {Number} index The zero-based index of the primitive to return.
		 * @returns {Object} The primitive at the <code>index</code>.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * // Toggle the show property of every primitive in the collection.
		 * var primitives = scene.primitives;
		 * var length = primitives.length;
		 * for (var i = 0; i < length; ++i) {
		 *   var p = primitives.get(i);
		 *   p.show = !p.show;
		 * }
		 * @see PrimitiveCollection#length
		 */
		get(index: number): any;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <br /><br />
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * @returns {Boolean} True if this object was destroyed; otherwise, false.
		 * @see PrimitiveCollection#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys the WebGL resources held by each primitive in this collection.  Explicitly destroying this
		 * collection allows for deterministic release of WebGL resources, instead of relying on the garbage
		 * collector to destroy this collection.
		 * <br /><br />
		 * Since destroying a collection destroys all the contained primitives, only destroy a collection
		 * when you are sure no other code is still using any of the contained primitives.
		 * <br /><br />
		 * Once this collection is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * primitives = primitives && primitives.destroy();
		 * @see PrimitiveCollection#isDestroyed
		 */
		destroy(): void;

	}

	/**
	 * The container for all 3D graphical objects and state in a Cesium virtual scene.  Generally,
	 * a scene is not created directly; instead, it is implicitly created by {@link CesiumWidget}.
	 * <p>
	 * <em><code>contextOptions</code> parameter details:</em>
	 * </p>
	 * <p>
	 * The default values are:
	 * <code>
	 * {
	 *   webgl : {
	 *     alpha : false,
	 *     depth : true,
	 *     stencil : false,
	 *     antialias : true,
	 *     premultipliedAlpha : true,
	 *     preserveDrawingBuffer : false,
	 *     failIfMajorPerformanceCaveat : false
	 *   },
	 *   allowTextureFilterAnisotropic : true
	 * }
	 * </code>
	 * </p>
	 * <p>
	 * The <code>webgl</code> property corresponds to the {@link http://www.khronos.org/registry/webgl/specs/latest/#5.2|WebGLContextAttributes}
	 * object used to create the WebGL context.
	 * </p>
	 * <p>
	 * <code>webgl.alpha</code> defaults to false, which can improve performance compared to the standard WebGL default
	 * of true.  If an application needs to composite Cesium above other HTML elements using alpha-blending, set
	 * <code>webgl.alpha</code> to true.
	 * </p>
	 * <p>
	 * The other <code>webgl</code> properties match the WebGL defaults for {@link http://www.khronos.org/registry/webgl/specs/latest/#5.2|WebGLContextAttributes}.
	 * </p>
	 * <p>
	 * <code>allowTextureFilterAnisotropic</code> defaults to true, which enables anisotropic texture filtering when the
	 * WebGL extension is supported.  Setting this to false will improve performance, but hurt visual quality, especially for horizon views.
	 * </p>
	 * @alias Scene
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {Canvas} options.canvas The HTML canvas element to create the scene for.
	 * @param {Object} [options.contextOptions] Context and WebGL creation properties.  See details above.
	 * @param {Element} [options.creditContainer] The HTML element in which the credits will be displayed.
	 * @param {Element} [options.creditViewport] The HTML element in which to display the credit popup.  If not specified, the viewport will be a added as a sibling of the canvas.
	 * @param {MapProjection} [options.mapProjection=new GeographicProjection()] The map projection to use in 2D and Columbus View modes.
	 * @param {Boolean} [options.orderIndependentTranslucency=true] If true and the configuration supports it, use order independent translucency.
	 * @param {Boolean} [options.scene3DOnly=false] If true, optimizes memory use and performance for 3D mode but disables the ability to use 2D or Columbus View.
	 * @param {Number} [options.terrainExaggeration=1.0] A scalar used to exaggerate the terrain. Note that terrain exaggeration will not modify any other primitive as they are positioned relative to the ellipsoid.
	 * @param {Boolean} [options.shadows=false] Determines if shadows are cast by the sun.
	 * @param {MapMode2D} [options.mapMode2D=MapMode2D.INFINITE_SCROLL] Determines if the 2D map is rotatable or can be scrolled infinitely in the horizontal direction.
	 * @param {Boolean} [options.requestRenderMode=false] If true, rendering a frame will only occur when needed as determined by changes within the scene. Enabling improves performance of the application, but requires using {@link Scene#requestRender} to render a new frame explicitly in this mode. This will be necessary in many cases after making changes to the scene in other parts of the API. See {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}.
	 * @param {Number} [options.maximumRenderTimeChange=0.0] If requestRenderMode is true, this value defines the maximum change in simulation time allowed before a render is requested. See {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}.
	 * @see CesiumWidget
	 * @see {@link http://www.khronos.org/registry/webgl/specs/latest/#5.2|WebGLContextAttributes}
	 * @exception {DeveloperError} options and options.canvas are required.
	 * @example
	 * // Create scene without anisotropic texture filtering
	 * var scene = new Cesium.Scene({
	 *   canvas : canvas,
	 *   contextOptions : {
	 *     allowTextureFilterAnisotropic : false
	 *   }
	 * });
	 */
	class EngineScene {
		constructor(options?: {
			canvas: any;
			contextOptions?: any;
			creditContainer?: Element;
			creditViewport?: Element;
			mapProjection?: MapProjection;
			orderIndependentTranslucency?: boolean;
			scene3DOnly?: boolean;
			terrainExaggeration?: number;
			shadows?: boolean;
			mapMode2D?: any;
			requestRenderMode?: boolean;
			maximumRenderTimeChange?: number;
		});

		/**
		 * Exceptions occurring in <code>render</code> are always caught in order to raise the
		 * <code>renderError</code> event.  If this property is true, the error is rethrown
		 * after the event is raised.  If this property is false, the <code>render</code> function
		 * returns normally after raising the event.
		 * @type {Boolean}
		 * @default false
		 */
		rethrowRenderErrors: boolean;

		/**
		 * Determines whether or not to instantly complete the
		 * scene transition animation on user input.
		 * @type {Boolean}
		 * @default true
		 */
		completeMorphOnUserInput: boolean;

		/**
		 * The event fired at the beginning of a scene transition.
		 * @type {Event}
		 * @default Event()
		 */
		morphStart: Event;

		/**
		 * The event fired at the completion of a scene transition.
		 * @type {Event}
		 * @default Event()
		 */
		morphComplete: Event;

		/**
		 * The {@link SkyBox} used to draw the stars.
		 * @type {SkyBox}
		 * @default undefined
		 * @see Scene#backgroundColor
		 */
		skyBox: SkyBox;

		/**
		 * The sky atmosphere drawn around the globe.
		 * @type {SkyAtmosphere}
		 * @default undefined
		 */
		skyAtmosphere: SkyAtmosphere;

		/**
		 * The {@link Sun}.
		 * @type {Sun}
		 * @default undefined
		 */
		sun: Sun;

		/**
		 * Uses a bloom filter on the sun when enabled.
		 * @type {Boolean}
		 * @default true
		 */
		sunBloom: boolean;

		/**
		 * The {@link Moon}
		 * @type Moon
		 * @default undefined
		 */
		moon: Moon;

		/**
		 * The background color, which is only visible if there is no sky box, i.e., {@link Scene#skyBox} is undefined.
		 * @type {Color}
		 * @default {@link Color.BLACK}
		 * @see Scene#skyBox
		 */
		backgroundColor: Color;

		/**
		 * The current morph transition time between 2D/Columbus View and 3D,
		 * with 0.0 being 2D or Columbus View and 1.0 being 3D.
		 * @type {Number}
		 * @default 1.0
		 */
		morphTime: number;

		/**
		 * The far-to-near ratio of the multi-frustum when using a normal depth buffer.
		 * <p>
		 * This value is used to create the near and far values for each frustum of the multi-frustum. It is only used
		 * when {@link Scene#logarithmicDepthBuffer} is <code>false</code>. When <code>logarithmicDepthBuffer</code> is
		 * <code>true</code>, use {@link Scene#logarithmicDepthFarToNearRatio}.
		 * </p>
		 * @type {Number}
		 * @default 1000.0
		 */
		farToNearRatio: number;

		/**
		 * The far-to-near ratio of the multi-frustum when using a logarithmic depth buffer.
		 * <p>
		 * This value is used to create the near and far values for each frustum of the multi-frustum. It is only used
		 * when {@link Scene#logarithmicDepthBuffer} is <code>true</code>. When <code>logarithmicDepthBuffer</code> is
		 * <code>false</code>, use {@link Scene#farToNearRatio}.
		 * </p>
		 * @type {Number}
		 * @default 1e9
		 */
		logarithmicDepthFarToNearRatio: number;

		/**
		 * Determines the uniform depth size in meters of each frustum of the multifrustum in 2D. If a primitive or model close
		 * to the surface shows z-fighting, decreasing this will eliminate the artifact, but decrease performance. On the
		 * other hand, increasing this will increase performance but may cause z-fighting among primitives close to the surface.
		 * @type {Number}
		 * @default 1.75e6
		 */
		nearToFarDistance2D: number;

		/**
		 * Determines the uniform depth size in meters of each frustum of the multifrustum in orthographic. If a primitive or model
		 * shows z-fighting, decreasing this will eliminate the artifact, but decrease performance. On the other hand, increasing
		 * this will increase performance but may cause z-fighting among primitives.
		 * @type {Number}
		 * @default 1.75e6
		 */
		nearToFarDistanceOrthographic: number;

		/**
		 * This property is for debugging only; it is not for production use.
		 * <p>
		 * A function that determines what commands are executed.  As shown in the examples below,
		 * the function receives the command's <code>owner</code> as an argument, and returns a boolean indicating if the
		 * command should be executed.
		 * </p>
		 * <p>
		 * The default is <code>undefined</code>, indicating that all commands are executed.
		 * </p>
		 * @type Function
		 * @default undefined
		 * @example
		 * // Do not execute any commands.
		 * scene.debugCommandFilter = function(command) {
		 *     return false;
		 * };
		 * // Execute only the billboard's commands.  That is, only draw the billboard.
		 * var billboards = new Cesium.BillboardCollection();
		 * scene.debugCommandFilter = function(command) {
		 *     return command.owner === billboards;
		 * };
		 */
		debugCommandFilter: Function;

		/**
		 * This property is for debugging only; it is not for production use.
		 * <p>
		 * When <code>true</code>, commands are randomly shaded.  This is useful
		 * for performance analysis to see what parts of a scene or model are
		 * command-dense and could benefit from batching.
		 * </p>
		 * @type Boolean
		 * @default false
		 */
		debugShowCommands: boolean;

		/**
		 * This property is for debugging only; it is not for production use.
		 * <p>
		 * When <code>true</code>, commands are shaded based on the frustums they
		 * overlap.  Commands in the closest frustum are tinted red, commands in
		 * the next closest are green, and commands in the farthest frustum are
		 * blue.  If a command overlaps more than one frustum, the color components
		 * are combined, e.g., a command overlapping the first two frustums is tinted
		 * yellow.
		 * </p>
		 * @type Boolean
		 * @default false
		 */
		debugShowFrustums: boolean;

		/**
		 * This property is for debugging only; it is not for production use.
		 * <p>
		 * Displays frames per second and time between frames.
		 * </p>
		 * @type Boolean
		 * @default false
		 */
		debugShowFramesPerSecond: boolean;

		/**
		 * This property is for debugging only; it is not for production use.
		 * <p>
		 * Displays depth information for the indicated frustum.
		 * </p>
		 * @type Boolean
		 * @default false
		 */
		debugShowGlobeDepth: boolean;

		/**
		 * This property is for debugging only; it is not for production use.
		 * <p>
		 * Indicates which frustum will have depth information displayed.
		 * </p>
		 * @type Number
		 * @default 1
		 */
		debugShowDepthFrustum: number;

		/**
		 * This property is for debugging only; it is not for production use.
		 * <p>
		 * When <code>true</code>, draws outlines to show the boundaries of the camera frustums
		 * </p>
		 * @type Boolean
		 * @default false
		 */
		debugShowFrustumPlanes: boolean;

		/**
		 * When <code>true</code>, enables picking using the depth buffer.
		 * @type Boolean
		 * @default true
		 */
		useDepthPicking: boolean;

		/**
		 * When <code>true</code>, enables picking translucent geometry using the depth buffer. Note that {@link Scene#useDepthPicking} must also be true for enabling this to work.
		 * <p>
		 * Render must be called between picks.
		 * <br>There is a decrease in performance when enabled. There are extra draw calls to write depth for
		 * translucent geometry.
		 * </p>
		 * @example
		 * // picking the position of a translucent primitive
		 * viewer.screenSpaceEventHandler.setInputAction(function onLeftClick(movement) {
		 *      var pickedFeature = viewer.scene.pick(movement.position);
		 *      if (!Cesium.defined(pickedFeature)) {
		 *          // nothing picked
		 *          return;
		 *      }
		 *      viewer.scene.render();
		 *      var worldPosition = viewer.scene.pickPosition(movement.position);
		 * }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
		 * @type {Boolean}
		 * @default false
		 */
		pickTranslucentDepth: boolean;

		/**
		 * Blends the atmosphere to geometry far from the camera for horizon views. Allows for additional
		 * performance improvements by rendering less geometry and dispatching less terrain requests.
		 * @type {Fog}
		 */
		fog: Fog;

		/**
		 * The shadow map in the scene. When enabled, models, primitives, and the globe may cast and receive shadows.
		 * By default the light source of the shadow map is the sun.
		 * @type {ShadowMap}
		 */
		shadowMap: ShadowMap;

		/**
		 * When <code>false</code>, 3D Tiles will render normally. When <code>true</code>, classified 3D Tile geometry will render normally and
		 * unclassified 3D Tile geometry will render with the color multiplied by {@link Scene#invertClassificationColor}.
		 * @type {Boolean}
		 * @default false
		 */
		invertClassification: boolean;

		/**
		 * The highlight color of unclassified 3D Tile geometry when {@link Scene#invertClassification} is <code>true</code>.
		 * <p>When the color's alpha is less than 1.0, the unclassified portions of the 3D Tiles will not blend correctly with the classified positions of the 3D Tiles.</p>
		 * <p>Also, when the color's alpha is less than 1.0, the WEBGL_depth_texture and EXT_frag_depth WebGL extensions must be supported.</p>
		 * @type {Color}
		 * @default Color.WHITE
		 */
		invertClassificationColor: Color;

		/**
		 * The focal length for use when with cardboard or WebVR.
		 * @type {Number}
		 */
		focalLength: number;

		/**
		 * The eye separation distance in meters for use with cardboard or WebVR.
		 * @type {Number}
		 */
		eyeSeparation: number;

		/**
		 * Post processing effects applied to the final render.
		 * @type {PostProcessStageCollection}
		 */
		postProcessStages: PostProcessStageCollection;

		/**
		 * When <code>true</code>, rendering a frame will only occur when needed as determined by changes within the scene.
		 * Enabling improves performance of the application, but requires using {@link Scene#requestRender}
		 * to render a new frame explicitly in this mode. This will be necessary in many cases after making changes
		 * to the scene in other parts of the API.
		 * @see {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}
		 * @see Scene#maximumRenderTimeChange
		 * @see Scene#requestRender
		 * @type {Boolean}
		 * @default false
		 */
		requestRenderMode: boolean;

		/**
		 * If {@link Scene#requestRenderMode} is <code>true</code>, this value defines the maximum change in
		 * simulation time allowed before a render is requested. Lower values increase the number of frames rendered
		 * and higher values decrease the number of frames rendered. If <code>undefined</code>, changes to
		 * the simulation time will never request a render.
		 * This value impacts the rate of rendering for changes in the scene like lighting, entity property updates,
		 * and animations.
		 * @see {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}
		 * @see Scene#requestRenderMode
		 * @type {Number}
		 * @default 0.5
		 */
		maximumRenderTimeChange: number;

		/**
		 * Gets the canvas element to which this scene is bound.
		 * @memberof Scene.prototype
		 * @type {Canvas}
		 * @readonly
		 */
		readonly canvas: any;

		/**
		 * The drawingBufferHeight of the underlying GL context.
		 * @memberof Scene.prototype
		 * @type {Number}
		 * @readonly
		 * @see {@link https://www.khronos.org/registry/webgl/specs/1.0/#DOM-WebGLRenderingContext-drawingBufferHeight|drawingBufferHeight}
		 */
		readonly drawingBufferHeight: number;

		/**
		 * The drawingBufferHeight of the underlying GL context.
		 * @memberof Scene.prototype
		 * @type {Number}
		 * @readonly
		 * @see {@link https://www.khronos.org/registry/webgl/specs/1.0/#DOM-WebGLRenderingContext-drawingBufferHeight|drawingBufferHeight}
		 */
		readonly drawingBufferWidth: number;

		/**
		 * The maximum aliased line width, in pixels, supported by this WebGL implementation.  It will be at least one.
		 * @memberof Scene.prototype
		 * @type {Number}
		 * @readonly
		 * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>ALIASED_LINE_WIDTH_RANGE</code>.
		 */
		readonly maximumAliasedLineWidth: number;

		/**
		 * The maximum length in pixels of one edge of a cube map, supported by this WebGL implementation.  It will be at least 16.
		 * @memberof Scene.prototype
		 * @type {Number}
		 * @readonly
		 * @see {@link https://www.khronos.org/opengles/sdk/docs/man/xhtml/glGet.xml|glGet} with <code>GL_MAX_CUBE_MAP_TEXTURE_SIZE</code>.
		 */
		readonly maximumCubeMapSize: number;

		/**
		 * Returns true if the pickPosition function is supported.
		 * @memberof Scene.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly pickPositionSupported: boolean;

		/**
		 * Gets or sets the depth-test ellipsoid.
		 * @memberof Scene.prototype
		 * @type {Globe}
		 */
		globe: Globe;

		/**
		 * Gets the collection of primitives.
		 * @memberof Scene.prototype
		 * @type {PrimitiveCollection}
		 * @readonly
		 */
		readonly primitives: PrimitiveCollection;

		/**
		 * Gets the collection of ground primitives.
		 * @memberof Scene.prototype
		 * @type {PrimitiveCollection}
		 * @readonly
		 */
		readonly groundPrimitives: PrimitiveCollection;

		/**
		 * Gets the camera.
		 * @memberof Scene.prototype
		 * @type {Camera}
		 * @readonly
		 */
		readonly camera: Camera;

		/**
		 * Gets the controller for camera input handling.
		 * @memberof Scene.prototype
		 * @type {ScreenSpaceCameraController}
		 * @readonly
		 */
		readonly screenSpaceCameraController: ScreenSpaceCameraController;

		/**
		 * Get the map projection to use in 2D and Columbus View modes.
		 * @memberof Scene.prototype
		 * @type {MapProjection}
		 * @readonly
		 * @default new GeographicProjection()
		 */
		readonly mapProjection: MapProjection;

		/**
		 * Gets the collection of image layers that will be rendered on the globe.
		 * @memberof Scene.prototype
		 * @type {ImageryLayerCollection}
		 * @readonly
		 */
		readonly imageryLayers: ImageryLayerCollection;

		/**
		 * The terrain provider providing surface geometry for the globe.
		 * @memberof Scene.prototype
		 * @type {TerrainProvider}
		 */
		terrainProvider: TerrainProvider;

		/**
		 * Gets an event that's raised when the terrain provider is changed
		 * @memberof Scene.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly terrainProviderChanged: Event;

		/**
		 * Gets the event that will be raised before the scene is updated or rendered.  Subscribers to the event
		 * receive the Scene instance as the first parameter and the current time as the second parameter.
		 * @memberof Scene.prototype
		 * @see {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}
		 * @see Scene#postUpdate
		 * @see Scene#preRender
		 * @see Scene#postRender
		 * @type {Event}
		 * @readonly
		 */
		readonly preUpdate: Event;

		/**
		 * Gets the event that will be raised immediately after the scene is updated and before the scene is rendered.
		 * Subscribers to the event receive the Scene instance as the first parameter and the current time as the second
		 * parameter.
		 * @memberof Scene.prototype
		 * @see {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}
		 * @see Scene#preUpdate
		 * @see Scene#preRender
		 * @see Scene#postRender
		 * @type {Event}
		 * @readonly
		 */
		readonly postUpdate: Event;

		/**
		 * Gets the event that will be raised when an error is thrown inside the <code>render</code> function.
		 * The Scene instance and the thrown error are the only two parameters passed to the event handler.
		 * By default, errors are not rethrown after this event is raised, but that can be changed by setting
		 * the <code>rethrowRenderErrors</code> property.
		 * @memberof Scene.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly renderError: Event;

		/**
		 * Gets the event that will be raised after the scene is updated and immediately before the scene is rendered.
		 * Subscribers to the event receive the Scene instance as the first parameter and the current time as the second
		 * parameter.
		 * @memberof Scene.prototype
		 * @see {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}
		 * @see Scene#preUpdate
		 * @see Scene#postUpdate
		 * @see Scene#postRender
		 * @type {Event}
		 * @readonly
		 */
		readonly preRender: Event;

		/**
		 * Gets the event that will be raised immediately after the scene is rendered.  Subscribers to the event
		 * receive the Scene instance as the first parameter and the current time as the second parameter.
		 * @memberof Scene.prototype
		 * @see {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}
		 * @see Scene#preUpdate
		 * @see Scene#postUpdate
		 * @see Scene#postRender
		 * @type {Event}
		 * @readonly
		 */
		readonly postRender: Event;

		/**
		 * Gets the simulation time when the scene was last rendered. Returns undefined if the scene has not yet been
		 * rendered.
		 * @memberof Scene.prototype
		 * @type {JulianDate}
		 * @readonly
		 */
		readonly lastRenderTime: JulianDate;

		/**
		 * This property is for debugging only; it is not for production use.
		 * <p>
		 * When {@link Scene.debugShowFrustums} is <code>true</code>, this contains
		 * properties with statistics about the number of command execute per frustum.
		 * <code>totalCommands</code> is the total number of commands executed, ignoring
		 * overlap. <code>commandsInFrustums</code> is an array with the number of times
		 * commands are executed redundantly, e.g., how many commands overlap two or
		 * three frustums.
		 * </p>
		 * @memberof Scene.prototype
		 * @type {Object}
		 * @readonly
		 * @default undefined
		 */
		readonly debugFrustumStatistics: any;

		/**
		 * Gets whether or not the scene is optimized for 3D only viewing.
		 * @memberof Scene.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly scene3DOnly: boolean;

		/**
		 * Gets whether or not the scene has order independent translucency enabled.
		 * Note that this only reflects the original construction option, and there are
		 * other factors that could prevent OIT from functioning on a given system configuration.
		 * @memberof Scene.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly orderIndependentTranslucency: boolean;

		/**
		 * Gets the unique identifier for this scene.
		 * @memberof Scene.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly id: string;

		/**
		 * Gets or sets the current mode of the scene.
		 * @memberof Scene.prototype
		 * @type {SceneMode}
		 * @default {@link SceneMode.SCENE3D}
		 */
		mode: any;

		/**
		 * Gets the scalar used to exaggerate the terrain.
		 * @memberof Scene.prototype
		 * @type {Number}
		 */
		terrainExaggeration: number;

		/**
		 * When <code>true</code>, splits the scene into two viewports with steroscopic views for the left and right eyes.
		 * Used for cardboard and WebVR.
		 * @memberof Scene.prototype
		 * @type {Boolean}
		 * @default false
		 */
		useWebVR: boolean;

		/**
		 * Determines if the 2D map is rotatable or can be scrolled infinitely in the horizontal direction.
		 * @memberof Scene.prototype
		 * @type {Boolean}
		 */
		mapMode2D: boolean;

		/**
		 * Gets or sets the position of the Imagery splitter within the viewport.  Valid values are between 0.0 and 1.0.
		 * @memberof Scene.prototype
		 * @type {Number}
		 */
		imagerySplitPosition: number;

		/**
		 * The distance from the camera at which to disable the depth test of billboards, labels and points
		 * to, for example, prevent clipping against terrain. When set to zero, the depth test should always
		 * be applied. When less than zero, the depth test should never be applied. Setting the disableDepthTestDistance
		 * property of a billboard, label or point will override this value.
		 * @memberof Scene.prototype
		 * @type {Number}
		 * @default 0.0
		 */
		minimumDisableDepthTestDistance: number;

		/**
		 * Whether or not to use a logarithmic depth buffer. Enabling this option will allow for less frustums in the multi-frustum,
		 * increasing performance. This property relies on {@link Context#fragmentDepth} being supported.
		 * @memberof Scene.prototype
		 * @type {Boolean}
		 */
		logarithmicDepthBuffer: boolean;

		/**
		 * Determines if a compressed texture format is supported.
		 * @param {String} format The texture format. May be the name of the format or the WebGL extension name, e.g. s3tc or WEBGL_compressed_texture_s3tc.
		 * @return {boolean} Whether or not the format is supported.
		 */
		getCompressedTextureFormatSupported(format: string): boolean;

		/**
		 * Requests a new rendered frame when {@link Scene#requestRenderMode} is set to <code>true</code>.
		 * The render rate will not exceed the {@link CesiumWidget#targetFrameRate}.
		 * @see Scene#requestRenderMode
		 */
		requestRender(): void;

		/**
		 * Returns an object with a `primitive` property that contains the first (top) primitive in the scene
		 * at a particular window coordinate or undefined if nothing is at the location. Other properties may
		 * potentially be set depending on the type of primitive.
		 * <p>
		 * When a feature of a 3D Tiles tileset is picked, <code>pick</code> returns a {@link Cesium3DTileFeature} object.
		 * </p>
		 * @example
		 * // On mouse over, color the feature yellow.
		 * handler.setInputAction(function(movement) {
		 *     var feature = scene.pick(movement.endPosition);
		 *     if (feature instanceof Cesium.Cesium3DTileFeature) {
		 *         feature.color = Cesium.Color.YELLOW;
		 *     }
		 * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
		 * @param {Cartesian2} windowPosition Window coordinates to perform picking on.
		 * @param {Number} [width=3] Width of the pick rectangle.
		 * @param {Number} [height=3] Height of the pick rectangle.
		 * @returns {Object} Object containing the picked primitive.
		 */
		pick(windowPosition: Cartesian2, width?: number, height?: number): any;

		/**
		 * Returns the cartesian position reconstructed from the depth buffer and window position.
		 * <p>
		 * The position reconstructed from the depth buffer in 2D may be slightly different from those
		 * reconstructed in 3D and Columbus view. This is caused by the difference in the distribution
		 * of depth values of perspective and orthographic projection.
		 * </p>
		 * <p>
		 * Set {@link Scene#pickTranslucentDepth} to <code>true</code> to include the depth of
		 * translucent primitives; otherwise, this essentially picks through translucent primitives.
		 * </p>
		 * @param {Cartesian2} windowPosition Window coordinates to perform picking on.
		 * @param {Cartesian3} [result] The object on which to restore the result.
		 * @returns {Cartesian3} The cartesian position.
		 * @exception {DeveloperError} Picking from the depth buffer is not supported. Check pickPositionSupported.
		 */
		pickPosition(windowPosition: Cartesian2, result?: Cartesian3): Cartesian3;

		/**
		 * Returns a list of objects, each containing a `primitive` property, for all primitives at
		 * a particular window coordinate position. Other properties may also be set depending on the
		 * type of primitive. The primitives in the list are ordered by their visual order in the
		 * scene (front to back).
		 * @param {Cartesian2} windowPosition Window coordinates to perform picking on.
		 * @param {Number} [limit] If supplied, stop drilling after collecting this many picks.
		 * @param {Number} [width=3] Width of the pick rectangle.
		 * @param {Number} [height=3] Height of the pick rectangle.
		 * @returns {Object[]} Array of objects, each containing 1 picked primitives.
		 * @exception {DeveloperError} windowPosition is undefined.
		 * @example
		 * var pickedObjects = scene.drillPick(new Cesium.Cartesian2(100.0, 200.0));
		 * @see Scene#pick
		 */
		drillPick(windowPosition: Cartesian2, limit?: number, width?: number, height?: number): any[];

		/**
		 * Transforms a position in cartesian coordinates to canvas coordinates.  This is commonly used to place an
		 * HTML element at the same screen position as an object in the scene.
		 * @param {Cartesian3} position The position in cartesian coordinates.
		 * @param {Cartesian2} [result] An optional object to return the input position transformed to canvas coordinates.
		 * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.  This may be <code>undefined</code> if the input position is near the center of the ellipsoid.
		 * @example
		 * // Output the canvas position of longitude/latitude (0, 0) every time the mouse moves.
		 * var scene = widget.scene;
		 * var ellipsoid = scene.globe.ellipsoid;
		 * var position = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
		 * var handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);
		 * handler.setInputAction(function(movement) {
		 *     console.log(scene.cartesianToCanvasCoordinates(position));
		 * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
		 */
		cartesianToCanvasCoordinates(position: Cartesian3, result?: Cartesian2): Cartesian2;

		/**
		 * Instantly completes an active transition.
		 */
		completeMorph(): void;

		/**
		 * Asynchronously transitions the scene to 2D.
		 * @param {Number} [duration=2.0] The amount of time, in seconds, for transition animations to complete.
		 */
		morphTo2D(duration?: number): void;

		/**
		 * Asynchronously transitions the scene to Columbus View.
		 * @param {Number} [duration=2.0] The amount of time, in seconds, for transition animations to complete.
		 */
		morphToColumbusView(duration?: number): void;

		/**
		 * Asynchronously transitions the scene to 3D.
		 * @param {Number} [duration=2.0] The amount of time, in seconds, for transition animations to complete.
		 */
		morphTo3D(duration?: number): void;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <br /><br />
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
		 * @see Scene#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
		 * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
		 * <br /><br />
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * scene = scene && scene.destroy();
		 * @see Scene#isDestroyed
		 */
		destroy(): void;

	}

	/**
	 * Functions that do scene-dependent transforms between rendering-related coordinate systems.
	 * @exports SceneTransforms
	 */
	namespace SceneTransforms {
		/**
		 * Transforms a position in WGS84 coordinates to window coordinates.  This is commonly used to place an
		 * HTML element at the same screen position as an object in the scene.
		 * @param {Scene} scene The scene.
		 * @param {Cartesian3} position The position in WGS84 (world) coordinates.
		 * @param {Cartesian2} [result] An optional object to return the input position transformed to window coordinates.
		 * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.  This may be <code>undefined</code> if the input position is near the center of the ellipsoid.
		 * @example
		 * // Output the window position of longitude/latitude (0, 0) every time the mouse moves.
		 * var scene = widget.scene;
		 * var ellipsoid = scene.globe.ellipsoid;
		 * var position = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
		 * var handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);
		 * handler.setInputAction(function(movement) {
		 *     console.log(Cesium.SceneTransforms.wgs84ToWindowCoordinates(scene, position));
		 * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
		 */
		function wgs84ToWindowCoordinates(scene: Scene, position: Cartesian3, result?: Cartesian2): Cartesian2;

		/**
		 * Transforms a position in WGS84 coordinates to drawing buffer coordinates.  This may produce different
		 * results from SceneTransforms.wgs84ToWindowCoordinates when the browser zoom is not 100%, or on high-DPI displays.
		 * @param {Scene} scene The scene.
		 * @param {Cartesian3} position The position in WGS84 (world) coordinates.
		 * @param {Cartesian2} [result] An optional object to return the input position transformed to window coordinates.
		 * @returns {Cartesian2} The modified result parameter or a new Cartesian2 instance if one was not provided.  This may be <code>undefined</code> if the input position is near the center of the ellipsoid.
		 * @example
		 * // Output the window position of longitude/latitude (0, 0) every time the mouse moves.
		 * var scene = widget.scene;
		 * var ellipsoid = scene.globe.ellipsoid;
		 * var position = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
		 * var handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);
		 * handler.setInputAction(function(movement) {
		 *     console.log(Cesium.SceneTransforms.wgs84ToWindowCoordinates(scene, position));
		 * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
		 */
		function wgs84ToDrawingBufferCoordinates(scene: Scene, position: Cartesian3, result?: Cartesian2): Cartesian2;

	}

	/**
	 * Modifies the camera position and orientation based on mouse input to a canvas.
	 * @alias ScreenSpaceCameraController
	 * @constructor
	 * @param {Scene} scene The scene.
	 */
	class ScreenSpaceCameraController {
		constructor(scene: Scene);

		/**
		 * If true, inputs are allowed conditionally with the flags enableTranslate, enableZoom,
		 * enableRotate, enableTilt, and enableLook.  If false, all inputs are disabled.
		 * NOTE: This setting is for temporary use cases, such as camera flights and
		 * drag-selection of regions (see Picking demo).  It is typically set to false at the
		 * start of such events, and set true on completion.  To keep inputs disabled
		 * past the end of camera flights, you must use the other booleans (enableTranslate,
		 * enableZoom, enableRotate, enableTilt, and enableLook).
		 * @type {Boolean}
		 * @default true
		 */
		enableInputs: boolean;

		/**
		 * If true, allows the user to pan around the map.  If false, the camera stays locked at the current position.
		 * This flag only applies in 2D and Columbus view modes.
		 * @type {Boolean}
		 * @default true
		 */
		enableTranslate: boolean;

		/**
		 * If true, allows the user to zoom in and out.  If false, the camera is locked to the current distance from the ellipsoid.
		 * @type {Boolean}
		 * @default true
		 */
		enableZoom: boolean;

		/**
		 * If true, allows the user to rotate the world which translates the user's position.
		 * This flag only applies in 2D and 3D.
		 * @type {Boolean}
		 * @default true
		 */
		enableRotate: boolean;

		/**
		 * If true, allows the user to tilt the camera.  If false, the camera is locked to the current heading.
		 * This flag only applies in 3D and Columbus view.
		 * @type {Boolean}
		 * @default true
		 */
		enableTilt: boolean;

		/**
		 * If true, allows the user to use free-look. If false, the camera view direction can only be changed through translating
		 * or rotating. This flag only applies in 3D and Columbus view modes.
		 * @type {Boolean}
		 * @default true
		 */
		enableLook: boolean;

		/**
		 * A parameter in the range <code>[0, 1)</code> used to determine how long
		 * the camera will continue to spin because of inertia.
		 * With value of zero, the camera will have no inertia.
		 * @type {Number}
		 * @default 0.9
		 */
		inertiaSpin: number;

		/**
		 * A parameter in the range <code>[0, 1)</code> used to determine how long
		 * the camera will continue to translate because of inertia.
		 * With value of zero, the camera will have no inertia.
		 * @type {Number}
		 * @default 0.9
		 */
		inertiaTranslate: number;

		/**
		 * A parameter in the range <code>[0, 1)</code> used to determine how long
		 * the camera will continue to zoom because of inertia.
		 * With value of zero, the camera will have no inertia.
		 * @type {Number}
		 * @default 0.8
		 */
		inertiaZoom: number;

		/**
		 * A parameter in the range <code>[0, 1)</code> used to limit the range
		 * of various user inputs to a percentage of the window width/height per animation frame.
		 * This helps keep the camera under control in low-frame-rate situations.
		 * @type {Number}
		 * @default 0.1
		 */
		maximumMovementRatio: number;

		/**
		 * Sets the duration, in seconds, of the bounce back animations in 2D and Columbus view.
		 * @type {Number}
		 * @default 3.0
		 */
		bounceAnimationTime: number;

		/**
		 * The minimum magnitude, in meters, of the camera position when zooming. Defaults to 1.0.
		 * @type {Number}
		 * @default 1.0
		 */
		minimumZoomDistance: number;

		/**
		 * The maximum magnitude, in meters, of the camera position when zooming. Defaults to positive infinity.
		 * @type {Number}
		 * @default {@link Number.POSITIVE_INFINITY}
		 */
		maximumZoomDistance: number;

		/**
		 * The input that allows the user to pan around the map. This only applies in 2D and Columbus view modes.
		 * <p>
		 * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>
		 * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},
		 * or an array of any of the preceding.
		 * </p>
		 * @type {CameraEventType|Array|undefined}
		 * @default {@link CameraEventType.LEFT_DRAG}
		 */
		translateEventTypes: any | any[] | undefined;

		/**
		 * The input that allows the user to zoom in/out.
		 * <p>
		 * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>
		 * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},
		 * or an array of any of the preceding.
		 * </p>
		 * @type {CameraEventType|Array|undefined}
		 * @default [{@link CameraEventType.RIGHT_DRAG}, {@link CameraEventType.WHEEL}, {@link CameraEventType.PINCH}]
		 */
		zoomEventTypes: any | any[] | undefined;

		/**
		 * The input that allows the user to rotate around the globe or another object. This only applies in 3D and Columbus view modes.
		 * <p>
		 * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>
		 * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},
		 * or an array of any of the preceding.
		 * </p>
		 * @type {CameraEventType|Array|undefined}
		 * @default {@link CameraEventType.LEFT_DRAG}
		 */
		rotateEventTypes: any | any[] | undefined;

		/**
		 * The input that allows the user to tilt in 3D and Columbus view or twist in 2D.
		 * <p>
		 * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>
		 * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},
		 * or an array of any of the preceding.
		 * </p>
		 * @type {CameraEventType|Array|undefined}
		 * @default [{@link CameraEventType.MIDDLE_DRAG}, {@link CameraEventType.PINCH}, {
		 *     eventType : {@link CameraEventType.LEFT_DRAG},
		 *     modifier : {@link KeyboardEventModifier.CTRL}
		 * }, {
		 *     eventType : {@link CameraEventType.RIGHT_DRAG},
		 *     modifier : {@link KeyboardEventModifier.CTRL}
		 * }]
		 */
		tiltEventTypes: any | any[] | undefined;

		/**
		 * The input that allows the user to change the direction the camera is viewing. This only applies in 3D and Columbus view modes.
		 * <p>
		 * The type came be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>
		 * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},
		 * or an array of any of the preceding.
		 * </p>
		 * @type {CameraEventType|Array|undefined}
		 * @default { eventType : {@link CameraEventType.LEFT_DRAG}, modifier : {@link KeyboardEventModifier.SHIFT} }
		 */
		lookEventTypes: any | any[] | undefined;

		/**
		 * The minimum height the camera must be before picking the terrain instead of the ellipsoid.
		 * @type {Number}
		 * @default 150000.0
		 */
		minimumPickingTerrainHeight: number;

		/**
		 * The minimum height the camera must be before testing for collision with terrain.
		 * @type {Number}
		 * @default 10000.0
		 */
		minimumCollisionTerrainHeight: number;

		/**
		 * The minimum height the camera must be before switching from rotating a track ball to
		 * free look when clicks originate on the sky on in space.
		 * @type {Number}
		 * @default 7500000.0
		 */
		minimumTrackBallHeight: number;

		/**
		 * Enables or disables camera collision detection with terrain.
		 * @type {Boolean}
		 * @default true
		 */
		enableCollisionDetection: boolean;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <br /><br />
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
		 * @see ScreenSpaceCameraController#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Removes mouse listeners held by this object.
		 * <br /><br />
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * controller = controller && controller.destroy();
		 * @see ScreenSpaceCameraController#isDestroyed
		 */
		destroy(): void;

	}

	/**
	 * Use {@link Viewer#shadowMap} to get the scene's shadow map originating from the sun. Do not construct this directly.
	 * <p>
	 * The normalOffset bias pushes the shadows forward slightly, and may be disabled
	 * for applications that require ultra precise shadows.
	 * </p>
	 * @alias ShadowMap
	 * @internalConstructor
	 * @class
	 * @param {Object} options An object containing the following properties:
	 * @param {Camera} options.lightCamera A camera representing the light source.
	 * @param {Boolean} [options.enabled=true] Whether the shadow map is enabled.
	 * @param {Boolean} [options.isPointLight=false] Whether the light source is a point light. Point light shadows do not use cascades.
	 * @param {Boolean} [options.pointLightRadius=100.0] Radius of the point light.
	 * @param {Boolean} [options.cascadesEnabled=true] Use multiple shadow maps to cover different partitions of the view frustum.
	 * @param {Number} [options.numberOfCascades=4] The number of cascades to use for the shadow map. Supported values are one and four.
	 * @param {Number} [options.maximumDistance=5000.0] The maximum distance used for generating cascaded shadows. Lower values improve shadow quality.
	 * @param {Number} [options.size=2048] The width and height, in pixels, of each shadow map.
	 * @param {Boolean} [options.softShadows=false] Whether percentage-closer-filtering is enabled for producing softer shadows.
	 * @param {Number} [options.darkness=0.3] The shadow darkness.
	 * @param {Boolean} [options.normalOffset=true] Whether a normal bias is applied to shadows.
	 * @exception {DeveloperError} Only one or four cascades are supported.
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Shadows.html|Cesium Sandcastle Shadows Demo}
	 */
	class ShadowMap {
		constructor(options: {
			 context?:any;
			lightCamera: Camera;
			enabled?: boolean;
			isPointLight?: boolean;
			pointLightRadius?: number;
			cascadesEnabled?: boolean;
			numberOfCascades?: number;
			maximumDistance?: number;
			size?: number;
			softShadows?: boolean;
			darkness?: number;
			normalOffset?: boolean;
		});

		/**
		 * Determines the darkness of the shadows.
		 * @type {Number}
		 * @default 0.3
		 */
		darkness: number;

		/**
		 * Determines the maximum distance of the shadow map. Only applicable for cascaded shadows. Larger distances may result in lower quality shadows.
		 * @type {Number}
		 * @default 5000.0
		 */
		maximumDistance: number;

		/**
		 * Determines if the shadow map will be shown.
		 * @memberof ShadowMap.prototype
		 * @type {Boolean}
		 * @default true
		 */
		enabled: boolean;

		/**
		 * Determines if a normal bias will be applied to shadows.
		 * @memberof ShadowMap.prototype
		 * @type {Boolean}
		 * @default true
		 */
		normalOffset: boolean;

		/**
		 * Determines if soft shadows are enabled. Uses pcf filtering which requires more texture reads and may hurt performance.
		 * @memberof ShadowMap.prototype
		 * @type {Boolean}
		 * @default false
		 */
		softShadows: boolean;

		/**
		 * The width and height, in pixels, of each shadow map.
		 * @memberof ShadowMap.prototype
		 * @type {Number}
		 * @default 2048
		 */
		size: number;

	}

	/**
	 * Specifies whether the object casts or receives shadows from each light source when
	 * shadows are enabled.
	 * @exports ShadowMode
	 */
	namespace ShadowMode {
		/**
		 * The object does not cast or receive shadows.
		 * @type {Number}
		 * @constant
		 */
		const DISABLED: number;

		/**
		 * The object casts and receives shadows.
		 * @type {Number}
		 * @constant
		 */
		const ENABLED: number;

		/**
		 * The object casts shadows only.
		 * @type {Number}
		 * @constant
		 */
		const CAST_ONLY: number;

		/**
		 * The object receives shadows only.
		 * @type {Number}
		 * @constant
		 */
		const RECEIVE_ONLY: number;

	}

	/**
	 * Provides a single, top-level imagery tile.  The single image is assumed to use a
	 * {@link GeographicTilingScheme}.
	 * @alias SingleTileImageryProvider
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Resource|String} options.url The url for the tile.
	 * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the image.
	 * @param {Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.
	 * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If not specified, the WGS84 ellipsoid is used.
	 * @see ArcGisMapServerImageryProvider
	 * @see BingMapsImageryProvider
	 * @see GoogleEarthEnterpriseMapsProvider
	 * @see createOpenStreetMapImageryProvider
	 * @see createTileMapServiceImageryProvider
	 * @see WebMapServiceImageryProvider
	 * @see WebMapTileServiceImageryProvider
	 * @see UrlTemplateImageryProvider
	 */
	class SingleTileImageryProvider {
		constructor(options: {
			url: Resource | string | HTMLCanvasElement;
			rectangle?: Rectangle;
			credit?: Credit | string;
			ellipsoid?: Ellipsoid;
		});

		/**
		 * Gets the URL of the single, top-level imagery tile.
		 * @memberof SingleTileImageryProvider.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly url: string;

		/**
		 * Gets the proxy used by this provider.
		 * @memberof SingleTileImageryProvider.prototype
		 * @type {Proxy}
		 * @readonly
		 */
		readonly proxy: Proxy;

		/**
		 * Gets the width of each tile, in pixels. This function should
		 * not be called before {@link SingleTileImageryProvider#ready} returns true.
		 * @memberof SingleTileImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly tileWidth: number;

		/**
		 * Gets the height of each tile, in pixels.  This function should
		 * not be called before {@link SingleTileImageryProvider#ready} returns true.
		 * @memberof SingleTileImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly tileHeight: number;

		/**
		 * Gets the maximum level-of-detail that can be requested.  This function should
		 * not be called before {@link SingleTileImageryProvider#ready} returns true.
		 * @memberof SingleTileImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly maximumLevel: number;

		/**
		 * Gets the minimum level-of-detail that can be requested.  This function should
		 * not be called before {@link SingleTileImageryProvider#ready} returns true.
		 * @memberof SingleTileImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly minimumLevel: number;

		/**
		 * Gets the tiling scheme used by this provider.  This function should
		 * not be called before {@link SingleTileImageryProvider#ready} returns true.
		 * @memberof SingleTileImageryProvider.prototype
		 * @type {TilingScheme}
		 * @readonly
		 */
		readonly tilingScheme: TilingScheme;

		/**
		 * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should
		 * not be called before {@link SingleTileImageryProvider#ready} returns true.
		 * @memberof SingleTileImageryProvider.prototype
		 * @type {Rectangle}
		 * @readonly
		 */
		readonly rectangle: Rectangle;

		/**
		 * Gets the tile discard policy.  If not undefined, the discard policy is responsible
		 * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
		 * returns undefined, no tiles are filtered.  This function should
		 * not be called before {@link SingleTileImageryProvider#ready} returns true.
		 * @memberof SingleTileImageryProvider.prototype
		 * @type {TileDiscardPolicy}
		 * @readonly
		 */
		readonly tileDiscardPolicy: TileDiscardPolicy;

		/**
		 * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
		 * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
		 * are passed an instance of {@link TileProviderError}.
		 * @memberof SingleTileImageryProvider.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly errorEvent: Event;

		/**
		 * Gets a value indicating whether or not the provider is ready for use.
		 * @memberof SingleTileImageryProvider.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly ready: boolean;

		/**
		 * Gets a promise that resolves to true when the provider is ready for use.
		 * @memberof SingleTileImageryProvider.prototype
		 * @type {Promise.<Boolean>}
		 * @readonly
		 */
		readonly readyPromise: any;

		/**
		 * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
		 * the source of the imagery.  This function should not be called before {@link SingleTileImageryProvider#ready} returns true.
		 * @memberof SingleTileImageryProvider.prototype
		 * @type {Credit}
		 * @readonly
		 */
		readonly credit: Credit;

		/**
		 * Gets a value indicating whether or not the images provided by this imagery provider
		 * include an alpha channel.  If this property is false, an alpha channel, if present, will
		 * be ignored.  If this property is true, any images without an alpha channel will be treated
		 * as if their alpha is 1.0 everywhere.  When this property is false, memory usage
		 * and texture upload time are reduced.
		 * @memberof SingleTileImageryProvider.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly hasAlphaChannel: boolean;

		/**
		 * Gets the credits to be displayed when a given tile is displayed.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level;
		 * @returns {Credit[]} The credits to be displayed when the tile is displayed.
		 * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.
		 */
		getTileCredits(x: number, y: number, level: number): (Credit)[];

		/**
		 * Requests the image for a given tile.  This function should
		 * not be called before {@link SingleTileImageryProvider#ready} returns true.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level.
		 * @param {Request} [request] The request object. Intended for internal use only.
		 * @returns {Promise.<Image|Canvas>|undefined} A promise for the image that will resolve when the image is available, or
		 *          undefined if there are too many active requests to the server, and the request
		 *          should be retried later.  The resolved image may be either an
		 *          Image or a Canvas DOM object.
		 * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.
		 */
		requestImage(x: number, y: number, level: number, request?: Request): any | any | undefined;

		/**
		 * Picking features is not currently supported by this imagery provider, so this function simply returns
		 * undefined.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level.
		 * @param {Number} longitude The longitude at which to pick features.
		 * @param {Number} latitude  The latitude at which to pick features.
		 * @return {Promise.<ImageryLayerFeatureInfo[]>|undefined} A promise for the picked features that will resolve when the asynchronous
		 *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}
		 *                   instances.  The array may be empty if no features are found at the given location.
		 *                   It may also be undefined if picking is not supported.
		 */
		pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): any | undefined;

	}

	/**
	 * An atmosphere drawn around the limb of the provided ellipsoid.  Based on
	 * {@link http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter16.html|Accurate Atmospheric Scattering}
	 * in GPU Gems 2.
	 * <p>
	 * This is only supported in 3D.  atmosphere is faded out when morphing to 2D or Columbus view.
	 * </p>
	 * @alias SkyAtmosphere
	 * @constructor
	 * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid that the atmosphere is drawn around.
	 * @example
	 * scene.skyAtmosphere = new Cesium.SkyAtmosphere();
	 * @see Scene.skyAtmosphere
	 */
	class SkyAtmosphere {
		constructor(ellipsoid?: Ellipsoid);

		/**
		 * Determines if the atmosphere is shown.
		 * @type {Boolean}
		 * @default true
		 */
		show: boolean;

		/**
		 * The hue shift to apply to the atmosphere. Defaults to 0.0 (no shift).
		 * A hue shift of 1.0 indicates a complete rotation of the hues available.
		 * @type {Number}
		 * @default 0.0
		 */
		hueShift: number;

		/**
		 * The saturation shift to apply to the atmosphere. Defaults to 0.0 (no shift).
		 * A saturation shift of -1.0 is monochrome.
		 * @type {Number}
		 * @default 0.0
		 */
		saturationShift: number;

		/**
		 * The brightness shift to apply to the atmosphere. Defaults to 0.0 (no shift).
		 * A brightness shift of -1.0 is complete darkness, which will let space show through.
		 * @type {Number}
		 * @default 0.0
		 */
		brightnessShift: number;

		/**
		 * Gets the ellipsoid the atmosphere is drawn around.
		 * @memberof SkyAtmosphere.prototype
		 * @type {Ellipsoid}
		 * @readonly
		 */
		readonly ellipsoid: Ellipsoid;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <br /><br />
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
		 * @see SkyAtmosphere#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
		 * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
		 * <br /><br />
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * skyAtmosphere = skyAtmosphere && skyAtmosphere.destroy();
		 * @see SkyAtmosphere#isDestroyed
		 */
		destroy(): void;

	}

	/**
	 * A sky box around the scene to draw stars.  The sky box is defined using the True Equator Mean Equinox (TEME) axes.
	 * <p>
	 * This is only supported in 3D.  The sky box is faded out when morphing to 2D or Columbus view.  The size of
	 * the sky box must not exceed {@link Scene#maximumCubeMapSize}.
	 * </p>
	 * @alias SkyBox
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Object} [options.sources] The source URL or <code>Image</code> object for each of the six cube map faces.  See the example below.
	 * @param {Boolean} [options.show=true] Determines if this primitive will be shown.
	 * @example
	 * scene.skyBox = new Cesium.SkyBox({
	 *   sources : {
	 *     positiveX : 'skybox_px.png',
	 *     negativeX : 'skybox_nx.png',
	 *     positiveY : 'skybox_py.png',
	 *     negativeY : 'skybox_ny.png',
	 *     positiveZ : 'skybox_pz.png',
	 *     negativeZ : 'skybox_nz.png'
	 *   }
	 * });
	 * @see Scene#skyBox
	 * @see Transforms.computeTemeToPseudoFixedMatrix
	 */
	class SkyBox {
		constructor(options: {
			sources?: any;
			show?: boolean;
		});

		/**
		 * The sources used to create the cube map faces: an object
		 * with <code>positiveX</code>, <code>negativeX</code>, <code>positiveY</code>,
		 * <code>negativeY</code>, <code>positiveZ</code>, and <code>negativeZ</code> properties.
		 * These can be either URLs or <code>Image</code> objects.
		 * @type Object
		 * @default undefined
		 */
		sources: any;

		/**
		 * Determines if the sky box will be shown.
		 * @type {Boolean}
		 * @default true
		 */
		show: boolean;

		/**
		 * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
		 * get the draw commands needed to render this primitive.
		 * <p>
		 * Do not call this function directly.  This is documented just to
		 * list the exceptions that may be propagated when the scene is rendered:
		 * </p>
		 * @exception {DeveloperError} this.sources is required and must have positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ properties.
		 * @exception {DeveloperError} this.sources properties must all be the same type.
		 */
		update(): void;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <br /><br />
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
		 * @see SkyBox#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
		 * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
		 * <br /><br />
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * skyBox = skyBox && skyBox.destroy();
		 * @see SkyBox#isDestroyed
		 */
		destroy(): void;

	}

	/**
	 * A ParticleEmitter that emits particles within a sphere.
	 * Particles will be positioned randomly within the sphere and have initial velocities emanating from the center of the sphere.
	 * @alias SphereEmitter
	 * @constructor
	 * @param {Number} [radius=1.0] The radius of the sphere in meters.
	 */
	class SphereEmitter {
		constructor(radius?: number);

		/**
		 * The radius of the sphere in meters.
		 * @memberof SphereEmitter.prototype
		 * @type {Number}
		 * @default 1.0
		 */
		radius: number;

	}

	/**
	 * Determines the function used to compare stencil values for the stencil test.
	 * @exports StencilFunction
	 */
	namespace StencilFunction {
		/**
		 * The stencil test never passes.
		 * @type {Number}
		 * @constant
		 */
		const NEVER: number;

		/**
		 * The stencil test passes when the masked reference value is less than the masked stencil value.
		 * @type {Number}
		 * @constant
		 */
		const LESS: number;

		/**
		 * The stencil test passes when the masked reference value is equal to the masked stencil value.
		 * @type {Number}
		 * @constant
		 */
		const EQUAL: number;

		/**
		 * The stencil test passes when the masked reference value is less than or equal to the masked stencil value.
		 * @type {Number}
		 * @constant
		 */
		const LESS_OR_EQUAL: number;

		/**
		 * The stencil test passes when the masked reference value is greater than the masked stencil value.
		 * @type {Number}
		 * @constant
		 */
		const GREATER: number;

		/**
		 * The stencil test passes when the masked reference value is not equal to the masked stencil value.
		 * @type {Number}
		 * @constant
		 */
		const NOT_EQUAL: number;

		/**
		 * The stencil test passes when the masked reference value is greater than or equal to the masked stencil value.
		 * @type {Number}
		 * @constant
		 */
		const GREATER_OR_EQUAL: number;

		/**
		 * The stencil test always passes.
		 * @type {Number}
		 * @constant
		 */
		const ALWAYS: number;

	}

	/**
	 * An expression for a style applied to a {@link Cesium3DTileset}.
	 * <p>
	 * Derived classes of this interface evaluate expressions in the
	 * {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification/Styling|3D Tiles Styling language}.
	 * </p>
	 * <p>
	 * This type describes an interface and is not intended to be instantiated directly.
	 * </p>
	 * @alias StyleExpression
	 * @constructor
	 * @see Expression
	 * @see ConditionsExpression
	 */
	class StyleExpression {
		constructor();

		/**
		 * Evaluates the result of an expression, optionally using the provided feature's properties. If the result of
		 * the expression in the
		 * {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification/Styling|3D Tiles Styling language}
		 * is of type <code>Boolean</code>, <code>Number</code>, or <code>String</code>, the corresponding JavaScript
		 * primitive type will be returned. If the result is a <code>RegExp</code>, a Javascript <code>RegExp</code>
		 * object will be returned. If the result is a <code>Cartesian2</code>, <code>Cartesian3</code>, or <code>Cartesian4</code>,
		 * a {@link Cartesian2}, {@link Cartesian3}, or {@link Cartesian4} object will be returned. If the <code>result</code> argument is
		 * a {@link Color}, the {@link Cartesian4} value is converted to a {@link Color} and then returned.
		 * @param {Cesium3DTileFeature} feature The feature whose properties may be used as variables in the expression.
		 * @param {Object} [result] The object onto which to store the result.
		 * @returns {Boolean|Number|String|RegExp|Cartesian2|Cartesian3|Cartesian4|Color} The result of evaluating the expression.
		 */
		evaluate(feature: Cesium3DTileFeature, result?: any): boolean | number | string | RegExp | Cartesian2 | Cartesian3 | Cartesian4 | Color;

		/**
		 * Evaluates the result of a Color expression, optionally using the provided feature's properties.
		 * <p>
		 * This is equivalent to {@link StyleExpression#evaluate} but always returns a {@link Color} object.
		 * </p>
		 * @param {Cesium3DTileFeature} feature The feature whose properties may be used as variables in the expression.
		 * @param {Color} [result] The object in which to store the result.
		 * @returns {Color} The modified result parameter or a new Color instance if one was not provided.
		 */
		evaluateColor(feature: Cesium3DTileFeature, result?: Color): Color;

	}

	/**
	 * Draws a sun billboard.
	 * <p>This is only supported in 3D and Columbus view.</p>
	 * @alias Sun
	 * @constructor
	 * @example
	 * scene.sun = new Cesium.Sun();
	 * @see Scene#sun
	 */
	class Sun {
		constructor();

		/**
		 * Determines if the sun will be shown.
		 * @type {Boolean}
		 * @default true
		 */
		show: boolean;

		/**
		 * Gets or sets a number that controls how "bright" the Sun's lens flare appears
		 * to be.  Zero shows just the Sun's disc without any flare.
		 * Use larger values for a more pronounced flare around the Sun.
		 * @memberof Sun.prototype
		 * @type {Number}
		 * @default 1.0
		 */
		glowFactor: number;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <br /><br />
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
		 * @see Sun#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
		 * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
		 * <br /><br />
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * sun = sun && sun.destroy();
		 *  @see Sun#isDestroyed
		 */
		destroy(): void;

	}

	/**
	 * An {@link ImageryProvider} that draws a box around every rendered tile in the tiling scheme, and draws
	 * a label inside it indicating the X, Y, Level coordinates of the tile.  This is mostly useful for
	 * debugging terrain and imagery rendering problems.
	 * @alias TileCoordinatesImageryProvider
	 * @constructor
	 * @param {Object} [options] Object with the following properties:
	 * @param {TilingScheme} [options.tilingScheme=new GeographicTilingScheme()] The tiling scheme for which to draw tiles.
	 * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If the tilingScheme is specified,
	 *                    this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither
	 *                    parameter is specified, the WGS84 ellipsoid is used.
	 * @param {Color} [options.color=Color.YELLOW] The color to draw the tile box and label.
	 * @param {Number} [options.tileWidth=256] The width of the tile for level-of-detail selection purposes.
	 * @param {Number} [options.tileHeight=256] The height of the tile for level-of-detail selection purposes.
	 */
	class TileCoordinatesImageryProvider {
		constructor(options?: {
			tilingScheme?: TilingScheme;
			ellipsoid?: Ellipsoid;
			color?: Color;
			tileWidth?: number;
			tileHeight?: number;
		});

		/**
		 * Gets the proxy used by this provider.
		 * @memberof TileCoordinatesImageryProvider.prototype
		 * @type {Proxy}
		 * @readonly
		 */
		readonly proxy: Proxy;

		/**
		 * Gets the width of each tile, in pixels. This function should
		 * not be called before {@link TileCoordinatesImageryProvider#ready} returns true.
		 * @memberof TileCoordinatesImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly tileWidth: number;

		/**
		 * Gets the height of each tile, in pixels.  This function should
		 * not be called before {@link TileCoordinatesImageryProvider#ready} returns true.
		 * @memberof TileCoordinatesImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly tileHeight: number;

		/**
		 * Gets the maximum level-of-detail that can be requested.  This function should
		 * not be called before {@link TileCoordinatesImageryProvider#ready} returns true.
		 * @memberof TileCoordinatesImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly maximumLevel: number;

		/**
		 * Gets the minimum level-of-detail that can be requested.  This function should
		 * not be called before {@link TileCoordinatesImageryProvider#ready} returns true.
		 * @memberof TileCoordinatesImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly minimumLevel: number;

		/**
		 * Gets the tiling scheme used by this provider.  This function should
		 * not be called before {@link TileCoordinatesImageryProvider#ready} returns true.
		 * @memberof TileCoordinatesImageryProvider.prototype
		 * @type {TilingScheme}
		 * @readonly
		 */
		readonly tilingScheme: TilingScheme;

		/**
		 * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should
		 * not be called before {@link TileCoordinatesImageryProvider#ready} returns true.
		 * @memberof TileCoordinatesImageryProvider.prototype
		 * @type {Rectangle}
		 * @readonly
		 */
		readonly rectangle: Rectangle;

		/**
		 * Gets the tile discard policy.  If not undefined, the discard policy is responsible
		 * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
		 * returns undefined, no tiles are filtered.  This function should
		 * not be called before {@link TileCoordinatesImageryProvider#ready} returns true.
		 * @memberof TileCoordinatesImageryProvider.prototype
		 * @type {TileDiscardPolicy}
		 * @readonly
		 */
		readonly tileDiscardPolicy: TileDiscardPolicy;

		/**
		 * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
		 * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
		 * are passed an instance of {@link TileProviderError}.
		 * @memberof TileCoordinatesImageryProvider.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly errorEvent: Event;

		/**
		 * Gets a value indicating whether or not the provider is ready for use.
		 * @memberof TileCoordinatesImageryProvider.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly ready: boolean;

		/**
		 * Gets a promise that resolves to true when the provider is ready for use.
		 * @memberof TileCoordinatesImageryProvider.prototype
		 * @type {Promise.<Boolean>}
		 * @readonly
		 */
		readonly readyPromise: any;

		/**
		 * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
		 * the source of the imagery.  This function should not be called before {@link TileCoordinatesImageryProvider#ready} returns true.
		 * @memberof TileCoordinatesImageryProvider.prototype
		 * @type {Credit}
		 * @readonly
		 */
		readonly credit: Credit;

		/**
		 * Gets a value indicating whether or not the images provided by this imagery provider
		 * include an alpha channel.  If this property is false, an alpha channel, if present, will
		 * be ignored.  If this property is true, any images without an alpha channel will be treated
		 * as if their alpha is 1.0 everywhere.  Setting this property to false reduces memory usage
		 * and texture upload time.
		 * @memberof TileCoordinatesImageryProvider.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly hasAlphaChannel: boolean;

		/**
		 * Gets the credits to be displayed when a given tile is displayed.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level;
		 * @returns {Credit[]} The credits to be displayed when the tile is displayed.
		 * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.
		 */
		getTileCredits(x: number, y: number, level: number): (Credit)[];

		/**
		 * Requests the image for a given tile.  This function should
		 * not be called before {@link TileCoordinatesImageryProvider#ready} returns true.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level.
		 * @param {Request} [request] The request object. Intended for internal use only.
		 * @returns {Promise.<Image|Canvas>|undefined} A promise for the image that will resolve when the image is available, or
		 *          undefined if there are too many active requests to the server, and the request
		 *          should be retried later.  The resolved image may be either an
		 *          Image or a Canvas DOM object.
		 */
		requestImage(x: number, y: number, level: number, request?: Request): any | any | undefined;

		/**
		 * Picking features is not currently supported by this imagery provider, so this function simply returns
		 * undefined.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level.
		 * @param {Number} longitude The longitude at which to pick features.
		 * @param {Number} latitude  The latitude at which to pick features.
		 * @return {Promise.<ImageryLayerFeatureInfo[]>|undefined} A promise for the picked features that will resolve when the asynchronous
		 *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}
		 *                   instances.  The array may be empty if no features are found at the given location.
		 *                   It may also be undefined if picking is not supported.
		 */
		pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): any | undefined;

	}

	/**
	 * A policy for discarding tile images according to some criteria.  This type describes an
	 * interface and is not intended to be instantiated directly.
	 * @alias TileDiscardPolicy
	 * @constructor
	 * @see DiscardMissingTileImagePolicy
	 * @see NeverTileDiscardPolicy
	 */
	class TileDiscardPolicy {
		constructor();

		/**
		 * Determines if the discard policy is ready to process images.
		 * @function
		 * @returns {Boolean} True if the discard policy is ready to process images; otherwise, false.
		 */
		isReady(): boolean;

		/**
		 * Given a tile image, decide whether to discard that image.
		 * @function
		 * @param {Image} image An image to test.
		 * @returns {Boolean} True if the image should be discarded; otherwise, false.
		 */
		shouldDiscardImage(image: any): boolean;

	}

	/**
	 * Provides functionality for ImageryProviders that have time dynamic imagery
	 * @alias TimeDynamicImagery
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Clock} options.clock A Clock instance that is used when determining the value for the time dimension. Required when <code>options.times</code> is specified.
	 * @param {TimeIntervalCollection} options.times TimeIntervalCollection with its <code>data</code> property being an object containing time dynamic dimension and their values.
	 * @param {Function} options.requestImageFunction A function that will request imagery tiles.
	 * @param {Function} options.reloadFunction A function that will be called when all imagery tiles need to be reloaded.
	 */
	class TimeDynamicImagery {
		constructor(options: {
			clock: Clock;
			times: TimeIntervalCollection;
			requestImageFunction: Function;
			reloadFunction: Function;
		});

		/**
		 * Gets or sets a clock that is used to get keep the time used for time dynamic parameters.
		 * @memberof TimeDynamicImagery.prototype
		 * @type {Clock}
		 */
		clock: Clock;

		/**
		 * Gets or sets a time interval collection.
		 * @memberof TimeDynamicImagery.prototype
		 * @type {TimeIntervalCollection}
		 */
		times: TimeIntervalCollection;

		/**
		 * Gets the current interval.
		 * @memberof TimeDynamicImagery.prototype
		 * @type {TimeInterval}
		 */
		currentInterval: TimeInterval;

		/**
		 * Gets the tile from the cache if its available.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level.
		 * @param {Request} [request] The request object. Intended for internal use only.
		 * @returns {Promise.<Image>|undefined} A promise for the image that will resolve when the image is available, or
		 *          undefined if the tile is not in the cache.
		 */
		getFromCache(x: number, y: number, level: number, request?: Request): any | undefined;

		/**
		 * Checks if the next interval is approaching and will start preload the tile if necessary. Otherwise it will
		 * just add the tile to a list to preload when we approach the next interval.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level.
		 * @param {Request} [request] The request object. Intended for internal use only.
		 */
		checkApproachingInterval(x: number, y: number, level: number, request?: Request): void;

	}

	/**
	 * Provides playback of time-dynamic point cloud data.
	 * <p>
	 * Point cloud frames are prefetched in intervals determined by the average frame load time and the current clock speed.
	 * If intermediate frames cannot be loaded in time to meet playback speed, they will be skipped. If frames are sufficiently
	 * small or the clock is sufficiently slow then no frames will be skipped.
	 * </p>
	 * @alias TimeDynamicPointCloud
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Clock} options.clock A {@link Clock} instance that is used when determining the value for the time dimension.
	 * @param {TimeIntervalCollection} options.intervals A {@link TimeIntervalCollection} with its data property being an object containing a <code>uri</code> to a 3D Tiles Point Cloud tile and an optional <code>transform</code>.
	 * @param {Boolean} [options.show=true] Determines if the point cloud will be shown.
	 * @param {Matrix4} [options.modelMatrix=Matrix4.IDENTITY] A 4x4 transformation matrix that transforms the point cloud.
	 * @param {ShadowMode} [options.shadows=ShadowMode.ENABLED] Determines whether the point cloud casts or receives shadows from each light source.
	 * @param {Number} [options.maximumMemoryUsage=256] The maximum amount of memory in MB that can be used by the point cloud.
	 * @param {Object} [options.shading] Options for constructing a {@link PointCloudShading} object to control point attenuation and eye dome lighting.
	 * @param {Cesium3DTileStyle} [options.style] The style, defined using the {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification/Styling|3D Tiles Styling language}, applied to each point in the point cloud.
	 * @param {ClippingPlaneCollection} [options.clippingPlanes] The {@link ClippingPlaneCollection} used to selectively disable rendering the point cloud.
	 */
	class TimeDynamicPointCloud {
		constructor(options: {
			clock: Clock;
			intervals: TimeIntervalCollection;
			show?: boolean;
			modelMatrix?: Matrix4;
			shadows?: any;
			maximumMemoryUsage?: number;
			shading?: any;
			style?: Cesium3DTileStyle;
			clippingPlanes?: ClippingPlaneCollection;
		});

		/**
		 * Determines if the point cloud will be shown.
		 * @type {Boolean}
		 * @default true
		 */
		show: boolean;

		/**
		 * A 4x4 transformation matrix that transforms the point cloud.
		 * @type {Matrix4}
		 * @default Matrix4.IDENTITY
		 */
		modelMatrix: Matrix4;

		/**
		 * Determines whether the point cloud casts or receives shadows from each light source.
		 * <p>
		 * Enabling shadows has a performance impact. A point cloud that casts shadows must be rendered twice, once from the camera and again from the light's point of view.
		 * </p>
		 * <p>
		 * Shadows are rendered only when {@link Viewer#shadows} is <code>true</code>.
		 * </p>
		 * @type {ShadowMode}
		 * @default ShadowMode.ENABLED
		 */
		shadows: any;

		/**
		 * The maximum amount of GPU memory (in MB) that may be used to cache point cloud frames.
		 * <p>
		 * Frames that are not being loaded or rendered are unloaded to enforce this.
		 * </p>
		 * <p>
		 * If decreasing this value results in unloading tiles, the tiles are unloaded the next frame.
		 * </p>
		 * @type {Number}
		 * @default 256
		 * @see TimeDynamicPointCloud#totalMemoryUsageInBytes
		 */
		maximumMemoryUsage: number;

		/**
		 * Options for controlling point size based on geometric error and eye dome lighting.
		 * @type {PointCloudShading}
		 */
		shading: PointCloudShading;

		/**
		 * The style, defined using the
		 * {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification/Styling|3D Tiles Styling language},
		 * applied to each point in the point cloud.
		 * <p>
		 * Assign <code>undefined</code> to remove the style, which will restore the visual
		 * appearance of the point cloud to its default when no style was applied.
		 * </p>
		 * @type {Cesium3DTileStyle}
		 * @example
		 * pointCloud.style = new Cesium.Cesium3DTileStyle({
		 *    color : {
		 *        conditions : [
		 *            ['${Classification} === 0', 'color("purple", 0.5)'],
		 *            ['${Classification} === 1', 'color("red")'],
		 *            ['true', '${COLOR}']
		 *        ]
		 *    },
		 *    show : '${Classification} !== 2'
		 * });
		 * @see {@link https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification/Styling|3D Tiles Styling language}
		 */
		style: Cesium3DTileStyle;

		/**
		 * The event fired to indicate that a frame failed to load. A frame may fail to load if the
		 * request for its uri fails or processing fails due to invalid content.
		 * <p>
		 * If there are no event listeners, error messages will be logged to the console.
		 * </p>
		 * <p>
		 * The error object passed to the listener contains two properties:
		 * <ul>
		 * <li><code>uri</code>: the uri of the failed frame.</li>
		 * <li><code>message</code>: the error message.</li>
		 * </ul>
		 * @type {Event}
		 * @default new Event()
		 * @example
		 * pointCloud.frameFailed.addEventListener(function(error) {
		 *     console.log('An error occurred loading frame: ' + error.uri);
		 *     console.log('Error: ' + error.message);
		 * });
		 */
		frameFailed: Event;

		/**
		 * The event fired to indicate that a new frame was rendered.
		 * <p>
		 * The time dynamic point cloud {@link TimeDynamicPointCloud} is passed to the event listener.
		 * </p>
		 * @type {Event}
		 * @default new Event()
		 * @example
		 * pointCloud.frameChanged.addEventListener(function(timeDynamicPointCloud) {
		 *     viewer.camera.viewBoundingSphere(timeDynamicPointCloud.boundingSphere);
		 * });
		 */
		frameChanged: Event;

		/**
		 * The {@link ClippingPlaneCollection} used to selectively disable rendering the point cloud.
		 * @memberof TimeDynamicPointCloud.prototype
		 * @type {ClippingPlaneCollection}
		 */
		clippingPlanes: ClippingPlaneCollection;

		/**
		 * The total amount of GPU memory in bytes used by the point cloud.
		 * @memberof TimeDynamicPointCloud.prototype
		 * @type {Number}
		 * @readonly
		 * @see TimeDynamicPointCloud#maximumMemoryUsage
		 */
		readonly totalMemoryUsageInBytes: number;

		/**
		 * The bounding sphere of the frame being rendered. Returns <code>undefined</code> if no frame is being rendered.
		 * @memberof TimeDynamicPointCloud.prototype
		 * @type {BoundingSphere}
		 * @readonly
		 */
		readonly boundingSphere: BoundingSphere;

		/**
		 * Gets the promise that will be resolved when the point cloud renders a frame for the first time.
		 * @memberof TimeDynamicPointCloud.prototype
		 * @type {Promise.<TimeDynamicPointCloud>}
		 * @readonly
		 */
		readonly readyPromise: any;

		/**
		 * Marks the point cloud's {@link TimeDynamicPointCloud#style} as dirty, which forces all
		 * points to re-evaluate the style in the next frame.
		 */
		makeStyleDirty(): void;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <br /><br />
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * @returns {Boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
		 * @see TimeDynamicPointCloud#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
		 * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
		 * <br /><br />
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * pointCloud = pointCloud && pointCloud.destroy();
		 * @see TimeDynamicPointCloud#isDestroyed
		 */
		destroy(): void;

	}

	/**
	 * Provides imagery by requesting tiles using a specified URL template.
	 * @alias UrlTemplateImageryProvider
	 * @constructor
	 * @param {Promise.<Object>|Object} [options] Object with the following properties:
	 * @param {Resource|String} options.url  The URL template to use to request tiles.  It has the following keywords:
	 * <ul>
	 *     <li><code>{z}</code>: The level of the tile in the tiling scheme.  Level zero is the root of the quadtree pyramid.</li>
	 *     <li><code>{x}</code>: The tile X coordinate in the tiling scheme, where 0 is the Westernmost tile.</li>
	 *     <li><code>{y}</code>: The tile Y coordinate in the tiling scheme, where 0 is the Northernmost tile.</li>
	 *     <li><code>{s}</code>: One of the available subdomains, used to overcome browser limits on the number of simultaneous requests per host.</li>
	 *     <li><code>{reverseX}</code>: The tile X coordinate in the tiling scheme, where 0 is the Easternmost tile.</li>
	 *     <li><code>{reverseY}</code>: The tile Y coordinate in the tiling scheme, where 0 is the Southernmost tile.</li>
	 *     <li><code>{reverseZ}</code>: The level of the tile in the tiling scheme, where level zero is the maximum level of the quadtree pyramid.  In order to use reverseZ, maximumLevel must be defined.</li>
	 *     <li><code>{westDegrees}</code>: The Western edge of the tile in geodetic degrees.</li>
	 *     <li><code>{southDegrees}</code>: The Southern edge of the tile in geodetic degrees.</li>
	 *     <li><code>{eastDegrees}</code>: The Eastern edge of the tile in geodetic degrees.</li>
	 *     <li><code>{northDegrees}</code>: The Northern edge of the tile in geodetic degrees.</li>
	 *     <li><code>{westProjected}</code>: The Western edge of the tile in projected coordinates of the tiling scheme.</li>
	 *     <li><code>{southProjected}</code>: The Southern edge of the tile in projected coordinates of the tiling scheme.</li>
	 *     <li><code>{eastProjected}</code>: The Eastern edge of the tile in projected coordinates of the tiling scheme.</li>
	 *     <li><code>{northProjected}</code>: The Northern edge of the tile in projected coordinates of the tiling scheme.</li>
	 *     <li><code>{width}</code>: The width of each tile in pixels.</li>
	 *     <li><code>{height}</code>: The height of each tile in pixels.</li>
	 * </ul>
	 * @param {Resource|String} [options.pickFeaturesUrl] The URL template to use to pick features.  If this property is not specified,
	 *                 {@link UrlTemplateImageryProvider#pickFeatures} will immediately returned undefined, indicating no
	 *                 features picked.  The URL template supports all of the keywords supported by the <code>url</code>
	 *                 parameter, plus the following:
	 * <ul>
	 *     <li><code>{i}</code>: The pixel column (horizontal coordinate) of the picked position, where the Westernmost pixel is 0.</li>
	 *     <li><code>{j}</code>: The pixel row (vertical coordinate) of the picked position, where the Northernmost pixel is 0.</li>
	 *     <li><code>{reverseI}</code>: The pixel column (horizontal coordinate) of the picked position, where the Easternmost pixel is 0.</li>
	 *     <li><code>{reverseJ}</code>: The pixel row (vertical coordinate) of the picked position, where the Southernmost pixel is 0.</li>
	 *     <li><code>{longitudeDegrees}</code>: The longitude of the picked position in degrees.</li>
	 *     <li><code>{latitudeDegrees}</code>: The latitude of the picked position in degrees.</li>
	 *     <li><code>{longitudeProjected}</code>: The longitude of the picked position in the projected coordinates of the tiling scheme.</li>
	 *     <li><code>{latitudeProjected}</code>: The latitude of the picked position in the projected coordinates of the tiling scheme.</li>
	 *     <li><code>{format}</code>: The format in which to get feature information, as specified in the {@link GetFeatureInfoFormat}.</li>
	 * </ul>
	 * @param {Object} [options.urlSchemeZeroPadding] Gets the URL scheme zero padding for each tile coordinate. The format is '000' where
	 * each coordinate will be padded on the left with zeros to match the width of the passed string of zeros. e.g. Setting:
	 * urlSchemeZeroPadding : { '{x}' : '0000'}
	 * will cause an 'x' value of 12 to return the string '0012' for {x} in the generated URL.
	 * It the passed object has the following keywords:
	 * <ul>
	 *  <li> <code>{z}</code>: The zero padding for the level of the tile in the tiling scheme.</li>
	 *  <li> <code>{x}</code>: The zero padding for the tile X coordinate in the tiling scheme.</li>
	 *  <li> <code>{y}</code>: The zero padding for the the tile Y coordinate in the tiling scheme.</li>
	 *  <li> <code>{reverseX}</code>: The zero padding for the tile reverseX coordinate in the tiling scheme.</li>
	 *  <li> <code>{reverseY}</code>: The zero padding for the tile reverseY coordinate in the tiling scheme.</li>
	 *  <li> <code>{reverseZ}</code>: The zero padding for the reverseZ coordinate of the tile in the tiling scheme.</li>
	 * </ul>
	 * @param {String|String[]} [options.subdomains='abc'] The subdomains to use for the <code>{s}</code> placeholder in the URL template.
	 *                          If this parameter is a single string, each character in the string is a subdomain.  If it is
	 *                          an array, each element in the array is a subdomain.
	 * @param {Credit|String} [options.credit=''] A credit for the data source, which is displayed on the canvas.
	 * @param {Number} [options.minimumLevel=0] The minimum level-of-detail supported by the imagery provider.  Take care when specifying
	 *                 this that the number of tiles at the minimum level is small, such as four or less.  A larger number is likely
	 *                 to result in rendering problems.
	 * @param {Number} [options.maximumLevel] The maximum level-of-detail supported by the imagery provider, or undefined if there is no limit.
	 * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the image.
	 * @param {TilingScheme} [options.tilingScheme=WebMercatorTilingScheme] The tiling scheme specifying how the ellipsoidal
	 * surface is broken into tiles.  If this parameter is not provided, a {@link WebMercatorTilingScheme}
	 * is used.
	 * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If the tilingScheme is specified,
	 *                    this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither
	 *                    parameter is specified, the WGS84 ellipsoid is used.
	 * @param {Number} [options.tileWidth=256] Pixel width of image tiles.
	 * @param {Number} [options.tileHeight=256] Pixel height of image tiles.
	 * @param {Boolean} [options.hasAlphaChannel=true] true if the images provided by this imagery provider
	 *                  include an alpha channel; otherwise, false.  If this property is false, an alpha channel, if
	 *                  present, will be ignored.  If this property is true, any images without an alpha channel will
	 *                  be treated as if their alpha is 1.0 everywhere.  When this property is false, memory usage
	 *                  and texture upload time are potentially reduced.
	 * @param {GetFeatureInfoFormat[]} [options.getFeatureInfoFormats] The formats in which to get feature information at a
	 *                                 specific location when {@link UrlTemplateImageryProvider#pickFeatures} is invoked.  If this
	 *                                 parameter is not specified, feature picking is disabled.
	 * @param {Boolean} [options.enablePickFeatures=true] If true, {@link UrlTemplateImageryProvider#pickFeatures} will
	 *        request the <code>options.pickFeaturesUrl</code> and attempt to interpret the features included in the response.  If false,
	 *        {@link UrlTemplateImageryProvider#pickFeatures} will immediately return undefined (indicating no pickable
	 *        features) without communicating with the server.  Set this property to false if you know your data
	 *        source does not support picking features or if you don't want this provider's features to be pickable. Note
	 *        that this can be dynamically overridden by modifying the {@link UriTemplateImageryProvider#enablePickFeatures}
	 *        property.
	 * @param {Object} [options.customTags] Allow to replace custom keywords in the URL template. The object must have strings as keys and functions as values.
	 * @example
	 * // Access Natural Earth II imagery, which uses a TMS tiling scheme and Geographic (EPSG:4326) project
	 * var tms = new Cesium.UrlTemplateImageryProvider({
	 *     url : 'https://cesiumjs.org/tilesets/imagery/naturalearthii/{z}/{x}/{reverseY}.jpg',
	 *     credit : '© Analytical Graphics, Inc.',
	 *     tilingScheme : new Cesium.GeographicTilingScheme(),
	 *     maximumLevel : 5
	 * });
	 * // Access the CartoDB Positron basemap, which uses an OpenStreetMap-like tiling scheme.
	 * var positron = new Cesium.UrlTemplateImageryProvider({
	 *     url : 'http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
	 *     credit : 'Map tiles by CartoDB, under CC BY 3.0. Data by OpenStreetMap, under ODbL.'
	 * });
	 * // Access a Web Map Service (WMS) server.
	 * var wms = new Cesium.UrlTemplateImageryProvider({
	 *    url : 'https://programs.communications.gov.au/geoserver/ows?tiled=true&' +
	 *          'transparent=true&format=image%2Fpng&exceptions=application%2Fvnd.ogc.se_xml&' +
	 *          'styles=&service=WMS&version=1.1.1&request=GetMap&' +
	 *          'layers=public%3AMyBroadband_Availability&srs=EPSG%3A3857&' +
	 *          'bbox={westProjected}%2C{southProjected}%2C{eastProjected}%2C{northProjected}&' +
	 *          'width=256&height=256',
	 *    rectangle : Cesium.Rectangle.fromDegrees(96.799393, -43.598214999057824, 153.63925700000001, -9.2159219997013)
	 * });
	 * // Using custom tags in your template url.
	 * var custom = new Cesium.UrlTemplateImageryProvider({
	 *    url : 'https://yoururl/{Time}/{z}/{y}/{x}.png',
	 *    customTags : {
	 *        Time: function(imageryProvider, x, y, level) {
	 *            return '20171231'
	 *        }
	 *    }
	 * });
	 * @see ArcGisMapServerImageryProvider
	 * @see BingMapsImageryProvider
	 * @see GoogleEarthEnterpriseMapsProvider
	 * @see createOpenStreetMapImageryProvider
	 * @see SingleTileImageryProvider
	 * @see createTileMapServiceImageryProvider
	 * @see WebMapServiceImageryProvider
	 * @see WebMapTileServiceImageryProvider
	 */
	class UrlTemplateImageryProvider {
		constructor(options?: {
			url: Resource | string;
			pickFeaturesUrl?: Resource | string;
			urlSchemeZeroPadding?: any;
			subdomains?: string | string[];
			credit?: Credit | string;
			minimumLevel?: number;
			maximumLevel?: number;
			rectangle?: Rectangle;
			tilingScheme?: TilingScheme;
			ellipsoid?: Ellipsoid;
			tileWidth?: number;
			tileHeight?: number;
			hasAlphaChannel?: boolean;
			getFeatureInfoFormats?: (GetFeatureInfoFormat)[];
			enablePickFeatures?: boolean;
			customTags?: any;
		});

		/**
		 * Gets or sets a value indicating whether feature picking is enabled.  If true, {@link UrlTemplateImageryProvider#pickFeatures} will
		 * request the <code>options.pickFeaturesUrl</code> and attempt to interpret the features included in the response.  If false,
		 * {@link UrlTemplateImageryProvider#pickFeatures} will immediately return undefined (indicating no pickable
		 * features) without communicating with the server.  Set this property to false if you know your data
		 * source does not support picking features or if you don't want this provider's features to be pickable.
		 * @type {Boolean}
		 * @default true
		 */
		enablePickFeatures: boolean;

		/**
		 * Gets the URL template to use to request tiles.  It has the following keywords:
		 * <ul>
		 *  <li> <code>{z}</code>: The level of the tile in the tiling scheme.  Level zero is the root of the quadtree pyramid.</li>
		 *  <li> <code>{x}</code>: The tile X coordinate in the tiling scheme, where 0 is the Westernmost tile.</li>
		 *  <li> <code>{y}</code>: The tile Y coordinate in the tiling scheme, where 0 is the Northernmost tile.</li>
		 *  <li> <code>{s}</code>: One of the available subdomains, used to overcome browser limits on the number of simultaneous requests per host.</li>
		 *  <li> <code>{reverseX}</code>: The tile X coordinate in the tiling scheme, where 0 is the Easternmost tile.</li>
		 *  <li> <code>{reverseY}</code>: The tile Y coordinate in the tiling scheme, where 0 is the Southernmost tile.</li>
		 *  <li> <code>{reverseZ}</code>: The level of the tile in the tiling scheme, where level zero is the maximum level of the quadtree pyramid.  In order to use reverseZ, maximumLevel must be defined.</li>
		 *  <li> <code>{westDegrees}</code>: The Western edge of the tile in geodetic degrees.</li>
		 *  <li> <code>{southDegrees}</code>: The Southern edge of the tile in geodetic degrees.</li>
		 *  <li> <code>{eastDegrees}</code>: The Eastern edge of the tile in geodetic degrees.</li>
		 *  <li> <code>{northDegrees}</code>: The Northern edge of the tile in geodetic degrees.</li>
		 *  <li> <code>{westProjected}</code>: The Western edge of the tile in projected coordinates of the tiling scheme.</li>
		 *  <li> <code>{southProjected}</code>: The Southern edge of the tile in projected coordinates of the tiling scheme.</li>
		 *  <li> <code>{eastProjected}</code>: The Eastern edge of the tile in projected coordinates of the tiling scheme.</li>
		 *  <li> <code>{northProjected}</code>: The Northern edge of the tile in projected coordinates of the tiling scheme.</li>
		 *  <li> <code>{width}</code>: The width of each tile in pixels.</li>
		 *  <li> <code>{height}</code>: The height of each tile in pixels.</li>
		 * </ul>
		 * @memberof UrlTemplateImageryProvider.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly url: string;

		/**
		 * Gets the URL scheme zero padding for each tile coordinate. The format is '000' where each coordinate will be padded on
		 * the left with zeros to match the width of the passed string of zeros. e.g. Setting:
		 * urlSchemeZeroPadding : { '{x}' : '0000'}
		 * will cause an 'x' value of 12 to return the string '0012' for {x} in the generated URL.
		 * It has the following keywords:
		 * <ul>
		 *  <li> <code>{z}</code>: The zero padding for the level of the tile in the tiling scheme.</li>
		 *  <li> <code>{x}</code>: The zero padding for the tile X coordinate in the tiling scheme.</li>
		 *  <li> <code>{y}</code>: The zero padding for the the tile Y coordinate in the tiling scheme.</li>
		 *  <li> <code>{reverseX}</code>: The zero padding for the tile reverseX coordinate in the tiling scheme.</li>
		 *  <li> <code>{reverseY}</code>: The zero padding for the tile reverseY coordinate in the tiling scheme.</li>
		 *  <li> <code>{reverseZ}</code>: The zero padding for the reverseZ coordinate of the tile in the tiling scheme.</li>
		 * </ul>
		 * @memberof UrlTemplateImageryProvider.prototype
		 * @type {Object}
		 * @readonly
		 */
		readonly urlSchemeZeroPadding: any;

		/**
		 * Gets the URL template to use to use to pick features.  If this property is not specified,
		 * {@link UrlTemplateImageryProvider#pickFeatures} will immediately returned undefined, indicating no
		 * features picked.  The URL template supports all of the keywords supported by the
		 * {@link UrlTemplateImageryProvider#url} property, plus the following:
		 * <ul>
		 *     <li><code>{i}</code>: The pixel column (horizontal coordinate) of the picked position, where the Westernmost pixel is 0.</li>
		 *     <li><code>{j}</code>: The pixel row (vertical coordinate) of the picked position, where the Northernmost pixel is 0.</li>
		 *     <li><code>{reverseI}</code>: The pixel column (horizontal coordinate) of the picked position, where the Easternmost pixel is 0.</li>
		 *     <li><code>{reverseJ}</code>: The pixel row (vertical coordinate) of the picked position, where the Southernmost pixel is 0.</li>
		 *     <li><code>{longitudeDegrees}</code>: The longitude of the picked position in degrees.</li>
		 *     <li><code>{latitudeDegrees}</code>: The latitude of the picked position in degrees.</li>
		 *     <li><code>{longitudeProjected}</code>: The longitude of the picked position in the projected coordinates of the tiling scheme.</li>
		 *     <li><code>{latitudeProjected}</code>: The latitude of the picked position in the projected coordinates of the tiling scheme.</li>
		 *     <li><code>{format}</code>: The format in which to get feature information, as specified in the {@link GetFeatureInfoFormat}.</li>
		 * </ul>
		 * @memberof UrlTemplateImageryProvider.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly pickFeaturesUrl: string;

		/**
		 * Gets the proxy used by this provider.
		 * @memberof UrlTemplateImageryProvider.prototype
		 * @type {Proxy}
		 * @readonly
		 * @default undefined
		 */
		readonly proxy: Proxy;

		/**
		 * Gets the width of each tile, in pixels. This function should
		 * not be called before {@link UrlTemplateImageryProvider#ready} returns true.
		 * @memberof UrlTemplateImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 * @default 256
		 */
		readonly tileWidth: number;

		/**
		 * Gets the height of each tile, in pixels.  This function should
		 * not be called before {@link UrlTemplateImageryProvider#ready} returns true.
		 * @memberof UrlTemplateImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 * @default 256
		 */
		readonly tileHeight: number;

		/**
		 * Gets the maximum level-of-detail that can be requested, or undefined if there is no limit.
		 * This function should not be called before {@link UrlTemplateImageryProvider#ready} returns true.
		 * @memberof UrlTemplateImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 * @default undefined
		 */
		readonly maximumLevel: number;

		/**
		 * Gets the minimum level-of-detail that can be requested.  This function should
		 * not be called before {@link UrlTemplateImageryProvider#ready} returns true.
		 * @memberof UrlTemplateImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 * @default 0
		 */
		readonly minimumLevel: number;

		/**
		 * Gets the tiling scheme used by this provider.  This function should
		 * not be called before {@link UrlTemplateImageryProvider#ready} returns true.
		 * @memberof UrlTemplateImageryProvider.prototype
		 * @type {TilingScheme}
		 * @readonly
		 * @default new WebMercatorTilingScheme()
		 */
		readonly tilingScheme: TilingScheme;

		/**
		 * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should
		 * not be called before {@link UrlTemplateImageryProvider#ready} returns true.
		 * @memberof UrlTemplateImageryProvider.prototype
		 * @type {Rectangle}
		 * @readonly
		 * @default tilingScheme.rectangle
		 */
		readonly rectangle: Rectangle;

		/**
		 * Gets the tile discard policy.  If not undefined, the discard policy is responsible
		 * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
		 * returns undefined, no tiles are filtered.  This function should
		 * not be called before {@link UrlTemplateImageryProvider#ready} returns true.
		 * @memberof UrlTemplateImageryProvider.prototype
		 * @type {TileDiscardPolicy}
		 * @readonly
		 * @default undefined
		 */
		readonly tileDiscardPolicy: TileDiscardPolicy;

		/**
		 * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
		 * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
		 * are passed an instance of {@link TileProviderError}.
		 * @memberof UrlTemplateImageryProvider.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly errorEvent: Event;

		/**
		 * Gets a value indicating whether or not the provider is ready for use.
		 * @memberof UrlTemplateImageryProvider.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly ready: boolean;

		/**
		 * Gets a promise that resolves to true when the provider is ready for use.
		 * @memberof UrlTemplateImageryProvider.prototype
		 * @type {Promise.<Boolean>}
		 * @readonly
		 */
		readonly readyPromise: any;

		/**
		 * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
		 * the source of the imagery.  This function should not be called before {@link UrlTemplateImageryProvider#ready} returns true.
		 * @memberof UrlTemplateImageryProvider.prototype
		 * @type {Credit}
		 * @readonly
		 * @default undefined
		 */
		readonly credit: Credit;

		/**
		 * Gets a value indicating whether or not the images provided by this imagery provider
		 * include an alpha channel.  If this property is false, an alpha channel, if present, will
		 * be ignored.  If this property is true, any images without an alpha channel will be treated
		 * as if their alpha is 1.0 everywhere.  When this property is false, memory usage
		 * and texture upload time are reduced.  This function should
		 * not be called before {@link ImageryProvider#ready} returns true.
		 * @memberof UrlTemplateImageryProvider.prototype
		 * @type {Boolean}
		 * @readonly
		 * @default true
		 */
		readonly hasAlphaChannel: boolean;

		/**
		 * Reinitializes this instance.  Reinitializing an instance already in use is supported, but it is not
		 * recommended because existing tiles provided by the imagery provider will not be updated.
		 * @param {Promise.<Object>|Object} options Any of the options that may be passed to the {@link UrlTemplateImageryProvider} constructor.
		 */
		reinitialize(options: any | any): void;

		/**
		 * Gets the credits to be displayed when a given tile is displayed.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level;
		 * @returns {Credit[]} The credits to be displayed when the tile is displayed.
		 * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.
		 */
		getTileCredits(x: number, y: number, level: number): (Credit)[];

		/**
		 * Requests the image for a given tile.  This function should
		 * not be called before {@link UrlTemplateImageryProvider#ready} returns true.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level.
		 * @param {Request} [request] The request object. Intended for internal use only.
		 * @returns {Promise.<Image|Canvas>|undefined} A promise for the image that will resolve when the image is available, or
		 *          undefined if there are too many active requests to the server, and the request
		 *          should be retried later.  The resolved image may be either an
		 *          Image or a Canvas DOM object.
		 */
		requestImage(x: number, y: number, level: number, request?: Request): any | any | undefined;

		/**
		 * Asynchronously determines what features, if any, are located at a given longitude and latitude within
		 * a tile.  This function should not be called before {@link ImageryProvider#ready} returns true.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level.
		 * @param {Number} longitude The longitude at which to pick features.
		 * @param {Number} latitude  The latitude at which to pick features.
		 * @return {Promise.<ImageryLayerFeatureInfo[]>|undefined} A promise for the picked features that will resolve when the asynchronous
		 *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}
		 *                   instances.  The array may be empty if no features are found at the given location.
		 *                   It may also be undefined if picking is not supported.
		 */
		pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): any | undefined;

	}

	/**
	 * A viewport aligned quad.
	 * @alias ViewportQuad
	 * @constructor
	 * @param {BoundingRectangle} [rectangle] The {@link BoundingRectangle} defining the quad's position within the viewport.
	 * @param {Material} [material] The {@link Material} defining the surface appearance of the viewport quad.
	 * @example
	 * var viewportQuad = new Cesium.ViewportQuad(new Cesium.BoundingRectangle(0, 0, 80, 40));
	 * viewportQuad.material.uniforms.color = new Cesium.Color(1.0, 0.0, 0.0, 1.0);
	 */
	class ViewportQuad {
		constructor(rectangle?: BoundingRectangle, material?: Material);

		/**
		 * Determines if the viewport quad primitive will be shown.
		 * @type {Boolean}
		 * @default true
		 */
		show: boolean;

		/**
		 * The BoundingRectangle defining the quad's position within the viewport.
		 * @type {BoundingRectangle}
		 * @example
		 * viewportQuad.rectangle = new Cesium.BoundingRectangle(0, 0, 80, 40);
		 */
		rectangle: BoundingRectangle;

		/**
		 * The surface appearance of the viewport quad.  This can be one of several built-in {@link Material} objects or a custom material, scripted with
		 * {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric|Fabric}.
		 * <p>
		 * The default material is <code>Material.ColorType</code>.
		 * </p>
		 * @type Material
		 * @example
		 * // 1. Change the color of the default material to yellow
		 * viewportQuad.material.uniforms.color = new Cesium.Color(1.0, 1.0, 0.0, 1.0);
		 * // 2. Change material to horizontal stripes
		 * viewportQuad.material = Cesium.Material.fromType(Cesium.Material.StripeType);
		 * @see {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/Fabric|Fabric}
		 */
		material: Material;

		/**
		 * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
		 * get the draw commands needed to render this primitive.
		 * <p>
		 * Do not call this function directly.  This is documented just to
		 * list the exceptions that may be propagated when the scene is rendered:
		 * </p>
		 * @exception {DeveloperError} this.material must be defined.
		 * @exception {DeveloperError} this.rectangle must be defined.
		 */
		update(): void;

		/**
		 * Returns true if this object was destroyed; otherwise, false.
		 * <br /><br />
		 * If this object was destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
		 * @returns {Boolean} True if this object was destroyed; otherwise, false.
		 * @see ViewportQuad#destroy
		 */
		isDestroyed(): boolean;

		/**
		 * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
		 * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
		 * <br /><br />
		 * Once an object is destroyed, it should not be used; calling any function other than
		 * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
		 * assign the return value (<code>undefined</code>) to the object as done in the example.
		 * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.
		 * @example
		 * quad = quad && quad.destroy();
		 * @see ViewportQuad#isDestroyed
		 */
		destroy(): void;

	}

	/**
	 * Provides tiled imagery hosted by a Web Map Service (WMS) server.
	 * @alias WebMapServiceImageryProvider
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Resource|String} options.url The URL of the WMS service. The URL supports the same keywords as the {@link UrlTemplateImageryProvider}.
	 * @param {String} options.layers The layers to include, separated by commas.
	 * @param {Object} [options.parameters=WebMapServiceImageryProvider.DefaultParameters] Additional parameters to pass to the WMS server in the GetMap URL.
	 * @param {Object} [options.getFeatureInfoParameters=WebMapServiceImageryProvider.GetFeatureInfoDefaultParameters] Additional parameters to pass to the WMS server in the GetFeatureInfo URL.
	 * @param {Boolean} [options.enablePickFeatures=true] If true, {@link WebMapServiceImageryProvider#pickFeatures} will invoke
	 *        the GetFeatureInfo operation on the WMS server and return the features included in the response.  If false,
	 *        {@link WebMapServiceImageryProvider#pickFeatures} will immediately return undefined (indicating no pickable features)
	 *        without communicating with the server.  Set this property to false if you know your WMS server does not support
	 *        GetFeatureInfo or if you don't want this provider's features to be pickable. Note that this can be dynamically
	 *        overridden by modifying the WebMapServiceImageryProvider#enablePickFeatures property.
	 * @param {GetFeatureInfoFormat[]} [options.getFeatureInfoFormats=WebMapServiceImageryProvider.DefaultGetFeatureInfoFormats] The formats
	 *        in which to try WMS GetFeatureInfo requests.
	 * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle of the layer.
	 * @param {TilingScheme} [options.tilingScheme=new GeographicTilingScheme()] The tiling scheme to use to divide the world into tiles.
	 * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If the tilingScheme is specified,
	 *        this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither
	 *        parameter is specified, the WGS84 ellipsoid is used.
	 * @param {Number} [options.tileWidth=256] The width of each tile in pixels.
	 * @param {Number} [options.tileHeight=256] The height of each tile in pixels.
	 * @param {Number} [options.minimumLevel=0] The minimum level-of-detail supported by the imagery provider.  Take care when
	 *        specifying this that the number of tiles at the minimum level is small, such as four or less.  A larger number is
	 *        likely to result in rendering problems.
	 * @param {Number} [options.maximumLevel] The maximum level-of-detail supported by the imagery provider, or undefined if there is no limit.
	 *        If not specified, there is no limit.
	 * @param {String} [options.crs] CRS specification, for use with WMS specification >= 1.3.0.
	 * @param {String} [options.srs] SRS specification, for use with WMS specification 1.1.0 or 1.1.1
	 * @param {Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.
	 * @param {String|String[]} [options.subdomains='abc'] The subdomains to use for the <code>{s}</code> placeholder in the URL template.
	 *                          If this parameter is a single string, each character in the string is a subdomain.  If it is
	 *                          an array, each element in the array is a subdomain.
	 * @see ArcGisMapServerImageryProvider
	 * @see BingMapsImageryProvider
	 * @see GoogleEarthEnterpriseMapsProvider
	 * @see createOpenStreetMapImageryProvider
	 * @see SingleTileImageryProvider
	 * @see createTileMapServiceImageryProvider
	 * @see WebMapTileServiceImageryProvider
	 * @see UrlTemplateImageryProvider
	 * @see {@link http://resources.esri.com/help/9.3/arcgisserver/apis/rest/|ArcGIS Server REST API}
	 * @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
	 * @example
	 * var provider = new Cesium.WebMapServiceImageryProvider({
	 *     url : 'https://sampleserver1.arcgisonline.com/ArcGIS/services/Specialty/ESRI_StatesCitiesRivers_USA/MapServer/WMSServer',
	 *     layers : '0',
	 *     proxy: new Cesium.DefaultProxy('/proxy/')
	 * });
	 * viewer.imageryLayers.addImageryProvider(provider);
	 */
	class WebMapServiceImageryProvider {
		constructor(options: {
			url: Resource | string;
			layers: string;
			parameters?: any;
			getFeatureInfoParameters?: any;
			enablePickFeatures?: boolean;
			getFeatureInfoFormats?: (GetFeatureInfoFormat)[];
			rectangle?: Rectangle;
			tilingScheme?: TilingScheme;
			ellipsoid?: Ellipsoid;
			tileWidth?: number;
			tileHeight?: number;
			minimumLevel?: number;
			maximumLevel?: number;
			crs?: string;
			srs?: string;
			credit?: Credit | string;
			subdomains?: string | string[];
		});

		/**
		 * Gets the URL of the WMS server.
		 * @memberof WebMapServiceImageryProvider.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly url: string;

		/**
		 * Gets the proxy used by this provider.
		 * @memberof WebMapServiceImageryProvider.prototype
		 * @type {Proxy}
		 * @readonly
		 */
		readonly proxy: Proxy;

		/**
		 * Gets the names of the WMS layers, separated by commas.
		 * @memberof WebMapServiceImageryProvider.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly layers: string;

		/**
		 * Gets the width of each tile, in pixels. This function should
		 * not be called before {@link WebMapServiceImageryProvider#ready} returns true.
		 * @memberof WebMapServiceImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly tileWidth: number;

		/**
		 * Gets the height of each tile, in pixels.  This function should
		 * not be called before {@link WebMapServiceImageryProvider#ready} returns true.
		 * @memberof WebMapServiceImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly tileHeight: number;

		/**
		 * Gets the maximum level-of-detail that can be requested.  This function should
		 * not be called before {@link WebMapServiceImageryProvider#ready} returns true.
		 * @memberof WebMapServiceImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly maximumLevel: number;

		/**
		 * Gets the minimum level-of-detail that can be requested.  This function should
		 * not be called before {@link WebMapServiceImageryProvider#ready} returns true.
		 * @memberof WebMapServiceImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly minimumLevel: number;

		/**
		 * Gets the tiling scheme used by this provider.  This function should
		 * not be called before {@link WebMapServiceImageryProvider#ready} returns true.
		 * @memberof WebMapServiceImageryProvider.prototype
		 * @type {TilingScheme}
		 * @readonly
		 */
		readonly tilingScheme: TilingScheme;

		/**
		 * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should
		 * not be called before {@link WebMapServiceImageryProvider#ready} returns true.
		 * @memberof WebMapServiceImageryProvider.prototype
		 * @type {Rectangle}
		 * @readonly
		 */
		readonly rectangle: Rectangle;

		/**
		 * Gets the tile discard policy.  If not undefined, the discard policy is responsible
		 * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
		 * returns undefined, no tiles are filtered.  This function should
		 * not be called before {@link WebMapServiceImageryProvider#ready} returns true.
		 * @memberof WebMapServiceImageryProvider.prototype
		 * @type {TileDiscardPolicy}
		 * @readonly
		 */
		readonly tileDiscardPolicy: TileDiscardPolicy;

		/**
		 * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
		 * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
		 * are passed an instance of {@link TileProviderError}.
		 * @memberof WebMapServiceImageryProvider.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly errorEvent: Event;

		/**
		 * Gets a value indicating whether or not the provider is ready for use.
		 * @memberof WebMapServiceImageryProvider.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly ready: boolean;

		/**
		 * Gets a promise that resolves to true when the provider is ready for use.
		 * @memberof WebMapServiceImageryProvider.prototype
		 * @type {Promise.<Boolean>}
		 * @readonly
		 */
		readonly readyPromise: any;

		/**
		 * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
		 * the source of the imagery.  This function should not be called before {@link WebMapServiceImageryProvider#ready} returns true.
		 * @memberof WebMapServiceImageryProvider.prototype
		 * @type {Credit}
		 * @readonly
		 */
		readonly credit: Credit;

		/**
		 * Gets a value indicating whether or not the images provided by this imagery provider
		 * include an alpha channel.  If this property is false, an alpha channel, if present, will
		 * be ignored.  If this property is true, any images without an alpha channel will be treated
		 * as if their alpha is 1.0 everywhere.  When this property is false, memory usage
		 * and texture upload time are reduced.
		 * @memberof WebMapServiceImageryProvider.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly hasAlphaChannel: boolean;

		/**
		 * Gets or sets a value indicating whether feature picking is enabled.  If true, {@link WebMapServiceImageryProvider#pickFeatures} will
		 * invoke the <code>GetFeatureInfo</code> service on the WMS server and attempt to interpret the features included in the response.  If false,
		 * {@link WebMapServiceImageryProvider#pickFeatures} will immediately return undefined (indicating no pickable
		 * features) without communicating with the server.  Set this property to false if you know your data
		 * source does not support picking features or if you don't want this provider's features to be pickable.
		 * @memberof WebMapServiceImageryProvider.prototype
		 * @type {Boolean}
		 * @default true
		 */
		enablePickFeatures: boolean;

		/**
		 * Gets the credits to be displayed when a given tile is displayed.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level;
		 * @returns {Credit[]} The credits to be displayed when the tile is displayed.
		 * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.
		 */
		getTileCredits(x: number, y: number, level: number): (Credit)[];

		/**
		 * Requests the image for a given tile.  This function should
		 * not be called before {@link WebMapServiceImageryProvider#ready} returns true.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level.
		 * @param {Request} [request] The request object. Intended for internal use only.
		 * @returns {Promise.<Image|Canvas>|undefined} A promise for the image that will resolve when the image is available, or
		 *          undefined if there are too many active requests to the server, and the request
		 *          should be retried later.  The resolved image may be either an
		 *          Image or a Canvas DOM object.
		 * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.
		 */
		requestImage(x: number, y: number, level: number, request?: Request): any | any | undefined;

		/**
		 * Asynchronously determines what features, if any, are located at a given longitude and latitude within
		 * a tile.  This function should not be called before {@link ImageryProvider#ready} returns true.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level.
		 * @param {Number} longitude The longitude at which to pick features.
		 * @param {Number} latitude  The latitude at which to pick features.
		 * @return {Promise.<ImageryLayerFeatureInfo[]>|undefined} A promise for the picked features that will resolve when the asynchronous
		 *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}
		 *                   instances.  The array may be empty if no features are found at the given location.
		 * @exception {DeveloperError} <code>pickFeatures</code> must not be called before the imagery provider is ready.
		 */
		pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): any | undefined;

		/**
		 * The default parameters to include in the WMS URL to obtain images.  The values are as follows:
		 *    service=WMS
		 *    version=1.1.1
		 *    request=GetMap
		 *    styles=
		 *    format=image/jpeg
		 * @constant
		 * @type {Object}
		 */
		static DefaultParameters: any;

		/**
		 * The default parameters to include in the WMS URL to get feature information.  The values are as follows:
		 *     service=WMS
		 *     version=1.1.1
		 *     request=GetFeatureInfo
		 * @constant
		 * @type {Object}
		 */
		static GetFeatureInfoDefaultParameters: any;

	}

	/**
	 * Provides tiled imagery served by {@link http://www.opengeospatial.org/standards/wmts|WMTS 1.0.0} compliant servers.
	 * This provider supports HTTP KVP-encoded and RESTful GetTile requests, but does not yet support the SOAP encoding.
	 * @alias WebMapTileServiceImageryProvider
	 * @constructor
	 * @param {Object} options Object with the following properties:
	 * @param {Resource|String} options.url The base URL for the WMTS GetTile operation (for KVP-encoded requests) or the tile-URL template (for RESTful requests). The tile-URL template should contain the following variables: &#123;style&#125;, &#123;TileMatrixSet&#125;, &#123;TileMatrix&#125;, &#123;TileRow&#125;, &#123;TileCol&#125;. The first two are optional if actual values are hardcoded or not required by the server. The &#123;s&#125; keyword may be used to specify subdomains.
	 * @param {String} [options.format='image/jpeg'] The MIME type for images to retrieve from the server.
	 * @param {String} options.layer The layer name for WMTS requests.
	 * @param {String} options.style The style name for WMTS requests.
	 * @param {String} options.tileMatrixSetID The identifier of the TileMatrixSet to use for WMTS requests.
	 * @param {Array} [options.tileMatrixLabels] A list of identifiers in the TileMatrix to use for WMTS requests, one per TileMatrix level.
	 * @param {Clock} [options.clock] A Clock instance that is used when determining the value for the time dimension. Required when options.times is specified.
	 * @param {TimeIntervalCollection} [options.times] TimeIntervalCollection with its <code>data</code> property being an object containing time dynamic dimension and their values.
	 * @param {Object} [options.dimensions] A object containing static dimensions and their values.
	 * @param {Number} [options.tileWidth=256] The tile width in pixels.
	 * @param {Number} [options.tileHeight=256] The tile height in pixels.
	 * @param {TilingScheme} [options.tilingScheme] The tiling scheme corresponding to the organization of the tiles in the TileMatrixSet.
	 * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle covered by the layer.
	 * @param {Number} [options.minimumLevel=0] The minimum level-of-detail supported by the imagery provider.
	 * @param {Number} [options.maximumLevel] The maximum level-of-detail supported by the imagery provider, or undefined if there is no limit.
	 * @param {Ellipsoid} [options.ellipsoid] The ellipsoid.  If not specified, the WGS84 ellipsoid is used.
	 * @param {Credit|String} [options.credit] A credit for the data source, which is displayed on the canvas.
	 * @param {String|String[]} [options.subdomains='abc'] The subdomains to use for the <code>{s}</code> placeholder in the URL template.
	 *                          If this parameter is a single string, each character in the string is a subdomain.  If it is
	 *                          an array, each element in the array is a subdomain.
	 * @demo {@link https://cesiumjs.org/Cesium/Apps/Sandcastle/index.html?src=Web%20Map%20Tile%20Service%20with%20Time.html|Cesium Sandcastle Web Map Tile Service with Time Demo}
	 * @example
	 * // Example 1. USGS shaded relief tiles (KVP)
	 * var shadedRelief1 = new Cesium.WebMapTileServiceImageryProvider({
	 *     url : 'http://basemap.nationalmap.gov/arcgis/rest/services/USGSShadedReliefOnly/MapServer/WMTS',
	 *     layer : 'USGSShadedReliefOnly',
	 *     style : 'default',
	 *     format : 'image/jpeg',
	 *     tileMatrixSetID : 'default028mm',
	 *     // tileMatrixLabels : ['default028mm:0', 'default028mm:1', 'default028mm:2' ...],
	 *     maximumLevel: 19,
	 *     credit : new Cesium.Credit('U. S. Geological Survey')
	 * });
	 * viewer.imageryLayers.addImageryProvider(shadedRelief1);
	 * @example
	 * // Example 2. USGS shaded relief tiles (RESTful)
	 * var shadedRelief2 = new Cesium.WebMapTileServiceImageryProvider({
	 *     url : 'http://basemap.nationalmap.gov/arcgis/rest/services/USGSShadedReliefOnly/MapServer/WMTS/tile/1.0.0/USGSShadedReliefOnly/{Style}/{TileMatrixSet}/{TileMatrix}/{TileRow}/{TileCol}.jpg',
	 *     layer : 'USGSShadedReliefOnly',
	 *     style : 'default',
	 *     format : 'image/jpeg',
	 *     tileMatrixSetID : 'default028mm',
	 *     maximumLevel: 19,
	 *     credit : new Cesium.Credit('U. S. Geological Survey')
	 * });
	 * viewer.imageryLayers.addImageryProvider(shadedRelief2);
	 * @example
	 * // Example 3. NASA time dynamic weather data (RESTful)
	 * var times = Cesium.TimeIntervalCollection.fromIso8601({
	 *     iso8601: '2015-07-30/2017-06-16/P1D',
	 *     dataFunction: function dataFunction(interval, index) {
	 *         return {
	 *             Time: Cesium.JulianDate.toIso8601(interval.start)
	 *         };
	 *     }
	 * });
	 * var weather = new Cesium.WebMapTileServiceImageryProvider({
	 *     url : 'https://gibs.earthdata.nasa.gov/wmts/epsg4326/best/AMSR2_Snow_Water_Equivalent/default/{Time}/{TileMatrixSet}/{TileMatrix}/{TileRow}/{TileCol}.png',
	 *     layer : 'AMSR2_Snow_Water_Equivalent',
	 *     style : 'default',
	 *     tileMatrixSetID : '2km',
	 *     maximumLevel : 5,
	 *     format : 'image/png',
	 *     clock: clock,
	 *     times: times,
	 *     credit : new Cesium.Credit('NASA Global Imagery Browse Services for EOSDIS')
	 * });
	 * viewer.imageryLayers.addImageryProvider(weather);
	 * @see ArcGisMapServerImageryProvider
	 * @see BingMapsImageryProvider
	 * @see GoogleEarthEnterpriseMapsProvider
	 * @see createOpenStreetMapImageryProvider
	 * @see SingleTileImageryProvider
	 * @see createTileMapServiceImageryProvider
	 * @see WebMapServiceImageryProvider
	 * @see UrlTemplateImageryProvider
	 */
	class WebMapTileServiceImageryProvider {
		constructor(options: {
			url: Resource | string;
			format?: string;
			layer: string;
			style: string;
			tileMatrixSetID: string;
			tileMatrixLabels?: any[];
			clock?: Clock;
			times?: TimeIntervalCollection;
			dimensions?: any;
			tileWidth?: number;
			tileHeight?: number;
			tilingScheme?: TilingScheme;
			rectangle?: Rectangle;
			minimumLevel?: number;
			maximumLevel?: number;
			ellipsoid?: Ellipsoid;
			credit?: Credit | string;
			subdomains?: string | string[];
		});

		/**
		 * Gets the URL of the service hosting the imagery.
		 * @memberof WebMapTileServiceImageryProvider.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly url: string;

		/**
		 * Gets the proxy used by this provider.
		 * @memberof WebMapTileServiceImageryProvider.prototype
		 * @type {Proxy}
		 * @readonly
		 */
		readonly proxy: Proxy;

		/**
		 * Gets the width of each tile, in pixels. This function should
		 * not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.
		 * @memberof WebMapTileServiceImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly tileWidth: number;

		/**
		 * Gets the height of each tile, in pixels.  This function should
		 * not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.
		 * @memberof WebMapTileServiceImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly tileHeight: number;

		/**
		 * Gets the maximum level-of-detail that can be requested.  This function should
		 * not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.
		 * @memberof WebMapTileServiceImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly maximumLevel: number;

		/**
		 * Gets the minimum level-of-detail that can be requested.  This function should
		 * not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.
		 * @memberof WebMapTileServiceImageryProvider.prototype
		 * @type {Number}
		 * @readonly
		 */
		readonly minimumLevel: number;

		/**
		 * Gets the tiling scheme used by this provider.  This function should
		 * not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.
		 * @memberof WebMapTileServiceImageryProvider.prototype
		 * @type {TilingScheme}
		 * @readonly
		 */
		readonly tilingScheme: TilingScheme;

		/**
		 * Gets the rectangle, in radians, of the imagery provided by this instance.  This function should
		 * not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.
		 * @memberof WebMapTileServiceImageryProvider.prototype
		 * @type {Rectangle}
		 * @readonly
		 */
		readonly rectangle: Rectangle;

		/**
		 * Gets the tile discard policy.  If not undefined, the discard policy is responsible
		 * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
		 * returns undefined, no tiles are filtered.  This function should
		 * not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.
		 * @memberof WebMapTileServiceImageryProvider.prototype
		 * @type {TileDiscardPolicy}
		 * @readonly
		 */
		readonly tileDiscardPolicy: TileDiscardPolicy;

		/**
		 * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
		 * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
		 * are passed an instance of {@link TileProviderError}.
		 * @memberof WebMapTileServiceImageryProvider.prototype
		 * @type {Event}
		 * @readonly
		 */
		readonly errorEvent: Event;

		/**
		 * Gets the mime type of images returned by this imagery provider.
		 * @memberof WebMapTileServiceImageryProvider.prototype
		 * @type {String}
		 * @readonly
		 */
		readonly format: string;

		/**
		 * Gets a value indicating whether or not the provider is ready for use.
		 * @memberof WebMapTileServiceImageryProvider.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly ready: boolean;

		/**
		 * Gets a promise that resolves to true when the provider is ready for use.
		 * @memberof WebMapTileServiceImageryProvider.prototype
		 * @type {Promise.<Boolean>}
		 * @readonly
		 */
		readonly readyPromise: any;

		/**
		 * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
		 * the source of the imagery.  This function should not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.
		 * @memberof WebMapTileServiceImageryProvider.prototype
		 * @type {Credit}
		 * @readonly
		 */
		readonly credit: Credit;

		/**
		 * Gets a value indicating whether or not the images provided by this imagery provider
		 * include an alpha channel.  If this property is false, an alpha channel, if present, will
		 * be ignored.  If this property is true, any images without an alpha channel will be treated
		 * as if their alpha is 1.0 everywhere.  When this property is false, memory usage
		 * and texture upload time are reduced.
		 * @memberof WebMapTileServiceImageryProvider.prototype
		 * @type {Boolean}
		 * @readonly
		 */
		readonly hasAlphaChannel: boolean;

		/**
		 * Gets or sets a clock that is used to get keep the time used for time dynamic parameters.
		 * @memberof WebMapTileServiceImageryProvider.prototype
		 * @type {Clock}
		 */
		clock: Clock;

		/**
		 * Gets or sets a time interval collection that is used to get time dynamic parameters. The data of each
		 * TimeInterval is an object containing the keys and values of the properties that are used during
		 * tile requests.
		 * @memberof WebMapTileServiceImageryProvider.prototype
		 * @type {TimeIntervalCollection}
		 */
		times: TimeIntervalCollection;

		/**
		 * Gets or sets an object that contains static dimensions and their values.
		 * @memberof WebMapTileServiceImageryProvider.prototype
		 * @type {Object}
		 */
		dimensions: any;

		/**
		 * Gets the credits to be displayed when a given tile is displayed.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level;
		 * @returns {Credit[]} The credits to be displayed when the tile is displayed.
		 * @exception {DeveloperError} <code>getTileCredits</code> must not be called before the imagery provider is ready.
		 */
		getTileCredits(x: number, y: number, level: number): (Credit)[];

		/**
		 * Requests the image for a given tile.  This function should
		 * not be called before {@link WebMapTileServiceImageryProvider#ready} returns true.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level.
		 * @param {Request} [request] The request object. Intended for internal use only.
		 * @returns {Promise.<Image|Canvas>|undefined} A promise for the image that will resolve when the image is available, or
		 *          undefined if there are too many active requests to the server, and the request
		 *          should be retried later.  The resolved image may be either an
		 *          Image or a Canvas DOM object.
		 * @exception {DeveloperError} <code>requestImage</code> must not be called before the imagery provider is ready.
		 */
		requestImage(x: number, y: number, level: number, request?: Request): any | any | undefined;

		/**
		 * Picking features is not currently supported by this imagery provider, so this function simply returns
		 * undefined.
		 * @param {Number} x The tile X coordinate.
		 * @param {Number} y The tile Y coordinate.
		 * @param {Number} level The tile level.
		 * @param {Number} longitude The longitude at which to pick features.
		 * @param {Number} latitude  The latitude at which to pick features.
		 * @return {Promise.<ImageryLayerFeatureInfo[]>|undefined} A promise for the picked features that will resolve when the asynchronous
		 *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}
		 *                   instances.  The array may be empty if no features are found at the given location.
		 *                   It may also be undefined if picking is not supported.
		 */
		pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): any | undefined;

	}

	/**
	 * Converts a module name + .extension into an URL path.
	 * *Requires* the use of a module name. It does not support using
	 * plain URLs like nameToUrl.
	 */
	function toUrl(): void;

	/**
	 * Creates an adapter function to allow a calculation function to operate as a Web Worker,
	 * paired with TaskProcessor, to receive tasks and return results.
	 * @exports createTaskProcessorWorker
	 * @param {createTaskProcessorWorker~WorkerFunction} workerFunction The calculation function,
	 *        which takes parameters and returns a result.
	 * @returns {createTaskProcessorWorker~TaskProcessorWorkerFunction} A function that adapts the
	 *          calculation function to work as a Web Worker onmessage listener with TaskProcessor.
	 * @example
	 * function doCalculation(parameters, transferableObjects) {
	 *   // calculate some result using the inputs in parameters
	 *   return result;
	 * }
	 * return Cesium.createTaskProcessorWorker(doCalculation);
	 * // the resulting function is compatible with TaskProcessor
	 * @see TaskProcessor
	 * @see {@link http://www.w3.org/TR/workers/|Web Workers}
	 * @see {@link http://www.w3.org/TR/html5/common-dom-interfaces.html#transferable-objects|Transferable objects}
	 */
	namespace createTaskProcessorWorker {
	}

	class Entity {
		availability?: TimeIntervalCollection;
		id: string;
		definitionChanged: Event;
		name?: string;
		show: boolean;
		isShowing: boolean;
		parent?: Entity;
		propertyNames: string[];
		billboard?: BillboardGraphics;
		box?: BoxGraphics;
		corridor?: CorridorGraphics;
		cylinder?: CylinderGraphics;
		description?: Property;
		ellipse?: EllipseGraphics;
		ellipsoid?: EllipsoidGraphics;
		entityCollection?: EntityCollection;
		label?: LabelGraphics;
		model?: ModelGraphics;
		orientation?: Property;
		path?: PathGraphics;
		point?: PointGraphics;
		polygon?: PolygonGraphics;
		polyline?: PolylineGraphics;
		polylineVolume?: PolylineVolumeGraphics;
		position?: PositionProperty;
		properties?: PropertyBag;
		rectangle?: RectangleGraphics;
		viewFrom?: Property;
		wall?: WallGraphics;
		constructor(options?: Entity.ConstructorOptions);
		isAvailable(time: JulianDate): boolean;
		addProperty(propertyName: string): void;
		removeProperty(propertyName: string): void;
		merge(source: Entity): void;
	}
	namespace Entity {
		type ConstructorOptions = {
			id?: string;
			name?: string;
			show?: boolean;
			description?: Property | string;
			position?: Property | Cartesian3;
			orientation?: Property | any;
			viewFrom?: Property | any;
			parent?: Entity;
			billboard?: BillboardGraphics;
			box?: BoxGraphics;
			corridor?: CorridorGraphics;
			cylinder?: CylinderGraphics;
			ellipse?: EllipseGraphics;
			ellipsoid?: EllipsoidGraphics;
			label?: LabelGraphics;
			model?: ModelGraphics;
			path?: PathGraphics;
			point?: PointGraphics;
			polygon?: PolygonGraphics;
			polyline?: PolylineGraphics;
			polylineVolume?: PolylineVolumeGraphics;
			properties?: { [key: string]: string | number | boolean | undefined };
			rectangle?: RectangleGraphics;
			wall?: WallGraphics
		}
	}

	function defined(value: any): boolean;

	function buildModuleUrl(url: string): string;

	namespace when {
		function all<T>(promises: Promise<T>[]): Promise<any[]>;
		function resolve<T>(val: T): Promise<T>;
		function defer(): any;
	}

	/**
	* Register an observer for a promise or immediate value.
	*
	* @param {*} promiseOrValue
	* @param {function?} [onFulfilled] callback to be called when promiseOrValue is
	*   successfully fulfilled.  If promiseOrValue is an immediate value, callback
	*   will be invoked immediately.
	* @param {function?} [onRejected] callback to be called when promiseOrValue is
	*   rejected.
	* @param {function?} [onProgress] callback to be called when progress updates
	*   are issued for promiseOrValue.
	* @returns {Promise} a new {@link Promise} that will complete with the return
	*   value of callback or errback or the completion value of promiseOrValue if
	*   callback and/or errback is not supplied.
	*/
	function when(promiseOrValue, onFulfilled?, onRejected?, onProgress?): Promise<any>;

	function createGuid(): string;

	/**
	 * Returns the first parameter if not undefined, otherwise the second parameter. Useful for setting a default value for a parameter.
	 * @param {object} a
	 * @param {object} b
	 */
	function defaultValue(a, b)
	module defaultValue{
		var EMPTY_OBJECT: Object
	}
	module EngineLabel{
		function getScreenSpaceBoundingBox(item:any,coord:any,result:any)
	}
	
	module EngineBillboard{
		function getScreenSpaceBoundingBox(item:any,coord:any,result:any)
		var _computeScreenSpacePosition:any
	}
	module PointPrimitive{
		function getScreenSpaceBoundingBox(item:any,coord:any,result:any)
	}
	


	function appendForwardSlash(url: string)

	/**
	* Asynchronously loads the given URL as JSON.  Returns a promise that will resolve to
	* a JSON object once loaded, or reject if the URL failed to load.  The data is loaded
	* using XMLHttpRequest, which means that in order to make requests to another origin,
	* the server must have Cross-Origin Resource Sharing (CORS) headers enabled. This function
	* adds 'Accept: application/json,&#42;&#47;&#42;;q=0.01' to the request headers, if not
	* already specified.
	*
	* @exports loadJson
	*
	* @param {String} url The URL to request.
	* @param {Object} [headers] HTTP headers to send with the request.
	* 'Accept: application/json,&#42;&#47;&#42;;q=0.01' is added to the request headers automatically
	* if not specified.
	* @param {Request} [request] The request object. Intended for internal use only.
	* @returns {Promise.<Object>|undefined} a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
	*
	*
	* @example
	* Engine.loadJson('http://someUrl.com/someJson.txt').then(function(jsonData) {
	*     // Do something with the JSON object
	* }).otherwise(function(error) {
	*     // an error occurred
	* });
	*
	* @see loadText
	* @see {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing}
	* @see {@link http://wiki.commonjs.org/wiki/Promises/A|CommonJS Promises/A}
	*/
	function loadJson(url, headers?, request?)
	// TODO
	var QuadtreePrimitive: any;
	var GlobeSurfaceTileProvider: any;
	var knockout: any;

	interface Proxy {
		getURL(resource: string): string;
	}

	class BillboardFeature extends EngineBillboard {

	}

	class PointPrimitiveCollectionFix extends PointPrimitiveCollection {

	}
	function destroyObject(obj: any);
	namespace Check {

		/**
		 * Throws if test is not defined
		 *
		 * @param {String} name The name of the variable being tested
		 * @param {*} test The value that is to be checked
		 * @exception {DeveloperError} test must be defined
		 */
		function defined(name: string, test: any);

		class typeOf {
			/**
			 * Throws if test is not typeof 'function'
			 *
			 * @param {String} name The name of the variable being tested
			 * @param {*} test The value to test
			 * @exception {DeveloperError} test must be typeof 'function'
			 */
			static func(name: string, test);
			/**
	 * Throws if test is not typeof 'string'
	 *
	 * @param {String} name The name of the variable being tested
	 * @param {*} test The value to test
	 * @exception {DeveloperError} test must be typeof 'string'
	 */
			static string(name: string, test);
			/**
			 * Throws if test is not typeof 'number'
			 *
			 * @param {String} name The name of the variable being tested
			 * @param {*} test The value to test
			 * @exception {DeveloperError} test must be typeof 'number'
			 */
			static number(name: string, test);
			/**
			 * Throws if test is not typeof 'number' and less than limit
			 *
			 * @param {String} name The name of the variable being tested
			 * @param {*} test The value to test
			 * @param {Number} limit The limit value to compare against
			 * @exception {DeveloperError} test must be typeof 'number' and less than limit
			 */
			static lessThan(name: string, test, limit: number);
			/**
			 * Throws if test is not typeof 'number' and less than or equal to limit
			 *
			 * @param {String} name The name of the variable being tested
			 * @param {*} test The value to test
			 * @param {Number} limit The limit value to compare against
			 * @exception {DeveloperError} test must be typeof 'number' and less than or equal to limit
			 */
			static lessThanOrEquals(name: string, test, limit: number);


			/**
			 * Throws if test is not typeof 'number' and greater than limit
			 *
			 * @param {String} name The name of the variable being tested
			 * @param {*} test The value to test
			 * @param {Number} limit The limit value to compare against
			 * @exception {DeveloperError} test must be typeof 'number' and greater than limit
			 */
			static greaterThan(name: string, test, limit: number);
			/**
			 * Throws if test is not typeof 'number' and greater than or equal to limit
			 *
			 * @param {String} name The name of the variable being tested
			 * @param {*} test The value to test
			 * @param {Number} limit The limit value to compare against
			 * @exception {DeveloperError} test must be typeof 'number' and greater than or equal to limit
			 */
			static greaterThanOrEquals(name: string, test, limit: number);
			/**
			 * Throws if test is not typeof 'object'
			 *
			 * @param {String} name The name of the variable being tested
			 * @param {*} test The value to test
			 * @exception {DeveloperError} test must be typeof 'object'
			 */
			static object(name: string, test);
			/**
			 * Throws if test is not typeof 'boolean'
			 *
			 * @param {String} name The name of the variable being tested
			 * @param {*} test The value to test
			 * @exception {DeveloperError} test must be typeof 'boolean'
			 */
			static bool(name: string, test);


			/**
	 * Throws if test1 and test2 is not typeof 'number' and not equal in value
	 *
	 * @param {String} name1 The name of the first variable being tested
	 * @param {String} name2 The name of the second variable being tested against
	 * @param {*} test1 The value to test
	 * @param {*} test2 The value to test against
	 * @exception {DeveloperError} test1 and test2 should be type of 'number' and be equal in value
	 */
			static equals(name1: string, name2: string, test1: number, test2: number);

		}
	}

	class BillboardCollectionFix2 extends BillboardCollection {

	}



	type lonlatTuple = [number, number, number] | number[]

	enum HeightReference {
		CLAMP_TO_GROUND,
		NONE,
		RELATIVE_TO_GROUND
	}

	class RenderState {
		static fromCache(options: any);
	}


	enum Visibility {
		NONE,
		PARTIAL,
		FULL,
	}

	enum WindingOrder {
		CLOCKWISE,
		COUNTER_CLOCKWISE,
	}

	enum StripeOrientation {
		HORIZONTAL,
		VERTICAL,
	}

	enum BingMapsStyle {
		AERIAL,
		AERIAL_WITH_LABELS,
		ROAD,
		ORDNANCE_SURVEY,
		COLLINS_BART,
	}

	enum BlendEquation {
		ADD,
		SUBTRACT,
		REVERSE_SUBTRACT,
	}

	enum BlendFunction {
		ZERO,
		ONE,
		SOURCE_COLOR,
		ONE_MINUS_SOURCE_COLOR,
		DESTINATION_COLOR,
		ONE_MINUS_DESTINATION_COLOR,
		SOURCE_ALPHA,
		ONE_MINUS_SOURCE_ALPHA,
		DESTINATION_ALPHA,
		ONE_MINUS_DESTINATION_ALPHA,
		CONSTANT_COLOR,
		ONE_MINUS_CONSTANT_COLOR,
		CONSTANT_ALPHA,
		ONE_MINUS_CONSTANT_ALPHA,
		SOURCE_ALPHA_SATURATE,
	}

	enum BlendingState {
		DISABLED,
		ALPHA_BLEND,
		PRE_MULTIPLIED_ALPHA_BLEND,
		ADDITIVE_BLEND,
	}

	enum CameraEventType {
		LEFT_DRAG,
		RIGHT_DRAG,
		MIDDLE_DRAG,
		WHEEL,
		PINCH,
	}

	enum CullFace {
		FRONT,
		BACK,
		FRONT_AND_BACK,
	}

	enum DepthFunction {
		NEVER,
		LESS,
		EQUAL,
		LESS_OR_EQUAL,
		GREATER,
		NOT_EQUAL,
		GREATER_OR_EQUAL,
		ALWAYS,
	}

	enum HorizontalOrigin {
		CENTER,
		LEFT,
		RIGHT,
	}

	enum LabelStyle {
		FILL,
		OUTLINE,
		FILL_AND_OUTLINE,
	}

	enum ModelAnimationLoop {
		NONE,
		REPEAT,
		MIRRORED_REPEAT,
	}

	enum SceneMode {
		MORPHING,
		COLUMBUS_VIEW,
		SCENE2D,
		SCENE3D,
	}

	enum TimeStandard {
		UTC,
		TAI,
	}

	enum ReferenceFrame {
		FIXED,
		INERTIAL,
	}

	enum ScreenSpaceEventType {
		LEFT_DOWN,
		LEFT_UP,
		LEFT_CLICK,
		LEFT_DOUBLE_CLICK,
		RIGHT_DOWN,
		RIGHT_UP,
		RIGHT_CLICK,
		RIGHT_DOUBLE_CLICK,
		MIDDLE_DOWN,
		MIDDLE_UP,
		MIDDLE_CLICK,
		MIDDLE_DOUBLE_CLICK,
		MOUSE_MOVE,
		WHEEL,
		PINCH_START,
		PINCH_END,
		PINCH_MOVE,
	}
	enum PixelFormat {
		DEPTH_COMPONENT,
		DEPTH_STENCIL,
		ALPHA,
		RGB,
		RGBA,
		LUMINANCE,
		LUMINANCE_ALPHA,
	}

	enum PrimitiveType {
		POINTS,
		LINES,
		LINE_LOOP,
		LINE_STRIP,
		TRIANGLES,
		TRIANGLE_STRIP,
		TRIANGLE_FAN,
	}




	enum KeyboardEventModifier {
		SHIFT,
		CTRL,
		ALT,
	}

	enum Intersect {
		OUTSIDE,
		INTERSECTING,
		INSIDE,
	}

	enum StencilOperation {
		ZERO,
		KEEP,
		REPLACE,
		INCREMENT,
		DECREMENT,
		INVERT,
		INCREMENT_WRAP,
		DECREMENT_WRAP,
	}

	enum VerticalOrigin {
		CENTER,
		BOTTOM,
		TOP,
	}

	enum PrimitiveState {
		READY,
		CREATING,
		CREATED,
		COMBINING,
		COMBINED,
		COMPLETE,
		FAILED
	}

	function isArray(value): boolean;

	/**
	 * The state of a BoundingSphere computation being performed by a {@link Visualizer}.
	 */
	enum BoundingSphereState {
		/**
		 * The BoundingSphere has been computed.
		 * @type BoundingSphereState
		 * @constant
		 */
		DONE,
		/**
		 * The BoundingSphere is still being computed.
		 * @type BoundingSphereState
		 * @constant
		 */
		PENDING,
		/**
		 * The BoundingSphere does not exist.
		 * @type BoundingSphereState
		 * @constant
		 */
		FAILED
	}

	class MultiMapProvider {
		constructor({ type: string })
		readonly ready: boolean;
		readonly readyPromise: any;
		readonly rectangle: Rectangle;
		readonly tileWidth: number;
		readonly tileHeight: number;
		readonly maximumLevel: number;
		readonly minimumLevel: number;
		readonly tilingScheme: TilingScheme;
		readonly tileDiscardPolicy: TileDiscardPolicy;
		readonly errorEvent: Event;
		readonly credit: Credit;
		readonly proxy: Proxy;
		readonly hasAlphaChannel: boolean;
		getTileCredits(x: number, y: number, level: number): (Credit)[];
		requestImage(x: number, y: number, level: number, request?: Request): any | any | undefined;
		pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): any | undefined;
		static loadImage(imageryProvider: ImageryProvider, url: Resource | string): any | any | undefined;
	}
	type GeometryTypes =
		BoxGeometry |
		BoxOutlineGeometry |
		CircleGeometry |
		CircleOutlineGeometry |
		CorridorGeometry |
		CorridorOutlineGeometry |
		CylinderGeometry |
		CylinderOutlineGeometry |
		EllipseGeometry |
		EllipseOutlineGeometry |
		EllipsoidGeometry |
		EllipsoidOutlineGeometry |
		FrustumGeometry |
		Geometry |
		PlaneGeometry |
		PlaneOutlineGeometry |
		PolygonOutlineGeometry |
		WallOutlineGeometry |
		WallGeometry |
		SphereGeometry|
		SphereOutlineGeometry |
		SimplePolylineGeometry |
		RectangleOutlineGeometry |
		RectangleGeometry |
		PolylineVolumeOutlineGeometry |
		PolylineVolumeGeometry |
		PolylineGeometry |
		PolygonGeometry

	// class Date extends JulianDate{} 

}