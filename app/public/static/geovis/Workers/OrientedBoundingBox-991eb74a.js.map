{"version":3,"file":"OrientedBoundingBox-991eb74a.js","sources":["../../../../Source/Core/OrientedBoundingBox.js"],"sourcesContent":["import BoundingSphere from './BoundingSphere.js';\r\nimport Cartesian2 from './Cartesian2.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport Cartographic from './Cartographic.js';\r\nimport Check from './Check.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport EllipsoidTangentPlane from './EllipsoidTangentPlane.js';\r\nimport Intersect from './Intersect.js';\r\nimport Interval from './Interval.js';\r\nimport CesiumMath from './Math.js';\r\nimport Matrix3 from './Matrix3.js';\r\nimport Plane from './Plane.js';\r\nimport Rectangle from './Rectangle.js';\r\n\r\n    /**\r\n     * Creates an instance of an OrientedBoundingBox.\r\n     * An OrientedBoundingBox of some object is a closed and convex cuboid. It can provide a tighter bounding volume than {@link BoundingSphere} or {@link AxisAlignedBoundingBox} in many cases.\r\n     * @alias OrientedBoundingBox\r\n     * @constructor\r\n     *\r\n     * @param {Cartesian3} [center=Cartesian3.ZERO] The center of the box.\r\n     * @param {Matrix3} [halfAxes=Matrix3.ZERO] The three orthogonal half-axes of the bounding box.\r\n     *                                          Equivalently, the transformation matrix, to rotate and scale a 0x0x0\r\n     *                                          cube centered at the origin.\r\n     *\r\n     *\r\n     * @example\r\n     * // Create an OrientedBoundingBox using a transformation matrix, a position where the box will be translated, and a scale.\r\n     * var center = new Cesium.Cartesian3(1.0, 0.0, 0.0);\r\n     * var halfAxes = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(1.0, 3.0, 2.0), new Cesium.Matrix3());\r\n     *\r\n     * var obb = new Cesium.OrientedBoundingBox(center, halfAxes);\r\n     *\r\n     * @see BoundingSphere\r\n     * @see BoundingRectangle\r\n     */\r\n    function OrientedBoundingBox(center, halfAxes) {\r\n        /**\r\n         * The center of the box.\r\n         * @type {Cartesian3}\r\n         * @default {@link Cartesian3.ZERO}\r\n         */\r\n        this.center = Cartesian3.clone(defaultValue(center, Cartesian3.ZERO));\r\n        /**\r\n         * The transformation matrix, to rotate the box to the right position.\r\n         * @type {Matrix3}\r\n         * @default {@link Matrix3.ZERO}\r\n         */\r\n        this.halfAxes = Matrix3.clone(defaultValue(halfAxes, Matrix3.ZERO));\r\n    }\r\n\r\n    /**\r\n     * The number of elements used to pack the object into an array.\r\n     * @type {Number}\r\n     */\r\n    OrientedBoundingBox.packedLength = Cartesian3.packedLength + Matrix3.packedLength;\r\n\r\n    /**\r\n     * Stores the provided instance into the provided array.\r\n     *\r\n     * @param {OrientedBoundingBox} value The value to pack.\r\n     * @param {Number[]} array The array to pack into.\r\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n     *\r\n     * @returns {Number[]} The array that was packed into\r\n     */\r\n    OrientedBoundingBox.pack = function(value, array, startingIndex) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('value', value);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        Cartesian3.pack(value.center, array, startingIndex);\r\n        Matrix3.pack(value.halfAxes, array, startingIndex + Cartesian3.packedLength);\r\n\r\n        return array;\r\n    };\r\n\r\n    /**\r\n     * Retrieves an instance from a packed array.\r\n     *\r\n     * @param {Number[]} array The packed array.\r\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n     * @param {OrientedBoundingBox} [result] The object into which to store the result.\r\n     * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\r\n     */\r\n    OrientedBoundingBox.unpack = function(array, startingIndex, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        startingIndex = defaultValue(startingIndex, 0);\r\n\r\n        if (!defined(result)) {\r\n            result = new OrientedBoundingBox();\r\n        }\r\n\r\n        Cartesian3.unpack(array, startingIndex, result.center);\r\n        Matrix3.unpack(array, startingIndex + Cartesian3.packedLength, result.halfAxes);\r\n        return result;\r\n    };\r\n\r\n    var scratchCartesian1 = new Cartesian3();\r\n    var scratchCartesian2 = new Cartesian3();\r\n    var scratchCartesian3 = new Cartesian3();\r\n    var scratchCartesian4 = new Cartesian3();\r\n    var scratchCartesian5 = new Cartesian3();\r\n    var scratchCartesian6 = new Cartesian3();\r\n    var scratchCovarianceResult = new Matrix3();\r\n    var scratchEigenResult = {\r\n        unitary : new Matrix3(),\r\n        diagonal : new Matrix3()\r\n    };\r\n\r\n    /**\r\n     * Computes an instance of an OrientedBoundingBox of the given positions.\r\n     * This is an implementation of Stefan Gottschalk's Collision Queries using Oriented Bounding Boxes solution (PHD thesis).\r\n     * Reference: http://gamma.cs.unc.edu/users/gottschalk/main.pdf\r\n     *\r\n     * @param {Cartesian3[]} [positions] List of {@link Cartesian3} points that the bounding box will enclose.\r\n     * @param {OrientedBoundingBox} [result] The object onto which to store the result.\r\n     * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\r\n     *\r\n     * @example\r\n     * // Compute an object oriented bounding box enclosing two points.\r\n     * var box = Cesium.OrientedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);\r\n     */\r\n    OrientedBoundingBox.fromPoints = function(positions, result) {\r\n        if (!defined(result)) {\r\n            result = new OrientedBoundingBox();\r\n        }\r\n\r\n        if (!defined(positions) || positions.length === 0) {\r\n            result.halfAxes = Matrix3.ZERO;\r\n            result.center = Cartesian3.ZERO;\r\n            return result;\r\n        }\r\n\r\n        var i;\r\n        var length = positions.length;\r\n\r\n        var meanPoint = Cartesian3.clone(positions[0], scratchCartesian1);\r\n        for (i = 1; i < length; i++) {\r\n            Cartesian3.add(meanPoint, positions[i], meanPoint);\r\n        }\r\n        var invLength = 1.0 / length;\r\n        Cartesian3.multiplyByScalar(meanPoint, invLength, meanPoint);\r\n\r\n        var exx = 0.0;\r\n        var exy = 0.0;\r\n        var exz = 0.0;\r\n        var eyy = 0.0;\r\n        var eyz = 0.0;\r\n        var ezz = 0.0;\r\n        var p;\r\n\r\n        for (i = 0; i < length; i++) {\r\n            p = Cartesian3.subtract(positions[i], meanPoint, scratchCartesian2);\r\n            exx += p.x * p.x;\r\n            exy += p.x * p.y;\r\n            exz += p.x * p.z;\r\n            eyy += p.y * p.y;\r\n            eyz += p.y * p.z;\r\n            ezz += p.z * p.z;\r\n        }\r\n\r\n        exx *= invLength;\r\n        exy *= invLength;\r\n        exz *= invLength;\r\n        eyy *= invLength;\r\n        eyz *= invLength;\r\n        ezz *= invLength;\r\n\r\n        var covarianceMatrix = scratchCovarianceResult;\r\n        covarianceMatrix[0] = exx;\r\n        covarianceMatrix[1] = exy;\r\n        covarianceMatrix[2] = exz;\r\n        covarianceMatrix[3] = exy;\r\n        covarianceMatrix[4] = eyy;\r\n        covarianceMatrix[5] = eyz;\r\n        covarianceMatrix[6] = exz;\r\n        covarianceMatrix[7] = eyz;\r\n        covarianceMatrix[8] = ezz;\r\n\r\n        var eigenDecomposition = Matrix3.computeEigenDecomposition(covarianceMatrix, scratchEigenResult);\r\n        var rotation = Matrix3.clone(eigenDecomposition.unitary, result.halfAxes);\r\n\r\n        var v1 = Matrix3.getColumn(rotation, 0, scratchCartesian4);\r\n        var v2 = Matrix3.getColumn(rotation, 1, scratchCartesian5);\r\n        var v3 = Matrix3.getColumn(rotation, 2, scratchCartesian6);\r\n\r\n        var u1 = -Number.MAX_VALUE;\r\n        var u2 = -Number.MAX_VALUE;\r\n        var u3 = -Number.MAX_VALUE;\r\n        var l1 = Number.MAX_VALUE;\r\n        var l2 = Number.MAX_VALUE;\r\n        var l3 = Number.MAX_VALUE;\r\n\r\n        for (i = 0; i < length; i++) {\r\n            p = positions[i];\r\n            u1 = Math.max(Cartesian3.dot(v1, p), u1);\r\n            u2 = Math.max(Cartesian3.dot(v2, p), u2);\r\n            u3 = Math.max(Cartesian3.dot(v3, p), u3);\r\n\r\n            l1 = Math.min(Cartesian3.dot(v1, p), l1);\r\n            l2 = Math.min(Cartesian3.dot(v2, p), l2);\r\n            l3 = Math.min(Cartesian3.dot(v3, p), l3);\r\n        }\r\n\r\n        v1 = Cartesian3.multiplyByScalar(v1, 0.5 * (l1 + u1), v1);\r\n        v2 = Cartesian3.multiplyByScalar(v2, 0.5 * (l2 + u2), v2);\r\n        v3 = Cartesian3.multiplyByScalar(v3, 0.5 * (l3 + u3), v3);\r\n\r\n        var center = Cartesian3.add(v1, v2, result.center);\r\n        Cartesian3.add(center, v3, center);\r\n\r\n        var scale = scratchCartesian3;\r\n        scale.x = u1 - l1;\r\n        scale.y = u2 - l2;\r\n        scale.z = u3 - l3;\r\n        Cartesian3.multiplyByScalar(scale, 0.5, scale);\r\n        Matrix3.multiplyByScale(result.halfAxes, scale, result.halfAxes);\r\n\r\n        return result;\r\n    };\r\n\r\n    var scratchOffset = new Cartesian3();\r\n    var scratchScale = new Cartesian3();\r\n    function fromPlaneExtents(planeOrigin, planeXAxis, planeYAxis, planeZAxis, minimumX, maximumX, minimumY, maximumY, minimumZ, maximumZ, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(minimumX) ||\r\n            !defined(maximumX) ||\r\n            !defined(minimumY) ||\r\n            !defined(maximumY) ||\r\n            !defined(minimumZ) ||\r\n            !defined(maximumZ)) {\r\n            throw new DeveloperError('all extents (minimum/maximum X/Y/Z) are required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            result = new OrientedBoundingBox();\r\n        }\r\n\r\n        var halfAxes = result.halfAxes;\r\n        Matrix3.setColumn(halfAxes, 0, planeXAxis, halfAxes);\r\n        Matrix3.setColumn(halfAxes, 1, planeYAxis, halfAxes);\r\n        Matrix3.setColumn(halfAxes, 2, planeZAxis, halfAxes);\r\n\r\n        var centerOffset = scratchOffset;\r\n        centerOffset.x = (minimumX + maximumX) / 2.0;\r\n        centerOffset.y = (minimumY + maximumY) / 2.0;\r\n        centerOffset.z = (minimumZ + maximumZ) / 2.0;\r\n\r\n        var scale = scratchScale;\r\n        scale.x = (maximumX - minimumX) / 2.0;\r\n        scale.y = (maximumY - minimumY) / 2.0;\r\n        scale.z = (maximumZ - minimumZ) / 2.0;\r\n\r\n        var center = result.center;\r\n        centerOffset = Matrix3.multiplyByVector(halfAxes, centerOffset, centerOffset);\r\n        Cartesian3.add(planeOrigin, centerOffset, center);\r\n        Matrix3.multiplyByScale(halfAxes, scale, halfAxes);\r\n\r\n        return result;\r\n    }\r\n\r\n    var scratchRectangleCenterCartographic = new Cartographic();\r\n    var scratchRectangleCenter = new Cartesian3();\r\n    var scratchPerimeterCartographicNC = new Cartographic();\r\n    var scratchPerimeterCartographicNW = new Cartographic();\r\n    var scratchPerimeterCartographicCW = new Cartographic();\r\n    var scratchPerimeterCartographicSW = new Cartographic();\r\n    var scratchPerimeterCartographicSC = new Cartographic();\r\n    var scratchPerimeterCartesianNC = new Cartesian3();\r\n    var scratchPerimeterCartesianNW = new Cartesian3();\r\n    var scratchPerimeterCartesianCW = new Cartesian3();\r\n    var scratchPerimeterCartesianSW = new Cartesian3();\r\n    var scratchPerimeterCartesianSC = new Cartesian3();\r\n    var scratchPerimeterProjectedNC = new Cartesian2();\r\n    var scratchPerimeterProjectedNW = new Cartesian2();\r\n    var scratchPerimeterProjectedCW = new Cartesian2();\r\n    var scratchPerimeterProjectedSW = new Cartesian2();\r\n    var scratchPerimeterProjectedSC = new Cartesian2();\r\n\r\n    var scratchPlaneOrigin = new Cartesian3();\r\n    var scratchPlaneNormal = new Cartesian3();\r\n    var scratchPlaneXAxis = new Cartesian3();\r\n    var scratchHorizonCartesian = new Cartesian3();\r\n    var scratchHorizonProjected = new Cartesian2();\r\n    var scratchMaxY = new Cartesian3();\r\n    var scratchMinY = new Cartesian3();\r\n    var scratchZ = new Cartesian3();\r\n    var scratchPlane = new Plane(Cartesian3.UNIT_X, 0.0);\r\n\r\n    /**\r\n     * Computes an OrientedBoundingBox that bounds a {@link Rectangle} on the surface of an {@link Ellipsoid}.\r\n     * There are no guarantees about the orientation of the bounding box.\r\n     *\r\n     * @param {Rectangle} rectangle The cartographic rectangle on the surface of the ellipsoid.\r\n     * @param {Number} [minimumHeight=0.0] The minimum height (elevation) within the tile.\r\n     * @param {Number} [maximumHeight=0.0] The maximum height (elevation) within the tile.\r\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid on which the rectangle is defined.\r\n     * @param {OrientedBoundingBox} [result] The object onto which to store the result.\r\n     * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided.\r\n     *\r\n     * @exception {DeveloperError} rectangle.width must be between 0 and pi.\r\n     * @exception {DeveloperError} rectangle.height must be between 0 and pi.\r\n     * @exception {DeveloperError} ellipsoid must be an ellipsoid of revolution (<code>radii.x == radii.y</code>)\r\n     */\r\n    OrientedBoundingBox.fromRectangle = function(rectangle, minimumHeight, maximumHeight, ellipsoid, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(rectangle)) {\r\n            throw new DeveloperError('rectangle is required');\r\n        }\r\n        if (rectangle.width < 0.0 || rectangle.width > CesiumMath.TWO_PI) {\r\n            throw new DeveloperError('Rectangle width must be between 0 and 2*pi');\r\n        }\r\n        if (rectangle.height < 0.0 || rectangle.height > CesiumMath.PI) {\r\n            throw new DeveloperError('Rectangle height must be between 0 and pi');\r\n        }\r\n        if (defined(ellipsoid) && !CesiumMath.equalsEpsilon(ellipsoid.radii.x, ellipsoid.radii.y, CesiumMath.EPSILON15)) {\r\n            throw new DeveloperError('Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        minimumHeight = defaultValue(minimumHeight, 0.0);\r\n        maximumHeight = defaultValue(maximumHeight, 0.0);\r\n        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\r\n\r\n        var minX, maxX, minY, maxY, minZ, maxZ, plane;\r\n\r\n        if (rectangle.width <= CesiumMath.PI) {\r\n            // The bounding box will be aligned with the tangent plane at the center of the rectangle.\r\n            var tangentPointCartographic = Rectangle.center(rectangle, scratchRectangleCenterCartographic);\r\n            var tangentPoint = ellipsoid.cartographicToCartesian(tangentPointCartographic, scratchRectangleCenter);\r\n            var tangentPlane = new EllipsoidTangentPlane(tangentPoint, ellipsoid);\r\n            plane = tangentPlane.plane;\r\n\r\n            // If the rectangle spans the equator, CW is instead aligned with the equator (because it sticks out the farthest at the equator).\r\n            var lonCenter = tangentPointCartographic.longitude;\r\n            var latCenter = (rectangle.south < 0.0 && rectangle.north > 0.0) ? 0.0 : tangentPointCartographic.latitude;\r\n\r\n            // Compute XY extents using the rectangle at maximum height\r\n            var perimeterCartographicNC = Cartographic.fromRadians(lonCenter, rectangle.north, maximumHeight, scratchPerimeterCartographicNC);\r\n            var perimeterCartographicNW = Cartographic.fromRadians(rectangle.west, rectangle.north, maximumHeight, scratchPerimeterCartographicNW);\r\n            var perimeterCartographicCW = Cartographic.fromRadians(rectangle.west, latCenter, maximumHeight, scratchPerimeterCartographicCW);\r\n            var perimeterCartographicSW = Cartographic.fromRadians(rectangle.west, rectangle.south, maximumHeight, scratchPerimeterCartographicSW);\r\n            var perimeterCartographicSC = Cartographic.fromRadians(lonCenter, rectangle.south, maximumHeight, scratchPerimeterCartographicSC);\r\n\r\n            var perimeterCartesianNC = ellipsoid.cartographicToCartesian(perimeterCartographicNC, scratchPerimeterCartesianNC);\r\n            var perimeterCartesianNW = ellipsoid.cartographicToCartesian(perimeterCartographicNW, scratchPerimeterCartesianNW);\r\n            var perimeterCartesianCW = ellipsoid.cartographicToCartesian(perimeterCartographicCW, scratchPerimeterCartesianCW);\r\n            var perimeterCartesianSW = ellipsoid.cartographicToCartesian(perimeterCartographicSW, scratchPerimeterCartesianSW);\r\n            var perimeterCartesianSC = ellipsoid.cartographicToCartesian(perimeterCartographicSC, scratchPerimeterCartesianSC);\r\n\r\n            var perimeterProjectedNC = tangentPlane.projectPointToNearestOnPlane(perimeterCartesianNC, scratchPerimeterProjectedNC);\r\n            var perimeterProjectedNW = tangentPlane.projectPointToNearestOnPlane(perimeterCartesianNW, scratchPerimeterProjectedNW);\r\n            var perimeterProjectedCW = tangentPlane.projectPointToNearestOnPlane(perimeterCartesianCW, scratchPerimeterProjectedCW);\r\n            var perimeterProjectedSW = tangentPlane.projectPointToNearestOnPlane(perimeterCartesianSW, scratchPerimeterProjectedSW);\r\n            var perimeterProjectedSC = tangentPlane.projectPointToNearestOnPlane(perimeterCartesianSC, scratchPerimeterProjectedSC);\r\n\r\n            minX = Math.min(perimeterProjectedNW.x, perimeterProjectedCW.x, perimeterProjectedSW.x);\r\n            maxX = -minX; // symmetrical\r\n\r\n            maxY = Math.max(perimeterProjectedNW.y, perimeterProjectedNC.y);\r\n            minY = Math.min(perimeterProjectedSW.y, perimeterProjectedSC.y);\r\n\r\n            // Compute minimum Z using the rectangle at minimum height, since it will be deeper than the maximum height\r\n            perimeterCartographicNW.height = perimeterCartographicSW.height = minimumHeight;\r\n            perimeterCartesianNW = ellipsoid.cartographicToCartesian(perimeterCartographicNW, scratchPerimeterCartesianNW);\r\n            perimeterCartesianSW = ellipsoid.cartographicToCartesian(perimeterCartographicSW, scratchPerimeterCartesianSW);\r\n\r\n            minZ = Math.min(Plane.getPointDistance(plane, perimeterCartesianNW), Plane.getPointDistance(plane, perimeterCartesianSW));\r\n            maxZ = maximumHeight;  // Since the tangent plane touches the surface at height = 0, this is okay\r\n\r\n            return fromPlaneExtents(tangentPlane.origin, tangentPlane.xAxis, tangentPlane.yAxis, tangentPlane.zAxis, minX, maxX, minY, maxY, minZ, maxZ, result);\r\n        }\r\n\r\n        // Handle the case where rectangle width is greater than PI (wraps around more than half the ellipsoid).\r\n        var fullyAboveEquator = rectangle.south > 0.0;\r\n        var fullyBelowEquator = rectangle.north < 0.0;\r\n        var latitudeNearestToEquator = fullyAboveEquator ? rectangle.south : (fullyBelowEquator ? rectangle.north : 0.0);\r\n        var centerLongitude = Rectangle.center(rectangle, scratchRectangleCenterCartographic).longitude;\r\n\r\n        // Plane is located at the rectangle's center longitude and the rectangle's latitude that is closest to the equator. It rotates around the Z axis.\r\n        // This results in a better fit than the obb approach for smaller rectangles, which orients with the rectangle's center normal.\r\n        var planeOrigin = Cartesian3.fromRadians(centerLongitude, latitudeNearestToEquator, maximumHeight, ellipsoid, scratchPlaneOrigin);\r\n        planeOrigin.z = 0.0; // center the plane on the equator to simpify plane normal calculation\r\n        var isPole = Math.abs(planeOrigin.x) < CesiumMath.EPSILON10 && Math.abs(planeOrigin.y) < CesiumMath.EPSILON10;\r\n        var planeNormal = !isPole ? Cartesian3.normalize(planeOrigin, scratchPlaneNormal) : Cartesian3.UNIT_X;\r\n        var planeYAxis = Cartesian3.UNIT_Z;\r\n        var planeXAxis = Cartesian3.cross(planeNormal, planeYAxis, scratchPlaneXAxis);\r\n        plane = Plane.fromPointNormal(planeOrigin, planeNormal, scratchPlane);\r\n\r\n        // Get the horizon point relative to the center. This will be the farthest extent in the plane's X dimension.\r\n        var horizonCartesian = Cartesian3.fromRadians(centerLongitude + CesiumMath.PI_OVER_TWO, latitudeNearestToEquator, maximumHeight, ellipsoid, scratchHorizonCartesian);\r\n        maxX = Cartesian3.dot(Plane.projectPointOntoPlane(plane, horizonCartesian, scratchHorizonProjected), planeXAxis);\r\n        minX = -maxX; // symmetrical\r\n\r\n        // Get the min and max Y, using the height that will give the largest extent\r\n        maxY = Cartesian3.fromRadians(0.0, rectangle.north, fullyBelowEquator ? minimumHeight : maximumHeight, ellipsoid, scratchMaxY).z;\r\n        minY = Cartesian3.fromRadians(0.0, rectangle.south, fullyAboveEquator ? minimumHeight : maximumHeight, ellipsoid, scratchMinY).z;\r\n\r\n        var farZ = Cartesian3.fromRadians(rectangle.east, latitudeNearestToEquator, maximumHeight, ellipsoid, scratchZ);\r\n        minZ = Plane.getPointDistance(plane, farZ);\r\n        maxZ = 0.0; // plane origin starts at maxZ already\r\n\r\n        // min and max are local to the plane axes\r\n        return fromPlaneExtents(planeOrigin, planeXAxis, planeYAxis, planeNormal, minX, maxX, minY, maxY, minZ, maxZ, result);\r\n    };\r\n\r\n    /**\r\n     * Duplicates a OrientedBoundingBox instance.\r\n     *\r\n     * @param {OrientedBoundingBox} box The bounding box to duplicate.\r\n     * @param {OrientedBoundingBox} [result] The object onto which to store the result.\r\n     * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if none was provided. (Returns undefined if box is undefined)\r\n     */\r\n    OrientedBoundingBox.clone = function(box, result) {\r\n        if (!defined(box)) {\r\n            return undefined;\r\n        }\r\n\r\n        if (!defined(result)) {\r\n            return new OrientedBoundingBox(box.center, box.halfAxes);\r\n        }\r\n\r\n        Cartesian3.clone(box.center, result.center);\r\n        Matrix3.clone(box.halfAxes, result.halfAxes);\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Determines which side of a plane the oriented bounding box is located.\r\n     *\r\n     * @param {OrientedBoundingBox} box The oriented bounding box to test.\r\n     * @param {Plane} plane The plane to test against.\r\n     * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\r\n     *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\r\n     *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\r\n     *                      intersects the plane.\r\n     */\r\n    OrientedBoundingBox.intersectPlane = function(box, plane) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(box)) {\r\n            throw new DeveloperError('box is required.');\r\n        }\r\n\r\n        if (!defined(plane)) {\r\n            throw new DeveloperError('plane is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var center = box.center;\r\n        var normal = plane.normal;\r\n        var halfAxes = box.halfAxes;\r\n        var normalX = normal.x, normalY = normal.y, normalZ = normal.z;\r\n        // plane is used as if it is its normal; the first three components are assumed to be normalized\r\n        var radEffective = Math.abs(normalX * halfAxes[Matrix3.COLUMN0ROW0] + normalY * halfAxes[Matrix3.COLUMN0ROW1] + normalZ * halfAxes[Matrix3.COLUMN0ROW2]) +\r\n                           Math.abs(normalX * halfAxes[Matrix3.COLUMN1ROW0] + normalY * halfAxes[Matrix3.COLUMN1ROW1] + normalZ * halfAxes[Matrix3.COLUMN1ROW2]) +\r\n                           Math.abs(normalX * halfAxes[Matrix3.COLUMN2ROW0] + normalY * halfAxes[Matrix3.COLUMN2ROW1] + normalZ * halfAxes[Matrix3.COLUMN2ROW2]);\r\n        var distanceToPlane = Cartesian3.dot(normal, center) + plane.distance;\r\n\r\n        if (distanceToPlane <= -radEffective) {\r\n            // The entire box is on the negative side of the plane normal\r\n            return Intersect.OUTSIDE;\r\n        } else if (distanceToPlane >= radEffective) {\r\n            // The entire box is on the positive side of the plane normal\r\n            return Intersect.INSIDE;\r\n        }\r\n        return Intersect.INTERSECTING;\r\n    };\r\n\r\n    var scratchCartesianU = new Cartesian3();\r\n    var scratchCartesianV = new Cartesian3();\r\n    var scratchCartesianW = new Cartesian3();\r\n    var scratchPPrime = new Cartesian3();\r\n\r\n    /**\r\n     * Computes the estimated distance squared from the closest point on a bounding box to a point.\r\n     *\r\n     * @param {OrientedBoundingBox} box The box.\r\n     * @param {Cartesian3} cartesian The point\r\n     * @returns {Number} The estimated distance squared from the bounding sphere to the point.\r\n     *\r\n     * @example\r\n     * // Sort bounding boxes from back to front\r\n     * boxes.sort(function(a, b) {\r\n     *     return Cesium.OrientedBoundingBox.distanceSquaredTo(b, camera.positionWC) - Cesium.OrientedBoundingBox.distanceSquaredTo(a, camera.positionWC);\r\n     * });\r\n     */\r\n    OrientedBoundingBox.distanceSquaredTo = function(box, cartesian) {\r\n        // See Geometric Tools for Computer Graphics 10.4.2\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(box)) {\r\n            throw new DeveloperError('box is required.');\r\n        }\r\n        if (!defined(cartesian)) {\r\n            throw new DeveloperError('cartesian is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var offset = Cartesian3.subtract(cartesian, box.center, scratchOffset);\r\n\r\n        var halfAxes = box.halfAxes;\r\n        var u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\r\n        var v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\r\n        var w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\r\n\r\n        var uHalf = Cartesian3.magnitude(u);\r\n        var vHalf = Cartesian3.magnitude(v);\r\n        var wHalf = Cartesian3.magnitude(w);\r\n\r\n        Cartesian3.normalize(u, u);\r\n        Cartesian3.normalize(v, v);\r\n        Cartesian3.normalize(w, w);\r\n\r\n        var pPrime = scratchPPrime;\r\n        pPrime.x = Cartesian3.dot(offset, u);\r\n        pPrime.y = Cartesian3.dot(offset, v);\r\n        pPrime.z = Cartesian3.dot(offset, w);\r\n\r\n        var distanceSquared = 0.0;\r\n        var d;\r\n\r\n        if (pPrime.x < -uHalf) {\r\n            d = pPrime.x + uHalf;\r\n            distanceSquared += d * d;\r\n        } else if (pPrime.x > uHalf) {\r\n            d = pPrime.x - uHalf;\r\n            distanceSquared += d * d;\r\n        }\r\n\r\n        if (pPrime.y < -vHalf) {\r\n            d = pPrime.y + vHalf;\r\n            distanceSquared += d * d;\r\n        } else if (pPrime.y > vHalf) {\r\n            d = pPrime.y - vHalf;\r\n            distanceSquared += d * d;\r\n        }\r\n\r\n        if (pPrime.z < -wHalf) {\r\n            d = pPrime.z + wHalf;\r\n            distanceSquared += d * d;\r\n        } else if (pPrime.z > wHalf) {\r\n            d = pPrime.z - wHalf;\r\n            distanceSquared += d * d;\r\n        }\r\n\r\n        return distanceSquared;\r\n    };\r\n\r\n    var scratchCorner = new Cartesian3();\r\n    var scratchToCenter = new Cartesian3();\r\n\r\n    /**\r\n     * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\r\n     * <br>\r\n     * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\r\n     * closest and farthest planes from position that intersect the bounding box.\r\n     *\r\n     * @param {OrientedBoundingBox} box The bounding box to calculate the distance to.\r\n     * @param {Cartesian3} position The position to calculate the distance from.\r\n     * @param {Cartesian3} direction The direction from position.\r\n     * @param {Interval} [result] A Interval to store the nearest and farthest distances.\r\n     * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\r\n     */\r\n    OrientedBoundingBox.computePlaneDistances = function(box, position, direction, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(box)) {\r\n            throw new DeveloperError('box is required.');\r\n        }\r\n\r\n        if (!defined(position)) {\r\n            throw new DeveloperError('position is required.');\r\n        }\r\n\r\n        if (!defined(direction)) {\r\n            throw new DeveloperError('direction is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        if (!defined(result)) {\r\n            result = new Interval();\r\n        }\r\n\r\n        var minDist = Number.POSITIVE_INFINITY;\r\n        var maxDist = Number.NEGATIVE_INFINITY;\r\n\r\n        var center = box.center;\r\n        var halfAxes = box.halfAxes;\r\n\r\n        var u = Matrix3.getColumn(halfAxes, 0, scratchCartesianU);\r\n        var v = Matrix3.getColumn(halfAxes, 1, scratchCartesianV);\r\n        var w = Matrix3.getColumn(halfAxes, 2, scratchCartesianW);\r\n\r\n        // project first corner\r\n        var corner = Cartesian3.add(u, v, scratchCorner);\r\n        Cartesian3.add(corner, w, corner);\r\n        Cartesian3.add(corner, center, corner);\r\n\r\n        var toCenter = Cartesian3.subtract(corner, position, scratchToCenter);\r\n        var mag = Cartesian3.dot(direction, toCenter);\r\n\r\n        minDist = Math.min(mag, minDist);\r\n        maxDist = Math.max(mag, maxDist);\r\n\r\n        // project second corner\r\n        Cartesian3.add(center, u, corner);\r\n        Cartesian3.add(corner, v, corner);\r\n        Cartesian3.subtract(corner, w, corner);\r\n\r\n        Cartesian3.subtract(corner, position, toCenter);\r\n        mag = Cartesian3.dot(direction, toCenter);\r\n\r\n        minDist = Math.min(mag, minDist);\r\n        maxDist = Math.max(mag, maxDist);\r\n\r\n        // project third corner\r\n        Cartesian3.add(center, u, corner);\r\n        Cartesian3.subtract(corner, v, corner);\r\n        Cartesian3.add(corner, w, corner);\r\n\r\n        Cartesian3.subtract(corner, position, toCenter);\r\n        mag = Cartesian3.dot(direction, toCenter);\r\n\r\n        minDist = Math.min(mag, minDist);\r\n        maxDist = Math.max(mag, maxDist);\r\n\r\n        // project fourth corner\r\n        Cartesian3.add(center, u, corner);\r\n        Cartesian3.subtract(corner, v, corner);\r\n        Cartesian3.subtract(corner, w, corner);\r\n\r\n        Cartesian3.subtract(corner, position, toCenter);\r\n        mag = Cartesian3.dot(direction, toCenter);\r\n\r\n        minDist = Math.min(mag, minDist);\r\n        maxDist = Math.max(mag, maxDist);\r\n\r\n        // project fifth corner\r\n        Cartesian3.subtract(center, u, corner);\r\n        Cartesian3.add(corner, v, corner);\r\n        Cartesian3.add(corner, w, corner);\r\n\r\n        Cartesian3.subtract(corner, position, toCenter);\r\n        mag = Cartesian3.dot(direction, toCenter);\r\n\r\n        minDist = Math.min(mag, minDist);\r\n        maxDist = Math.max(mag, maxDist);\r\n\r\n        // project sixth corner\r\n        Cartesian3.subtract(center, u, corner);\r\n        Cartesian3.add(corner, v, corner);\r\n        Cartesian3.subtract(corner, w, corner);\r\n\r\n        Cartesian3.subtract(corner, position, toCenter);\r\n        mag = Cartesian3.dot(direction, toCenter);\r\n\r\n        minDist = Math.min(mag, minDist);\r\n        maxDist = Math.max(mag, maxDist);\r\n\r\n        // project seventh corner\r\n        Cartesian3.subtract(center, u, corner);\r\n        Cartesian3.subtract(corner, v, corner);\r\n        Cartesian3.add(corner, w, corner);\r\n\r\n        Cartesian3.subtract(corner, position, toCenter);\r\n        mag = Cartesian3.dot(direction, toCenter);\r\n\r\n        minDist = Math.min(mag, minDist);\r\n        maxDist = Math.max(mag, maxDist);\r\n\r\n        // project eighth corner\r\n        Cartesian3.subtract(center, u, corner);\r\n        Cartesian3.subtract(corner, v, corner);\r\n        Cartesian3.subtract(corner, w, corner);\r\n\r\n        Cartesian3.subtract(corner, position, toCenter);\r\n        mag = Cartesian3.dot(direction, toCenter);\r\n\r\n        minDist = Math.min(mag, minDist);\r\n        maxDist = Math.max(mag, maxDist);\r\n\r\n        result.start = minDist;\r\n        result.stop = maxDist;\r\n        return result;\r\n    };\r\n\r\n    var scratchBoundingSphere = new BoundingSphere();\r\n\r\n    /**\r\n     * Determines whether or not a bounding box is hidden from view by the occluder.\r\n     *\r\n     * @param {OrientedBoundingBox} box The bounding box surrounding the occludee object.\r\n     * @param {Occluder} occluder The occluder.\r\n     * @returns {Boolean} <code>true</code> if the box is not visible; otherwise <code>false</code>.\r\n     */\r\n    OrientedBoundingBox.isOccluded = function(box, occluder) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if (!defined(box)) {\r\n            throw new DeveloperError('box is required.');\r\n        }\r\n        if (!defined(occluder)) {\r\n            throw new DeveloperError('occluder is required.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        var sphere = BoundingSphere.fromOrientedBoundingBox(box, scratchBoundingSphere);\r\n\r\n        return !occluder.isBoundingSphereVisible(sphere);\r\n    };\r\n\r\n    /**\r\n     * Determines which side of a plane the oriented bounding box is located.\r\n     *\r\n     * @param {Plane} plane The plane to test against.\r\n     * @returns {Intersect} {@link Intersect.INSIDE} if the entire box is on the side of the plane\r\n     *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is\r\n     *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box\r\n     *                      intersects the plane.\r\n     */\r\n    OrientedBoundingBox.prototype.intersectPlane = function(plane) {\r\n        return OrientedBoundingBox.intersectPlane(this, plane);\r\n    };\r\n\r\n    /**\r\n     * Computes the estimated distance squared from the closest point on a bounding box to a point.\r\n     *\r\n     * @param {Cartesian3} cartesian The point\r\n     * @returns {Number} The estimated distance squared from the bounding sphere to the point.\r\n     *\r\n     * @example\r\n     * // Sort bounding boxes from back to front\r\n     * boxes.sort(function(a, b) {\r\n     *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);\r\n     * });\r\n     */\r\n    OrientedBoundingBox.prototype.distanceSquaredTo = function(cartesian) {\r\n        return OrientedBoundingBox.distanceSquaredTo(this, cartesian);\r\n    };\r\n\r\n    /**\r\n     * The distances calculated by the vector from the center of the bounding box to position projected onto direction.\r\n     * <br>\r\n     * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the\r\n     * closest and farthest planes from position that intersect the bounding box.\r\n     *\r\n     * @param {Cartesian3} position The position to calculate the distance from.\r\n     * @param {Cartesian3} direction The direction from position.\r\n     * @param {Interval} [result] A Interval to store the nearest and farthest distances.\r\n     * @returns {Interval} The nearest and farthest distances on the bounding box from position in direction.\r\n     */\r\n    OrientedBoundingBox.prototype.computePlaneDistances = function(position, direction, result) {\r\n        return OrientedBoundingBox.computePlaneDistances(this, position, direction, result);\r\n    };\r\n\r\n    /**\r\n     * Determines whether or not a bounding box is hidden from view by the occluder.\r\n     *\r\n     * @param {Occluder} occluder The occluder.\r\n     * @returns {Boolean} <code>true</code> if the sphere is not visible; otherwise <code>false</code>.\r\n     */\r\n    OrientedBoundingBox.prototype.isOccluded = function(occluder) {\r\n        return OrientedBoundingBox.isOccluded(this, occluder);\r\n    };\r\n\r\n    /**\r\n     * Compares the provided OrientedBoundingBox componentwise and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {OrientedBoundingBox} left The first OrientedBoundingBox.\r\n     * @param {OrientedBoundingBox} right The second OrientedBoundingBox.\r\n     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\r\n     */\r\n    OrientedBoundingBox.equals = function(left, right) {\r\n        return (left === right) ||\r\n                ((defined(left)) &&\r\n                 (defined(right)) &&\r\n                 Cartesian3.equals(left.center, right.center) &&\r\n                 Matrix3.equals(left.halfAxes, right.halfAxes));\r\n    };\r\n\r\n    /**\r\n     * Duplicates this OrientedBoundingBox instance.\r\n     *\r\n     * @param {OrientedBoundingBox} [result] The object onto which to store the result.\r\n     * @returns {OrientedBoundingBox} The modified result parameter or a new OrientedBoundingBox instance if one was not provided.\r\n     */\r\n    OrientedBoundingBox.prototype.clone = function(result) {\r\n        return OrientedBoundingBox.clone(this, result);\r\n    };\r\n\r\n    /**\r\n     * Compares this OrientedBoundingBox against the provided OrientedBoundingBox componentwise and returns\r\n     * <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     *\r\n     * @param {OrientedBoundingBox} [right] The right hand side OrientedBoundingBox.\r\n     * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\r\n     */\r\n    OrientedBoundingBox.prototype.equals = function(right) {\r\n        return OrientedBoundingBox.equals(this, right);\r\n    };\r\nexport default OrientedBoundingBox;\r\n"],"names":["Cartesian3","defaultValue","Matrix3","Check","defined","DeveloperError","Cartographic","Cartesian2","Plane","CesiumMath","Ellipsoid","Rectangle","EllipsoidTangentPlane","Intersect","Interval","BoundingSphere"],"mappings":"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"}