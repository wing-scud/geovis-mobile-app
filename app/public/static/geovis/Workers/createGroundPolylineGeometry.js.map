{"version":3,"file":"createGroundPolylineGeometry.js","sources":["../../../../Source/Core/GeographicTilingScheme.js","../../../../Source/Core/ApproximateTerrainHeights.js","../../../../Source/Core/GroundPolylineGeometry.js","../../../../Source/WorkersES6/createGroundPolylineGeometry.js"],"sourcesContent":["import Cartesian2 from './Cartesian2.js';\r\nimport Check from './Check.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport GeographicProjection from './GeographicProjection.js';\r\nimport CesiumMath from './Math.js';\r\nimport Rectangle from './Rectangle.js';\r\n\r\n    /**\r\n     * A tiling scheme for geometry referenced to a simple {@link GeographicProjection} where\r\n     * longitude and latitude are directly mapped to X and Y.  This projection is commonly\r\n     * known as geographic, equirectangular, equidistant cylindrical, or plate carr√©e.\r\n     *\r\n     * @alias GeographicTilingScheme\r\n     * @constructor\r\n     *\r\n     * @param {Object} [options] Object with the following properties:\r\n     * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid whose surface is being tiled. Defaults to\r\n     * the WGS84 ellipsoid.\r\n     * @param {Rectangle} [options.rectangle=Rectangle.MAX_VALUE] The rectangle, in radians, covered by the tiling scheme.\r\n     * @param {Number} [options.numberOfLevelZeroTilesX=2] The number of tiles in the X direction at level zero of\r\n     * the tile tree.\r\n     * @param {Number} [options.numberOfLevelZeroTilesY=1] The number of tiles in the Y direction at level zero of\r\n     * the tile tree.\r\n     */\r\n    function GeographicTilingScheme(options) {\r\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n        this._ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n        this._rectangle = defaultValue(options.rectangle, Rectangle.MAX_VALUE);\r\n        this._projection = new GeographicProjection(this._ellipsoid);\r\n        this._numberOfLevelZeroTilesX = defaultValue(options.numberOfLevelZeroTilesX, 2);\r\n        this._numberOfLevelZeroTilesY = defaultValue(options.numberOfLevelZeroTilesY, 1);\r\n    }\r\n\r\n    Object.defineProperties(GeographicTilingScheme.prototype, {\r\n        /**\r\n         * Gets the ellipsoid that is tiled by this tiling scheme.\r\n         * @memberof GeographicTilingScheme.prototype\r\n         * @type {Ellipsoid}\r\n         */\r\n        ellipsoid : {\r\n            get : function() {\r\n                return this._ellipsoid;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Gets the rectangle, in radians, covered by this tiling scheme.\r\n         * @memberof GeographicTilingScheme.prototype\r\n         * @type {Rectangle}\r\n         */\r\n        rectangle : {\r\n            get : function() {\r\n                return this._rectangle;\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Gets the map projection used by this tiling scheme.\r\n         * @memberof GeographicTilingScheme.prototype\r\n         * @type {MapProjection}\r\n         */\r\n        projection : {\r\n            get : function() {\r\n                return this._projection;\r\n            }\r\n        }\r\n    });\r\n\r\n    /**\r\n     * Gets the total number of tiles in the X direction at a specified level-of-detail.\r\n     *\r\n     * @param {Number} level The level-of-detail.\r\n     * @returns {Number} The number of tiles in the X direction at the given level.\r\n     */\r\n    GeographicTilingScheme.prototype.getNumberOfXTilesAtLevel = function(level) {\r\n        return this._numberOfLevelZeroTilesX << level;\r\n    };\r\n\r\n    /**\r\n     * Gets the total number of tiles in the Y direction at a specified level-of-detail.\r\n     *\r\n     * @param {Number} level The level-of-detail.\r\n     * @returns {Number} The number of tiles in the Y direction at the given level.\r\n     */\r\n    GeographicTilingScheme.prototype.getNumberOfYTilesAtLevel = function(level) {\r\n        return this._numberOfLevelZeroTilesY << level;\r\n    };\r\n\r\n    /**\r\n     * Transforms a rectangle specified in geodetic radians to the native coordinate system\r\n     * of this tiling scheme.\r\n     *\r\n     * @param {Rectangle} rectangle The rectangle to transform.\r\n     * @param {Rectangle} [result] The instance to which to copy the result, or undefined if a new instance\r\n     *        should be created.\r\n     * @returns {Rectangle} The specified 'result', or a new object containing the native rectangle if 'result'\r\n     *          is undefined.\r\n     */\r\n    GeographicTilingScheme.prototype.rectangleToNativeRectangle = function(rectangle, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('rectangle', rectangle);\r\n        //>>includeEnd('debug');\r\n\r\n        var west = CesiumMath.toDegrees(rectangle.west);\r\n        var south = CesiumMath.toDegrees(rectangle.south);\r\n        var east = CesiumMath.toDegrees(rectangle.east);\r\n        var north = CesiumMath.toDegrees(rectangle.north);\r\n\r\n        if (!defined(result)) {\r\n            return new Rectangle(west, south, east, north);\r\n        }\r\n\r\n        result.west = west;\r\n        result.south = south;\r\n        result.east = east;\r\n        result.north = north;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Converts tile x, y coordinates and level to a rectangle expressed in the native coordinates\r\n     * of the tiling scheme.\r\n     *\r\n     * @param {Number} x The integer x coordinate of the tile.\r\n     * @param {Number} y The integer y coordinate of the tile.\r\n     * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\r\n     * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance\r\n     *        should be created.\r\n     * @returns {Rectangle} The specified 'result', or a new object containing the rectangle\r\n     *          if 'result' is undefined.\r\n     */\r\n    GeographicTilingScheme.prototype.tileXYToNativeRectangle = function(x, y, level, result) {\r\n        var rectangleRadians = this.tileXYToRectangle(x, y, level, result);\r\n        rectangleRadians.west = CesiumMath.toDegrees(rectangleRadians.west);\r\n        rectangleRadians.south = CesiumMath.toDegrees(rectangleRadians.south);\r\n        rectangleRadians.east = CesiumMath.toDegrees(rectangleRadians.east);\r\n        rectangleRadians.north = CesiumMath.toDegrees(rectangleRadians.north);\r\n        return rectangleRadians;\r\n    };\r\n\r\n    /**\r\n     * Converts tile x, y coordinates and level to a cartographic rectangle in radians.\r\n     *\r\n     * @param {Number} x The integer x coordinate of the tile.\r\n     * @param {Number} y The integer y coordinate of the tile.\r\n     * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\r\n     * @param {Object} [result] The instance to which to copy the result, or undefined if a new instance\r\n     *        should be created.\r\n     * @returns {Rectangle} The specified 'result', or a new object containing the rectangle\r\n     *          if 'result' is undefined.\r\n     */\r\n    GeographicTilingScheme.prototype.tileXYToRectangle = function(x, y, level, result) {\r\n        var rectangle = this._rectangle;\r\n\r\n        var xTiles = this.getNumberOfXTilesAtLevel(level);\r\n        var yTiles = this.getNumberOfYTilesAtLevel(level);\r\n\r\n        var xTileWidth = rectangle.width / xTiles;\r\n        var west = x * xTileWidth + rectangle.west;\r\n        var east = (x + 1) * xTileWidth + rectangle.west;\r\n\r\n        var yTileHeight = rectangle.height / yTiles;\r\n        var north = rectangle.north - y * yTileHeight;\r\n        var south = rectangle.north - (y + 1) * yTileHeight;\r\n\r\n        if (!defined(result)) {\r\n            result = new Rectangle(west, south, east, north);\r\n        }\r\n\r\n        result.west = west;\r\n        result.south = south;\r\n        result.east = east;\r\n        result.north = north;\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Calculates the tile x, y coordinates of the tile containing\r\n     * a given cartographic position.\r\n     *\r\n     * @param {Cartographic} position The position.\r\n     * @param {Number} level The tile level-of-detail.  Zero is the least detailed.\r\n     * @param {Cartesian2} [result] The instance to which to copy the result, or undefined if a new instance\r\n     *        should be created.\r\n     * @returns {Cartesian2} The specified 'result', or a new object containing the tile x, y coordinates\r\n     *          if 'result' is undefined.\r\n     */\r\n    GeographicTilingScheme.prototype.positionToTileXY = function(position, level, result) {\r\n        var rectangle = this._rectangle;\r\n        if (!Rectangle.contains(rectangle, position)) {\r\n            // outside the bounds of the tiling scheme\r\n            return undefined;\r\n        }\r\n\r\n        var xTiles = this.getNumberOfXTilesAtLevel(level);\r\n        var yTiles = this.getNumberOfYTilesAtLevel(level);\r\n\r\n        var xTileWidth = rectangle.width / xTiles;\r\n        var yTileHeight = rectangle.height / yTiles;\r\n\r\n        var longitude = position.longitude;\r\n        if (rectangle.east < rectangle.west) {\r\n            longitude += CesiumMath.TWO_PI;\r\n        }\r\n\r\n        var xTileCoordinate = (longitude - rectangle.west) / xTileWidth | 0;\r\n        if (xTileCoordinate >= xTiles) {\r\n            xTileCoordinate = xTiles - 1;\r\n        }\r\n\r\n        var yTileCoordinate = (rectangle.north - position.latitude) / yTileHeight | 0;\r\n        if (yTileCoordinate >= yTiles) {\r\n            yTileCoordinate = yTiles - 1;\r\n        }\r\n\r\n        if (!defined(result)) {\r\n            return new Cartesian2(xTileCoordinate, yTileCoordinate);\r\n        }\r\n\r\n        result.x = xTileCoordinate;\r\n        result.y = yTileCoordinate;\r\n        return result;\r\n    };\r\nexport default GeographicTilingScheme;\r\n","import BoundingSphere from './BoundingSphere.js';\r\nimport buildModuleUrl from './buildModuleUrl.js';\r\nimport Cartesian2 from './Cartesian2.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport Cartographic from './Cartographic.js';\r\nimport Check from './Check.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport GeographicTilingScheme from './GeographicTilingScheme.js';\r\nimport Rectangle from './Rectangle.js';\r\nimport Resource from './Resource.js';\r\n\r\n    var scratchDiagonalCartesianNE = new Cartesian3();\r\n    var scratchDiagonalCartesianSW = new Cartesian3();\r\n    var scratchDiagonalCartographic = new Cartographic();\r\n    var scratchCenterCartesian = new Cartesian3();\r\n    var scratchSurfaceCartesian = new Cartesian3();\r\n\r\n    var scratchBoundingSphere = new BoundingSphere();\r\n    var tilingScheme = new GeographicTilingScheme();\r\n    var scratchCorners = [new Cartographic(), new Cartographic(), new Cartographic(), new Cartographic()];\r\n    var scratchTileXY = new Cartesian2();\r\n\r\n    /**\r\n     * A collection of functions for approximating terrain height\r\n     * @private\r\n     */\r\n    var ApproximateTerrainHeights = {};\r\n\r\n    /**\r\n     * Initializes the minimum and maximum terrain heights\r\n     * @return {Promise}\r\n     */\r\n    ApproximateTerrainHeights.initialize = function() {\r\n        var initPromise = ApproximateTerrainHeights._initPromise;\r\n        if (defined(initPromise)) {\r\n            return initPromise;\r\n        }\r\n\r\n        initPromise = Resource.fetchJson(buildModuleUrl('Assets/approximateTerrainHeights.json'))\r\n            .then(function(json) {\r\n                ApproximateTerrainHeights._terrainHeights = json;\r\n            });\r\n        ApproximateTerrainHeights._initPromise = initPromise;\r\n\r\n        return initPromise;\r\n    };\r\n\r\n    /**\r\n     * Computes the minimum and maximum terrain heights for a given rectangle\r\n     * @param {Rectangle} rectangle The bounding rectangle\r\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid\r\n     * @return {{minimumTerrainHeight: Number, maximumTerrainHeight: Number}}\r\n     */\r\n    ApproximateTerrainHeights.getMinimumMaximumHeights = function(rectangle, ellipsoid) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('rectangle', rectangle);\r\n        if (!defined(ApproximateTerrainHeights._terrainHeights)) {\r\n            throw new DeveloperError('You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function');\r\n        }\r\n        //>>includeEnd('debug');\r\n        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\r\n\r\n        var xyLevel = getTileXYLevel(rectangle);\r\n\r\n        // Get the terrain min/max for that tile\r\n        var minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\r\n        var maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\r\n        if (defined(xyLevel)) {\r\n            var key = xyLevel.level + '-' + xyLevel.x + '-' + xyLevel.y;\r\n            var heights = ApproximateTerrainHeights._terrainHeights[key];\r\n            if (defined(heights)) {\r\n                minTerrainHeight = heights[0];\r\n                maxTerrainHeight = heights[1];\r\n            }\r\n\r\n            // Compute min by taking the center of the NE->SW diagonal and finding distance to the surface\r\n            ellipsoid.cartographicToCartesian(Rectangle.northeast(rectangle, scratchDiagonalCartographic),\r\n                scratchDiagonalCartesianNE);\r\n            ellipsoid.cartographicToCartesian(Rectangle.southwest(rectangle, scratchDiagonalCartographic),\r\n                scratchDiagonalCartesianSW);\r\n\r\n            Cartesian3.midpoint(scratchDiagonalCartesianSW, scratchDiagonalCartesianNE, scratchCenterCartesian);\r\n            var surfacePosition = ellipsoid.scaleToGeodeticSurface(scratchCenterCartesian, scratchSurfaceCartesian);\r\n            if (defined(surfacePosition)) {\r\n                var distance = Cartesian3.distance(scratchCenterCartesian, surfacePosition);\r\n                minTerrainHeight = Math.min(minTerrainHeight, -distance);\r\n            } else {\r\n                minTerrainHeight = ApproximateTerrainHeights._defaultMinTerrainHeight;\r\n            }\r\n        }\r\n\r\n        minTerrainHeight = Math.max(ApproximateTerrainHeights._defaultMinTerrainHeight, minTerrainHeight);\r\n\r\n        return {\r\n            minimumTerrainHeight: minTerrainHeight,\r\n            maximumTerrainHeight: maxTerrainHeight\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Computes the bounding sphere based on the tile heights in the rectangle\r\n     * @param {Rectangle} rectangle The bounding rectangle\r\n     * @param {Ellipsoid} [ellipsoid=Ellipsoid.WGS84] The ellipsoid\r\n     * @return {BoundingSphere} The result bounding sphere\r\n     */\r\n    ApproximateTerrainHeights.getBoundingSphere = function(rectangle, ellipsoid) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('rectangle', rectangle);\r\n        if (!defined(ApproximateTerrainHeights._terrainHeights)) {\r\n            throw new DeveloperError('You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function');\r\n        }\r\n        //>>includeEnd('debug');\r\n        ellipsoid = defaultValue(ellipsoid, Ellipsoid.WGS84);\r\n\r\n        var xyLevel = getTileXYLevel(rectangle);\r\n\r\n        // Get the terrain max for that tile\r\n        var maxTerrainHeight = ApproximateTerrainHeights._defaultMaxTerrainHeight;\r\n        if (defined(xyLevel)) {\r\n            var key = xyLevel.level + '-' + xyLevel.x + '-' + xyLevel.y;\r\n            var heights = ApproximateTerrainHeights._terrainHeights[key];\r\n            if (defined(heights)) {\r\n                maxTerrainHeight = heights[1];\r\n            }\r\n        }\r\n\r\n        var result = BoundingSphere.fromRectangle3D(rectangle, ellipsoid, 0.0);\r\n        BoundingSphere.fromRectangle3D(rectangle, ellipsoid, maxTerrainHeight, scratchBoundingSphere);\r\n\r\n        return BoundingSphere.union(result, scratchBoundingSphere, result);\r\n    };\r\n\r\n    function getTileXYLevel(rectangle) {\r\n        Cartographic.fromRadians(rectangle.east, rectangle.north, 0.0, scratchCorners[0]);\r\n        Cartographic.fromRadians(rectangle.west, rectangle.north, 0.0, scratchCorners[1]);\r\n        Cartographic.fromRadians(rectangle.east, rectangle.south, 0.0, scratchCorners[2]);\r\n        Cartographic.fromRadians(rectangle.west, rectangle.south, 0.0, scratchCorners[3]);\r\n\r\n        // Determine which tile the bounding rectangle is in\r\n        var lastLevelX = 0, lastLevelY = 0;\r\n        var currentX = 0, currentY = 0;\r\n        var maxLevel = ApproximateTerrainHeights._terrainHeightsMaxLevel;\r\n        var i;\r\n        for(i = 0; i <= maxLevel; ++i) {\r\n            var failed = false;\r\n            for(var j = 0; j < 4; ++j) {\r\n                var corner = scratchCorners[j];\r\n                tilingScheme.positionToTileXY(corner, i, scratchTileXY);\r\n                if (j === 0) {\r\n                    currentX = scratchTileXY.x;\r\n                    currentY = scratchTileXY.y;\r\n                } else if(currentX !== scratchTileXY.x || currentY !== scratchTileXY.y) {\r\n                    failed = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (failed) {\r\n                break;\r\n            }\r\n\r\n            lastLevelX = currentX;\r\n            lastLevelY = currentY;\r\n        }\r\n\r\n        if (i === 0) {\r\n            return undefined;\r\n        }\r\n\r\n        return {\r\n            x : lastLevelX,\r\n            y : lastLevelY,\r\n            level : (i > maxLevel) ? maxLevel : (i - 1)\r\n        };\r\n    }\r\n\r\n    ApproximateTerrainHeights._terrainHeightsMaxLevel = 6;\r\n    ApproximateTerrainHeights._defaultMaxTerrainHeight = 9000.0;\r\n    ApproximateTerrainHeights._defaultMinTerrainHeight = -100000.0;\r\n    ApproximateTerrainHeights._terrainHeights = undefined;\r\n    ApproximateTerrainHeights._initPromise = undefined;\r\n\r\n    Object.defineProperties(ApproximateTerrainHeights, {\r\n        /**\r\n         * Determines if the terrain heights are initialized and ready to use. To initialize the terrain heights,\r\n         * call {@link ApproximateTerrainHeights#initialize} and wait for the returned promise to resolve.\r\n         * @type {Boolean}\r\n         * @readonly\r\n         * @memberof ApproximateTerrainHeights\r\n         */\r\n        initialized: {\r\n            get: function() {\r\n                return defined(ApproximateTerrainHeights._terrainHeights);\r\n            }\r\n        }\r\n    });\r\nexport default ApproximateTerrainHeights;\r\n","import ApproximateTerrainHeights from './ApproximateTerrainHeights.js';\r\nimport ArcType from './ArcType.js';\r\nimport arrayRemoveDuplicates from './arrayRemoveDuplicates.js';\r\nimport BoundingSphere from './BoundingSphere.js';\r\nimport Cartesian3 from './Cartesian3.js';\r\nimport Cartographic from './Cartographic.js';\r\nimport Check from './Check.js';\r\nimport ComponentDatatype from './ComponentDatatype.js';\r\nimport defaultValue from './defaultValue.js';\r\nimport defined from './defined.js';\r\nimport DeveloperError from './DeveloperError.js';\r\nimport Ellipsoid from './Ellipsoid.js';\r\nimport EllipsoidGeodesic from './EllipsoidGeodesic.js';\r\nimport EllipsoidRhumbLine from './EllipsoidRhumbLine.js';\r\nimport EncodedCartesian3 from './EncodedCartesian3.js';\r\nimport GeographicProjection from './GeographicProjection.js';\r\nimport Geometry from './Geometry.js';\r\nimport GeometryAttribute from './GeometryAttribute.js';\r\nimport IntersectionTests from './IntersectionTests.js';\r\nimport CesiumMath from './Math.js';\r\nimport Matrix3 from './Matrix3.js';\r\nimport Plane from './Plane.js';\r\nimport Quaternion from './Quaternion.js';\r\nimport Rectangle from './Rectangle.js';\r\nimport WebMercatorProjection from './WebMercatorProjection.js';\r\n\r\n    var PROJECTIONS = [GeographicProjection, WebMercatorProjection];\r\n    var PROJECTION_COUNT = PROJECTIONS.length;\r\n\r\n    var MITER_BREAK_SMALL = Math.cos(CesiumMath.toRadians(30.0));\r\n    var MITER_BREAK_LARGE = Math.cos(CesiumMath.toRadians(150.0));\r\n\r\n    // Initial heights for constructing the wall.\r\n    // Keeping WALL_INITIAL_MIN_HEIGHT near the ellipsoid surface helps\r\n    // prevent precision problems with planes in the shader.\r\n    // Putting the start point of a plane at ApproximateTerrainHeights._defaultMinTerrainHeight,\r\n    // which is a highly conservative bound, usually puts the plane origin several thousands\r\n    // of meters away from the actual terrain, causing floating point problems when checking\r\n    // fragments on terrain against the plane.\r\n    // Ellipsoid height is generally much closer.\r\n    // The initial max height is arbitrary.\r\n    // Both heights are corrected using ApproximateTerrainHeights for computing the actual volume geometry.\r\n    var WALL_INITIAL_MIN_HEIGHT = 0.0;\r\n    var WALL_INITIAL_MAX_HEIGHT = 1000.0;\r\n\r\n    /**\r\n     * A description of a polyline on terrain or 3D Tiles. Only to be used with {@link GroundPolylinePrimitive}.\r\n     *\r\n     * @alias GroundPolylineGeometry\r\n     * @constructor\r\n     *\r\n     * @param {Object} options Options with the following properties:\r\n     * @param {Cartesian3[]} options.positions An array of {@link Cartesian3} defining the polyline's points. Heights above the ellipsoid will be ignored.\r\n     * @param {Number} [options.width=1.0] The screen space width in pixels.\r\n     * @param {Number} [options.granularity=9999.0] The distance interval in meters used for interpolating options.points. Defaults to 9999.0 meters. Zero indicates no interpolation.\r\n     * @param {Boolean} [options.loop=false] Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.\r\n     * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polyline segments must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\r\n     *\r\n     * @exception {DeveloperError} At least two positions are required.\r\n     *\r\n     * @see GroundPolylinePrimitive\r\n     *\r\n     * @example\r\n     * var positions = Cesium.Cartesian3.fromDegreesArray([\r\n     *   -112.1340164450331, 36.05494287836128,\r\n     *   -112.08821010582645, 36.097804071380715,\r\n     *   -112.13296079730024, 36.168769146801104\r\n     * ]);\r\n     *\r\n     * var geometry = new Cesium.GroundPolylineGeometry({\r\n     *   positions : positions\r\n     * });\r\n     */\r\n    function GroundPolylineGeometry(options) {\r\n        options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n        var positions = options.positions;\r\n\r\n        //>>includeStart('debug', pragmas.debug);\r\n        if ((!defined(positions)) || (positions.length < 2)) {\r\n            throw new DeveloperError('At least two positions are required.');\r\n        }\r\n        if (defined(options.arcType) && options.arcType !== ArcType.GEODESIC && options.arcType !== ArcType.RHUMB) {\r\n            throw new DeveloperError('Valid options for arcType are ArcType.GEODESIC and ArcType.RHUMB.');\r\n        }\r\n        //>>includeEnd('debug');\r\n\r\n        /**\r\n         * The screen space width in pixels.\r\n         * @type {Number}\r\n         */\r\n        this.width = defaultValue(options.width, 1.0); // Doesn't get packed, not necessary for computing geometry.\r\n\r\n        this._positions = positions;\r\n\r\n        /**\r\n         * The distance interval used for interpolating options.points. Zero indicates no interpolation.\r\n         * Default of 9999.0 allows centimeter accuracy with 32 bit floating point.\r\n         * @type {Boolean}\r\n         * @default 9999.0\r\n         */\r\n        this.granularity = defaultValue(options.granularity, 9999.0);\r\n\r\n        /**\r\n         * Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.\r\n         * If the geometry has two positions this parameter will be ignored.\r\n         * @type {Boolean}\r\n         * @default false\r\n         */\r\n        this.loop = defaultValue(options.loop, false);\r\n\r\n        /**\r\n         * The type of path the polyline must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\r\n         * @type {ArcType}\r\n         * @default ArcType.GEODESIC\r\n         */\r\n        this.arcType = defaultValue(options.arcType, ArcType.GEODESIC);\r\n\r\n        this._ellipsoid = Ellipsoid.WGS84;\r\n\r\n        // MapProjections can't be packed, so store the index to a known MapProjection.\r\n        this._projectionIndex = 0;\r\n        this._workerName = 'createGroundPolylineGeometry';\r\n\r\n        // Used by GroundPolylinePrimitive to signal worker that scenemode is 3D only.\r\n        this._scene3DOnly = false;\r\n    }\r\n\r\n    Object.defineProperties(GroundPolylineGeometry.prototype, {\r\n        /**\r\n         * The number of elements used to pack the object into an array.\r\n         * @memberof GroundPolylineGeometry.prototype\r\n         * @type {Number}\r\n         * @readonly\r\n         * @private\r\n         */\r\n        packedLength: {\r\n            get: function() {\r\n                return 1.0 + this._positions.length * 3 + 1.0 + 1.0 + 1.0 + Ellipsoid.packedLength + 1.0 + 1.0;\r\n            }\r\n        }\r\n    });\r\n\r\n    /**\r\n     * Set the GroundPolylineGeometry's projection and ellipsoid.\r\n     * Used by GroundPolylinePrimitive to signal scene information to the geometry for generating 2D attributes.\r\n     *\r\n     * @param {GroundPolylineGeometry} groundPolylineGeometry GroundPolylinGeometry describing a polyline on terrain or 3D Tiles.\r\n     * @param {Projection} mapProjection A MapProjection used for projecting cartographic coordinates to 2D.\r\n     * @private\r\n     */\r\n    GroundPolylineGeometry.setProjectionAndEllipsoid = function(groundPolylineGeometry, mapProjection) {\r\n        var projectionIndex = 0;\r\n        for (var i = 0; i < PROJECTION_COUNT; i++) {\r\n            if (mapProjection instanceof PROJECTIONS[i]) {\r\n                projectionIndex = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        groundPolylineGeometry._projectionIndex = projectionIndex;\r\n        groundPolylineGeometry._ellipsoid = mapProjection.ellipsoid;\r\n    };\r\n\r\n    var cart3Scratch1 = new Cartesian3();\r\n    var cart3Scratch2 = new Cartesian3();\r\n    var cart3Scratch3 = new Cartesian3();\r\n    function computeRightNormal(start, end, maxHeight, ellipsoid, result) {\r\n        var startBottom = getPosition(ellipsoid, start, 0.0, cart3Scratch1);\r\n        var startTop = getPosition(ellipsoid, start, maxHeight, cart3Scratch2);\r\n        var endBottom = getPosition(ellipsoid, end, 0.0, cart3Scratch3);\r\n\r\n        var up = direction(startTop, startBottom, cart3Scratch2);\r\n        var forward = direction(endBottom, startBottom, cart3Scratch3);\r\n\r\n        Cartesian3.cross(forward, up, result);\r\n        return Cartesian3.normalize(result, result);\r\n    }\r\n\r\n    var interpolatedCartographicScratch = new Cartographic();\r\n    var interpolatedBottomScratch = new Cartesian3();\r\n    var interpolatedTopScratch = new Cartesian3();\r\n    var interpolatedNormalScratch = new Cartesian3();\r\n    function interpolateSegment(start, end, minHeight, maxHeight, granularity, arcType, ellipsoid, normalsArray, bottomPositionsArray, topPositionsArray, cartographicsArray) {\r\n        if (granularity === 0.0) {\r\n            return;\r\n        }\r\n\r\n        var ellipsoidLine;\r\n        if (arcType === ArcType.GEODESIC) {\r\n            ellipsoidLine = new EllipsoidGeodesic(start, end, ellipsoid);\r\n        } else if (arcType === ArcType.RHUMB) {\r\n            ellipsoidLine = new EllipsoidRhumbLine(start, end, ellipsoid);\r\n        }\r\n\r\n        var surfaceDistance = ellipsoidLine.surfaceDistance;\r\n        if (surfaceDistance < granularity) {\r\n            return;\r\n        }\r\n\r\n        // Compute rightwards normal applicable at all interpolated points\r\n        var interpolatedNormal = computeRightNormal(start, end, maxHeight, ellipsoid, interpolatedNormalScratch);\r\n\r\n        var segments = Math.ceil(surfaceDistance / granularity);\r\n        var interpointDistance = surfaceDistance / segments;\r\n        var distanceFromStart = interpointDistance;\r\n        var pointsToAdd = segments - 1;\r\n        var packIndex = normalsArray.length;\r\n        for (var i = 0; i < pointsToAdd; i++) {\r\n            var interpolatedCartographic = ellipsoidLine.interpolateUsingSurfaceDistance(distanceFromStart, interpolatedCartographicScratch);\r\n            var interpolatedBottom = getPosition(ellipsoid, interpolatedCartographic, minHeight, interpolatedBottomScratch);\r\n            var interpolatedTop = getPosition(ellipsoid, interpolatedCartographic, maxHeight, interpolatedTopScratch);\r\n\r\n            Cartesian3.pack(interpolatedNormal, normalsArray, packIndex);\r\n            Cartesian3.pack(interpolatedBottom, bottomPositionsArray, packIndex);\r\n            Cartesian3.pack(interpolatedTop, topPositionsArray, packIndex);\r\n            cartographicsArray.push(interpolatedCartographic.latitude);\r\n            cartographicsArray.push(interpolatedCartographic.longitude);\r\n\r\n            packIndex += 3;\r\n            distanceFromStart += interpointDistance;\r\n        }\r\n    }\r\n\r\n    var heightlessCartographicScratch = new Cartographic();\r\n    function getPosition(ellipsoid, cartographic, height, result) {\r\n        Cartographic.clone(cartographic, heightlessCartographicScratch);\r\n        heightlessCartographicScratch.height = height;\r\n        return Cartographic.toCartesian(heightlessCartographicScratch, ellipsoid, result);\r\n    }\r\n\r\n    /**\r\n     * Stores the provided instance into the provided array.\r\n     *\r\n     * @param {PolygonGeometry} value The value to pack.\r\n     * @param {Number[]} array The array to pack into.\r\n     * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n     *\r\n     * @returns {Number[]} The array that was packed into\r\n     */\r\n    GroundPolylineGeometry.pack = function(value, array, startingIndex) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.typeOf.object('value', value);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        var index = defaultValue(startingIndex, 0);\r\n\r\n        var positions = value._positions;\r\n        var positionsLength = positions.length;\r\n\r\n        array[index++] = positionsLength;\r\n\r\n        for (var i = 0; i < positionsLength; ++i) {\r\n            var cartesian = positions[i];\r\n            Cartesian3.pack(cartesian, array, index);\r\n            index += 3;\r\n        }\r\n\r\n        array[index++] = value.granularity;\r\n        array[index++] = value.loop ? 1.0 : 0.0;\r\n        array[index++] = value.arcType;\r\n\r\n        Ellipsoid.pack(value._ellipsoid, array, index);\r\n        index += Ellipsoid.packedLength;\r\n\r\n        array[index++] = value._projectionIndex;\r\n        array[index++] = value._scene3DOnly ? 1.0 : 0.0;\r\n\r\n        return array;\r\n    };\r\n\r\n    /**\r\n     * Retrieves an instance from a packed array.\r\n     *\r\n     * @param {Number[]} array The packed array.\r\n     * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n     * @param {PolygonGeometry} [result] The object into which to store the result.\r\n     */\r\n    GroundPolylineGeometry.unpack = function(array, startingIndex, result) {\r\n        //>>includeStart('debug', pragmas.debug);\r\n        Check.defined('array', array);\r\n        //>>includeEnd('debug');\r\n\r\n        var index = defaultValue(startingIndex, 0);\r\n        var positionsLength = array[index++];\r\n        var positions = new Array(positionsLength);\r\n\r\n        for (var i = 0; i < positionsLength; i++) {\r\n            positions[i] = Cartesian3.unpack(array, index);\r\n            index += 3;\r\n        }\r\n\r\n        var granularity = array[index++];\r\n        var loop = array[index++] === 1.0;\r\n        var arcType = array[index++];\r\n\r\n        var ellipsoid = Ellipsoid.unpack(array, index);\r\n        index += Ellipsoid.packedLength;\r\n\r\n        var projectionIndex = array[index++];\r\n        var scene3DOnly = (array[index++] === 1.0);\r\n\r\n        if (!defined(result)) {\r\n            result = new GroundPolylineGeometry({\r\n                positions : positions\r\n            });\r\n        }\r\n\r\n        result._positions = positions;\r\n        result.granularity = granularity;\r\n        result.loop = loop;\r\n        result.arcType = arcType;\r\n        result._ellipsoid = ellipsoid;\r\n        result._projectionIndex = projectionIndex;\r\n        result._scene3DOnly = scene3DOnly;\r\n\r\n        return result;\r\n    };\r\n\r\n    function direction(target, origin, result) {\r\n        Cartesian3.subtract(target, origin, result);\r\n        Cartesian3.normalize(result, result);\r\n        return result;\r\n    }\r\n\r\n    function tangentDirection(target, origin, up, result) {\r\n        result = direction(target, origin, result);\r\n\r\n        // orthogonalize\r\n        result = Cartesian3.cross(result, up, result);\r\n        result = Cartesian3.normalize(result, result);\r\n        result = Cartesian3.cross(up, result, result);\r\n        return result;\r\n    }\r\n\r\n    var toPreviousScratch = new Cartesian3();\r\n    var toNextScratch = new Cartesian3();\r\n    var forwardScratch = new Cartesian3();\r\n    var vertexUpScratch = new Cartesian3();\r\n    var cosine90 = 0.0;\r\n    var cosine180 = -1.0;\r\n    function computeVertexMiterNormal(previousBottom, vertexBottom, vertexTop, nextBottom, result) {\r\n        var up = direction(vertexTop, vertexBottom, vertexUpScratch);\r\n\r\n        // Compute vectors pointing towards neighboring points but tangent to this point on the ellipsoid\r\n        var toPrevious = tangentDirection(previousBottom, vertexBottom, up, toPreviousScratch);\r\n        var toNext = tangentDirection(nextBottom, vertexBottom, up, toNextScratch);\r\n\r\n        // Check if tangents are almost opposite - if so, no need to miter.\r\n        if (CesiumMath.equalsEpsilon(Cartesian3.dot(toPrevious, toNext), cosine180, CesiumMath.EPSILON5)) {\r\n             result = Cartesian3.cross(up, toPrevious, result);\r\n             result = Cartesian3.normalize(result, result);\r\n             return result;\r\n        }\r\n\r\n        // Average directions to previous and to next in the plane of Up\r\n        result = Cartesian3.add(toNext, toPrevious, result);\r\n        result = Cartesian3.normalize(result, result);\r\n\r\n        // Flip the normal if it isn't pointing roughly bound right (aka if forward is pointing more \"backwards\")\r\n        var forward = Cartesian3.cross(up, result, forwardScratch);\r\n        if (Cartesian3.dot(toNext, forward) < cosine90) {\r\n            result = Cartesian3.negate(result, result);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    var XZ_PLANE = Plane.fromPointNormal(Cartesian3.ZERO, Cartesian3.UNIT_Y);\r\n\r\n    var previousBottomScratch = new Cartesian3();\r\n    var vertexBottomScratch = new Cartesian3();\r\n    var vertexTopScratch = new Cartesian3();\r\n    var nextBottomScratch = new Cartesian3();\r\n    var vertexNormalScratch = new Cartesian3();\r\n    var intersectionScratch = new Cartesian3();\r\n    var cartographicScratch0 = new Cartographic();\r\n    var cartographicScratch1 = new Cartographic();\r\n    var cartographicIntersectionScratch = new Cartographic();\r\n    /**\r\n     * Computes shadow volumes for the ground polyline, consisting of its vertices, indices, and a bounding sphere.\r\n     * Vertices are \"fat,\" packing all the data needed in each volume to describe a line on terrain or 3D Tiles.\r\n     * Should not be called independent of {@link GroundPolylinePrimitive}.\r\n     *\r\n     * @param {GroundPolylineGeometry} groundPolylineGeometry\r\n     * @private\r\n     */\r\n    GroundPolylineGeometry.createGeometry = function(groundPolylineGeometry) {\r\n        var compute2dAttributes = !groundPolylineGeometry._scene3DOnly;\r\n        var loop = groundPolylineGeometry.loop;\r\n        var ellipsoid = groundPolylineGeometry._ellipsoid;\r\n        var granularity = groundPolylineGeometry.granularity;\r\n        var arcType = groundPolylineGeometry.arcType;\r\n        var projection = new PROJECTIONS[groundPolylineGeometry._projectionIndex](ellipsoid);\r\n\r\n        var minHeight = WALL_INITIAL_MIN_HEIGHT;\r\n        var maxHeight = WALL_INITIAL_MAX_HEIGHT;\r\n\r\n        var index;\r\n        var i;\r\n\r\n        var positions = groundPolylineGeometry._positions;\r\n        var positionsLength = positions.length;\r\n\r\n        if (positionsLength === 2) {\r\n            loop = false;\r\n        }\r\n\r\n        // Split positions across the IDL and the Prime Meridian as well.\r\n        // Split across prime meridian because very large geometries crossing the Prime Meridian but not the IDL\r\n        // may get split by the plane of IDL + Prime Meridian.\r\n        var p0;\r\n        var p1;\r\n        var c0;\r\n        var c1;\r\n        var rhumbLine = new EllipsoidRhumbLine(undefined, undefined, ellipsoid);\r\n        var intersection;\r\n        var intersectionCartographic;\r\n        var intersectionLongitude;\r\n        var splitPositions = [positions[0]];\r\n        for (i = 0; i < positionsLength - 1; i++) {\r\n            p0 = positions[i];\r\n            p1 = positions[i + 1];\r\n            intersection = IntersectionTests.lineSegmentPlane(p0, p1, XZ_PLANE, intersectionScratch);\r\n            if (defined(intersection) &&\r\n                !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\r\n                !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)) {\r\n                if (groundPolylineGeometry.arcType === ArcType.GEODESIC) {\r\n                    splitPositions.push(Cartesian3.clone(intersection));\r\n                } else if (groundPolylineGeometry.arcType === ArcType.RHUMB) {\r\n                    intersectionLongitude = ellipsoid.cartesianToCartographic(intersection, cartographicScratch0).longitude;\r\n                    c0 = ellipsoid.cartesianToCartographic(p0, cartographicScratch0);\r\n                    c1 = ellipsoid.cartesianToCartographic(p1, cartographicScratch1);\r\n                    rhumbLine.setEndPoints(c0, c1);\r\n                    intersectionCartographic = rhumbLine.findIntersectionWithLongitude(intersectionLongitude, cartographicIntersectionScratch);\r\n                    intersection = ellipsoid.cartographicToCartesian(intersectionCartographic, intersectionScratch);\r\n                    if (defined(intersection) &&\r\n                        !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\r\n                        !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)) {\r\n                        splitPositions.push(Cartesian3.clone(intersection));\r\n                    }\r\n                }\r\n            }\r\n            splitPositions.push(p1);\r\n        }\r\n\r\n        if (loop) {\r\n            p0 = positions[positionsLength - 1];\r\n            p1 = positions[0];\r\n            intersection = IntersectionTests.lineSegmentPlane(p0, p1, XZ_PLANE, intersectionScratch);\r\n            if (defined(intersection) &&\r\n                !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\r\n                !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)) {\r\n                if (groundPolylineGeometry.arcType === ArcType.GEODESIC) {\r\n                    splitPositions.push(Cartesian3.clone(intersection));\r\n                } else if (groundPolylineGeometry.arcType === ArcType.RHUMB) {\r\n                    intersectionLongitude = ellipsoid.cartesianToCartographic(intersection, cartographicScratch0).longitude;\r\n                    c0 = ellipsoid.cartesianToCartographic(p0, cartographicScratch0);\r\n                    c1 = ellipsoid.cartesianToCartographic(p1, cartographicScratch1);\r\n                    rhumbLine.setEndPoints(c0, c1);\r\n                    intersectionCartographic = rhumbLine.findIntersectionWithLongitude(intersectionLongitude, cartographicIntersectionScratch);\r\n                    intersection = ellipsoid.cartographicToCartesian(intersectionCartographic, intersectionScratch);\r\n                    if (defined(intersection) &&\r\n                        !Cartesian3.equalsEpsilon(intersection, p0, CesiumMath.EPSILON7) &&\r\n                        !Cartesian3.equalsEpsilon(intersection, p1, CesiumMath.EPSILON7)) {\r\n                        splitPositions.push(Cartesian3.clone(intersection));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        var cartographicsLength = splitPositions.length;\r\n\r\n        var cartographics = new Array(cartographicsLength);\r\n        for (i = 0; i < cartographicsLength; i++) {\r\n            var cartographic = Cartographic.fromCartesian(splitPositions[i], ellipsoid);\r\n            cartographic.height = 0.0;\r\n            cartographics[i] = cartographic;\r\n        }\r\n\r\n        cartographics = arrayRemoveDuplicates(cartographics, Cartographic.equalsEpsilon);\r\n        cartographicsLength = cartographics.length;\r\n\r\n        if (cartographicsLength < 2) {\r\n            return undefined;\r\n        }\r\n\r\n        /**** Build heap-side arrays for positions, interpolated cartographics, and normals from which to compute vertices ****/\r\n        // We build a \"wall\" and then decompose it into separately connected component \"volumes\" because we need a lot\r\n        // of information about the wall. Also, this simplifies interpolation.\r\n        // Convention: \"next\" and \"end\" are locally forward to each segment of the wall,\r\n        // and we are computing normals pointing towards the local right side of the vertices in each segment.\r\n        var cartographicsArray = [];\r\n        var normalsArray = [];\r\n        var bottomPositionsArray = [];\r\n        var topPositionsArray = [];\r\n\r\n        var previousBottom = previousBottomScratch;\r\n        var vertexBottom = vertexBottomScratch;\r\n        var vertexTop = vertexTopScratch;\r\n        var nextBottom = nextBottomScratch;\r\n        var vertexNormal = vertexNormalScratch;\r\n\r\n        // First point - either loop or attach a \"perpendicular\" normal\r\n        var startCartographic = cartographics[0];\r\n        var nextCartographic = cartographics[1];\r\n\r\n        var prestartCartographic = cartographics[cartographicsLength - 1];\r\n        previousBottom = getPosition(ellipsoid, prestartCartographic, minHeight, previousBottom);\r\n        nextBottom = getPosition(ellipsoid, nextCartographic, minHeight, nextBottom);\r\n        vertexBottom = getPosition(ellipsoid, startCartographic, minHeight, vertexBottom);\r\n        vertexTop = getPosition(ellipsoid, startCartographic, maxHeight, vertexTop);\r\n\r\n        if (loop) {\r\n            vertexNormal = computeVertexMiterNormal(previousBottom, vertexBottom, vertexTop, nextBottom, vertexNormal);\r\n        } else {\r\n            vertexNormal = computeRightNormal(startCartographic, nextCartographic, maxHeight, ellipsoid, vertexNormal);\r\n        }\r\n\r\n        Cartesian3.pack(vertexNormal, normalsArray, 0);\r\n        Cartesian3.pack(vertexBottom, bottomPositionsArray, 0);\r\n        Cartesian3.pack(vertexTop, topPositionsArray, 0);\r\n        cartographicsArray.push(startCartographic.latitude);\r\n        cartographicsArray.push(startCartographic.longitude);\r\n\r\n        interpolateSegment(startCartographic, nextCartographic, minHeight, maxHeight, granularity, arcType, ellipsoid, normalsArray, bottomPositionsArray, topPositionsArray, cartographicsArray);\r\n\r\n        // All inbetween points\r\n        for (i = 1; i < cartographicsLength - 1; ++i) {\r\n            previousBottom = Cartesian3.clone(vertexBottom, previousBottom);\r\n            vertexBottom = Cartesian3.clone(nextBottom, vertexBottom);\r\n            var vertexCartographic = cartographics[i];\r\n            getPosition(ellipsoid, vertexCartographic, maxHeight, vertexTop);\r\n            getPosition(ellipsoid, cartographics[i + 1], minHeight, nextBottom);\r\n\r\n            computeVertexMiterNormal(previousBottom, vertexBottom, vertexTop, nextBottom, vertexNormal);\r\n\r\n            index = normalsArray.length;\r\n            Cartesian3.pack(vertexNormal, normalsArray, index);\r\n            Cartesian3.pack(vertexBottom, bottomPositionsArray, index);\r\n            Cartesian3.pack(vertexTop, topPositionsArray, index);\r\n            cartographicsArray.push(vertexCartographic.latitude);\r\n            cartographicsArray.push(vertexCartographic.longitude);\r\n\r\n            interpolateSegment(cartographics[i], cartographics[i + 1], minHeight, maxHeight, granularity, arcType, ellipsoid, normalsArray, bottomPositionsArray, topPositionsArray, cartographicsArray);\r\n        }\r\n\r\n        // Last point - either loop or attach a normal \"perpendicular\" to the wall.\r\n        var endCartographic = cartographics[cartographicsLength - 1];\r\n        var preEndCartographic = cartographics[cartographicsLength - 2];\r\n\r\n        vertexBottom = getPosition(ellipsoid, endCartographic, minHeight, vertexBottom);\r\n        vertexTop = getPosition(ellipsoid, endCartographic, maxHeight, vertexTop);\r\n\r\n        if (loop) {\r\n            var postEndCartographic = cartographics[0];\r\n            previousBottom = getPosition(ellipsoid, preEndCartographic, minHeight, previousBottom);\r\n            nextBottom = getPosition(ellipsoid, postEndCartographic, minHeight, nextBottom);\r\n\r\n            vertexNormal = computeVertexMiterNormal(previousBottom, vertexBottom, vertexTop, nextBottom, vertexNormal);\r\n        } else {\r\n            vertexNormal = computeRightNormal(preEndCartographic, endCartographic, maxHeight, ellipsoid, vertexNormal);\r\n        }\r\n\r\n        index = normalsArray.length;\r\n        Cartesian3.pack(vertexNormal, normalsArray, index);\r\n        Cartesian3.pack(vertexBottom, bottomPositionsArray, index);\r\n        Cartesian3.pack(vertexTop, topPositionsArray, index);\r\n        cartographicsArray.push(endCartographic.latitude);\r\n        cartographicsArray.push(endCartographic.longitude);\r\n\r\n        if (loop) {\r\n            interpolateSegment(endCartographic, startCartographic, minHeight, maxHeight, granularity, arcType, ellipsoid, normalsArray, bottomPositionsArray, topPositionsArray, cartographicsArray);\r\n            index = normalsArray.length;\r\n            for (i = 0; i < 3; ++i) {\r\n                normalsArray[index + i] = normalsArray[i];\r\n                bottomPositionsArray[index + i] = bottomPositionsArray[i];\r\n                topPositionsArray[index + i] = topPositionsArray[i];\r\n            }\r\n            cartographicsArray.push(startCartographic.latitude);\r\n            cartographicsArray.push(startCartographic.longitude);\r\n        }\r\n\r\n        return generateGeometryAttributes(loop, projection, bottomPositionsArray, topPositionsArray, normalsArray, cartographicsArray, compute2dAttributes);\r\n    };\r\n\r\n    // If the end normal angle is too steep compared to the direction of the line segment,\r\n    // \"break\" the miter by rotating the normal 90 degrees around the \"up\" direction at the point\r\n    // For ultra precision we would want to project into a plane, but in practice this is sufficient.\r\n    var lineDirectionScratch = new Cartesian3();\r\n    var matrix3Scratch = new Matrix3();\r\n    var quaternionScratch = new Quaternion();\r\n    function breakMiter(endGeometryNormal, startBottom, endBottom, endTop) {\r\n        var lineDirection = direction(endBottom, startBottom, lineDirectionScratch);\r\n\r\n        var dot = Cartesian3.dot(lineDirection, endGeometryNormal);\r\n        if (dot > MITER_BREAK_SMALL || dot < MITER_BREAK_LARGE) {\r\n            var vertexUp = direction(endTop, endBottom, vertexUpScratch);\r\n            var angle = dot < MITER_BREAK_LARGE ? CesiumMath.PI_OVER_TWO : -CesiumMath.PI_OVER_TWO;\r\n            var quaternion = Quaternion.fromAxisAngle(vertexUp, angle, quaternionScratch);\r\n            var rotationMatrix = Matrix3.fromQuaternion(quaternion, matrix3Scratch);\r\n            Matrix3.multiplyByVector(rotationMatrix, endGeometryNormal, endGeometryNormal);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    var endPosCartographicScratch = new Cartographic();\r\n    var normalStartpointScratch = new Cartesian3();\r\n    var normalEndpointScratch = new Cartesian3();\r\n    function projectNormal(projection, cartographic, normal, projectedPosition, result) {\r\n        var position = Cartographic.toCartesian(cartographic, projection._ellipsoid, normalStartpointScratch);\r\n        var normalEndpoint = Cartesian3.add(position, normal, normalEndpointScratch);\r\n        var flipNormal = false;\r\n\r\n        var ellipsoid = projection._ellipsoid;\r\n        var normalEndpointCartographic = ellipsoid.cartesianToCartographic(normalEndpoint, endPosCartographicScratch);\r\n        // If normal crosses the IDL, go the other way and flip the result.\r\n        // In practice this almost never happens because the cartographic start\r\n        // and end points of each segment are \"nudged\" to be on the same side\r\n        // of the IDL and slightly away from the IDL.\r\n        if (Math.abs(cartographic.longitude - normalEndpointCartographic.longitude) > CesiumMath.PI_OVER_TWO) {\r\n            flipNormal = true;\r\n            normalEndpoint = Cartesian3.subtract(position, normal, normalEndpointScratch);\r\n            normalEndpointCartographic = ellipsoid.cartesianToCartographic(normalEndpoint, endPosCartographicScratch);\r\n        }\r\n\r\n        normalEndpointCartographic.height = 0.0;\r\n        var normalEndpointProjected = projection.project(normalEndpointCartographic, result);\r\n        result = Cartesian3.subtract(normalEndpointProjected, projectedPosition, result);\r\n        result.z = 0.0;\r\n        result = Cartesian3.normalize(result, result);\r\n        if (flipNormal) {\r\n            Cartesian3.negate(result, result);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    var adjustHeightNormalScratch = new Cartesian3();\r\n    var adjustHeightOffsetScratch = new Cartesian3();\r\n    function adjustHeights(bottom, top, minHeight, maxHeight, adjustHeightBottom, adjustHeightTop) {\r\n        // bottom and top should be at WALL_INITIAL_MIN_HEIGHT and WALL_INITIAL_MAX_HEIGHT, respectively\r\n        var adjustHeightNormal = Cartesian3.subtract(top, bottom, adjustHeightNormalScratch);\r\n        Cartesian3.normalize(adjustHeightNormal, adjustHeightNormal);\r\n\r\n        var distanceForBottom = minHeight - WALL_INITIAL_MIN_HEIGHT;\r\n        var adjustHeightOffset = Cartesian3.multiplyByScalar(adjustHeightNormal, distanceForBottom, adjustHeightOffsetScratch);\r\n        Cartesian3.add(bottom, adjustHeightOffset, adjustHeightBottom);\r\n\r\n        var distanceForTop = maxHeight - WALL_INITIAL_MAX_HEIGHT;\r\n        adjustHeightOffset = Cartesian3.multiplyByScalar(adjustHeightNormal, distanceForTop, adjustHeightOffsetScratch);\r\n        Cartesian3.add(top, adjustHeightOffset, adjustHeightTop);\r\n    }\r\n\r\n    var nudgeDirectionScratch = new Cartesian3();\r\n    function nudgeXZ(start, end) {\r\n        var startToXZdistance = Plane.getPointDistance(XZ_PLANE, start);\r\n        var endToXZdistance = Plane.getPointDistance(XZ_PLANE, end);\r\n        var offset = nudgeDirectionScratch;\r\n        // Larger epsilon than what's used in GeometryPipeline, a centimeter in world space\r\n        if (CesiumMath.equalsEpsilon(startToXZdistance, 0.0, CesiumMath.EPSILON2)) {\r\n            offset = direction(end, start, offset);\r\n            Cartesian3.multiplyByScalar(offset, CesiumMath.EPSILON2, offset);\r\n            Cartesian3.add(start, offset, start);\r\n        } else if (CesiumMath.equalsEpsilon(endToXZdistance, 0.0, CesiumMath.EPSILON2)) {\r\n            offset = direction(start, end, offset);\r\n            Cartesian3.multiplyByScalar(offset, CesiumMath.EPSILON2, offset);\r\n            Cartesian3.add(end, offset, end);\r\n        }\r\n    }\r\n\r\n    // \"Nudge\" cartographic coordinates so start and end are on the same side of the IDL.\r\n    // Nudge amounts are tiny, basically just an IDL flip.\r\n    // Only used for 2D/CV.\r\n    function nudgeCartographic(start, end) {\r\n        var absStartLon = Math.abs(start.longitude);\r\n        var absEndLon = Math.abs(end.longitude);\r\n        if (CesiumMath.equalsEpsilon(absStartLon, CesiumMath.PI, CesiumMath.EPSILON11)) {\r\n            var endSign = CesiumMath.sign(end.longitude);\r\n            start.longitude = endSign * (absStartLon - CesiumMath.EPSILON11);\r\n            return 1;\r\n        } else if (CesiumMath.equalsEpsilon(absEndLon, CesiumMath.PI, CesiumMath.EPSILON11)) {\r\n            var startSign = CesiumMath.sign(start.longitude);\r\n            end.longitude = startSign * (absEndLon - CesiumMath.EPSILON11);\r\n            return 2;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    var startCartographicScratch = new Cartographic();\r\n    var endCartographicScratch = new Cartographic();\r\n\r\n    var segmentStartTopScratch = new Cartesian3();\r\n    var segmentEndTopScratch = new Cartesian3();\r\n    var segmentStartBottomScratch = new Cartesian3();\r\n    var segmentEndBottomScratch = new Cartesian3();\r\n    var segmentStartNormalScratch = new Cartesian3();\r\n    var segmentEndNormalScratch = new Cartesian3();\r\n\r\n    var getHeightCartographics = [startCartographicScratch, endCartographicScratch];\r\n    var getHeightRectangleScratch = new Rectangle();\r\n\r\n    var adjustHeightStartTopScratch = new Cartesian3();\r\n    var adjustHeightEndTopScratch = new Cartesian3();\r\n    var adjustHeightStartBottomScratch = new Cartesian3();\r\n    var adjustHeightEndBottomScratch = new Cartesian3();\r\n\r\n    var segmentStart2DScratch = new Cartesian3();\r\n    var segmentEnd2DScratch = new Cartesian3();\r\n    var segmentStartNormal2DScratch = new Cartesian3();\r\n    var segmentEndNormal2DScratch = new Cartesian3();\r\n\r\n    var offsetScratch = new Cartesian3();\r\n    var startUpScratch = new Cartesian3();\r\n    var endUpScratch = new Cartesian3();\r\n    var rightScratch = new Cartesian3();\r\n    var startPlaneNormalScratch = new Cartesian3();\r\n    var endPlaneNormalScratch = new Cartesian3();\r\n    var encodeScratch = new EncodedCartesian3();\r\n\r\n    var encodeScratch2D = new EncodedCartesian3();\r\n    var forwardOffset2DScratch = new Cartesian3();\r\n    var right2DScratch = new Cartesian3();\r\n\r\n    var normalNudgeScratch = new Cartesian3();\r\n\r\n    var scratchBoundingSpheres = [new BoundingSphere(), new BoundingSphere()];\r\n\r\n    // Winding order is reversed so each segment's volume is inside-out\r\n    var REFERENCE_INDICES = [\r\n        0, 2, 1, 0, 3, 2, // right\r\n        0, 7, 3, 0, 4, 7, // start\r\n        0, 5, 4, 0, 1, 5, // bottom\r\n        5, 7, 4, 5, 6, 7, // left\r\n        5, 2, 6, 5, 1, 2, // end\r\n        3, 6, 2, 3, 7, 6 // top\r\n    ];\r\n    var REFERENCE_INDICES_LENGTH = REFERENCE_INDICES.length;\r\n\r\n    // Decompose the \"wall\" into a series of shadow volumes.\r\n    // Each shadow volume's vertices encode a description of the line it contains,\r\n    // including mitering planes at the end points, a plane along the line itself,\r\n    // and attributes for computing length-wise texture coordinates.\r\n    function generateGeometryAttributes(loop, projection, bottomPositionsArray, topPositionsArray, normalsArray, cartographicsArray, compute2dAttributes) {\r\n        var i;\r\n        var index;\r\n        var ellipsoid = projection._ellipsoid;\r\n\r\n        // Each segment will have 8 vertices\r\n        var segmentCount = (bottomPositionsArray.length / 3) - 1;\r\n        var vertexCount = segmentCount * 8;\r\n        var arraySizeVec4 = vertexCount * 4;\r\n        var indexCount = segmentCount * 36;\r\n\r\n        var indices = vertexCount > 65535 ? new Uint32Array(indexCount) : new Uint16Array(indexCount);\r\n        var positionsArray = new Float64Array(vertexCount * 3);\r\n\r\n        var startHiAndForwardOffsetX = new Float32Array(arraySizeVec4);\r\n        var startLoAndForwardOffsetY = new Float32Array(arraySizeVec4);\r\n        var startNormalAndForwardOffsetZ = new Float32Array(arraySizeVec4);\r\n        var endNormalAndTextureCoordinateNormalizationX = new Float32Array(arraySizeVec4);\r\n        var rightNormalAndTextureCoordinateNormalizationY = new Float32Array(arraySizeVec4);\r\n\r\n        var startHiLo2D;\r\n        var offsetAndRight2D;\r\n        var startEndNormals2D;\r\n        var texcoordNormalization2D;\r\n\r\n        if (compute2dAttributes) {\r\n            startHiLo2D = new Float32Array(arraySizeVec4);\r\n            offsetAndRight2D = new Float32Array(arraySizeVec4);\r\n            startEndNormals2D = new Float32Array(arraySizeVec4);\r\n            texcoordNormalization2D = new Float32Array(vertexCount * 2);\r\n        }\r\n\r\n        /*** Compute total lengths for texture coordinate normalization ***/\r\n        // 2D\r\n        var cartographicsLength = cartographicsArray.length / 2;\r\n        var length2D = 0.0;\r\n\r\n        var startCartographic = startCartographicScratch;\r\n        startCartographic.height = 0.0;\r\n        var endCartographic = endCartographicScratch;\r\n        endCartographic.height = 0.0;\r\n\r\n        var segmentStartCartesian = segmentStartTopScratch;\r\n        var segmentEndCartesian = segmentEndTopScratch;\r\n\r\n        if (compute2dAttributes) {\r\n            index = 0;\r\n            for (i = 1; i < cartographicsLength; i++) {\r\n                // Don't clone anything from previous segment b/c possible IDL touch\r\n                startCartographic.latitude = cartographicsArray[index];\r\n                startCartographic.longitude = cartographicsArray[index + 1];\r\n                endCartographic.latitude = cartographicsArray[index + 2];\r\n                endCartographic.longitude = cartographicsArray[index + 3];\r\n\r\n                segmentStartCartesian = projection.project(startCartographic, segmentStartCartesian);\r\n                segmentEndCartesian = projection.project(endCartographic, segmentEndCartesian);\r\n                length2D += Cartesian3.distance(segmentStartCartesian, segmentEndCartesian);\r\n                index += 2;\r\n            }\r\n        }\r\n\r\n        // 3D\r\n        var positionsLength = topPositionsArray.length / 3;\r\n        segmentEndCartesian = Cartesian3.unpack(topPositionsArray, 0, segmentEndCartesian);\r\n        var length3D = 0.0;\r\n\r\n        index = 3;\r\n        for (i = 1; i < positionsLength; i++) {\r\n            segmentStartCartesian = Cartesian3.clone(segmentEndCartesian, segmentStartCartesian);\r\n            segmentEndCartesian = Cartesian3.unpack(topPositionsArray, index, segmentEndCartesian);\r\n            length3D += Cartesian3.distance(segmentStartCartesian, segmentEndCartesian);\r\n            index += 3;\r\n        }\r\n\r\n        /*** Generate segments ***/\r\n        var j;\r\n        index = 3;\r\n        var cartographicsIndex = 0;\r\n        var vec2sWriteIndex = 0;\r\n        var vec3sWriteIndex = 0;\r\n        var vec4sWriteIndex = 0;\r\n        var miterBroken = false;\r\n\r\n        var endBottom = Cartesian3.unpack(bottomPositionsArray, 0, segmentEndBottomScratch);\r\n        var endTop = Cartesian3.unpack(topPositionsArray, 0, segmentEndTopScratch);\r\n        var endGeometryNormal = Cartesian3.unpack(normalsArray, 0, segmentEndNormalScratch);\r\n\r\n        if (loop) {\r\n            var preEndBottom = Cartesian3.unpack(bottomPositionsArray, bottomPositionsArray.length - 6, segmentStartBottomScratch);\r\n            if (breakMiter(endGeometryNormal, preEndBottom, endBottom, endTop)) {\r\n                // Miter broken as if for the last point in the loop, needs to be inverted for first point (clone of endBottom)\r\n                endGeometryNormal = Cartesian3.negate(endGeometryNormal, endGeometryNormal);\r\n            }\r\n        }\r\n\r\n        var lengthSoFar3D = 0.0;\r\n        var lengthSoFar2D = 0.0;\r\n\r\n        // For translating bounding volume\r\n        var sumHeights = 0.0;\r\n\r\n        for (i = 0; i < segmentCount; i++) {\r\n            var startBottom = Cartesian3.clone(endBottom, segmentStartBottomScratch);\r\n            var startTop = Cartesian3.clone(endTop, segmentStartTopScratch);\r\n            var startGeometryNormal = Cartesian3.clone(endGeometryNormal, segmentStartNormalScratch);\r\n\r\n            if (miterBroken) {\r\n                startGeometryNormal = Cartesian3.negate(startGeometryNormal, startGeometryNormal);\r\n            }\r\n\r\n            endBottom = Cartesian3.unpack(bottomPositionsArray, index, segmentEndBottomScratch);\r\n            endTop = Cartesian3.unpack(topPositionsArray, index, segmentEndTopScratch);\r\n            endGeometryNormal = Cartesian3.unpack(normalsArray, index, segmentEndNormalScratch);\r\n\r\n            miterBroken = breakMiter(endGeometryNormal, startBottom, endBottom, endTop);\r\n\r\n            // 2D - don't clone anything from previous segment b/c possible IDL touch\r\n            startCartographic.latitude = cartographicsArray[cartographicsIndex];\r\n            startCartographic.longitude = cartographicsArray[cartographicsIndex + 1];\r\n            endCartographic.latitude = cartographicsArray[cartographicsIndex + 2];\r\n            endCartographic.longitude = cartographicsArray[cartographicsIndex + 3];\r\n            var start2D;\r\n            var end2D;\r\n            var startGeometryNormal2D;\r\n            var endGeometryNormal2D;\r\n\r\n            if (compute2dAttributes) {\r\n                var nudgeResult = nudgeCartographic(startCartographic, endCartographic);\r\n                start2D = projection.project(startCartographic, segmentStart2DScratch);\r\n                end2D = projection.project(endCartographic, segmentEnd2DScratch);\r\n                var direction2D = direction(end2D, start2D, forwardOffset2DScratch);\r\n                direction2D.y = Math.abs(direction2D.y);\r\n\r\n                startGeometryNormal2D = segmentStartNormal2DScratch;\r\n                endGeometryNormal2D = segmentEndNormal2DScratch;\r\n                if (nudgeResult === 0 || Cartesian3.dot(direction2D, Cartesian3.UNIT_Y) > MITER_BREAK_SMALL) {\r\n                    // No nudge - project the original normal\r\n                    // Or, if the line's angle relative to the IDL is very acute,\r\n                    // in which case snapping will produce oddly shaped volumes.\r\n                    startGeometryNormal2D = projectNormal(projection, startCartographic, startGeometryNormal, start2D, segmentStartNormal2DScratch);\r\n                    endGeometryNormal2D = projectNormal(projection, endCartographic, endGeometryNormal, end2D, segmentEndNormal2DScratch);\r\n                } else if (nudgeResult === 1) {\r\n                    // Start is close to IDL - snap start normal to align with IDL\r\n                    endGeometryNormal2D = projectNormal(projection, endCartographic, endGeometryNormal, end2D, segmentEndNormal2DScratch);\r\n                    startGeometryNormal2D.x = 0.0;\r\n                    // If start longitude is negative and end longitude is less negative, relative right is unit -Y\r\n                    // If start longitude is positive and end longitude is less positive, relative right is unit +Y\r\n                    startGeometryNormal2D.y = CesiumMath.sign(startCartographic.longitude - Math.abs(endCartographic.longitude));\r\n                    startGeometryNormal2D.z = 0.0;\r\n                } else {\r\n                    // End is close to IDL - snap end normal to align with IDL\r\n                    startGeometryNormal2D = projectNormal(projection, startCartographic, startGeometryNormal, start2D, segmentStartNormal2DScratch);\r\n                    endGeometryNormal2D.x = 0.0;\r\n                    // If end longitude is negative and start longitude is less negative, relative right is unit Y\r\n                    // If end longitude is positive and start longitude is less positive, relative right is unit -Y\r\n                    endGeometryNormal2D.y = CesiumMath.sign(startCartographic.longitude - endCartographic.longitude);\r\n                    endGeometryNormal2D.z = 0.0;\r\n                }\r\n            }\r\n\r\n            /****************************************\r\n             * Geometry descriptors of a \"line on terrain,\"\r\n             * as opposed to the \"shadow volume used to draw\r\n             * the line on terrain\":\r\n             * - position of start + offset to end\r\n             * - start, end, and right-facing planes\r\n             * - encoded texture coordinate offsets\r\n             ****************************************/\r\n\r\n             /** 3D **/\r\n            var segmentLength3D = Cartesian3.distance(startTop, endTop);\r\n\r\n            var encodedStart = EncodedCartesian3.fromCartesian(startBottom, encodeScratch);\r\n            var forwardOffset = Cartesian3.subtract(endBottom, startBottom, offsetScratch);\r\n            var forward = Cartesian3.normalize(forwardOffset, rightScratch);\r\n\r\n            var startUp = Cartesian3.subtract(startTop, startBottom, startUpScratch);\r\n            startUp = Cartesian3.normalize(startUp, startUp);\r\n            var rightNormal = Cartesian3.cross(forward, startUp, rightScratch);\r\n            rightNormal = Cartesian3.normalize(rightNormal, rightNormal);\r\n\r\n            var startPlaneNormal = Cartesian3.cross(startUp, startGeometryNormal, startPlaneNormalScratch);\r\n            startPlaneNormal = Cartesian3.normalize(startPlaneNormal, startPlaneNormal);\r\n\r\n            var endUp = Cartesian3.subtract(endTop, endBottom, endUpScratch);\r\n            endUp = Cartesian3.normalize(endUp, endUp);\r\n            var endPlaneNormal = Cartesian3.cross(endGeometryNormal, endUp, endPlaneNormalScratch);\r\n            endPlaneNormal = Cartesian3.normalize(endPlaneNormal, endPlaneNormal);\r\n\r\n            var texcoordNormalization3DX = segmentLength3D / length3D;\r\n            var texcoordNormalization3DY = lengthSoFar3D / length3D;\r\n\r\n            /** 2D **/\r\n            var segmentLength2D = 0.0;\r\n            var encodedStart2D;\r\n            var forwardOffset2D;\r\n            var right2D;\r\n            var texcoordNormalization2DX = 0.0;\r\n            var texcoordNormalization2DY = 0.0;\r\n            if (compute2dAttributes) {\r\n                segmentLength2D = Cartesian3.distance(start2D, end2D);\r\n\r\n                encodedStart2D = EncodedCartesian3.fromCartesian(start2D, encodeScratch2D);\r\n                forwardOffset2D = Cartesian3.subtract(end2D, start2D, forwardOffset2DScratch);\r\n\r\n                // Right direction is just forward direction rotated by -90 degrees around Z\r\n                // Similarly with plane normals\r\n                right2D = Cartesian3.normalize(forwardOffset2D, right2DScratch);\r\n                var swap = right2D.x;\r\n                right2D.x = right2D.y;\r\n                right2D.y = -swap;\r\n\r\n                texcoordNormalization2DX = segmentLength2D / length2D;\r\n                texcoordNormalization2DY = lengthSoFar2D / length2D;\r\n            }\r\n            /** Pack **/\r\n            for (j = 0; j < 8; j++) {\r\n                var vec4Index = vec4sWriteIndex + j * 4;\r\n                var vec2Index = vec2sWriteIndex + j * 2;\r\n                var wIndex = vec4Index + 3;\r\n\r\n                // Encode sidedness of vertex relative to right plane in texture coordinate normalization X,\r\n                // whether vertex is top or bottom of volume in sign/magnitude of normalization Y.\r\n                var rightPlaneSide = j < 4 ? 1.0 : -1.0;\r\n                var topBottomSide = (j === 2 || j === 3 || j === 6 || j === 7) ? 1.0 : -1.0;\r\n\r\n                // 3D\r\n                Cartesian3.pack(encodedStart.high, startHiAndForwardOffsetX, vec4Index);\r\n                startHiAndForwardOffsetX[wIndex] = forwardOffset.x;\r\n\r\n                Cartesian3.pack(encodedStart.low, startLoAndForwardOffsetY, vec4Index);\r\n                startLoAndForwardOffsetY[wIndex] = forwardOffset.y;\r\n\r\n                Cartesian3.pack(startPlaneNormal, startNormalAndForwardOffsetZ, vec4Index);\r\n                startNormalAndForwardOffsetZ[wIndex] = forwardOffset.z;\r\n\r\n                Cartesian3.pack(endPlaneNormal, endNormalAndTextureCoordinateNormalizationX, vec4Index);\r\n                endNormalAndTextureCoordinateNormalizationX[wIndex] = texcoordNormalization3DX * rightPlaneSide;\r\n\r\n                Cartesian3.pack(rightNormal, rightNormalAndTextureCoordinateNormalizationY, vec4Index);\r\n\r\n                var texcoordNormalization = texcoordNormalization3DY * topBottomSide;\r\n                if (texcoordNormalization === 0.0 && topBottomSide < 0.0) {\r\n                    texcoordNormalization = 9.0; // some value greater than 1.0\r\n                }\r\n                rightNormalAndTextureCoordinateNormalizationY[wIndex] = texcoordNormalization;\r\n\r\n                // 2D\r\n                if (compute2dAttributes) {\r\n                    startHiLo2D[vec4Index] = encodedStart2D.high.x;\r\n                    startHiLo2D[vec4Index + 1] = encodedStart2D.high.y;\r\n                    startHiLo2D[vec4Index + 2] = encodedStart2D.low.x;\r\n                    startHiLo2D[vec4Index + 3] = encodedStart2D.low.y;\r\n\r\n                    startEndNormals2D[vec4Index] = -startGeometryNormal2D.y;\r\n                    startEndNormals2D[vec4Index + 1] = startGeometryNormal2D.x;\r\n                    startEndNormals2D[vec4Index + 2] = endGeometryNormal2D.y;\r\n                    startEndNormals2D[vec4Index + 3] = -endGeometryNormal2D.x;\r\n\r\n                    offsetAndRight2D[vec4Index] = forwardOffset2D.x;\r\n                    offsetAndRight2D[vec4Index + 1] = forwardOffset2D.y;\r\n                    offsetAndRight2D[vec4Index + 2] = right2D.x;\r\n                    offsetAndRight2D[vec4Index + 3] = right2D.y;\r\n\r\n                    texcoordNormalization2D[vec2Index] = texcoordNormalization2DX * rightPlaneSide;\r\n\r\n                    texcoordNormalization = texcoordNormalization2DY * topBottomSide;\r\n                    if (texcoordNormalization === 0.0 && topBottomSide < 0.0) {\r\n                        texcoordNormalization = 9.0; // some value greater than 1.0\r\n                    }\r\n                    texcoordNormalization2D[vec2Index + 1] = texcoordNormalization;\r\n                }\r\n            }\r\n\r\n            // Adjust height of volume in 3D\r\n            var adjustHeightStartBottom = adjustHeightStartBottomScratch;\r\n            var adjustHeightEndBottom = adjustHeightEndBottomScratch;\r\n            var adjustHeightStartTop = adjustHeightStartTopScratch;\r\n            var adjustHeightEndTop = adjustHeightEndTopScratch;\r\n\r\n            var getHeightsRectangle = Rectangle.fromCartographicArray(getHeightCartographics, getHeightRectangleScratch);\r\n            var minMaxHeights = ApproximateTerrainHeights.getMinimumMaximumHeights(getHeightsRectangle, ellipsoid);\r\n            var minHeight = minMaxHeights.minimumTerrainHeight;\r\n            var maxHeight = minMaxHeights.maximumTerrainHeight;\r\n\r\n            sumHeights += minHeight;\r\n            sumHeights += maxHeight;\r\n\r\n            adjustHeights(startBottom, startTop, minHeight, maxHeight, adjustHeightStartBottom, adjustHeightStartTop);\r\n            adjustHeights(endBottom, endTop, minHeight, maxHeight, adjustHeightEndBottom, adjustHeightEndTop);\r\n\r\n            // Nudge the positions away from the \"polyline\" a little bit to prevent errors in GeometryPipeline\r\n            var normalNudge = Cartesian3.multiplyByScalar(rightNormal, CesiumMath.EPSILON5, normalNudgeScratch);\r\n            Cartesian3.add(adjustHeightStartBottom, normalNudge, adjustHeightStartBottom);\r\n            Cartesian3.add(adjustHeightEndBottom, normalNudge, adjustHeightEndBottom);\r\n            Cartesian3.add(adjustHeightStartTop, normalNudge, adjustHeightStartTop);\r\n            Cartesian3.add(adjustHeightEndTop, normalNudge, adjustHeightEndTop);\r\n\r\n            // If the segment is very close to the XZ plane, nudge the vertices slightly to avoid touching it.\r\n            nudgeXZ(adjustHeightStartBottom, adjustHeightEndBottom);\r\n            nudgeXZ(adjustHeightStartTop, adjustHeightEndTop);\r\n\r\n            Cartesian3.pack(adjustHeightStartBottom, positionsArray, vec3sWriteIndex);\r\n            Cartesian3.pack(adjustHeightEndBottom, positionsArray, vec3sWriteIndex + 3);\r\n            Cartesian3.pack(adjustHeightEndTop, positionsArray, vec3sWriteIndex + 6);\r\n            Cartesian3.pack(adjustHeightStartTop, positionsArray, vec3sWriteIndex + 9);\r\n\r\n            normalNudge = Cartesian3.multiplyByScalar(rightNormal, -2.0 * CesiumMath.EPSILON5, normalNudgeScratch);\r\n            Cartesian3.add(adjustHeightStartBottom, normalNudge, adjustHeightStartBottom);\r\n            Cartesian3.add(adjustHeightEndBottom, normalNudge, adjustHeightEndBottom);\r\n            Cartesian3.add(adjustHeightStartTop, normalNudge, adjustHeightStartTop);\r\n            Cartesian3.add(adjustHeightEndTop, normalNudge, adjustHeightEndTop);\r\n\r\n            nudgeXZ(adjustHeightStartBottom, adjustHeightEndBottom);\r\n            nudgeXZ(adjustHeightStartTop, adjustHeightEndTop);\r\n\r\n            Cartesian3.pack(adjustHeightStartBottom, positionsArray, vec3sWriteIndex + 12);\r\n            Cartesian3.pack(adjustHeightEndBottom, positionsArray, vec3sWriteIndex + 15);\r\n            Cartesian3.pack(adjustHeightEndTop, positionsArray, vec3sWriteIndex + 18);\r\n            Cartesian3.pack(adjustHeightStartTop, positionsArray, vec3sWriteIndex + 21);\r\n\r\n            cartographicsIndex += 2;\r\n            index += 3;\r\n\r\n            vec2sWriteIndex += 16;\r\n            vec3sWriteIndex += 24;\r\n            vec4sWriteIndex += 32;\r\n\r\n            lengthSoFar3D += segmentLength3D;\r\n            lengthSoFar2D += segmentLength2D;\r\n        }\r\n\r\n        index = 0;\r\n        var indexOffset = 0;\r\n        for (i = 0; i < segmentCount; i++) {\r\n            for (j = 0; j < REFERENCE_INDICES_LENGTH; j++) {\r\n                indices[index + j] = REFERENCE_INDICES[j] + indexOffset;\r\n            }\r\n            indexOffset += 8;\r\n            index += REFERENCE_INDICES_LENGTH;\r\n        }\r\n\r\n        var boundingSpheres = scratchBoundingSpheres;\r\n        BoundingSphere.fromVertices(bottomPositionsArray, Cartesian3.ZERO, 3, boundingSpheres[0]);\r\n        BoundingSphere.fromVertices(topPositionsArray, Cartesian3.ZERO, 3, boundingSpheres[1]);\r\n        var boundingSphere = BoundingSphere.fromBoundingSpheres(boundingSpheres);\r\n\r\n        // Adjust bounding sphere height and radius to cover more of the volume\r\n        boundingSphere.radius += sumHeights / (segmentCount * 2.0);\r\n\r\n        var attributes = {\r\n            position : new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.DOUBLE,\r\n                componentsPerAttribute : 3,\r\n                normalize : false,\r\n                values : positionsArray\r\n            }),\r\n            startHiAndForwardOffsetX : getVec4GeometryAttribute(startHiAndForwardOffsetX),\r\n            startLoAndForwardOffsetY : getVec4GeometryAttribute(startLoAndForwardOffsetY),\r\n            startNormalAndForwardOffsetZ : getVec4GeometryAttribute(startNormalAndForwardOffsetZ),\r\n            endNormalAndTextureCoordinateNormalizationX : getVec4GeometryAttribute(endNormalAndTextureCoordinateNormalizationX),\r\n            rightNormalAndTextureCoordinateNormalizationY : getVec4GeometryAttribute(rightNormalAndTextureCoordinateNormalizationY)\r\n        };\r\n\r\n        if (compute2dAttributes) {\r\n            attributes.startHiLo2D = getVec4GeometryAttribute(startHiLo2D);\r\n            attributes.offsetAndRight2D = getVec4GeometryAttribute(offsetAndRight2D);\r\n            attributes.startEndNormals2D = getVec4GeometryAttribute(startEndNormals2D);\r\n            attributes.texcoordNormalization2D = new GeometryAttribute({\r\n                componentDatatype : ComponentDatatype.FLOAT,\r\n                componentsPerAttribute : 2,\r\n                normalize : false,\r\n                values : texcoordNormalization2D\r\n            });\r\n        }\r\n\r\n        return new Geometry({\r\n            attributes : attributes,\r\n            indices : indices,\r\n            boundingSphere : boundingSphere\r\n        });\r\n    }\r\n\r\n    function getVec4GeometryAttribute(typedArray) {\r\n        return new GeometryAttribute({\r\n            componentDatatype : ComponentDatatype.FLOAT,\r\n            componentsPerAttribute : 4,\r\n            normalize : false,\r\n            values : typedArray\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Approximates an ellipsoid-tangent vector in 2D by projecting the end point into 2D.\r\n     * Exposed for testing.\r\n     *\r\n     * @param {MapProjection} projection Map Projection for projecting coordinates to 2D.\r\n     * @param {Cartographic} cartographic The cartographic origin point of the normal.\r\n     *   Used to check if the normal crosses the IDL during projection.\r\n     * @param {Cartesian3} normal The normal in 3D.\r\n     * @param {Cartesian3} projectedPosition The projected origin point of the normal in 2D.\r\n     * @param {Cartesian3} result Result parameter on which to store the projected normal.\r\n     * @private\r\n     */\r\n    GroundPolylineGeometry._projectNormal = projectNormal;\r\nexport default GroundPolylineGeometry;\r\n","import ApproximateTerrainHeights from '../Core/ApproximateTerrainHeights.js';\r\nimport defined from '../Core/defined.js';\r\nimport GroundPolylineGeometry from '../Core/GroundPolylineGeometry.js';\r\n\r\n    function createGroundPolylineGeometry(groundPolylineGeometry, offset) {\r\n        return ApproximateTerrainHeights.initialize()\r\n            .then(function() {\r\n                if (defined(offset)) {\r\n                    groundPolylineGeometry = GroundPolylineGeometry.unpack(groundPolylineGeometry, offset);\r\n                }\r\n                return GroundPolylineGeometry.createGeometry(groundPolylineGeometry);\r\n            });\r\n    }\r\nexport default createGroundPolylineGeometry;\r\n"],"names":["defaultValue","Ellipsoid","Rectangle","GeographicProjection","Check","CesiumMath","defined","Cartesian2","Cartesian3","Cartographic","BoundingSphere","Resource","buildModuleUrl","DeveloperError","WebMercatorProjection","ArcType","EllipsoidGeodesic","EllipsoidRhumbLine","Plane","IntersectionTests","arrayRemoveDuplicates","Matrix3","Quaternion","EncodedCartesian3","GeometryAttribute","ComponentDatatype","Geometry"],"mappings":"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"}